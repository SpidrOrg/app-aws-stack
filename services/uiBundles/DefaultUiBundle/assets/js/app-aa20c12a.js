import { i as idpData$1 } from "../../idpConfig.js";
(function polyfill() {
  const relList = document.createElement("link").relList;
  if (relList && relList.supports && relList.supports("modulepreload")) {
    return;
  }
  for (const link of document.querySelectorAll('link[rel="modulepreload"]')) {
    processPreload(link);
  }
  new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.type !== "childList") {
        continue;
      }
      for (const node of mutation.addedNodes) {
        if (node.tagName === "LINK" && node.rel === "modulepreload")
          processPreload(node);
      }
    }
  }).observe(document, { childList: true, subtree: true });
  function getFetchOpts(script) {
    const fetchOpts = {};
    if (script.integrity)
      fetchOpts.integrity = script.integrity;
    if (script.referrerpolicy)
      fetchOpts.referrerPolicy = script.referrerpolicy;
    if (script.crossorigin === "use-credentials")
      fetchOpts.credentials = "include";
    else if (script.crossorigin === "anonymous")
      fetchOpts.credentials = "omit";
    else
      fetchOpts.credentials = "same-origin";
    return fetchOpts;
  }
  function processPreload(link) {
    if (link.ep)
      return;
    link.ep = true;
    const fetchOpts = getFetchOpts(link);
    fetch(link.href, fetchOpts);
  }
})();
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getAugmentedNamespace(n2) {
  var f = n2.default;
  if (typeof f == "function") {
    var a3 = function() {
      return f.apply(this, arguments);
    };
    a3.prototype = f.prototype;
  } else
    a3 = {};
  Object.defineProperty(a3, "__esModule", { value: true });
  Object.keys(n2).forEach(function(k2) {
    var d3 = Object.getOwnPropertyDescriptor(n2, k2);
    Object.defineProperty(a3, k2, d3.get ? d3 : {
      enumerable: true,
      get: function() {
        return n2[k2];
      }
    });
  });
  return a3;
}
var lodash = { exports: {} };
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
(function(module2, exports) {
  (function() {
    var undefined$1;
    var VERSION2 = "4.17.21";
    var LARGE_ARRAY_SIZE = 200;
    var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var MAX_MEMOIZE_SIZE = 500;
    var PLACEHOLDER = "__lodash_placeholder__";
    var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
    var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
    var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
    var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
    var HOT_COUNT = 800, HOT_SPAN = 16;
    var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
    var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
    var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
    var wrapFlags = [
      ["ary", WRAP_ARY_FLAG],
      ["bind", WRAP_BIND_FLAG],
      ["bindKey", WRAP_BIND_KEY_FLAG],
      ["curry", WRAP_CURRY_FLAG],
      ["curryRight", WRAP_CURRY_RIGHT_FLAG],
      ["flip", WRAP_FLIP_FLAG],
      ["partial", WRAP_PARTIAL_FLAG],
      ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
      ["rearg", WRAP_REARG_FLAG]
    ];
    var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
    var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
    var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
    var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
    var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
    var reTrimStart = /^\s+/;
    var reWhitespace = /\s/;
    var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
    var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
    var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
    var reEscapeChar = /\\(\\)?/g;
    var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
    var reFlags = /\w*$/;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsOctal = /^0o[0-7]+$/i;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
    var reNoMatch = /($^)/;
    var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
    var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
    var rsApos = "['\u2019]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
    var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
    var reApos = RegExp(rsApos, "g");
    var reComboMark = RegExp(rsCombo, "g");
    var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
    var reUnicodeWord = RegExp([
      rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
      rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
      rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
      rsUpper + "+" + rsOptContrUpper,
      rsOrdUpper,
      rsOrdLower,
      rsDigits,
      rsEmoji
    ].join("|"), "g");
    var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
    var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
    var contextProps = [
      "Array",
      "Buffer",
      "DataView",
      "Date",
      "Error",
      "Float32Array",
      "Float64Array",
      "Function",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Map",
      "Math",
      "Object",
      "Promise",
      "RegExp",
      "Set",
      "String",
      "Symbol",
      "TypeError",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "WeakMap",
      "_",
      "clearTimeout",
      "isFinite",
      "parseInt",
      "setTimeout"
    ];
    var templateCounter = -1;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    var deburredLetters = {
      "\xC0": "A",
      "\xC1": "A",
      "\xC2": "A",
      "\xC3": "A",
      "\xC4": "A",
      "\xC5": "A",
      "\xE0": "a",
      "\xE1": "a",
      "\xE2": "a",
      "\xE3": "a",
      "\xE4": "a",
      "\xE5": "a",
      "\xC7": "C",
      "\xE7": "c",
      "\xD0": "D",
      "\xF0": "d",
      "\xC8": "E",
      "\xC9": "E",
      "\xCA": "E",
      "\xCB": "E",
      "\xE8": "e",
      "\xE9": "e",
      "\xEA": "e",
      "\xEB": "e",
      "\xCC": "I",
      "\xCD": "I",
      "\xCE": "I",
      "\xCF": "I",
      "\xEC": "i",
      "\xED": "i",
      "\xEE": "i",
      "\xEF": "i",
      "\xD1": "N",
      "\xF1": "n",
      "\xD2": "O",
      "\xD3": "O",
      "\xD4": "O",
      "\xD5": "O",
      "\xD6": "O",
      "\xD8": "O",
      "\xF2": "o",
      "\xF3": "o",
      "\xF4": "o",
      "\xF5": "o",
      "\xF6": "o",
      "\xF8": "o",
      "\xD9": "U",
      "\xDA": "U",
      "\xDB": "U",
      "\xDC": "U",
      "\xF9": "u",
      "\xFA": "u",
      "\xFB": "u",
      "\xFC": "u",
      "\xDD": "Y",
      "\xFD": "y",
      "\xFF": "y",
      "\xC6": "Ae",
      "\xE6": "ae",
      "\xDE": "Th",
      "\xFE": "th",
      "\xDF": "ss",
      "\u0100": "A",
      "\u0102": "A",
      "\u0104": "A",
      "\u0101": "a",
      "\u0103": "a",
      "\u0105": "a",
      "\u0106": "C",
      "\u0108": "C",
      "\u010A": "C",
      "\u010C": "C",
      "\u0107": "c",
      "\u0109": "c",
      "\u010B": "c",
      "\u010D": "c",
      "\u010E": "D",
      "\u0110": "D",
      "\u010F": "d",
      "\u0111": "d",
      "\u0112": "E",
      "\u0114": "E",
      "\u0116": "E",
      "\u0118": "E",
      "\u011A": "E",
      "\u0113": "e",
      "\u0115": "e",
      "\u0117": "e",
      "\u0119": "e",
      "\u011B": "e",
      "\u011C": "G",
      "\u011E": "G",
      "\u0120": "G",
      "\u0122": "G",
      "\u011D": "g",
      "\u011F": "g",
      "\u0121": "g",
      "\u0123": "g",
      "\u0124": "H",
      "\u0126": "H",
      "\u0125": "h",
      "\u0127": "h",
      "\u0128": "I",
      "\u012A": "I",
      "\u012C": "I",
      "\u012E": "I",
      "\u0130": "I",
      "\u0129": "i",
      "\u012B": "i",
      "\u012D": "i",
      "\u012F": "i",
      "\u0131": "i",
      "\u0134": "J",
      "\u0135": "j",
      "\u0136": "K",
      "\u0137": "k",
      "\u0138": "k",
      "\u0139": "L",
      "\u013B": "L",
      "\u013D": "L",
      "\u013F": "L",
      "\u0141": "L",
      "\u013A": "l",
      "\u013C": "l",
      "\u013E": "l",
      "\u0140": "l",
      "\u0142": "l",
      "\u0143": "N",
      "\u0145": "N",
      "\u0147": "N",
      "\u014A": "N",
      "\u0144": "n",
      "\u0146": "n",
      "\u0148": "n",
      "\u014B": "n",
      "\u014C": "O",
      "\u014E": "O",
      "\u0150": "O",
      "\u014D": "o",
      "\u014F": "o",
      "\u0151": "o",
      "\u0154": "R",
      "\u0156": "R",
      "\u0158": "R",
      "\u0155": "r",
      "\u0157": "r",
      "\u0159": "r",
      "\u015A": "S",
      "\u015C": "S",
      "\u015E": "S",
      "\u0160": "S",
      "\u015B": "s",
      "\u015D": "s",
      "\u015F": "s",
      "\u0161": "s",
      "\u0162": "T",
      "\u0164": "T",
      "\u0166": "T",
      "\u0163": "t",
      "\u0165": "t",
      "\u0167": "t",
      "\u0168": "U",
      "\u016A": "U",
      "\u016C": "U",
      "\u016E": "U",
      "\u0170": "U",
      "\u0172": "U",
      "\u0169": "u",
      "\u016B": "u",
      "\u016D": "u",
      "\u016F": "u",
      "\u0171": "u",
      "\u0173": "u",
      "\u0174": "W",
      "\u0175": "w",
      "\u0176": "Y",
      "\u0177": "y",
      "\u0178": "Y",
      "\u0179": "Z",
      "\u017B": "Z",
      "\u017D": "Z",
      "\u017A": "z",
      "\u017C": "z",
      "\u017E": "z",
      "\u0132": "IJ",
      "\u0133": "ij",
      "\u0152": "Oe",
      "\u0153": "oe",
      "\u0149": "'n",
      "\u017F": "s"
    };
    var htmlEscapes = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    };
    var htmlUnescapes = {
      "&amp;": "&",
      "&lt;": "<",
      "&gt;": ">",
      "&quot;": '"',
      "&#39;": "'"
    };
    var stringEscapes = {
      "\\": "\\",
      "'": "'",
      "\n": "n",
      "\r": "r",
      "\u2028": "u2028",
      "\u2029": "u2029"
    };
    var freeParseFloat = parseFloat, freeParseInt = parseInt;
    var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = exports && !exports.nodeType && exports;
    var freeModule = freeExports && true && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types2 = freeModule && freeModule.require && freeModule.require("util").types;
        if (types2) {
          return types2;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e3) {
      }
    }();
    var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function arrayAggregator(array, setter, iteratee, accumulator) {
      var index2 = -1, length = array == null ? 0 : array.length;
      while (++index2 < length) {
        var value = array[index2];
        setter(accumulator, value, iteratee(value), array);
      }
      return accumulator;
    }
    function arrayEach(array, iteratee) {
      var index2 = -1, length = array == null ? 0 : array.length;
      while (++index2 < length) {
        if (iteratee(array[index2], index2, array) === false) {
          break;
        }
      }
      return array;
    }
    function arrayEachRight(array, iteratee) {
      var length = array == null ? 0 : array.length;
      while (length--) {
        if (iteratee(array[length], length, array) === false) {
          break;
        }
      }
      return array;
    }
    function arrayEvery(array, predicate) {
      var index2 = -1, length = array == null ? 0 : array.length;
      while (++index2 < length) {
        if (!predicate(array[index2], index2, array)) {
          return false;
        }
      }
      return true;
    }
    function arrayFilter(array, predicate) {
      var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index2 < length) {
        var value = array[index2];
        if (predicate(value, index2, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    function arrayIncludes(array, value) {
      var length = array == null ? 0 : array.length;
      return !!length && baseIndexOf(array, value, 0) > -1;
    }
    function arrayIncludesWith(array, value, comparator2) {
      var index2 = -1, length = array == null ? 0 : array.length;
      while (++index2 < length) {
        if (comparator2(value, array[index2])) {
          return true;
        }
      }
      return false;
    }
    function arrayMap(array, iteratee) {
      var index2 = -1, length = array == null ? 0 : array.length, result = Array(length);
      while (++index2 < length) {
        result[index2] = iteratee(array[index2], index2, array);
      }
      return result;
    }
    function arrayPush(array, values) {
      var index2 = -1, length = values.length, offset = array.length;
      while (++index2 < length) {
        array[offset + index2] = values[index2];
      }
      return array;
    }
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index2 = -1, length = array == null ? 0 : array.length;
      if (initAccum && length) {
        accumulator = array[++index2];
      }
      while (++index2 < length) {
        accumulator = iteratee(accumulator, array[index2], index2, array);
      }
      return accumulator;
    }
    function arrayReduceRight(array, iteratee, accumulator, initAccum) {
      var length = array == null ? 0 : array.length;
      if (initAccum && length) {
        accumulator = array[--length];
      }
      while (length--) {
        accumulator = iteratee(accumulator, array[length], length, array);
      }
      return accumulator;
    }
    function arraySome(array, predicate) {
      var index2 = -1, length = array == null ? 0 : array.length;
      while (++index2 < length) {
        if (predicate(array[index2], index2, array)) {
          return true;
        }
      }
      return false;
    }
    var asciiSize = baseProperty("length");
    function asciiToArray(string) {
      return string.split("");
    }
    function asciiWords(string) {
      return string.match(reAsciiWord) || [];
    }
    function baseFindKey(collection, predicate, eachFunc) {
      var result;
      eachFunc(collection, function(value, key, collection2) {
        if (predicate(value, key, collection2)) {
          result = key;
          return false;
        }
      });
      return result;
    }
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length, index2 = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index2-- : ++index2 < length) {
        if (predicate(array[index2], index2, array)) {
          return index2;
        }
      }
      return -1;
    }
    function baseIndexOf(array, value, fromIndex) {
      return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
    }
    function baseIndexOfWith(array, value, fromIndex, comparator2) {
      var index2 = fromIndex - 1, length = array.length;
      while (++index2 < length) {
        if (comparator2(array[index2], value)) {
          return index2;
        }
      }
      return -1;
    }
    function baseIsNaN(value) {
      return value !== value;
    }
    function baseMean(array, iteratee) {
      var length = array == null ? 0 : array.length;
      return length ? baseSum(array, iteratee) / length : NAN;
    }
    function baseProperty(key) {
      return function(object) {
        return object == null ? undefined$1 : object[key];
      };
    }
    function basePropertyOf(object) {
      return function(key) {
        return object == null ? undefined$1 : object[key];
      };
    }
    function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
      eachFunc(collection, function(value, index2, collection2) {
        accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index2, collection2);
      });
      return accumulator;
    }
    function baseSortBy(array, comparer) {
      var length = array.length;
      array.sort(comparer);
      while (length--) {
        array[length] = array[length].value;
      }
      return array;
    }
    function baseSum(array, iteratee) {
      var result, index2 = -1, length = array.length;
      while (++index2 < length) {
        var current = iteratee(array[index2]);
        if (current !== undefined$1) {
          result = result === undefined$1 ? current : result + current;
        }
      }
      return result;
    }
    function baseTimes(n2, iteratee) {
      var index2 = -1, result = Array(n2);
      while (++index2 < n2) {
        result[index2] = iteratee(index2);
      }
      return result;
    }
    function baseToPairs(object, props) {
      return arrayMap(props, function(key) {
        return [key, object[key]];
      });
    }
    function baseTrim(string) {
      return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function baseValues(object, props) {
      return arrayMap(props, function(key) {
        return object[key];
      });
    }
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    function charsStartIndex(strSymbols, chrSymbols) {
      var index2 = -1, length = strSymbols.length;
      while (++index2 < length && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
      }
      return index2;
    }
    function charsEndIndex(strSymbols, chrSymbols) {
      var index2 = strSymbols.length;
      while (index2-- && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
      }
      return index2;
    }
    function countHolders(array, placeholder) {
      var length = array.length, result = 0;
      while (length--) {
        if (array[length] === placeholder) {
          ++result;
        }
      }
      return result;
    }
    var deburrLetter = basePropertyOf(deburredLetters);
    var escapeHtmlChar = basePropertyOf(htmlEscapes);
    function escapeStringChar(chr) {
      return "\\" + stringEscapes[chr];
    }
    function getValue(object, key) {
      return object == null ? undefined$1 : object[key];
    }
    function hasUnicode(string) {
      return reHasUnicode.test(string);
    }
    function hasUnicodeWord(string) {
      return reHasUnicodeWord.test(string);
    }
    function iteratorToArray(iterator) {
      var data, result = [];
      while (!(data = iterator.next()).done) {
        result.push(data.value);
      }
      return result;
    }
    function mapToArray(map) {
      var index2 = -1, result = Array(map.size);
      map.forEach(function(value, key) {
        result[++index2] = [key, value];
      });
      return result;
    }
    function overArg(func, transform2) {
      return function(arg) {
        return func(transform2(arg));
      };
    }
    function replaceHolders(array, placeholder) {
      var index2 = -1, length = array.length, resIndex = 0, result = [];
      while (++index2 < length) {
        var value = array[index2];
        if (value === placeholder || value === PLACEHOLDER) {
          array[index2] = PLACEHOLDER;
          result[resIndex++] = index2;
        }
      }
      return result;
    }
    function setToArray(set2) {
      var index2 = -1, result = Array(set2.size);
      set2.forEach(function(value) {
        result[++index2] = value;
      });
      return result;
    }
    function setToPairs(set2) {
      var index2 = -1, result = Array(set2.size);
      set2.forEach(function(value) {
        result[++index2] = [value, value];
      });
      return result;
    }
    function strictIndexOf(array, value, fromIndex) {
      var index2 = fromIndex - 1, length = array.length;
      while (++index2 < length) {
        if (array[index2] === value) {
          return index2;
        }
      }
      return -1;
    }
    function strictLastIndexOf(array, value, fromIndex) {
      var index2 = fromIndex + 1;
      while (index2--) {
        if (array[index2] === value) {
          return index2;
        }
      }
      return index2;
    }
    function stringSize(string) {
      return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
    }
    function stringToArray(string) {
      return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
    }
    function trimmedEndIndex(string) {
      var index2 = string.length;
      while (index2-- && reWhitespace.test(string.charAt(index2))) {
      }
      return index2;
    }
    var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
    function unicodeSize(string) {
      var result = reUnicode.lastIndex = 0;
      while (reUnicode.test(string)) {
        ++result;
      }
      return result;
    }
    function unicodeToArray(string) {
      return string.match(reUnicode) || [];
    }
    function unicodeWords(string) {
      return string.match(reUnicodeWord) || [];
    }
    var runInContext = function runInContext2(context) {
      context = context == null ? root : _2.defaults(root.Object(), context, _2.pick(root, contextProps));
      var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
      var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
      var coreJsData = context["__core-js_shared__"];
      var funcToString = funcProto.toString;
      var hasOwnProperty2 = objectProto.hasOwnProperty;
      var idCounter = 0;
      var maskSrcKey = function() {
        var uid2 = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
        return uid2 ? "Symbol(src)_1." + uid2 : "";
      }();
      var nativeObjectToString = objectProto.toString;
      var objectCtorString = funcToString.call(Object2);
      var oldDash = root._;
      var reIsNative = RegExp2(
        "^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      );
      var Buffer2 = moduleExports ? context.Buffer : undefined$1, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined$1, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined$1, symIterator = Symbol2 ? Symbol2.iterator : undefined$1, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined$1;
      var defineProperty = function() {
        try {
          var func = getNative(Object2, "defineProperty");
          func({}, "", {});
          return func;
        } catch (e3) {
        }
      }();
      var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
      var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined$1, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
      var DataView2 = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap2 = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
      var metaMap = WeakMap2 && new WeakMap2();
      var realNames = {};
      var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
      var symbolProto = Symbol2 ? Symbol2.prototype : undefined$1, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined$1, symbolToString = symbolProto ? symbolProto.toString : undefined$1;
      function lodash2(value) {
        if (isObjectLike(value) && !isArray2(value) && !(value instanceof LazyWrapper)) {
          if (value instanceof LodashWrapper) {
            return value;
          }
          if (hasOwnProperty2.call(value, "__wrapped__")) {
            return wrapperClone(value);
          }
        }
        return new LodashWrapper(value);
      }
      var baseCreate = function() {
        function object() {
        }
        return function(proto) {
          if (!isObject2(proto)) {
            return {};
          }
          if (objectCreate) {
            return objectCreate(proto);
          }
          object.prototype = proto;
          var result2 = new object();
          object.prototype = undefined$1;
          return result2;
        };
      }();
      function baseLodash() {
      }
      function LodashWrapper(value, chainAll) {
        this.__wrapped__ = value;
        this.__actions__ = [];
        this.__chain__ = !!chainAll;
        this.__index__ = 0;
        this.__values__ = undefined$1;
      }
      lodash2.templateSettings = {
        "escape": reEscape,
        "evaluate": reEvaluate,
        "interpolate": reInterpolate,
        "variable": "",
        "imports": {
          "_": lodash2
        }
      };
      lodash2.prototype = baseLodash.prototype;
      lodash2.prototype.constructor = lodash2;
      LodashWrapper.prototype = baseCreate(baseLodash.prototype);
      LodashWrapper.prototype.constructor = LodashWrapper;
      function LazyWrapper(value) {
        this.__wrapped__ = value;
        this.__actions__ = [];
        this.__dir__ = 1;
        this.__filtered__ = false;
        this.__iteratees__ = [];
        this.__takeCount__ = MAX_ARRAY_LENGTH;
        this.__views__ = [];
      }
      function lazyClone() {
        var result2 = new LazyWrapper(this.__wrapped__);
        result2.__actions__ = copyArray(this.__actions__);
        result2.__dir__ = this.__dir__;
        result2.__filtered__ = this.__filtered__;
        result2.__iteratees__ = copyArray(this.__iteratees__);
        result2.__takeCount__ = this.__takeCount__;
        result2.__views__ = copyArray(this.__views__);
        return result2;
      }
      function lazyReverse() {
        if (this.__filtered__) {
          var result2 = new LazyWrapper(this);
          result2.__dir__ = -1;
          result2.__filtered__ = true;
        } else {
          result2 = this.clone();
          result2.__dir__ *= -1;
        }
        return result2;
      }
      function lazyValue() {
        var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray2(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index2 = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
        if (!isArr || !isRight && arrLength == length && takeCount == length) {
          return baseWrapperValue(array, this.__actions__);
        }
        var result2 = [];
        outer:
          while (length-- && resIndex < takeCount) {
            index2 += dir;
            var iterIndex = -1, value = array[index2];
            while (++iterIndex < iterLength) {
              var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed2 = iteratee2(value);
              if (type == LAZY_MAP_FLAG) {
                value = computed2;
              } else if (!computed2) {
                if (type == LAZY_FILTER_FLAG) {
                  continue outer;
                } else {
                  break outer;
                }
              }
            }
            result2[resIndex++] = value;
          }
        return result2;
      }
      LazyWrapper.prototype = baseCreate(baseLodash.prototype);
      LazyWrapper.prototype.constructor = LazyWrapper;
      function Hash(entries) {
        var index2 = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index2 < length) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
        this.size = 0;
      }
      function hashDelete(key) {
        var result2 = this.has(key) && delete this.__data__[key];
        this.size -= result2 ? 1 : 0;
        return result2;
      }
      function hashGet(key) {
        var data = this.__data__;
        if (nativeCreate) {
          var result2 = data[key];
          return result2 === HASH_UNDEFINED ? undefined$1 : result2;
        }
        return hasOwnProperty2.call(data, key) ? data[key] : undefined$1;
      }
      function hashHas(key) {
        var data = this.__data__;
        return nativeCreate ? data[key] !== undefined$1 : hasOwnProperty2.call(data, key);
      }
      function hashSet(key, value) {
        var data = this.__data__;
        this.size += this.has(key) ? 0 : 1;
        data[key] = nativeCreate && value === undefined$1 ? HASH_UNDEFINED : value;
        return this;
      }
      Hash.prototype.clear = hashClear;
      Hash.prototype["delete"] = hashDelete;
      Hash.prototype.get = hashGet;
      Hash.prototype.has = hashHas;
      Hash.prototype.set = hashSet;
      function ListCache(entries) {
        var index2 = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index2 < length) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      function listCacheClear() {
        this.__data__ = [];
        this.size = 0;
      }
      function listCacheDelete(key) {
        var data = this.__data__, index2 = assocIndexOf(data, key);
        if (index2 < 0) {
          return false;
        }
        var lastIndex = data.length - 1;
        if (index2 == lastIndex) {
          data.pop();
        } else {
          splice.call(data, index2, 1);
        }
        --this.size;
        return true;
      }
      function listCacheGet(key) {
        var data = this.__data__, index2 = assocIndexOf(data, key);
        return index2 < 0 ? undefined$1 : data[index2][1];
      }
      function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
      }
      function listCacheSet(key, value) {
        var data = this.__data__, index2 = assocIndexOf(data, key);
        if (index2 < 0) {
          ++this.size;
          data.push([key, value]);
        } else {
          data[index2][1] = value;
        }
        return this;
      }
      ListCache.prototype.clear = listCacheClear;
      ListCache.prototype["delete"] = listCacheDelete;
      ListCache.prototype.get = listCacheGet;
      ListCache.prototype.has = listCacheHas;
      ListCache.prototype.set = listCacheSet;
      function MapCache(entries) {
        var index2 = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index2 < length) {
          var entry = entries[index2];
          this.set(entry[0], entry[1]);
        }
      }
      function mapCacheClear() {
        this.size = 0;
        this.__data__ = {
          "hash": new Hash(),
          "map": new (Map2 || ListCache)(),
          "string": new Hash()
        };
      }
      function mapCacheDelete(key) {
        var result2 = getMapData(this, key)["delete"](key);
        this.size -= result2 ? 1 : 0;
        return result2;
      }
      function mapCacheGet(key) {
        return getMapData(this, key).get(key);
      }
      function mapCacheHas(key) {
        return getMapData(this, key).has(key);
      }
      function mapCacheSet(key, value) {
        var data = getMapData(this, key), size3 = data.size;
        data.set(key, value);
        this.size += data.size == size3 ? 0 : 1;
        return this;
      }
      MapCache.prototype.clear = mapCacheClear;
      MapCache.prototype["delete"] = mapCacheDelete;
      MapCache.prototype.get = mapCacheGet;
      MapCache.prototype.has = mapCacheHas;
      MapCache.prototype.set = mapCacheSet;
      function SetCache(values2) {
        var index2 = -1, length = values2 == null ? 0 : values2.length;
        this.__data__ = new MapCache();
        while (++index2 < length) {
          this.add(values2[index2]);
        }
      }
      function setCacheAdd(value) {
        this.__data__.set(value, HASH_UNDEFINED);
        return this;
      }
      function setCacheHas(value) {
        return this.__data__.has(value);
      }
      SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
      SetCache.prototype.has = setCacheHas;
      function Stack(entries) {
        var data = this.__data__ = new ListCache(entries);
        this.size = data.size;
      }
      function stackClear() {
        this.__data__ = new ListCache();
        this.size = 0;
      }
      function stackDelete(key) {
        var data = this.__data__, result2 = data["delete"](key);
        this.size = data.size;
        return result2;
      }
      function stackGet(key) {
        return this.__data__.get(key);
      }
      function stackHas(key) {
        return this.__data__.has(key);
      }
      function stackSet(key, value) {
        var data = this.__data__;
        if (data instanceof ListCache) {
          var pairs = data.__data__;
          if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([key, value]);
            this.size = ++data.size;
            return this;
          }
          data = this.__data__ = new MapCache(pairs);
        }
        data.set(key, value);
        this.size = data.size;
        return this;
      }
      Stack.prototype.clear = stackClear;
      Stack.prototype["delete"] = stackDelete;
      Stack.prototype.get = stackGet;
      Stack.prototype.has = stackHas;
      Stack.prototype.set = stackSet;
      function arrayLikeKeys(value, inherited) {
        var isArr = isArray2(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer2(value), isType = !isArr && !isArg && !isBuff && isTypedArray2(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
        for (var key in value) {
          if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
            result2.push(key);
          }
        }
        return result2;
      }
      function arraySample(array) {
        var length = array.length;
        return length ? array[baseRandom(0, length - 1)] : undefined$1;
      }
      function arraySampleSize(array, n2) {
        return shuffleSelf(copyArray(array), baseClamp(n2, 0, array.length));
      }
      function arrayShuffle(array) {
        return shuffleSelf(copyArray(array));
      }
      function assignMergeValue(object, key, value) {
        if (value !== undefined$1 && !eq(object[key], value) || value === undefined$1 && !(key in object)) {
          baseAssignValue(object, key, value);
        }
      }
      function assignValue(object, key, value) {
        var objValue = object[key];
        if (!(hasOwnProperty2.call(object, key) && eq(objValue, value)) || value === undefined$1 && !(key in object)) {
          baseAssignValue(object, key, value);
        }
      }
      function assocIndexOf(array, key) {
        var length = array.length;
        while (length--) {
          if (eq(array[length][0], key)) {
            return length;
          }
        }
        return -1;
      }
      function baseAggregator(collection, setter, iteratee2, accumulator) {
        baseEach(collection, function(value, key, collection2) {
          setter(accumulator, value, iteratee2(value), collection2);
        });
        return accumulator;
      }
      function baseAssign(object, source) {
        return object && copyObject(source, keys(source), object);
      }
      function baseAssignIn(object, source) {
        return object && copyObject(source, keysIn(source), object);
      }
      function baseAssignValue(object, key, value) {
        if (key == "__proto__" && defineProperty) {
          defineProperty(object, key, {
            "configurable": true,
            "enumerable": true,
            "value": value,
            "writable": true
          });
        } else {
          object[key] = value;
        }
      }
      function baseAt(object, paths) {
        var index2 = -1, length = paths.length, result2 = Array2(length), skip = object == null;
        while (++index2 < length) {
          result2[index2] = skip ? undefined$1 : get2(object, paths[index2]);
        }
        return result2;
      }
      function baseClamp(number, lower, upper) {
        if (number === number) {
          if (upper !== undefined$1) {
            number = number <= upper ? number : upper;
          }
          if (lower !== undefined$1) {
            number = number >= lower ? number : lower;
          }
        }
        return number;
      }
      function baseClone(value, bitmask, customizer, key, object, stack) {
        var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
        if (customizer) {
          result2 = object ? customizer(value, key, object, stack) : customizer(value);
        }
        if (result2 !== undefined$1) {
          return result2;
        }
        if (!isObject2(value)) {
          return value;
        }
        var isArr = isArray2(value);
        if (isArr) {
          result2 = initCloneArray(value);
          if (!isDeep) {
            return copyArray(value, result2);
          }
        } else {
          var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
          if (isBuffer2(value)) {
            return cloneBuffer(value, isDeep);
          }
          if (tag == objectTag || tag == argsTag || isFunc && !object) {
            result2 = isFlat || isFunc ? {} : initCloneObject(value);
            if (!isDeep) {
              return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
            }
          } else {
            if (!cloneableTags[tag]) {
              return object ? value : {};
            }
            result2 = initCloneByTag(value, tag, isDeep);
          }
        }
        stack || (stack = new Stack());
        var stacked = stack.get(value);
        if (stacked) {
          return stacked;
        }
        stack.set(value, result2);
        if (isSet2(value)) {
          value.forEach(function(subValue) {
            result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
          });
        } else if (isMap2(value)) {
          value.forEach(function(subValue, key2) {
            result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
        }
        var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
        var props = isArr ? undefined$1 : keysFunc(value);
        arrayEach(props || value, function(subValue, key2) {
          if (props) {
            key2 = subValue;
            subValue = value[key2];
          }
          assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
        });
        return result2;
      }
      function baseConforms(source) {
        var props = keys(source);
        return function(object) {
          return baseConformsTo(object, source, props);
        };
      }
      function baseConformsTo(object, source, props) {
        var length = props.length;
        if (object == null) {
          return !length;
        }
        object = Object2(object);
        while (length--) {
          var key = props[length], predicate = source[key], value = object[key];
          if (value === undefined$1 && !(key in object) || !predicate(value)) {
            return false;
          }
        }
        return true;
      }
      function baseDelay(func, wait, args) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        return setTimeout2(function() {
          func.apply(undefined$1, args);
        }, wait);
      }
      function baseDifference(array, values2, iteratee2, comparator2) {
        var index2 = -1, includes3 = arrayIncludes, isCommon = true, length = array.length, result2 = [], valuesLength = values2.length;
        if (!length) {
          return result2;
        }
        if (iteratee2) {
          values2 = arrayMap(values2, baseUnary(iteratee2));
        }
        if (comparator2) {
          includes3 = arrayIncludesWith;
          isCommon = false;
        } else if (values2.length >= LARGE_ARRAY_SIZE) {
          includes3 = cacheHas;
          isCommon = false;
          values2 = new SetCache(values2);
        }
        outer:
          while (++index2 < length) {
            var value = array[index2], computed2 = iteratee2 == null ? value : iteratee2(value);
            value = comparator2 || value !== 0 ? value : 0;
            if (isCommon && computed2 === computed2) {
              var valuesIndex = valuesLength;
              while (valuesIndex--) {
                if (values2[valuesIndex] === computed2) {
                  continue outer;
                }
              }
              result2.push(value);
            } else if (!includes3(values2, computed2, comparator2)) {
              result2.push(value);
            }
          }
        return result2;
      }
      var baseEach = createBaseEach(baseForOwn);
      var baseEachRight = createBaseEach(baseForOwnRight, true);
      function baseEvery(collection, predicate) {
        var result2 = true;
        baseEach(collection, function(value, index2, collection2) {
          result2 = !!predicate(value, index2, collection2);
          return result2;
        });
        return result2;
      }
      function baseExtremum(array, iteratee2, comparator2) {
        var index2 = -1, length = array.length;
        while (++index2 < length) {
          var value = array[index2], current = iteratee2(value);
          if (current != null && (computed2 === undefined$1 ? current === current && !isSymbol2(current) : comparator2(current, computed2))) {
            var computed2 = current, result2 = value;
          }
        }
        return result2;
      }
      function baseFill(array, value, start, end) {
        var length = array.length;
        start = toInteger2(start);
        if (start < 0) {
          start = -start > length ? 0 : length + start;
        }
        end = end === undefined$1 || end > length ? length : toInteger2(end);
        if (end < 0) {
          end += length;
        }
        end = start > end ? 0 : toLength(end);
        while (start < end) {
          array[start++] = value;
        }
        return array;
      }
      function baseFilter(collection, predicate) {
        var result2 = [];
        baseEach(collection, function(value, index2, collection2) {
          if (predicate(value, index2, collection2)) {
            result2.push(value);
          }
        });
        return result2;
      }
      function baseFlatten(array, depth, predicate, isStrict, result2) {
        var index2 = -1, length = array.length;
        predicate || (predicate = isFlattenable);
        result2 || (result2 = []);
        while (++index2 < length) {
          var value = array[index2];
          if (depth > 0 && predicate(value)) {
            if (depth > 1) {
              baseFlatten(value, depth - 1, predicate, isStrict, result2);
            } else {
              arrayPush(result2, value);
            }
          } else if (!isStrict) {
            result2[result2.length] = value;
          }
        }
        return result2;
      }
      var baseFor = createBaseFor();
      var baseForRight = createBaseFor(true);
      function baseForOwn(object, iteratee2) {
        return object && baseFor(object, iteratee2, keys);
      }
      function baseForOwnRight(object, iteratee2) {
        return object && baseForRight(object, iteratee2, keys);
      }
      function baseFunctions(object, props) {
        return arrayFilter(props, function(key) {
          return isFunction2(object[key]);
        });
      }
      function baseGet(object, path) {
        path = castPath(path, object);
        var index2 = 0, length = path.length;
        while (object != null && index2 < length) {
          object = object[toKey(path[index2++])];
        }
        return index2 && index2 == length ? object : undefined$1;
      }
      function baseGetAllKeys(object, keysFunc, symbolsFunc) {
        var result2 = keysFunc(object);
        return isArray2(object) ? result2 : arrayPush(result2, symbolsFunc(object));
      }
      function baseGetTag(value) {
        if (value == null) {
          return value === undefined$1 ? undefinedTag : nullTag;
        }
        return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString2(value);
      }
      function baseGt(value, other) {
        return value > other;
      }
      function baseHas(object, key) {
        return object != null && hasOwnProperty2.call(object, key);
      }
      function baseHasIn(object, key) {
        return object != null && key in Object2(object);
      }
      function baseInRange(number, start, end) {
        return number >= nativeMin(start, end) && number < nativeMax(start, end);
      }
      function baseIntersection(arrays, iteratee2, comparator2) {
        var includes3 = comparator2 ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
        while (othIndex--) {
          var array = arrays[othIndex];
          if (othIndex && iteratee2) {
            array = arrayMap(array, baseUnary(iteratee2));
          }
          maxLength = nativeMin(array.length, maxLength);
          caches[othIndex] = !comparator2 && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined$1;
        }
        array = arrays[0];
        var index2 = -1, seen2 = caches[0];
        outer:
          while (++index2 < length && result2.length < maxLength) {
            var value = array[index2], computed2 = iteratee2 ? iteratee2(value) : value;
            value = comparator2 || value !== 0 ? value : 0;
            if (!(seen2 ? cacheHas(seen2, computed2) : includes3(result2, computed2, comparator2))) {
              othIndex = othLength;
              while (--othIndex) {
                var cache = caches[othIndex];
                if (!(cache ? cacheHas(cache, computed2) : includes3(arrays[othIndex], computed2, comparator2))) {
                  continue outer;
                }
              }
              if (seen2) {
                seen2.push(computed2);
              }
              result2.push(value);
            }
          }
        return result2;
      }
      function baseInverter(object, setter, iteratee2, accumulator) {
        baseForOwn(object, function(value, key, object2) {
          setter(accumulator, iteratee2(value), key, object2);
        });
        return accumulator;
      }
      function baseInvoke(object, path, args) {
        path = castPath(path, object);
        object = parent(object, path);
        var func = object == null ? object : object[toKey(last(path))];
        return func == null ? undefined$1 : apply(func, object, args);
      }
      function baseIsArguments(value) {
        return isObjectLike(value) && baseGetTag(value) == argsTag;
      }
      function baseIsArrayBuffer(value) {
        return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
      }
      function baseIsDate(value) {
        return isObjectLike(value) && baseGetTag(value) == dateTag;
      }
      function baseIsEqual(value, other, bitmask, customizer, stack) {
        if (value === other) {
          return true;
        }
        if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
          return value !== value && other !== other;
        }
        return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
      }
      function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
        var objIsArr = isArray2(object), othIsArr = isArray2(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
        objTag = objTag == argsTag ? objectTag : objTag;
        othTag = othTag == argsTag ? objectTag : othTag;
        var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
        if (isSameTag && isBuffer2(object)) {
          if (!isBuffer2(other)) {
            return false;
          }
          objIsArr = true;
          objIsObj = false;
        }
        if (isSameTag && !objIsObj) {
          stack || (stack = new Stack());
          return objIsArr || isTypedArray2(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
        }
        if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
          var objIsWrapped = objIsObj && hasOwnProperty2.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
          if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
            stack || (stack = new Stack());
            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
          }
        }
        if (!isSameTag) {
          return false;
        }
        stack || (stack = new Stack());
        return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
      }
      function baseIsMap(value) {
        return isObjectLike(value) && getTag(value) == mapTag;
      }
      function baseIsMatch(object, source, matchData, customizer) {
        var index2 = matchData.length, length = index2, noCustomizer = !customizer;
        if (object == null) {
          return !length;
        }
        object = Object2(object);
        while (index2--) {
          var data = matchData[index2];
          if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
            return false;
          }
        }
        while (++index2 < length) {
          data = matchData[index2];
          var key = data[0], objValue = object[key], srcValue = data[1];
          if (noCustomizer && data[2]) {
            if (objValue === undefined$1 && !(key in object)) {
              return false;
            }
          } else {
            var stack = new Stack();
            if (customizer) {
              var result2 = customizer(objValue, srcValue, key, object, source, stack);
            }
            if (!(result2 === undefined$1 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
              return false;
            }
          }
        }
        return true;
      }
      function baseIsNative(value) {
        if (!isObject2(value) || isMasked(value)) {
          return false;
        }
        var pattern = isFunction2(value) ? reIsNative : reIsHostCtor;
        return pattern.test(toSource(value));
      }
      function baseIsRegExp(value) {
        return isObjectLike(value) && baseGetTag(value) == regexpTag;
      }
      function baseIsSet(value) {
        return isObjectLike(value) && getTag(value) == setTag;
      }
      function baseIsTypedArray(value) {
        return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
      }
      function baseIteratee(value) {
        if (typeof value == "function") {
          return value;
        }
        if (value == null) {
          return identity;
        }
        if (typeof value == "object") {
          return isArray2(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
        }
        return property(value);
      }
      function baseKeys(object) {
        if (!isPrototype(object)) {
          return nativeKeys(object);
        }
        var result2 = [];
        for (var key in Object2(object)) {
          if (hasOwnProperty2.call(object, key) && key != "constructor") {
            result2.push(key);
          }
        }
        return result2;
      }
      function baseKeysIn(object) {
        if (!isObject2(object)) {
          return nativeKeysIn(object);
        }
        var isProto = isPrototype(object), result2 = [];
        for (var key in object) {
          if (!(key == "constructor" && (isProto || !hasOwnProperty2.call(object, key)))) {
            result2.push(key);
          }
        }
        return result2;
      }
      function baseLt(value, other) {
        return value < other;
      }
      function baseMap(collection, iteratee2) {
        var index2 = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
        baseEach(collection, function(value, key, collection2) {
          result2[++index2] = iteratee2(value, key, collection2);
        });
        return result2;
      }
      function baseMatches(source) {
        var matchData = getMatchData(source);
        if (matchData.length == 1 && matchData[0][2]) {
          return matchesStrictComparable(matchData[0][0], matchData[0][1]);
        }
        return function(object) {
          return object === source || baseIsMatch(object, source, matchData);
        };
      }
      function baseMatchesProperty(path, srcValue) {
        if (isKey(path) && isStrictComparable(srcValue)) {
          return matchesStrictComparable(toKey(path), srcValue);
        }
        return function(object) {
          var objValue = get2(object, path);
          return objValue === undefined$1 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
        };
      }
      function baseMerge(object, source, srcIndex, customizer, stack) {
        if (object === source) {
          return;
        }
        baseFor(source, function(srcValue, key) {
          stack || (stack = new Stack());
          if (isObject2(srcValue)) {
            baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
          } else {
            var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined$1;
            if (newValue === undefined$1) {
              newValue = srcValue;
            }
            assignMergeValue(object, key, newValue);
          }
        }, keysIn);
      }
      function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
        var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
        if (stacked) {
          assignMergeValue(object, key, stacked);
          return;
        }
        var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined$1;
        var isCommon = newValue === undefined$1;
        if (isCommon) {
          var isArr = isArray2(srcValue), isBuff = !isArr && isBuffer2(srcValue), isTyped = !isArr && !isBuff && isTypedArray2(srcValue);
          newValue = srcValue;
          if (isArr || isBuff || isTyped) {
            if (isArray2(objValue)) {
              newValue = objValue;
            } else if (isArrayLikeObject(objValue)) {
              newValue = copyArray(objValue);
            } else if (isBuff) {
              isCommon = false;
              newValue = cloneBuffer(srcValue, true);
            } else if (isTyped) {
              isCommon = false;
              newValue = cloneTypedArray(srcValue, true);
            } else {
              newValue = [];
            }
          } else if (isPlainObject2(srcValue) || isArguments(srcValue)) {
            newValue = objValue;
            if (isArguments(objValue)) {
              newValue = toPlainObject(objValue);
            } else if (!isObject2(objValue) || isFunction2(objValue)) {
              newValue = initCloneObject(srcValue);
            }
          } else {
            isCommon = false;
          }
        }
        if (isCommon) {
          stack.set(srcValue, newValue);
          mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
          stack["delete"](srcValue);
        }
        assignMergeValue(object, key, newValue);
      }
      function baseNth(array, n2) {
        var length = array.length;
        if (!length) {
          return;
        }
        n2 += n2 < 0 ? length : 0;
        return isIndex(n2, length) ? array[n2] : undefined$1;
      }
      function baseOrderBy(collection, iteratees, orders) {
        if (iteratees.length) {
          iteratees = arrayMap(iteratees, function(iteratee2) {
            if (isArray2(iteratee2)) {
              return function(value) {
                return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
              };
            }
            return iteratee2;
          });
        } else {
          iteratees = [identity];
        }
        var index2 = -1;
        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
        var result2 = baseMap(collection, function(value, key, collection2) {
          var criteria = arrayMap(iteratees, function(iteratee2) {
            return iteratee2(value);
          });
          return { "criteria": criteria, "index": ++index2, "value": value };
        });
        return baseSortBy(result2, function(object, other) {
          return compareMultiple(object, other, orders);
        });
      }
      function basePick(object, paths) {
        return basePickBy(object, paths, function(value, path) {
          return hasIn(object, path);
        });
      }
      function basePickBy(object, paths, predicate) {
        var index2 = -1, length = paths.length, result2 = {};
        while (++index2 < length) {
          var path = paths[index2], value = baseGet(object, path);
          if (predicate(value, path)) {
            baseSet(result2, castPath(path, object), value);
          }
        }
        return result2;
      }
      function basePropertyDeep(path) {
        return function(object) {
          return baseGet(object, path);
        };
      }
      function basePullAll(array, values2, iteratee2, comparator2) {
        var indexOf2 = comparator2 ? baseIndexOfWith : baseIndexOf, index2 = -1, length = values2.length, seen2 = array;
        if (array === values2) {
          values2 = copyArray(values2);
        }
        if (iteratee2) {
          seen2 = arrayMap(array, baseUnary(iteratee2));
        }
        while (++index2 < length) {
          var fromIndex = 0, value = values2[index2], computed2 = iteratee2 ? iteratee2(value) : value;
          while ((fromIndex = indexOf2(seen2, computed2, fromIndex, comparator2)) > -1) {
            if (seen2 !== array) {
              splice.call(seen2, fromIndex, 1);
            }
            splice.call(array, fromIndex, 1);
          }
        }
        return array;
      }
      function basePullAt(array, indexes) {
        var length = array ? indexes.length : 0, lastIndex = length - 1;
        while (length--) {
          var index2 = indexes[length];
          if (length == lastIndex || index2 !== previous) {
            var previous = index2;
            if (isIndex(index2)) {
              splice.call(array, index2, 1);
            } else {
              baseUnset(array, index2);
            }
          }
        }
        return array;
      }
      function baseRandom(lower, upper) {
        return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
      }
      function baseRange(start, end, step, fromRight) {
        var index2 = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length);
        while (length--) {
          result2[fromRight ? length : ++index2] = start;
          start += step;
        }
        return result2;
      }
      function baseRepeat(string, n2) {
        var result2 = "";
        if (!string || n2 < 1 || n2 > MAX_SAFE_INTEGER) {
          return result2;
        }
        do {
          if (n2 % 2) {
            result2 += string;
          }
          n2 = nativeFloor(n2 / 2);
          if (n2) {
            string += string;
          }
        } while (n2);
        return result2;
      }
      function baseRest(func, start) {
        return setToString(overRest(func, start, identity), func + "");
      }
      function baseSample(collection) {
        return arraySample(values(collection));
      }
      function baseSampleSize(collection, n2) {
        var array = values(collection);
        return shuffleSelf(array, baseClamp(n2, 0, array.length));
      }
      function baseSet(object, path, value, customizer) {
        if (!isObject2(object)) {
          return object;
        }
        path = castPath(path, object);
        var index2 = -1, length = path.length, lastIndex = length - 1, nested = object;
        while (nested != null && ++index2 < length) {
          var key = toKey(path[index2]), newValue = value;
          if (key === "__proto__" || key === "constructor" || key === "prototype") {
            return object;
          }
          if (index2 != lastIndex) {
            var objValue = nested[key];
            newValue = customizer ? customizer(objValue, key, nested) : undefined$1;
            if (newValue === undefined$1) {
              newValue = isObject2(objValue) ? objValue : isIndex(path[index2 + 1]) ? [] : {};
            }
          }
          assignValue(nested, key, newValue);
          nested = nested[key];
        }
        return object;
      }
      var baseSetData = !metaMap ? identity : function(func, data) {
        metaMap.set(func, data);
        return func;
      };
      var baseSetToString = !defineProperty ? identity : function(func, string) {
        return defineProperty(func, "toString", {
          "configurable": true,
          "enumerable": false,
          "value": constant(string),
          "writable": true
        });
      };
      function baseShuffle(collection) {
        return shuffleSelf(values(collection));
      }
      function baseSlice(array, start, end) {
        var index2 = -1, length = array.length;
        if (start < 0) {
          start = -start > length ? 0 : length + start;
        }
        end = end > length ? length : end;
        if (end < 0) {
          end += length;
        }
        length = start > end ? 0 : end - start >>> 0;
        start >>>= 0;
        var result2 = Array2(length);
        while (++index2 < length) {
          result2[index2] = array[index2 + start];
        }
        return result2;
      }
      function baseSome(collection, predicate) {
        var result2;
        baseEach(collection, function(value, index2, collection2) {
          result2 = predicate(value, index2, collection2);
          return !result2;
        });
        return !!result2;
      }
      function baseSortedIndex(array, value, retHighest) {
        var low = 0, high = array == null ? low : array.length;
        if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
          while (low < high) {
            var mid = low + high >>> 1, computed2 = array[mid];
            if (computed2 !== null && !isSymbol2(computed2) && (retHighest ? computed2 <= value : computed2 < value)) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return high;
        }
        return baseSortedIndexBy(array, value, identity, retHighest);
      }
      function baseSortedIndexBy(array, value, iteratee2, retHighest) {
        var low = 0, high = array == null ? 0 : array.length;
        if (high === 0) {
          return 0;
        }
        value = iteratee2(value);
        var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol2(value), valIsUndefined = value === undefined$1;
        while (low < high) {
          var mid = nativeFloor((low + high) / 2), computed2 = iteratee2(array[mid]), othIsDefined = computed2 !== undefined$1, othIsNull = computed2 === null, othIsReflexive = computed2 === computed2, othIsSymbol = isSymbol2(computed2);
          if (valIsNaN) {
            var setLow = retHighest || othIsReflexive;
          } else if (valIsUndefined) {
            setLow = othIsReflexive && (retHighest || othIsDefined);
          } else if (valIsNull) {
            setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
          } else if (valIsSymbol) {
            setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
          } else if (othIsNull || othIsSymbol) {
            setLow = false;
          } else {
            setLow = retHighest ? computed2 <= value : computed2 < value;
          }
          if (setLow) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return nativeMin(high, MAX_ARRAY_INDEX);
      }
      function baseSortedUniq(array, iteratee2) {
        var index2 = -1, length = array.length, resIndex = 0, result2 = [];
        while (++index2 < length) {
          var value = array[index2], computed2 = iteratee2 ? iteratee2(value) : value;
          if (!index2 || !eq(computed2, seen2)) {
            var seen2 = computed2;
            result2[resIndex++] = value === 0 ? 0 : value;
          }
        }
        return result2;
      }
      function baseToNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol2(value)) {
          return NAN;
        }
        return +value;
      }
      function baseToString(value) {
        if (typeof value == "string") {
          return value;
        }
        if (isArray2(value)) {
          return arrayMap(value, baseToString) + "";
        }
        if (isSymbol2(value)) {
          return symbolToString ? symbolToString.call(value) : "";
        }
        var result2 = value + "";
        return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
      }
      function baseUniq(array, iteratee2, comparator2) {
        var index2 = -1, includes3 = arrayIncludes, length = array.length, isCommon = true, result2 = [], seen2 = result2;
        if (comparator2) {
          isCommon = false;
          includes3 = arrayIncludesWith;
        } else if (length >= LARGE_ARRAY_SIZE) {
          var set3 = iteratee2 ? null : createSet(array);
          if (set3) {
            return setToArray(set3);
          }
          isCommon = false;
          includes3 = cacheHas;
          seen2 = new SetCache();
        } else {
          seen2 = iteratee2 ? [] : result2;
        }
        outer:
          while (++index2 < length) {
            var value = array[index2], computed2 = iteratee2 ? iteratee2(value) : value;
            value = comparator2 || value !== 0 ? value : 0;
            if (isCommon && computed2 === computed2) {
              var seenIndex = seen2.length;
              while (seenIndex--) {
                if (seen2[seenIndex] === computed2) {
                  continue outer;
                }
              }
              if (iteratee2) {
                seen2.push(computed2);
              }
              result2.push(value);
            } else if (!includes3(seen2, computed2, comparator2)) {
              if (seen2 !== result2) {
                seen2.push(computed2);
              }
              result2.push(value);
            }
          }
        return result2;
      }
      function baseUnset(object, path) {
        path = castPath(path, object);
        object = parent(object, path);
        return object == null || delete object[toKey(last(path))];
      }
      function baseUpdate(object, path, updater, customizer) {
        return baseSet(object, path, updater(baseGet(object, path)), customizer);
      }
      function baseWhile(array, predicate, isDrop, fromRight) {
        var length = array.length, index2 = fromRight ? length : -1;
        while ((fromRight ? index2-- : ++index2 < length) && predicate(array[index2], index2, array)) {
        }
        return isDrop ? baseSlice(array, fromRight ? 0 : index2, fromRight ? index2 + 1 : length) : baseSlice(array, fromRight ? index2 + 1 : 0, fromRight ? length : index2);
      }
      function baseWrapperValue(value, actions) {
        var result2 = value;
        if (result2 instanceof LazyWrapper) {
          result2 = result2.value();
        }
        return arrayReduce(actions, function(result3, action) {
          return action.func.apply(action.thisArg, arrayPush([result3], action.args));
        }, result2);
      }
      function baseXor(arrays, iteratee2, comparator2) {
        var length = arrays.length;
        if (length < 2) {
          return length ? baseUniq(arrays[0]) : [];
        }
        var index2 = -1, result2 = Array2(length);
        while (++index2 < length) {
          var array = arrays[index2], othIndex = -1;
          while (++othIndex < length) {
            if (othIndex != index2) {
              result2[index2] = baseDifference(result2[index2] || array, arrays[othIndex], iteratee2, comparator2);
            }
          }
        }
        return baseUniq(baseFlatten(result2, 1), iteratee2, comparator2);
      }
      function baseZipObject(props, values2, assignFunc) {
        var index2 = -1, length = props.length, valsLength = values2.length, result2 = {};
        while (++index2 < length) {
          var value = index2 < valsLength ? values2[index2] : undefined$1;
          assignFunc(result2, props[index2], value);
        }
        return result2;
      }
      function castArrayLikeObject(value) {
        return isArrayLikeObject(value) ? value : [];
      }
      function castFunction(value) {
        return typeof value == "function" ? value : identity;
      }
      function castPath(value, object) {
        if (isArray2(value)) {
          return value;
        }
        return isKey(value, object) ? [value] : stringToPath(toString3(value));
      }
      var castRest = baseRest;
      function castSlice(array, start, end) {
        var length = array.length;
        end = end === undefined$1 ? length : end;
        return !start && end >= length ? array : baseSlice(array, start, end);
      }
      var clearTimeout2 = ctxClearTimeout || function(id) {
        return root.clearTimeout(id);
      };
      function cloneBuffer(buffer2, isDeep) {
        if (isDeep) {
          return buffer2.slice();
        }
        var length = buffer2.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer2.constructor(length);
        buffer2.copy(result2);
        return result2;
      }
      function cloneArrayBuffer(arrayBuffer) {
        var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
        new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
        return result2;
      }
      function cloneDataView(dataView, isDeep) {
        var buffer2 = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
        return new dataView.constructor(buffer2, dataView.byteOffset, dataView.byteLength);
      }
      function cloneRegExp(regexp) {
        var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
        result2.lastIndex = regexp.lastIndex;
        return result2;
      }
      function cloneSymbol(symbol) {
        return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
      }
      function cloneTypedArray(typedArray, isDeep) {
        var buffer2 = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
        return new typedArray.constructor(buffer2, typedArray.byteOffset, typedArray.length);
      }
      function compareAscending(value, other) {
        if (value !== other) {
          var valIsDefined = value !== undefined$1, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol2(value);
          var othIsDefined = other !== undefined$1, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol2(other);
          if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
            return 1;
          }
          if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
            return -1;
          }
        }
        return 0;
      }
      function compareMultiple(object, other, orders) {
        var index2 = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
        while (++index2 < length) {
          var result2 = compareAscending(objCriteria[index2], othCriteria[index2]);
          if (result2) {
            if (index2 >= ordersLength) {
              return result2;
            }
            var order = orders[index2];
            return result2 * (order == "desc" ? -1 : 1);
          }
        }
        return object.index - other.index;
      }
      function composeArgs(args, partials, holders, isCurried) {
        var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
        while (++leftIndex < leftLength) {
          result2[leftIndex] = partials[leftIndex];
        }
        while (++argsIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result2[holders[argsIndex]] = args[argsIndex];
          }
        }
        while (rangeLength--) {
          result2[leftIndex++] = args[argsIndex++];
        }
        return result2;
      }
      function composeArgsRight(args, partials, holders, isCurried) {
        var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
        while (++argsIndex < rangeLength) {
          result2[argsIndex] = args[argsIndex];
        }
        var offset = argsIndex;
        while (++rightIndex < rightLength) {
          result2[offset + rightIndex] = partials[rightIndex];
        }
        while (++holdersIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result2[offset + holders[holdersIndex]] = args[argsIndex++];
          }
        }
        return result2;
      }
      function copyArray(source, array) {
        var index2 = -1, length = source.length;
        array || (array = Array2(length));
        while (++index2 < length) {
          array[index2] = source[index2];
        }
        return array;
      }
      function copyObject(source, props, object, customizer) {
        var isNew = !object;
        object || (object = {});
        var index2 = -1, length = props.length;
        while (++index2 < length) {
          var key = props[index2];
          var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined$1;
          if (newValue === undefined$1) {
            newValue = source[key];
          }
          if (isNew) {
            baseAssignValue(object, key, newValue);
          } else {
            assignValue(object, key, newValue);
          }
        }
        return object;
      }
      function copySymbols(source, object) {
        return copyObject(source, getSymbols(source), object);
      }
      function copySymbolsIn(source, object) {
        return copyObject(source, getSymbolsIn(source), object);
      }
      function createAggregator(setter, initializer) {
        return function(collection, iteratee2) {
          var func = isArray2(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
          return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
        };
      }
      function createAssigner(assigner) {
        return baseRest(function(object, sources) {
          var index2 = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined$1, guard = length > 2 ? sources[2] : undefined$1;
          customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined$1;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            customizer = length < 3 ? undefined$1 : customizer;
            length = 1;
          }
          object = Object2(object);
          while (++index2 < length) {
            var source = sources[index2];
            if (source) {
              assigner(object, source, index2, customizer);
            }
          }
          return object;
        });
      }
      function createBaseEach(eachFunc, fromRight) {
        return function(collection, iteratee2) {
          if (collection == null) {
            return collection;
          }
          if (!isArrayLike(collection)) {
            return eachFunc(collection, iteratee2);
          }
          var length = collection.length, index2 = fromRight ? length : -1, iterable = Object2(collection);
          while (fromRight ? index2-- : ++index2 < length) {
            if (iteratee2(iterable[index2], index2, iterable) === false) {
              break;
            }
          }
          return collection;
        };
      }
      function createBaseFor(fromRight) {
        return function(object, iteratee2, keysFunc) {
          var index2 = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
          while (length--) {
            var key = props[fromRight ? length : ++index2];
            if (iteratee2(iterable[key], key, iterable) === false) {
              break;
            }
          }
          return object;
        };
      }
      function createBind(func, bitmask, thisArg) {
        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
        function wrapper() {
          var fn2 = this && this !== root && this instanceof wrapper ? Ctor : func;
          return fn2.apply(isBind ? thisArg : this, arguments);
        }
        return wrapper;
      }
      function createCaseFirst(methodName) {
        return function(string) {
          string = toString3(string);
          var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined$1;
          var chr = strSymbols ? strSymbols[0] : string.charAt(0);
          var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
          return chr[methodName]() + trailing;
        };
      }
      function createCompounder(callback) {
        return function(string) {
          return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
        };
      }
      function createCtor(Ctor) {
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return new Ctor();
            case 1:
              return new Ctor(args[0]);
            case 2:
              return new Ctor(args[0], args[1]);
            case 3:
              return new Ctor(args[0], args[1], args[2]);
            case 4:
              return new Ctor(args[0], args[1], args[2], args[3]);
            case 5:
              return new Ctor(args[0], args[1], args[2], args[3], args[4]);
            case 6:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
            case 7:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
          }
          var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
          return isObject2(result2) ? result2 : thisBinding;
        };
      }
      function createCurry(func, bitmask, arity) {
        var Ctor = createCtor(func);
        function wrapper() {
          var length = arguments.length, args = Array2(length), index2 = length, placeholder = getHolder(wrapper);
          while (index2--) {
            args[index2] = arguments[index2];
          }
          var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
          length -= holders.length;
          if (length < arity) {
            return createRecurry(
              func,
              bitmask,
              createHybrid,
              wrapper.placeholder,
              undefined$1,
              args,
              holders,
              undefined$1,
              undefined$1,
              arity - length
            );
          }
          var fn2 = this && this !== root && this instanceof wrapper ? Ctor : func;
          return apply(fn2, this, args);
        }
        return wrapper;
      }
      function createFind(findIndexFunc) {
        return function(collection, predicate, fromIndex) {
          var iterable = Object2(collection);
          if (!isArrayLike(collection)) {
            var iteratee2 = getIteratee(predicate, 3);
            collection = keys(collection);
            predicate = function(key) {
              return iteratee2(iterable[key], key, iterable);
            };
          }
          var index2 = findIndexFunc(collection, predicate, fromIndex);
          return index2 > -1 ? iterable[iteratee2 ? collection[index2] : index2] : undefined$1;
        };
      }
      function createFlow(fromRight) {
        return flatRest(function(funcs) {
          var length = funcs.length, index2 = length, prereq = LodashWrapper.prototype.thru;
          if (fromRight) {
            funcs.reverse();
          }
          while (index2--) {
            var func = funcs[index2];
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            if (prereq && !wrapper && getFuncName(func) == "wrapper") {
              var wrapper = new LodashWrapper([], true);
            }
          }
          index2 = wrapper ? index2 : length;
          while (++index2 < length) {
            func = funcs[index2];
            var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined$1;
            if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
              wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
            } else {
              wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
            }
          }
          return function() {
            var args = arguments, value = args[0];
            if (wrapper && args.length == 1 && isArray2(value)) {
              return wrapper.plant(value).value();
            }
            var index3 = 0, result2 = length ? funcs[index3].apply(this, args) : value;
            while (++index3 < length) {
              result2 = funcs[index3].call(this, result2);
            }
            return result2;
          };
        });
      }
      function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
        var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined$1 : createCtor(func);
        function wrapper() {
          var length = arguments.length, args = Array2(length), index2 = length;
          while (index2--) {
            args[index2] = arguments[index2];
          }
          if (isCurried) {
            var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
          }
          if (partials) {
            args = composeArgs(args, partials, holders, isCurried);
          }
          if (partialsRight) {
            args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
          }
          length -= holdersCount;
          if (isCurried && length < arity) {
            var newHolders = replaceHolders(args, placeholder);
            return createRecurry(
              func,
              bitmask,
              createHybrid,
              wrapper.placeholder,
              thisArg,
              args,
              newHolders,
              argPos,
              ary2,
              arity - length
            );
          }
          var thisBinding = isBind ? thisArg : this, fn2 = isBindKey ? thisBinding[func] : func;
          length = args.length;
          if (argPos) {
            args = reorder(args, argPos);
          } else if (isFlip && length > 1) {
            args.reverse();
          }
          if (isAry && ary2 < length) {
            args.length = ary2;
          }
          if (this && this !== root && this instanceof wrapper) {
            fn2 = Ctor || createCtor(fn2);
          }
          return fn2.apply(thisBinding, args);
        }
        return wrapper;
      }
      function createInverter(setter, toIteratee) {
        return function(object, iteratee2) {
          return baseInverter(object, setter, toIteratee(iteratee2), {});
        };
      }
      function createMathOperation(operator, defaultValue) {
        return function(value, other) {
          var result2;
          if (value === undefined$1 && other === undefined$1) {
            return defaultValue;
          }
          if (value !== undefined$1) {
            result2 = value;
          }
          if (other !== undefined$1) {
            if (result2 === undefined$1) {
              return other;
            }
            if (typeof value == "string" || typeof other == "string") {
              value = baseToString(value);
              other = baseToString(other);
            } else {
              value = baseToNumber(value);
              other = baseToNumber(other);
            }
            result2 = operator(value, other);
          }
          return result2;
        };
      }
      function createOver(arrayFunc) {
        return flatRest(function(iteratees) {
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          return baseRest(function(args) {
            var thisArg = this;
            return arrayFunc(iteratees, function(iteratee2) {
              return apply(iteratee2, thisArg, args);
            });
          });
        });
      }
      function createPadding(length, chars) {
        chars = chars === undefined$1 ? " " : baseToString(chars);
        var charsLength = chars.length;
        if (charsLength < 2) {
          return charsLength ? baseRepeat(chars, length) : chars;
        }
        var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
        return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
      }
      function createPartial(func, bitmask, thisArg, partials) {
        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
        function wrapper() {
          var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn2 = this && this !== root && this instanceof wrapper ? Ctor : func;
          while (++leftIndex < leftLength) {
            args[leftIndex] = partials[leftIndex];
          }
          while (argsLength--) {
            args[leftIndex++] = arguments[++argsIndex];
          }
          return apply(fn2, isBind ? thisArg : this, args);
        }
        return wrapper;
      }
      function createRange2(fromRight) {
        return function(start, end, step) {
          if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
            end = step = undefined$1;
          }
          start = toFinite(start);
          if (end === undefined$1) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }
          step = step === undefined$1 ? start < end ? 1 : -1 : toFinite(step);
          return baseRange(start, end, step, fromRight);
        };
      }
      function createRelationalOperation(operator) {
        return function(value, other) {
          if (!(typeof value == "string" && typeof other == "string")) {
            value = toNumber2(value);
            other = toNumber2(other);
          }
          return operator(value, other);
        };
      }
      function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
        var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined$1, newHoldersRight = isCurry ? undefined$1 : holders, newPartials = isCurry ? partials : undefined$1, newPartialsRight = isCurry ? undefined$1 : partials;
        bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
        bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
        if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
          bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
        }
        var newData = [
          func,
          bitmask,
          thisArg,
          newPartials,
          newHolders,
          newPartialsRight,
          newHoldersRight,
          argPos,
          ary2,
          arity
        ];
        var result2 = wrapFunc.apply(undefined$1, newData);
        if (isLaziable(func)) {
          setData(result2, newData);
        }
        result2.placeholder = placeholder;
        return setWrapToString(result2, func, bitmask);
      }
      function createRound(methodName) {
        var func = Math2[methodName];
        return function(number, precision) {
          number = toNumber2(number);
          precision = precision == null ? 0 : nativeMin(toInteger2(precision), 292);
          if (precision && nativeIsFinite(number)) {
            var pair = (toString3(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
            pair = (toString3(value) + "e").split("e");
            return +(pair[0] + "e" + (+pair[1] - precision));
          }
          return func(number);
        };
      }
      var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop2 : function(values2) {
        return new Set2(values2);
      };
      function createToPairs(keysFunc) {
        return function(object) {
          var tag = getTag(object);
          if (tag == mapTag) {
            return mapToArray(object);
          }
          if (tag == setTag) {
            return setToPairs(object);
          }
          return baseToPairs(object, keysFunc(object));
        };
      }
      function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
        var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
        if (!isBindKey && typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        var length = partials ? partials.length : 0;
        if (!length) {
          bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
          partials = holders = undefined$1;
        }
        ary2 = ary2 === undefined$1 ? ary2 : nativeMax(toInteger2(ary2), 0);
        arity = arity === undefined$1 ? arity : toInteger2(arity);
        length -= holders ? holders.length : 0;
        if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
          var partialsRight = partials, holdersRight = holders;
          partials = holders = undefined$1;
        }
        var data = isBindKey ? undefined$1 : getData(func);
        var newData = [
          func,
          bitmask,
          thisArg,
          partials,
          holders,
          partialsRight,
          holdersRight,
          argPos,
          ary2,
          arity
        ];
        if (data) {
          mergeData(newData, data);
        }
        func = newData[0];
        bitmask = newData[1];
        thisArg = newData[2];
        partials = newData[3];
        holders = newData[4];
        arity = newData[9] = newData[9] === undefined$1 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
        if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
          bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
        }
        if (!bitmask || bitmask == WRAP_BIND_FLAG) {
          var result2 = createBind(func, bitmask, thisArg);
        } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
          result2 = createCurry(func, bitmask, arity);
        } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
          result2 = createPartial(func, bitmask, thisArg, partials);
        } else {
          result2 = createHybrid.apply(undefined$1, newData);
        }
        var setter = data ? baseSetData : setData;
        return setWrapToString(setter(result2, newData), func, bitmask);
      }
      function customDefaultsAssignIn(objValue, srcValue, key, object) {
        if (objValue === undefined$1 || eq(objValue, objectProto[key]) && !hasOwnProperty2.call(object, key)) {
          return srcValue;
        }
        return objValue;
      }
      function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
        if (isObject2(objValue) && isObject2(srcValue)) {
          stack.set(srcValue, objValue);
          baseMerge(objValue, srcValue, undefined$1, customDefaultsMerge, stack);
          stack["delete"](srcValue);
        }
        return objValue;
      }
      function customOmitClone(value) {
        return isPlainObject2(value) ? undefined$1 : value;
      }
      function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
          return false;
        }
        var arrStacked = stack.get(array);
        var othStacked = stack.get(other);
        if (arrStacked && othStacked) {
          return arrStacked == other && othStacked == array;
        }
        var index2 = -1, result2 = true, seen2 = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined$1;
        stack.set(array, other);
        stack.set(other, array);
        while (++index2 < arrLength) {
          var arrValue = array[index2], othValue = other[index2];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index2, other, array, stack) : customizer(arrValue, othValue, index2, array, other, stack);
          }
          if (compared !== undefined$1) {
            if (compared) {
              continue;
            }
            result2 = false;
            break;
          }
          if (seen2) {
            if (!arraySome(other, function(othValue2, othIndex) {
              if (!cacheHas(seen2, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                return seen2.push(othIndex);
              }
            })) {
              result2 = false;
              break;
            }
          } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
            result2 = false;
            break;
          }
        }
        stack["delete"](array);
        stack["delete"](other);
        return result2;
      }
      function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
        switch (tag) {
          case dataViewTag:
            if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
              return false;
            }
            object = object.buffer;
            other = other.buffer;
          case arrayBufferTag:
            if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
              return false;
            }
            return true;
          case boolTag:
          case dateTag:
          case numberTag:
            return eq(+object, +other);
          case errorTag:
            return object.name == other.name && object.message == other.message;
          case regexpTag:
          case stringTag:
            return object == other + "";
          case mapTag:
            var convert = mapToArray;
          case setTag:
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
            convert || (convert = setToArray);
            if (object.size != other.size && !isPartial) {
              return false;
            }
            var stacked = stack.get(object);
            if (stacked) {
              return stacked == other;
            }
            bitmask |= COMPARE_UNORDERED_FLAG;
            stack.set(object, other);
            var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
            stack["delete"](object);
            return result2;
          case symbolTag:
            if (symbolValueOf) {
              return symbolValueOf.call(object) == symbolValueOf.call(other);
            }
        }
        return false;
      }
      function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
        if (objLength != othLength && !isPartial) {
          return false;
        }
        var index2 = objLength;
        while (index2--) {
          var key = objProps[index2];
          if (!(isPartial ? key in other : hasOwnProperty2.call(other, key))) {
            return false;
          }
        }
        var objStacked = stack.get(object);
        var othStacked = stack.get(other);
        if (objStacked && othStacked) {
          return objStacked == other && othStacked == object;
        }
        var result2 = true;
        stack.set(object, other);
        stack.set(other, object);
        var skipCtor = isPartial;
        while (++index2 < objLength) {
          key = objProps[index2];
          var objValue = object[key], othValue = other[key];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
          }
          if (!(compared === undefined$1 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
            result2 = false;
            break;
          }
          skipCtor || (skipCtor = key == "constructor");
        }
        if (result2 && !skipCtor) {
          var objCtor = object.constructor, othCtor = other.constructor;
          if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
            result2 = false;
          }
        }
        stack["delete"](object);
        stack["delete"](other);
        return result2;
      }
      function flatRest(func) {
        return setToString(overRest(func, undefined$1, flatten), func + "");
      }
      function getAllKeys(object) {
        return baseGetAllKeys(object, keys, getSymbols);
      }
      function getAllKeysIn(object) {
        return baseGetAllKeys(object, keysIn, getSymbolsIn);
      }
      var getData = !metaMap ? noop2 : function(func) {
        return metaMap.get(func);
      };
      function getFuncName(func) {
        var result2 = func.name + "", array = realNames[result2], length = hasOwnProperty2.call(realNames, result2) ? array.length : 0;
        while (length--) {
          var data = array[length], otherFunc = data.func;
          if (otherFunc == null || otherFunc == func) {
            return data.name;
          }
        }
        return result2;
      }
      function getHolder(func) {
        var object = hasOwnProperty2.call(lodash2, "placeholder") ? lodash2 : func;
        return object.placeholder;
      }
      function getIteratee() {
        var result2 = lodash2.iteratee || iteratee;
        result2 = result2 === iteratee ? baseIteratee : result2;
        return arguments.length ? result2(arguments[0], arguments[1]) : result2;
      }
      function getMapData(map2, key) {
        var data = map2.__data__;
        return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
      }
      function getMatchData(object) {
        var result2 = keys(object), length = result2.length;
        while (length--) {
          var key = result2[length], value = object[key];
          result2[length] = [key, value, isStrictComparable(value)];
        }
        return result2;
      }
      function getNative(object, key) {
        var value = getValue(object, key);
        return baseIsNative(value) ? value : undefined$1;
      }
      function getRawTag(value) {
        var isOwn = hasOwnProperty2.call(value, symToStringTag), tag = value[symToStringTag];
        try {
          value[symToStringTag] = undefined$1;
          var unmasked = true;
        } catch (e3) {
        }
        var result2 = nativeObjectToString.call(value);
        if (unmasked) {
          if (isOwn) {
            value[symToStringTag] = tag;
          } else {
            delete value[symToStringTag];
          }
        }
        return result2;
      }
      var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
        if (object == null) {
          return [];
        }
        object = Object2(object);
        return arrayFilter(nativeGetSymbols(object), function(symbol) {
          return propertyIsEnumerable.call(object, symbol);
        });
      };
      var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
        var result2 = [];
        while (object) {
          arrayPush(result2, getSymbols(object));
          object = getPrototype(object);
        }
        return result2;
      };
      var getTag = baseGetTag;
      if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
        getTag = function(value) {
          var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined$1, ctorString = Ctor ? toSource(Ctor) : "";
          if (ctorString) {
            switch (ctorString) {
              case dataViewCtorString:
                return dataViewTag;
              case mapCtorString:
                return mapTag;
              case promiseCtorString:
                return promiseTag;
              case setCtorString:
                return setTag;
              case weakMapCtorString:
                return weakMapTag;
            }
          }
          return result2;
        };
      }
      function getView(start, end, transforms) {
        var index2 = -1, length = transforms.length;
        while (++index2 < length) {
          var data = transforms[index2], size3 = data.size;
          switch (data.type) {
            case "drop":
              start += size3;
              break;
            case "dropRight":
              end -= size3;
              break;
            case "take":
              end = nativeMin(end, start + size3);
              break;
            case "takeRight":
              start = nativeMax(start, end - size3);
              break;
          }
        }
        return { "start": start, "end": end };
      }
      function getWrapDetails(source) {
        var match2 = source.match(reWrapDetails);
        return match2 ? match2[1].split(reSplitDetails) : [];
      }
      function hasPath(object, path, hasFunc) {
        path = castPath(path, object);
        var index2 = -1, length = path.length, result2 = false;
        while (++index2 < length) {
          var key = toKey(path[index2]);
          if (!(result2 = object != null && hasFunc(object, key))) {
            break;
          }
          object = object[key];
        }
        if (result2 || ++index2 != length) {
          return result2;
        }
        length = object == null ? 0 : object.length;
        return !!length && isLength(length) && isIndex(key, length) && (isArray2(object) || isArguments(object));
      }
      function initCloneArray(array) {
        var length = array.length, result2 = new array.constructor(length);
        if (length && typeof array[0] == "string" && hasOwnProperty2.call(array, "index")) {
          result2.index = array.index;
          result2.input = array.input;
        }
        return result2;
      }
      function initCloneObject(object) {
        return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
      }
      function initCloneByTag(object, tag, isDeep) {
        var Ctor = object.constructor;
        switch (tag) {
          case arrayBufferTag:
            return cloneArrayBuffer(object);
          case boolTag:
          case dateTag:
            return new Ctor(+object);
          case dataViewTag:
            return cloneDataView(object, isDeep);
          case float32Tag:
          case float64Tag:
          case int8Tag:
          case int16Tag:
          case int32Tag:
          case uint8Tag:
          case uint8ClampedTag:
          case uint16Tag:
          case uint32Tag:
            return cloneTypedArray(object, isDeep);
          case mapTag:
            return new Ctor();
          case numberTag:
          case stringTag:
            return new Ctor(object);
          case regexpTag:
            return cloneRegExp(object);
          case setTag:
            return new Ctor();
          case symbolTag:
            return cloneSymbol(object);
        }
      }
      function insertWrapDetails(source, details) {
        var length = details.length;
        if (!length) {
          return source;
        }
        var lastIndex = length - 1;
        details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
        details = details.join(length > 2 ? ", " : " ");
        return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
      }
      function isFlattenable(value) {
        return isArray2(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
      }
      function isIndex(value, length) {
        var type = typeof value;
        length = length == null ? MAX_SAFE_INTEGER : length;
        return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
      }
      function isIterateeCall(value, index2, object) {
        if (!isObject2(object)) {
          return false;
        }
        var type = typeof index2;
        if (type == "number" ? isArrayLike(object) && isIndex(index2, object.length) : type == "string" && index2 in object) {
          return eq(object[index2], value);
        }
        return false;
      }
      function isKey(value, object) {
        if (isArray2(value)) {
          return false;
        }
        var type = typeof value;
        if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol2(value)) {
          return true;
        }
        return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
      }
      function isKeyable(value) {
        var type = typeof value;
        return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
      }
      function isLaziable(func) {
        var funcName = getFuncName(func), other = lodash2[funcName];
        if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
          return false;
        }
        if (func === other) {
          return true;
        }
        var data = getData(other);
        return !!data && func === data[0];
      }
      function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func;
      }
      var isMaskable = coreJsData ? isFunction2 : stubFalse;
      function isPrototype(value) {
        var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
        return value === proto;
      }
      function isStrictComparable(value) {
        return value === value && !isObject2(value);
      }
      function matchesStrictComparable(key, srcValue) {
        return function(object) {
          if (object == null) {
            return false;
          }
          return object[key] === srcValue && (srcValue !== undefined$1 || key in Object2(object));
        };
      }
      function memoizeCapped(func) {
        var result2 = memoize(func, function(key) {
          if (cache.size === MAX_MEMOIZE_SIZE) {
            cache.clear();
          }
          return key;
        });
        var cache = result2.cache;
        return result2;
      }
      function mergeData(data, source) {
        var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
        var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
        if (!(isCommon || isCombo)) {
          return data;
        }
        if (srcBitmask & WRAP_BIND_FLAG) {
          data[2] = source[2];
          newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
        }
        var value = source[3];
        if (value) {
          var partials = data[3];
          data[3] = partials ? composeArgs(partials, value, source[4]) : value;
          data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
        }
        value = source[5];
        if (value) {
          partials = data[5];
          data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
          data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
        }
        value = source[7];
        if (value) {
          data[7] = value;
        }
        if (srcBitmask & WRAP_ARY_FLAG) {
          data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
        }
        if (data[9] == null) {
          data[9] = source[9];
        }
        data[0] = source[0];
        data[1] = newBitmask;
        return data;
      }
      function nativeKeysIn(object) {
        var result2 = [];
        if (object != null) {
          for (var key in Object2(object)) {
            result2.push(key);
          }
        }
        return result2;
      }
      function objectToString2(value) {
        return nativeObjectToString.call(value);
      }
      function overRest(func, start, transform3) {
        start = nativeMax(start === undefined$1 ? func.length - 1 : start, 0);
        return function() {
          var args = arguments, index2 = -1, length = nativeMax(args.length - start, 0), array = Array2(length);
          while (++index2 < length) {
            array[index2] = args[start + index2];
          }
          index2 = -1;
          var otherArgs = Array2(start + 1);
          while (++index2 < start) {
            otherArgs[index2] = args[index2];
          }
          otherArgs[start] = transform3(array);
          return apply(func, this, otherArgs);
        };
      }
      function parent(object, path) {
        return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
      }
      function reorder(array, indexes) {
        var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
        while (length--) {
          var index2 = indexes[length];
          array[length] = isIndex(index2, arrLength) ? oldArray[index2] : undefined$1;
        }
        return array;
      }
      function safeGet(object, key) {
        if (key === "constructor" && typeof object[key] === "function") {
          return;
        }
        if (key == "__proto__") {
          return;
        }
        return object[key];
      }
      var setData = shortOut(baseSetData);
      var setTimeout2 = ctxSetTimeout || function(func, wait) {
        return root.setTimeout(func, wait);
      };
      var setToString = shortOut(baseSetToString);
      function setWrapToString(wrapper, reference, bitmask) {
        var source = reference + "";
        return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
      }
      function shortOut(func) {
        var count = 0, lastCalled = 0;
        return function() {
          var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
          lastCalled = stamp;
          if (remaining > 0) {
            if (++count >= HOT_COUNT) {
              return arguments[0];
            }
          } else {
            count = 0;
          }
          return func.apply(undefined$1, arguments);
        };
      }
      function shuffleSelf(array, size3) {
        var index2 = -1, length = array.length, lastIndex = length - 1;
        size3 = size3 === undefined$1 ? length : size3;
        while (++index2 < size3) {
          var rand = baseRandom(index2, lastIndex), value = array[rand];
          array[rand] = array[index2];
          array[index2] = value;
        }
        array.length = size3;
        return array;
      }
      var stringToPath = memoizeCapped(function(string) {
        var result2 = [];
        if (string.charCodeAt(0) === 46) {
          result2.push("");
        }
        string.replace(rePropName, function(match2, number, quote, subString) {
          result2.push(quote ? subString.replace(reEscapeChar, "$1") : number || match2);
        });
        return result2;
      });
      function toKey(value) {
        if (typeof value == "string" || isSymbol2(value)) {
          return value;
        }
        var result2 = value + "";
        return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
      }
      function toSource(func) {
        if (func != null) {
          try {
            return funcToString.call(func);
          } catch (e3) {
          }
          try {
            return func + "";
          } catch (e3) {
          }
        }
        return "";
      }
      function updateWrapDetails(details, bitmask) {
        arrayEach(wrapFlags, function(pair) {
          var value = "_." + pair[0];
          if (bitmask & pair[1] && !arrayIncludes(details, value)) {
            details.push(value);
          }
        });
        return details.sort();
      }
      function wrapperClone(wrapper) {
        if (wrapper instanceof LazyWrapper) {
          return wrapper.clone();
        }
        var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
        result2.__actions__ = copyArray(wrapper.__actions__);
        result2.__index__ = wrapper.__index__;
        result2.__values__ = wrapper.__values__;
        return result2;
      }
      function chunk2(array, size3, guard) {
        if (guard ? isIterateeCall(array, size3, guard) : size3 === undefined$1) {
          size3 = 1;
        } else {
          size3 = nativeMax(toInteger2(size3), 0);
        }
        var length = array == null ? 0 : array.length;
        if (!length || size3 < 1) {
          return [];
        }
        var index2 = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size3));
        while (index2 < length) {
          result2[resIndex++] = baseSlice(array, index2, index2 += size3);
        }
        return result2;
      }
      function compact(array) {
        var index2 = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
        while (++index2 < length) {
          var value = array[index2];
          if (value) {
            result2[resIndex++] = value;
          }
        }
        return result2;
      }
      function concat() {
        var length = arguments.length;
        if (!length) {
          return [];
        }
        var args = Array2(length - 1), array = arguments[0], index2 = length;
        while (index2--) {
          args[index2 - 1] = arguments[index2];
        }
        return arrayPush(isArray2(array) ? copyArray(array) : [array], baseFlatten(args, 1));
      }
      var difference = baseRest(function(array, values2) {
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
      });
      var differenceBy = baseRest(function(array, values2) {
        var iteratee2 = last(values2);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined$1;
        }
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
      });
      var differenceWith = baseRest(function(array, values2) {
        var comparator2 = last(values2);
        if (isArrayLikeObject(comparator2)) {
          comparator2 = undefined$1;
        }
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), undefined$1, comparator2) : [];
      });
      function drop(array, n2, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n2 = guard || n2 === undefined$1 ? 1 : toInteger2(n2);
        return baseSlice(array, n2 < 0 ? 0 : n2, length);
      }
      function dropRight(array, n2, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n2 = guard || n2 === undefined$1 ? 1 : toInteger2(n2);
        n2 = length - n2;
        return baseSlice(array, 0, n2 < 0 ? 0 : n2);
      }
      function dropRightWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
      }
      function dropWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
      }
      function fill(array, value, start, end) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        if (start && typeof start != "number" && isIterateeCall(array, value, start)) {
          start = 0;
          end = length;
        }
        return baseFill(array, value, start, end);
      }
      function findIndex2(array, predicate, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index2 = fromIndex == null ? 0 : toInteger2(fromIndex);
        if (index2 < 0) {
          index2 = nativeMax(length + index2, 0);
        }
        return baseFindIndex(array, getIteratee(predicate, 3), index2);
      }
      function findLastIndex(array, predicate, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index2 = length - 1;
        if (fromIndex !== undefined$1) {
          index2 = toInteger2(fromIndex);
          index2 = fromIndex < 0 ? nativeMax(length + index2, 0) : nativeMin(index2, length - 1);
        }
        return baseFindIndex(array, getIteratee(predicate, 3), index2, true);
      }
      function flatten(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseFlatten(array, 1) : [];
      }
      function flattenDeep(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseFlatten(array, INFINITY) : [];
      }
      function flattenDepth(array, depth) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        depth = depth === undefined$1 ? 1 : toInteger2(depth);
        return baseFlatten(array, depth);
      }
      function fromPairs(pairs) {
        var index2 = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
        while (++index2 < length) {
          var pair = pairs[index2];
          result2[pair[0]] = pair[1];
        }
        return result2;
      }
      function head(array) {
        return array && array.length ? array[0] : undefined$1;
      }
      function indexOf(array, value, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index2 = fromIndex == null ? 0 : toInteger2(fromIndex);
        if (index2 < 0) {
          index2 = nativeMax(length + index2, 0);
        }
        return baseIndexOf(array, value, index2);
      }
      function initial(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseSlice(array, 0, -1) : [];
      }
      var intersection = baseRest(function(arrays) {
        var mapped = arrayMap(arrays, castArrayLikeObject);
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
      });
      var intersectionBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
        if (iteratee2 === last(mapped)) {
          iteratee2 = undefined$1;
        } else {
          mapped.pop();
        }
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
      });
      var intersectionWith = baseRest(function(arrays) {
        var comparator2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
        comparator2 = typeof comparator2 == "function" ? comparator2 : undefined$1;
        if (comparator2) {
          mapped.pop();
        }
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined$1, comparator2) : [];
      });
      function join(array, separator) {
        return array == null ? "" : nativeJoin.call(array, separator);
      }
      function last(array) {
        var length = array == null ? 0 : array.length;
        return length ? array[length - 1] : undefined$1;
      }
      function lastIndexOf(array, value, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index2 = length;
        if (fromIndex !== undefined$1) {
          index2 = toInteger2(fromIndex);
          index2 = index2 < 0 ? nativeMax(length + index2, 0) : nativeMin(index2, length - 1);
        }
        return value === value ? strictLastIndexOf(array, value, index2) : baseFindIndex(array, baseIsNaN, index2, true);
      }
      function nth(array, n2) {
        return array && array.length ? baseNth(array, toInteger2(n2)) : undefined$1;
      }
      var pull = baseRest(pullAll);
      function pullAll(array, values2) {
        return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
      }
      function pullAllBy(array, values2, iteratee2) {
        return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
      }
      function pullAllWith(array, values2, comparator2) {
        return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined$1, comparator2) : array;
      }
      var pullAt = flatRest(function(array, indexes) {
        var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
        basePullAt(array, arrayMap(indexes, function(index2) {
          return isIndex(index2, length) ? +index2 : index2;
        }).sort(compareAscending));
        return result2;
      });
      function remove2(array, predicate) {
        var result2 = [];
        if (!(array && array.length)) {
          return result2;
        }
        var index2 = -1, indexes = [], length = array.length;
        predicate = getIteratee(predicate, 3);
        while (++index2 < length) {
          var value = array[index2];
          if (predicate(value, index2, array)) {
            result2.push(value);
            indexes.push(index2);
          }
        }
        basePullAt(array, indexes);
        return result2;
      }
      function reverse(array) {
        return array == null ? array : nativeReverse.call(array);
      }
      function slice(array, start, end) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        if (end && typeof end != "number" && isIterateeCall(array, start, end)) {
          start = 0;
          end = length;
        } else {
          start = start == null ? 0 : toInteger2(start);
          end = end === undefined$1 ? length : toInteger2(end);
        }
        return baseSlice(array, start, end);
      }
      function sortedIndex(array, value) {
        return baseSortedIndex(array, value);
      }
      function sortedIndexBy(array, value, iteratee2) {
        return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
      }
      function sortedIndexOf(array, value) {
        var length = array == null ? 0 : array.length;
        if (length) {
          var index2 = baseSortedIndex(array, value);
          if (index2 < length && eq(array[index2], value)) {
            return index2;
          }
        }
        return -1;
      }
      function sortedLastIndex(array, value) {
        return baseSortedIndex(array, value, true);
      }
      function sortedLastIndexBy(array, value, iteratee2) {
        return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
      }
      function sortedLastIndexOf(array, value) {
        var length = array == null ? 0 : array.length;
        if (length) {
          var index2 = baseSortedIndex(array, value, true) - 1;
          if (eq(array[index2], value)) {
            return index2;
          }
        }
        return -1;
      }
      function sortedUniq(array) {
        return array && array.length ? baseSortedUniq(array) : [];
      }
      function sortedUniqBy(array, iteratee2) {
        return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
      }
      function tail(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseSlice(array, 1, length) : [];
      }
      function take(array, n2, guard) {
        if (!(array && array.length)) {
          return [];
        }
        n2 = guard || n2 === undefined$1 ? 1 : toInteger2(n2);
        return baseSlice(array, 0, n2 < 0 ? 0 : n2);
      }
      function takeRight(array, n2, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n2 = guard || n2 === undefined$1 ? 1 : toInteger2(n2);
        n2 = length - n2;
        return baseSlice(array, n2 < 0 ? 0 : n2, length);
      }
      function takeRightWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
      }
      function takeWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
      }
      var union = baseRest(function(arrays) {
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
      });
      var unionBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined$1;
        }
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
      });
      var unionWith = baseRest(function(arrays) {
        var comparator2 = last(arrays);
        comparator2 = typeof comparator2 == "function" ? comparator2 : undefined$1;
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined$1, comparator2);
      });
      function uniq(array) {
        return array && array.length ? baseUniq(array) : [];
      }
      function uniqBy(array, iteratee2) {
        return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
      }
      function uniqWith(array, comparator2) {
        comparator2 = typeof comparator2 == "function" ? comparator2 : undefined$1;
        return array && array.length ? baseUniq(array, undefined$1, comparator2) : [];
      }
      function unzip(array) {
        if (!(array && array.length)) {
          return [];
        }
        var length = 0;
        array = arrayFilter(array, function(group) {
          if (isArrayLikeObject(group)) {
            length = nativeMax(group.length, length);
            return true;
          }
        });
        return baseTimes(length, function(index2) {
          return arrayMap(array, baseProperty(index2));
        });
      }
      function unzipWith(array, iteratee2) {
        if (!(array && array.length)) {
          return [];
        }
        var result2 = unzip(array);
        if (iteratee2 == null) {
          return result2;
        }
        return arrayMap(result2, function(group) {
          return apply(iteratee2, undefined$1, group);
        });
      }
      var without = baseRest(function(array, values2) {
        return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
      });
      var xor = baseRest(function(arrays) {
        return baseXor(arrayFilter(arrays, isArrayLikeObject));
      });
      var xorBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined$1;
        }
        return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
      });
      var xorWith = baseRest(function(arrays) {
        var comparator2 = last(arrays);
        comparator2 = typeof comparator2 == "function" ? comparator2 : undefined$1;
        return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined$1, comparator2);
      });
      var zip = baseRest(unzip);
      function zipObject(props, values2) {
        return baseZipObject(props || [], values2 || [], assignValue);
      }
      function zipObjectDeep(props, values2) {
        return baseZipObject(props || [], values2 || [], baseSet);
      }
      var zipWith = baseRest(function(arrays) {
        var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined$1;
        iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined$1;
        return unzipWith(arrays, iteratee2);
      });
      function chain(value) {
        var result2 = lodash2(value);
        result2.__chain__ = true;
        return result2;
      }
      function tap(value, interceptor) {
        interceptor(value);
        return value;
      }
      function thru(value, interceptor) {
        return interceptor(value);
      }
      var wrapperAt = flatRest(function(paths) {
        var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
          return baseAt(object, paths);
        };
        if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
          return this.thru(interceptor);
        }
        value = value.slice(start, +start + (length ? 1 : 0));
        value.__actions__.push({
          "func": thru,
          "args": [interceptor],
          "thisArg": undefined$1
        });
        return new LodashWrapper(value, this.__chain__).thru(function(array) {
          if (length && !array.length) {
            array.push(undefined$1);
          }
          return array;
        });
      });
      function wrapperChain() {
        return chain(this);
      }
      function wrapperCommit() {
        return new LodashWrapper(this.value(), this.__chain__);
      }
      function wrapperNext() {
        if (this.__values__ === undefined$1) {
          this.__values__ = toArray2(this.value());
        }
        var done = this.__index__ >= this.__values__.length, value = done ? undefined$1 : this.__values__[this.__index__++];
        return { "done": done, "value": value };
      }
      function wrapperToIterator() {
        return this;
      }
      function wrapperPlant(value) {
        var result2, parent2 = this;
        while (parent2 instanceof baseLodash) {
          var clone2 = wrapperClone(parent2);
          clone2.__index__ = 0;
          clone2.__values__ = undefined$1;
          if (result2) {
            previous.__wrapped__ = clone2;
          } else {
            result2 = clone2;
          }
          var previous = clone2;
          parent2 = parent2.__wrapped__;
        }
        previous.__wrapped__ = value;
        return result2;
      }
      function wrapperReverse() {
        var value = this.__wrapped__;
        if (value instanceof LazyWrapper) {
          var wrapped = value;
          if (this.__actions__.length) {
            wrapped = new LazyWrapper(this);
          }
          wrapped = wrapped.reverse();
          wrapped.__actions__.push({
            "func": thru,
            "args": [reverse],
            "thisArg": undefined$1
          });
          return new LodashWrapper(wrapped, this.__chain__);
        }
        return this.thru(reverse);
      }
      function wrapperValue() {
        return baseWrapperValue(this.__wrapped__, this.__actions__);
      }
      var countBy = createAggregator(function(result2, value, key) {
        if (hasOwnProperty2.call(result2, key)) {
          ++result2[key];
        } else {
          baseAssignValue(result2, key, 1);
        }
      });
      function every(collection, predicate, guard) {
        var func = isArray2(collection) ? arrayEvery : baseEvery;
        if (guard && isIterateeCall(collection, predicate, guard)) {
          predicate = undefined$1;
        }
        return func(collection, getIteratee(predicate, 3));
      }
      function filter2(collection, predicate) {
        var func = isArray2(collection) ? arrayFilter : baseFilter;
        return func(collection, getIteratee(predicate, 3));
      }
      var find = createFind(findIndex2);
      var findLast = createFind(findLastIndex);
      function flatMap(collection, iteratee2) {
        return baseFlatten(map(collection, iteratee2), 1);
      }
      function flatMapDeep(collection, iteratee2) {
        return baseFlatten(map(collection, iteratee2), INFINITY);
      }
      function flatMapDepth(collection, iteratee2, depth) {
        depth = depth === undefined$1 ? 1 : toInteger2(depth);
        return baseFlatten(map(collection, iteratee2), depth);
      }
      function forEach2(collection, iteratee2) {
        var func = isArray2(collection) ? arrayEach : baseEach;
        return func(collection, getIteratee(iteratee2, 3));
      }
      function forEachRight(collection, iteratee2) {
        var func = isArray2(collection) ? arrayEachRight : baseEachRight;
        return func(collection, getIteratee(iteratee2, 3));
      }
      var groupBy = createAggregator(function(result2, value, key) {
        if (hasOwnProperty2.call(result2, key)) {
          result2[key].push(value);
        } else {
          baseAssignValue(result2, key, [value]);
        }
      });
      function includes2(collection, value, fromIndex, guard) {
        collection = isArrayLike(collection) ? collection : values(collection);
        fromIndex = fromIndex && !guard ? toInteger2(fromIndex) : 0;
        var length = collection.length;
        if (fromIndex < 0) {
          fromIndex = nativeMax(length + fromIndex, 0);
        }
        return isString2(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
      }
      var invokeMap = baseRest(function(collection, path, args) {
        var index2 = -1, isFunc = typeof path == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
        baseEach(collection, function(value) {
          result2[++index2] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
        });
        return result2;
      });
      var keyBy = createAggregator(function(result2, value, key) {
        baseAssignValue(result2, key, value);
      });
      function map(collection, iteratee2) {
        var func = isArray2(collection) ? arrayMap : baseMap;
        return func(collection, getIteratee(iteratee2, 3));
      }
      function orderBy(collection, iteratees, orders, guard) {
        if (collection == null) {
          return [];
        }
        if (!isArray2(iteratees)) {
          iteratees = iteratees == null ? [] : [iteratees];
        }
        orders = guard ? undefined$1 : orders;
        if (!isArray2(orders)) {
          orders = orders == null ? [] : [orders];
        }
        return baseOrderBy(collection, iteratees, orders);
      }
      var partition = createAggregator(function(result2, value, key) {
        result2[key ? 0 : 1].push(value);
      }, function() {
        return [[], []];
      });
      function reduce(collection, iteratee2, accumulator) {
        var func = isArray2(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
      }
      function reduceRight(collection, iteratee2, accumulator) {
        var func = isArray2(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
      }
      function reject(collection, predicate) {
        var func = isArray2(collection) ? arrayFilter : baseFilter;
        return func(collection, negate(getIteratee(predicate, 3)));
      }
      function sample(collection) {
        var func = isArray2(collection) ? arraySample : baseSample;
        return func(collection);
      }
      function sampleSize(collection, n2, guard) {
        if (guard ? isIterateeCall(collection, n2, guard) : n2 === undefined$1) {
          n2 = 1;
        } else {
          n2 = toInteger2(n2);
        }
        var func = isArray2(collection) ? arraySampleSize : baseSampleSize;
        return func(collection, n2);
      }
      function shuffle(collection) {
        var func = isArray2(collection) ? arrayShuffle : baseShuffle;
        return func(collection);
      }
      function size2(collection) {
        if (collection == null) {
          return 0;
        }
        if (isArrayLike(collection)) {
          return isString2(collection) ? stringSize(collection) : collection.length;
        }
        var tag = getTag(collection);
        if (tag == mapTag || tag == setTag) {
          return collection.size;
        }
        return baseKeys(collection).length;
      }
      function some(collection, predicate, guard) {
        var func = isArray2(collection) ? arraySome : baseSome;
        if (guard && isIterateeCall(collection, predicate, guard)) {
          predicate = undefined$1;
        }
        return func(collection, getIteratee(predicate, 3));
      }
      var sortBy = baseRest(function(collection, iteratees) {
        if (collection == null) {
          return [];
        }
        var length = iteratees.length;
        if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
          iteratees = [];
        } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
          iteratees = [iteratees[0]];
        }
        return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
      });
      var now = ctxNow || function() {
        return root.Date.now();
      };
      function after(n2, func) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        n2 = toInteger2(n2);
        return function() {
          if (--n2 < 1) {
            return func.apply(this, arguments);
          }
        };
      }
      function ary(func, n2, guard) {
        n2 = guard ? undefined$1 : n2;
        n2 = func && n2 == null ? func.length : n2;
        return createWrap(func, WRAP_ARY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, n2);
      }
      function before(n2, func) {
        var result2;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        n2 = toInteger2(n2);
        return function() {
          if (--n2 > 0) {
            result2 = func.apply(this, arguments);
          }
          if (n2 <= 1) {
            func = undefined$1;
          }
          return result2;
        };
      }
      var bind2 = baseRest(function(func, thisArg, partials) {
        var bitmask = WRAP_BIND_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bind2));
          bitmask |= WRAP_PARTIAL_FLAG;
        }
        return createWrap(func, bitmask, thisArg, partials, holders);
      });
      var bindKey = baseRest(function(object, key, partials) {
        var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bindKey));
          bitmask |= WRAP_PARTIAL_FLAG;
        }
        return createWrap(key, bitmask, object, partials, holders);
      });
      function curry(func, arity, guard) {
        arity = guard ? undefined$1 : arity;
        var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
        result2.placeholder = curry.placeholder;
        return result2;
      }
      function curryRight(func, arity, guard) {
        arity = guard ? undefined$1 : arity;
        var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
        result2.placeholder = curryRight.placeholder;
        return result2;
      }
      function debounce2(func, wait, options) {
        var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        wait = toNumber2(wait) || 0;
        if (isObject2(options)) {
          leading = !!options.leading;
          maxing = "maxWait" in options;
          maxWait = maxing ? nativeMax(toNumber2(options.maxWait) || 0, wait) : maxWait;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        function invokeFunc(time) {
          var args = lastArgs, thisArg = lastThis;
          lastArgs = lastThis = undefined$1;
          lastInvokeTime = time;
          result2 = func.apply(thisArg, args);
          return result2;
        }
        function leadingEdge(time) {
          lastInvokeTime = time;
          timerId = setTimeout2(timerExpired, wait);
          return leading ? invokeFunc(time) : result2;
        }
        function remainingWait(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
          return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
        }
        function shouldInvoke(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
          return lastCallTime === undefined$1 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
        }
        function timerExpired() {
          var time = now();
          if (shouldInvoke(time)) {
            return trailingEdge(time);
          }
          timerId = setTimeout2(timerExpired, remainingWait(time));
        }
        function trailingEdge(time) {
          timerId = undefined$1;
          if (trailing && lastArgs) {
            return invokeFunc(time);
          }
          lastArgs = lastThis = undefined$1;
          return result2;
        }
        function cancel() {
          if (timerId !== undefined$1) {
            clearTimeout2(timerId);
          }
          lastInvokeTime = 0;
          lastArgs = lastCallTime = lastThis = timerId = undefined$1;
        }
        function flush() {
          return timerId === undefined$1 ? result2 : trailingEdge(now());
        }
        function debounced() {
          var time = now(), isInvoking = shouldInvoke(time);
          lastArgs = arguments;
          lastThis = this;
          lastCallTime = time;
          if (isInvoking) {
            if (timerId === undefined$1) {
              return leadingEdge(lastCallTime);
            }
            if (maxing) {
              clearTimeout2(timerId);
              timerId = setTimeout2(timerExpired, wait);
              return invokeFunc(lastCallTime);
            }
          }
          if (timerId === undefined$1) {
            timerId = setTimeout2(timerExpired, wait);
          }
          return result2;
        }
        debounced.cancel = cancel;
        debounced.flush = flush;
        return debounced;
      }
      var defer = baseRest(function(func, args) {
        return baseDelay(func, 1, args);
      });
      var delay = baseRest(function(func, wait, args) {
        return baseDelay(func, toNumber2(wait) || 0, args);
      });
      function flip(func) {
        return createWrap(func, WRAP_FLIP_FLAG);
      }
      function memoize(func, resolver) {
        if (typeof func != "function" || resolver != null && typeof resolver != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        var memoized = function() {
          var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
          if (cache.has(key)) {
            return cache.get(key);
          }
          var result2 = func.apply(this, args);
          memoized.cache = cache.set(key, result2) || cache;
          return result2;
        };
        memoized.cache = new (memoize.Cache || MapCache)();
        return memoized;
      }
      memoize.Cache = MapCache;
      function negate(predicate) {
        if (typeof predicate != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return !predicate.call(this);
            case 1:
              return !predicate.call(this, args[0]);
            case 2:
              return !predicate.call(this, args[0], args[1]);
            case 3:
              return !predicate.call(this, args[0], args[1], args[2]);
          }
          return !predicate.apply(this, args);
        };
      }
      function once(func) {
        return before(2, func);
      }
      var overArgs = castRest(function(func, transforms) {
        transforms = transforms.length == 1 && isArray2(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
        var funcsLength = transforms.length;
        return baseRest(function(args) {
          var index2 = -1, length = nativeMin(args.length, funcsLength);
          while (++index2 < length) {
            args[index2] = transforms[index2].call(this, args[index2]);
          }
          return apply(func, this, args);
        });
      });
      var partial = baseRest(function(func, partials) {
        var holders = replaceHolders(partials, getHolder(partial));
        return createWrap(func, WRAP_PARTIAL_FLAG, undefined$1, partials, holders);
      });
      var partialRight = baseRest(function(func, partials) {
        var holders = replaceHolders(partials, getHolder(partialRight));
        return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined$1, partials, holders);
      });
      var rearg = flatRest(function(func, indexes) {
        return createWrap(func, WRAP_REARG_FLAG, undefined$1, undefined$1, undefined$1, indexes);
      });
      function rest(func, start) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        start = start === undefined$1 ? start : toInteger2(start);
        return baseRest(func, start);
      }
      function spread2(func, start) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        start = start == null ? 0 : nativeMax(toInteger2(start), 0);
        return baseRest(function(args) {
          var array = args[start], otherArgs = castSlice(args, 0, start);
          if (array) {
            arrayPush(otherArgs, array);
          }
          return apply(func, this, otherArgs);
        });
      }
      function throttle(func, wait, options) {
        var leading = true, trailing = true;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        if (isObject2(options)) {
          leading = "leading" in options ? !!options.leading : leading;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        return debounce2(func, wait, {
          "leading": leading,
          "maxWait": wait,
          "trailing": trailing
        });
      }
      function unary(func) {
        return ary(func, 1);
      }
      function wrap(value, wrapper) {
        return partial(castFunction(wrapper), value);
      }
      function castArray() {
        if (!arguments.length) {
          return [];
        }
        var value = arguments[0];
        return isArray2(value) ? value : [value];
      }
      function clone(value) {
        return baseClone(value, CLONE_SYMBOLS_FLAG);
      }
      function cloneWith(value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
      }
      function cloneDeep(value) {
        return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
      }
      function cloneDeepWith(value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
      }
      function conformsTo(object, source) {
        return source == null || baseConformsTo(object, source, keys(source));
      }
      function eq(value, other) {
        return value === other || value !== value && other !== other;
      }
      var gt = createRelationalOperation(baseGt);
      var gte = createRelationalOperation(function(value, other) {
        return value >= other;
      });
      var isArguments = baseIsArguments(function() {
        return arguments;
      }()) ? baseIsArguments : function(value) {
        return isObjectLike(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
      };
      var isArray2 = Array2.isArray;
      var isArrayBuffer2 = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
      function isArrayLike(value) {
        return value != null && isLength(value.length) && !isFunction2(value);
      }
      function isArrayLikeObject(value) {
        return isObjectLike(value) && isArrayLike(value);
      }
      function isBoolean2(value) {
        return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
      }
      var isBuffer2 = nativeIsBuffer || stubFalse;
      var isDate2 = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
      function isElement(value) {
        return isObjectLike(value) && value.nodeType === 1 && !isPlainObject2(value);
      }
      function isEmpty(value) {
        if (value == null) {
          return true;
        }
        if (isArrayLike(value) && (isArray2(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer2(value) || isTypedArray2(value) || isArguments(value))) {
          return !value.length;
        }
        var tag = getTag(value);
        if (tag == mapTag || tag == setTag) {
          return !value.size;
        }
        if (isPrototype(value)) {
          return !baseKeys(value).length;
        }
        for (var key in value) {
          if (hasOwnProperty2.call(value, key)) {
            return false;
          }
        }
        return true;
      }
      function isEqual2(value, other) {
        return baseIsEqual(value, other);
      }
      function isEqualWith(value, other, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        var result2 = customizer ? customizer(value, other) : undefined$1;
        return result2 === undefined$1 ? baseIsEqual(value, other, undefined$1, customizer) : !!result2;
      }
      function isError(value) {
        if (!isObjectLike(value)) {
          return false;
        }
        var tag = baseGetTag(value);
        return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject2(value);
      }
      function isFinite2(value) {
        return typeof value == "number" && nativeIsFinite(value);
      }
      function isFunction2(value) {
        if (!isObject2(value)) {
          return false;
        }
        var tag = baseGetTag(value);
        return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
      }
      function isInteger(value) {
        return typeof value == "number" && value == toInteger2(value);
      }
      function isLength(value) {
        return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
      }
      function isObject2(value) {
        var type = typeof value;
        return value != null && (type == "object" || type == "function");
      }
      function isObjectLike(value) {
        return value != null && typeof value == "object";
      }
      var isMap2 = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
      function isMatch(object, source) {
        return object === source || baseIsMatch(object, source, getMatchData(source));
      }
      function isMatchWith(object, source, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return baseIsMatch(object, source, getMatchData(source), customizer);
      }
      function isNaN2(value) {
        return isNumber2(value) && value != +value;
      }
      function isNative(value) {
        if (isMaskable(value)) {
          throw new Error2(CORE_ERROR_TEXT);
        }
        return baseIsNative(value);
      }
      function isNull(value) {
        return value === null;
      }
      function isNil(value) {
        return value == null;
      }
      function isNumber2(value) {
        return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
      }
      function isPlainObject2(value) {
        if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
          return false;
        }
        var proto = getPrototype(value);
        if (proto === null) {
          return true;
        }
        var Ctor = hasOwnProperty2.call(proto, "constructor") && proto.constructor;
        return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
      }
      var isRegExp2 = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
      function isSafeInteger(value) {
        return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
      }
      var isSet2 = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
      function isString2(value) {
        return typeof value == "string" || !isArray2(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
      }
      function isSymbol2(value) {
        return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
      }
      var isTypedArray2 = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
      function isUndefined2(value) {
        return value === undefined$1;
      }
      function isWeakMap(value) {
        return isObjectLike(value) && getTag(value) == weakMapTag;
      }
      function isWeakSet(value) {
        return isObjectLike(value) && baseGetTag(value) == weakSetTag;
      }
      var lt = createRelationalOperation(baseLt);
      var lte = createRelationalOperation(function(value, other) {
        return value <= other;
      });
      function toArray2(value) {
        if (!value) {
          return [];
        }
        if (isArrayLike(value)) {
          return isString2(value) ? stringToArray(value) : copyArray(value);
        }
        if (symIterator && value[symIterator]) {
          return iteratorToArray(value[symIterator]());
        }
        var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
        return func(value);
      }
      function toFinite(value) {
        if (!value) {
          return value === 0 ? value : 0;
        }
        value = toNumber2(value);
        if (value === INFINITY || value === -INFINITY) {
          var sign = value < 0 ? -1 : 1;
          return sign * MAX_INTEGER;
        }
        return value === value ? value : 0;
      }
      function toInteger2(value) {
        var result2 = toFinite(value), remainder = result2 % 1;
        return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
      }
      function toLength(value) {
        return value ? baseClamp(toInteger2(value), 0, MAX_ARRAY_LENGTH) : 0;
      }
      function toNumber2(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol2(value)) {
          return NAN;
        }
        if (isObject2(value)) {
          var other = typeof value.valueOf == "function" ? value.valueOf() : value;
          value = isObject2(other) ? other + "" : other;
        }
        if (typeof value != "string") {
          return value === 0 ? value : +value;
        }
        value = baseTrim(value);
        var isBinary = reIsBinary.test(value);
        return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
      }
      function toPlainObject(value) {
        return copyObject(value, keysIn(value));
      }
      function toSafeInteger(value) {
        return value ? baseClamp(toInteger2(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
      }
      function toString3(value) {
        return value == null ? "" : baseToString(value);
      }
      var assign2 = createAssigner(function(object, source) {
        if (isPrototype(source) || isArrayLike(source)) {
          copyObject(source, keys(source), object);
          return;
        }
        for (var key in source) {
          if (hasOwnProperty2.call(source, key)) {
            assignValue(object, key, source[key]);
          }
        }
      });
      var assignIn = createAssigner(function(object, source) {
        copyObject(source, keysIn(source), object);
      });
      var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
        copyObject(source, keysIn(source), object, customizer);
      });
      var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
        copyObject(source, keys(source), object, customizer);
      });
      var at2 = flatRest(baseAt);
      function create(prototype2, properties) {
        var result2 = baseCreate(prototype2);
        return properties == null ? result2 : baseAssign(result2, properties);
      }
      var defaults2 = baseRest(function(object, sources) {
        object = Object2(object);
        var index2 = -1;
        var length = sources.length;
        var guard = length > 2 ? sources[2] : undefined$1;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          length = 1;
        }
        while (++index2 < length) {
          var source = sources[index2];
          var props = keysIn(source);
          var propsIndex = -1;
          var propsLength = props.length;
          while (++propsIndex < propsLength) {
            var key = props[propsIndex];
            var value = object[key];
            if (value === undefined$1 || eq(value, objectProto[key]) && !hasOwnProperty2.call(object, key)) {
              object[key] = source[key];
            }
          }
        }
        return object;
      });
      var defaultsDeep = baseRest(function(args) {
        args.push(undefined$1, customDefaultsMerge);
        return apply(mergeWith, undefined$1, args);
      });
      function findKey2(object, predicate) {
        return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
      }
      function findLastKey(object, predicate) {
        return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
      }
      function forIn(object, iteratee2) {
        return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
      }
      function forInRight(object, iteratee2) {
        return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
      }
      function forOwn(object, iteratee2) {
        return object && baseForOwn(object, getIteratee(iteratee2, 3));
      }
      function forOwnRight(object, iteratee2) {
        return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
      }
      function functions(object) {
        return object == null ? [] : baseFunctions(object, keys(object));
      }
      function functionsIn(object) {
        return object == null ? [] : baseFunctions(object, keysIn(object));
      }
      function get2(object, path, defaultValue) {
        var result2 = object == null ? undefined$1 : baseGet(object, path);
        return result2 === undefined$1 ? defaultValue : result2;
      }
      function has2(object, path) {
        return object != null && hasPath(object, path, baseHas);
      }
      function hasIn(object, path) {
        return object != null && hasPath(object, path, baseHasIn);
      }
      var invert = createInverter(function(result2, value, key) {
        if (value != null && typeof value.toString != "function") {
          value = nativeObjectToString.call(value);
        }
        result2[value] = key;
      }, constant(identity));
      var invertBy = createInverter(function(result2, value, key) {
        if (value != null && typeof value.toString != "function") {
          value = nativeObjectToString.call(value);
        }
        if (hasOwnProperty2.call(result2, value)) {
          result2[value].push(key);
        } else {
          result2[value] = [key];
        }
      }, getIteratee);
      var invoke = baseRest(baseInvoke);
      function keys(object) {
        return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
      }
      function keysIn(object) {
        return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
      }
      function mapKeys(object, iteratee2) {
        var result2 = {};
        iteratee2 = getIteratee(iteratee2, 3);
        baseForOwn(object, function(value, key, object2) {
          baseAssignValue(result2, iteratee2(value, key, object2), value);
        });
        return result2;
      }
      function mapValues(object, iteratee2) {
        var result2 = {};
        iteratee2 = getIteratee(iteratee2, 3);
        baseForOwn(object, function(value, key, object2) {
          baseAssignValue(result2, key, iteratee2(value, key, object2));
        });
        return result2;
      }
      var merge2 = createAssigner(function(object, source, srcIndex) {
        baseMerge(object, source, srcIndex);
      });
      var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
        baseMerge(object, source, srcIndex, customizer);
      });
      var omit2 = flatRest(function(object, paths) {
        var result2 = {};
        if (object == null) {
          return result2;
        }
        var isDeep = false;
        paths = arrayMap(paths, function(path) {
          path = castPath(path, object);
          isDeep || (isDeep = path.length > 1);
          return path;
        });
        copyObject(object, getAllKeysIn(object), result2);
        if (isDeep) {
          result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
        }
        var length = paths.length;
        while (length--) {
          baseUnset(result2, paths[length]);
        }
        return result2;
      });
      function omitBy(object, predicate) {
        return pickBy(object, negate(getIteratee(predicate)));
      }
      var pick2 = flatRest(function(object, paths) {
        return object == null ? {} : basePick(object, paths);
      });
      function pickBy(object, predicate) {
        if (object == null) {
          return {};
        }
        var props = arrayMap(getAllKeysIn(object), function(prop) {
          return [prop];
        });
        predicate = getIteratee(predicate);
        return basePickBy(object, props, function(value, path) {
          return predicate(value, path[0]);
        });
      }
      function result(object, path, defaultValue) {
        path = castPath(path, object);
        var index2 = -1, length = path.length;
        if (!length) {
          length = 1;
          object = undefined$1;
        }
        while (++index2 < length) {
          var value = object == null ? undefined$1 : object[toKey(path[index2])];
          if (value === undefined$1) {
            index2 = length;
            value = defaultValue;
          }
          object = isFunction2(value) ? value.call(object) : value;
        }
        return object;
      }
      function set2(object, path, value) {
        return object == null ? object : baseSet(object, path, value);
      }
      function setWith(object, path, value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return object == null ? object : baseSet(object, path, value, customizer);
      }
      var toPairs = createToPairs(keys);
      var toPairsIn = createToPairs(keysIn);
      function transform2(object, iteratee2, accumulator) {
        var isArr = isArray2(object), isArrLike = isArr || isBuffer2(object) || isTypedArray2(object);
        iteratee2 = getIteratee(iteratee2, 4);
        if (accumulator == null) {
          var Ctor = object && object.constructor;
          if (isArrLike) {
            accumulator = isArr ? new Ctor() : [];
          } else if (isObject2(object)) {
            accumulator = isFunction2(Ctor) ? baseCreate(getPrototype(object)) : {};
          } else {
            accumulator = {};
          }
        }
        (isArrLike ? arrayEach : baseForOwn)(object, function(value, index2, object2) {
          return iteratee2(accumulator, value, index2, object2);
        });
        return accumulator;
      }
      function unset(object, path) {
        return object == null ? true : baseUnset(object, path);
      }
      function update(object, path, updater) {
        return object == null ? object : baseUpdate(object, path, castFunction(updater));
      }
      function updateWith(object, path, updater, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined$1;
        return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
      }
      function values(object) {
        return object == null ? [] : baseValues(object, keys(object));
      }
      function valuesIn(object) {
        return object == null ? [] : baseValues(object, keysIn(object));
      }
      function clamp2(number, lower, upper) {
        if (upper === undefined$1) {
          upper = lower;
          lower = undefined$1;
        }
        if (upper !== undefined$1) {
          upper = toNumber2(upper);
          upper = upper === upper ? upper : 0;
        }
        if (lower !== undefined$1) {
          lower = toNumber2(lower);
          lower = lower === lower ? lower : 0;
        }
        return baseClamp(toNumber2(number), lower, upper);
      }
      function inRange(number, start, end) {
        start = toFinite(start);
        if (end === undefined$1) {
          end = start;
          start = 0;
        } else {
          end = toFinite(end);
        }
        number = toNumber2(number);
        return baseInRange(number, start, end);
      }
      function random(lower, upper, floating) {
        if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
          upper = floating = undefined$1;
        }
        if (floating === undefined$1) {
          if (typeof upper == "boolean") {
            floating = upper;
            upper = undefined$1;
          } else if (typeof lower == "boolean") {
            floating = lower;
            lower = undefined$1;
          }
        }
        if (lower === undefined$1 && upper === undefined$1) {
          lower = 0;
          upper = 1;
        } else {
          lower = toFinite(lower);
          if (upper === undefined$1) {
            upper = lower;
            lower = 0;
          } else {
            upper = toFinite(upper);
          }
        }
        if (lower > upper) {
          var temp = lower;
          lower = upper;
          upper = temp;
        }
        if (floating || lower % 1 || upper % 1) {
          var rand = nativeRandom();
          return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
        }
        return baseRandom(lower, upper);
      }
      var camelCase = createCompounder(function(result2, word, index2) {
        word = word.toLowerCase();
        return result2 + (index2 ? capitalize2(word) : word);
      });
      function capitalize2(string) {
        return upperFirst(toString3(string).toLowerCase());
      }
      function deburr(string) {
        string = toString3(string);
        return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
      }
      function endsWith2(string, target, position) {
        string = toString3(string);
        target = baseToString(target);
        var length = string.length;
        position = position === undefined$1 ? length : baseClamp(toInteger2(position), 0, length);
        var end = position;
        position -= target.length;
        return position >= 0 && string.slice(position, end) == target;
      }
      function escape2(string) {
        string = toString3(string);
        return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
      }
      function escapeRegExp(string) {
        string = toString3(string);
        return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
      }
      var kebabCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? "-" : "") + word.toLowerCase();
      });
      var lowerCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? " " : "") + word.toLowerCase();
      });
      var lowerFirst = createCaseFirst("toLowerCase");
      function pad(string, length, chars) {
        string = toString3(string);
        length = toInteger2(length);
        var strLength = length ? stringSize(string) : 0;
        if (!length || strLength >= length) {
          return string;
        }
        var mid = (length - strLength) / 2;
        return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
      }
      function padEnd(string, length, chars) {
        string = toString3(string);
        length = toInteger2(length);
        var strLength = length ? stringSize(string) : 0;
        return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
      }
      function padStart(string, length, chars) {
        string = toString3(string);
        length = toInteger2(length);
        var strLength = length ? stringSize(string) : 0;
        return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
      }
      function parseInt2(string, radix, guard) {
        if (guard || radix == null) {
          radix = 0;
        } else if (radix) {
          radix = +radix;
        }
        return nativeParseInt(toString3(string).replace(reTrimStart, ""), radix || 0);
      }
      function repeat(string, n2, guard) {
        if (guard ? isIterateeCall(string, n2, guard) : n2 === undefined$1) {
          n2 = 1;
        } else {
          n2 = toInteger2(n2);
        }
        return baseRepeat(toString3(string), n2);
      }
      function replace2() {
        var args = arguments, string = toString3(args[0]);
        return args.length < 3 ? string : string.replace(args[1], args[2]);
      }
      var snakeCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? "_" : "") + word.toLowerCase();
      });
      function split(string, separator, limit) {
        if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
          separator = limit = undefined$1;
        }
        limit = limit === undefined$1 ? MAX_ARRAY_LENGTH : limit >>> 0;
        if (!limit) {
          return [];
        }
        string = toString3(string);
        if (string && (typeof separator == "string" || separator != null && !isRegExp2(separator))) {
          separator = baseToString(separator);
          if (!separator && hasUnicode(string)) {
            return castSlice(stringToArray(string), 0, limit);
          }
        }
        return string.split(separator, limit);
      }
      var startCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? " " : "") + upperFirst(word);
      });
      function startsWith(string, target, position) {
        string = toString3(string);
        position = position == null ? 0 : baseClamp(toInteger2(position), 0, string.length);
        target = baseToString(target);
        return string.slice(position, position + target.length) == target;
      }
      function template(string, options, guard) {
        var settings = lodash2.templateSettings;
        if (guard && isIterateeCall(string, options, guard)) {
          options = undefined$1;
        }
        string = toString3(string);
        options = assignInWith({}, options, settings, customDefaultsAssignIn);
        var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
        var isEscaping, isEvaluating, index2 = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
        var reDelimiters = RegExp2(
          (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
          "g"
        );
        var sourceURL = "//# sourceURL=" + (hasOwnProperty2.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
        string.replace(reDelimiters, function(match2, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
          interpolateValue || (interpolateValue = esTemplateValue);
          source += string.slice(index2, offset).replace(reUnescapedString, escapeStringChar);
          if (escapeValue) {
            isEscaping = true;
            source += "' +\n__e(" + escapeValue + ") +\n'";
          }
          if (evaluateValue) {
            isEvaluating = true;
            source += "';\n" + evaluateValue + ";\n__p += '";
          }
          if (interpolateValue) {
            source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
          }
          index2 = offset + match2.length;
          return match2;
        });
        source += "';\n";
        var variable = hasOwnProperty2.call(options, "variable") && options.variable;
        if (!variable) {
          source = "with (obj) {\n" + source + "\n}\n";
        } else if (reForbiddenIdentifierChars.test(variable)) {
          throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
        }
        source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
        source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
        var result2 = attempt(function() {
          return Function2(importsKeys, sourceURL + "return " + source).apply(undefined$1, importsValues);
        });
        result2.source = source;
        if (isError(result2)) {
          throw result2;
        }
        return result2;
      }
      function toLower(value) {
        return toString3(value).toLowerCase();
      }
      function toUpper(value) {
        return toString3(value).toUpperCase();
      }
      function trim2(string, chars, guard) {
        string = toString3(string);
        if (string && (guard || chars === undefined$1)) {
          return baseTrim(string);
        }
        if (!string || !(chars = baseToString(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
        return castSlice(strSymbols, start, end).join("");
      }
      function trimEnd(string, chars, guard) {
        string = toString3(string);
        if (string && (guard || chars === undefined$1)) {
          return string.slice(0, trimmedEndIndex(string) + 1);
        }
        if (!string || !(chars = baseToString(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
        return castSlice(strSymbols, 0, end).join("");
      }
      function trimStart(string, chars, guard) {
        string = toString3(string);
        if (string && (guard || chars === undefined$1)) {
          return string.replace(reTrimStart, "");
        }
        if (!string || !(chars = baseToString(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
        return castSlice(strSymbols, start).join("");
      }
      function truncate(string, options) {
        var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
        if (isObject2(options)) {
          var separator = "separator" in options ? options.separator : separator;
          length = "length" in options ? toInteger2(options.length) : length;
          omission = "omission" in options ? baseToString(options.omission) : omission;
        }
        string = toString3(string);
        var strLength = string.length;
        if (hasUnicode(string)) {
          var strSymbols = stringToArray(string);
          strLength = strSymbols.length;
        }
        if (length >= strLength) {
          return string;
        }
        var end = length - stringSize(omission);
        if (end < 1) {
          return omission;
        }
        var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
        if (separator === undefined$1) {
          return result2 + omission;
        }
        if (strSymbols) {
          end += result2.length - end;
        }
        if (isRegExp2(separator)) {
          if (string.slice(end).search(separator)) {
            var match2, substring = result2;
            if (!separator.global) {
              separator = RegExp2(separator.source, toString3(reFlags.exec(separator)) + "g");
            }
            separator.lastIndex = 0;
            while (match2 = separator.exec(substring)) {
              var newEnd = match2.index;
            }
            result2 = result2.slice(0, newEnd === undefined$1 ? end : newEnd);
          }
        } else if (string.indexOf(baseToString(separator), end) != end) {
          var index2 = result2.lastIndexOf(separator);
          if (index2 > -1) {
            result2 = result2.slice(0, index2);
          }
        }
        return result2 + omission;
      }
      function unescape2(string) {
        string = toString3(string);
        return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
      }
      var upperCase = createCompounder(function(result2, word, index2) {
        return result2 + (index2 ? " " : "") + word.toUpperCase();
      });
      var upperFirst = createCaseFirst("toUpperCase");
      function words(string, pattern, guard) {
        string = toString3(string);
        pattern = guard ? undefined$1 : pattern;
        if (pattern === undefined$1) {
          return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
        }
        return string.match(pattern) || [];
      }
      var attempt = baseRest(function(func, args) {
        try {
          return apply(func, undefined$1, args);
        } catch (e3) {
          return isError(e3) ? e3 : new Error2(e3);
        }
      });
      var bindAll = flatRest(function(object, methodNames) {
        arrayEach(methodNames, function(key) {
          key = toKey(key);
          baseAssignValue(object, key, bind2(object[key], object));
        });
        return object;
      });
      function cond(pairs) {
        var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
        pairs = !length ? [] : arrayMap(pairs, function(pair) {
          if (typeof pair[1] != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return [toIteratee(pair[0]), pair[1]];
        });
        return baseRest(function(args) {
          var index2 = -1;
          while (++index2 < length) {
            var pair = pairs[index2];
            if (apply(pair[0], this, args)) {
              return apply(pair[1], this, args);
            }
          }
        });
      }
      function conforms(source) {
        return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
      }
      function constant(value) {
        return function() {
          return value;
        };
      }
      function defaultTo(value, defaultValue) {
        return value == null || value !== value ? defaultValue : value;
      }
      var flow = createFlow();
      var flowRight = createFlow(true);
      function identity(value) {
        return value;
      }
      function iteratee(func) {
        return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
      }
      function matches(source) {
        return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
      }
      function matchesProperty(path, srcValue) {
        return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
      }
      var method = baseRest(function(path, args) {
        return function(object) {
          return baseInvoke(object, path, args);
        };
      });
      var methodOf = baseRest(function(object, args) {
        return function(path) {
          return baseInvoke(object, path, args);
        };
      });
      function mixin(object, source, options) {
        var props = keys(source), methodNames = baseFunctions(source, props);
        if (options == null && !(isObject2(source) && (methodNames.length || !props.length))) {
          options = source;
          source = object;
          object = this;
          methodNames = baseFunctions(source, keys(source));
        }
        var chain2 = !(isObject2(options) && "chain" in options) || !!options.chain, isFunc = isFunction2(object);
        arrayEach(methodNames, function(methodName) {
          var func = source[methodName];
          object[methodName] = func;
          if (isFunc) {
            object.prototype[methodName] = function() {
              var chainAll = this.__chain__;
              if (chain2 || chainAll) {
                var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                actions.push({ "func": func, "args": arguments, "thisArg": object });
                result2.__chain__ = chainAll;
                return result2;
              }
              return func.apply(object, arrayPush([this.value()], arguments));
            };
          }
        });
        return object;
      }
      function noConflict() {
        if (root._ === this) {
          root._ = oldDash;
        }
        return this;
      }
      function noop2() {
      }
      function nthArg(n2) {
        n2 = toInteger2(n2);
        return baseRest(function(args) {
          return baseNth(args, n2);
        });
      }
      var over = createOver(arrayMap);
      var overEvery = createOver(arrayEvery);
      var overSome = createOver(arraySome);
      function property(path) {
        return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
      }
      function propertyOf(object) {
        return function(path) {
          return object == null ? undefined$1 : baseGet(object, path);
        };
      }
      var range = createRange2();
      var rangeRight = createRange2(true);
      function stubArray() {
        return [];
      }
      function stubFalse() {
        return false;
      }
      function stubObject() {
        return {};
      }
      function stubString() {
        return "";
      }
      function stubTrue() {
        return true;
      }
      function times(n2, iteratee2) {
        n2 = toInteger2(n2);
        if (n2 < 1 || n2 > MAX_SAFE_INTEGER) {
          return [];
        }
        var index2 = MAX_ARRAY_LENGTH, length = nativeMin(n2, MAX_ARRAY_LENGTH);
        iteratee2 = getIteratee(iteratee2);
        n2 -= MAX_ARRAY_LENGTH;
        var result2 = baseTimes(length, iteratee2);
        while (++index2 < n2) {
          iteratee2(index2);
        }
        return result2;
      }
      function toPath(value) {
        if (isArray2(value)) {
          return arrayMap(value, toKey);
        }
        return isSymbol2(value) ? [value] : copyArray(stringToPath(toString3(value)));
      }
      function uniqueId(prefix) {
        var id = ++idCounter;
        return toString3(prefix) + id;
      }
      var add2 = createMathOperation(function(augend, addend) {
        return augend + addend;
      }, 0);
      var ceil = createRound("ceil");
      var divide = createMathOperation(function(dividend, divisor) {
        return dividend / divisor;
      }, 1);
      var floor = createRound("floor");
      function max(array) {
        return array && array.length ? baseExtremum(array, identity, baseGt) : undefined$1;
      }
      function maxBy(array, iteratee2) {
        return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined$1;
      }
      function mean(array) {
        return baseMean(array, identity);
      }
      function meanBy(array, iteratee2) {
        return baseMean(array, getIteratee(iteratee2, 2));
      }
      function min(array) {
        return array && array.length ? baseExtremum(array, identity, baseLt) : undefined$1;
      }
      function minBy(array, iteratee2) {
        return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined$1;
      }
      var multiply = createMathOperation(function(multiplier, multiplicand) {
        return multiplier * multiplicand;
      }, 1);
      var round = createRound("round");
      var subtract = createMathOperation(function(minuend, subtrahend) {
        return minuend - subtrahend;
      }, 0);
      function sum(array) {
        return array && array.length ? baseSum(array, identity) : 0;
      }
      function sumBy(array, iteratee2) {
        return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
      }
      lodash2.after = after;
      lodash2.ary = ary;
      lodash2.assign = assign2;
      lodash2.assignIn = assignIn;
      lodash2.assignInWith = assignInWith;
      lodash2.assignWith = assignWith;
      lodash2.at = at2;
      lodash2.before = before;
      lodash2.bind = bind2;
      lodash2.bindAll = bindAll;
      lodash2.bindKey = bindKey;
      lodash2.castArray = castArray;
      lodash2.chain = chain;
      lodash2.chunk = chunk2;
      lodash2.compact = compact;
      lodash2.concat = concat;
      lodash2.cond = cond;
      lodash2.conforms = conforms;
      lodash2.constant = constant;
      lodash2.countBy = countBy;
      lodash2.create = create;
      lodash2.curry = curry;
      lodash2.curryRight = curryRight;
      lodash2.debounce = debounce2;
      lodash2.defaults = defaults2;
      lodash2.defaultsDeep = defaultsDeep;
      lodash2.defer = defer;
      lodash2.delay = delay;
      lodash2.difference = difference;
      lodash2.differenceBy = differenceBy;
      lodash2.differenceWith = differenceWith;
      lodash2.drop = drop;
      lodash2.dropRight = dropRight;
      lodash2.dropRightWhile = dropRightWhile;
      lodash2.dropWhile = dropWhile;
      lodash2.fill = fill;
      lodash2.filter = filter2;
      lodash2.flatMap = flatMap;
      lodash2.flatMapDeep = flatMapDeep;
      lodash2.flatMapDepth = flatMapDepth;
      lodash2.flatten = flatten;
      lodash2.flattenDeep = flattenDeep;
      lodash2.flattenDepth = flattenDepth;
      lodash2.flip = flip;
      lodash2.flow = flow;
      lodash2.flowRight = flowRight;
      lodash2.fromPairs = fromPairs;
      lodash2.functions = functions;
      lodash2.functionsIn = functionsIn;
      lodash2.groupBy = groupBy;
      lodash2.initial = initial;
      lodash2.intersection = intersection;
      lodash2.intersectionBy = intersectionBy;
      lodash2.intersectionWith = intersectionWith;
      lodash2.invert = invert;
      lodash2.invertBy = invertBy;
      lodash2.invokeMap = invokeMap;
      lodash2.iteratee = iteratee;
      lodash2.keyBy = keyBy;
      lodash2.keys = keys;
      lodash2.keysIn = keysIn;
      lodash2.map = map;
      lodash2.mapKeys = mapKeys;
      lodash2.mapValues = mapValues;
      lodash2.matches = matches;
      lodash2.matchesProperty = matchesProperty;
      lodash2.memoize = memoize;
      lodash2.merge = merge2;
      lodash2.mergeWith = mergeWith;
      lodash2.method = method;
      lodash2.methodOf = methodOf;
      lodash2.mixin = mixin;
      lodash2.negate = negate;
      lodash2.nthArg = nthArg;
      lodash2.omit = omit2;
      lodash2.omitBy = omitBy;
      lodash2.once = once;
      lodash2.orderBy = orderBy;
      lodash2.over = over;
      lodash2.overArgs = overArgs;
      lodash2.overEvery = overEvery;
      lodash2.overSome = overSome;
      lodash2.partial = partial;
      lodash2.partialRight = partialRight;
      lodash2.partition = partition;
      lodash2.pick = pick2;
      lodash2.pickBy = pickBy;
      lodash2.property = property;
      lodash2.propertyOf = propertyOf;
      lodash2.pull = pull;
      lodash2.pullAll = pullAll;
      lodash2.pullAllBy = pullAllBy;
      lodash2.pullAllWith = pullAllWith;
      lodash2.pullAt = pullAt;
      lodash2.range = range;
      lodash2.rangeRight = rangeRight;
      lodash2.rearg = rearg;
      lodash2.reject = reject;
      lodash2.remove = remove2;
      lodash2.rest = rest;
      lodash2.reverse = reverse;
      lodash2.sampleSize = sampleSize;
      lodash2.set = set2;
      lodash2.setWith = setWith;
      lodash2.shuffle = shuffle;
      lodash2.slice = slice;
      lodash2.sortBy = sortBy;
      lodash2.sortedUniq = sortedUniq;
      lodash2.sortedUniqBy = sortedUniqBy;
      lodash2.split = split;
      lodash2.spread = spread2;
      lodash2.tail = tail;
      lodash2.take = take;
      lodash2.takeRight = takeRight;
      lodash2.takeRightWhile = takeRightWhile;
      lodash2.takeWhile = takeWhile;
      lodash2.tap = tap;
      lodash2.throttle = throttle;
      lodash2.thru = thru;
      lodash2.toArray = toArray2;
      lodash2.toPairs = toPairs;
      lodash2.toPairsIn = toPairsIn;
      lodash2.toPath = toPath;
      lodash2.toPlainObject = toPlainObject;
      lodash2.transform = transform2;
      lodash2.unary = unary;
      lodash2.union = union;
      lodash2.unionBy = unionBy;
      lodash2.unionWith = unionWith;
      lodash2.uniq = uniq;
      lodash2.uniqBy = uniqBy;
      lodash2.uniqWith = uniqWith;
      lodash2.unset = unset;
      lodash2.unzip = unzip;
      lodash2.unzipWith = unzipWith;
      lodash2.update = update;
      lodash2.updateWith = updateWith;
      lodash2.values = values;
      lodash2.valuesIn = valuesIn;
      lodash2.without = without;
      lodash2.words = words;
      lodash2.wrap = wrap;
      lodash2.xor = xor;
      lodash2.xorBy = xorBy;
      lodash2.xorWith = xorWith;
      lodash2.zip = zip;
      lodash2.zipObject = zipObject;
      lodash2.zipObjectDeep = zipObjectDeep;
      lodash2.zipWith = zipWith;
      lodash2.entries = toPairs;
      lodash2.entriesIn = toPairsIn;
      lodash2.extend = assignIn;
      lodash2.extendWith = assignInWith;
      mixin(lodash2, lodash2);
      lodash2.add = add2;
      lodash2.attempt = attempt;
      lodash2.camelCase = camelCase;
      lodash2.capitalize = capitalize2;
      lodash2.ceil = ceil;
      lodash2.clamp = clamp2;
      lodash2.clone = clone;
      lodash2.cloneDeep = cloneDeep;
      lodash2.cloneDeepWith = cloneDeepWith;
      lodash2.cloneWith = cloneWith;
      lodash2.conformsTo = conformsTo;
      lodash2.deburr = deburr;
      lodash2.defaultTo = defaultTo;
      lodash2.divide = divide;
      lodash2.endsWith = endsWith2;
      lodash2.eq = eq;
      lodash2.escape = escape2;
      lodash2.escapeRegExp = escapeRegExp;
      lodash2.every = every;
      lodash2.find = find;
      lodash2.findIndex = findIndex2;
      lodash2.findKey = findKey2;
      lodash2.findLast = findLast;
      lodash2.findLastIndex = findLastIndex;
      lodash2.findLastKey = findLastKey;
      lodash2.floor = floor;
      lodash2.forEach = forEach2;
      lodash2.forEachRight = forEachRight;
      lodash2.forIn = forIn;
      lodash2.forInRight = forInRight;
      lodash2.forOwn = forOwn;
      lodash2.forOwnRight = forOwnRight;
      lodash2.get = get2;
      lodash2.gt = gt;
      lodash2.gte = gte;
      lodash2.has = has2;
      lodash2.hasIn = hasIn;
      lodash2.head = head;
      lodash2.identity = identity;
      lodash2.includes = includes2;
      lodash2.indexOf = indexOf;
      lodash2.inRange = inRange;
      lodash2.invoke = invoke;
      lodash2.isArguments = isArguments;
      lodash2.isArray = isArray2;
      lodash2.isArrayBuffer = isArrayBuffer2;
      lodash2.isArrayLike = isArrayLike;
      lodash2.isArrayLikeObject = isArrayLikeObject;
      lodash2.isBoolean = isBoolean2;
      lodash2.isBuffer = isBuffer2;
      lodash2.isDate = isDate2;
      lodash2.isElement = isElement;
      lodash2.isEmpty = isEmpty;
      lodash2.isEqual = isEqual2;
      lodash2.isEqualWith = isEqualWith;
      lodash2.isError = isError;
      lodash2.isFinite = isFinite2;
      lodash2.isFunction = isFunction2;
      lodash2.isInteger = isInteger;
      lodash2.isLength = isLength;
      lodash2.isMap = isMap2;
      lodash2.isMatch = isMatch;
      lodash2.isMatchWith = isMatchWith;
      lodash2.isNaN = isNaN2;
      lodash2.isNative = isNative;
      lodash2.isNil = isNil;
      lodash2.isNull = isNull;
      lodash2.isNumber = isNumber2;
      lodash2.isObject = isObject2;
      lodash2.isObjectLike = isObjectLike;
      lodash2.isPlainObject = isPlainObject2;
      lodash2.isRegExp = isRegExp2;
      lodash2.isSafeInteger = isSafeInteger;
      lodash2.isSet = isSet2;
      lodash2.isString = isString2;
      lodash2.isSymbol = isSymbol2;
      lodash2.isTypedArray = isTypedArray2;
      lodash2.isUndefined = isUndefined2;
      lodash2.isWeakMap = isWeakMap;
      lodash2.isWeakSet = isWeakSet;
      lodash2.join = join;
      lodash2.kebabCase = kebabCase;
      lodash2.last = last;
      lodash2.lastIndexOf = lastIndexOf;
      lodash2.lowerCase = lowerCase;
      lodash2.lowerFirst = lowerFirst;
      lodash2.lt = lt;
      lodash2.lte = lte;
      lodash2.max = max;
      lodash2.maxBy = maxBy;
      lodash2.mean = mean;
      lodash2.meanBy = meanBy;
      lodash2.min = min;
      lodash2.minBy = minBy;
      lodash2.stubArray = stubArray;
      lodash2.stubFalse = stubFalse;
      lodash2.stubObject = stubObject;
      lodash2.stubString = stubString;
      lodash2.stubTrue = stubTrue;
      lodash2.multiply = multiply;
      lodash2.nth = nth;
      lodash2.noConflict = noConflict;
      lodash2.noop = noop2;
      lodash2.now = now;
      lodash2.pad = pad;
      lodash2.padEnd = padEnd;
      lodash2.padStart = padStart;
      lodash2.parseInt = parseInt2;
      lodash2.random = random;
      lodash2.reduce = reduce;
      lodash2.reduceRight = reduceRight;
      lodash2.repeat = repeat;
      lodash2.replace = replace2;
      lodash2.result = result;
      lodash2.round = round;
      lodash2.runInContext = runInContext2;
      lodash2.sample = sample;
      lodash2.size = size2;
      lodash2.snakeCase = snakeCase;
      lodash2.some = some;
      lodash2.sortedIndex = sortedIndex;
      lodash2.sortedIndexBy = sortedIndexBy;
      lodash2.sortedIndexOf = sortedIndexOf;
      lodash2.sortedLastIndex = sortedLastIndex;
      lodash2.sortedLastIndexBy = sortedLastIndexBy;
      lodash2.sortedLastIndexOf = sortedLastIndexOf;
      lodash2.startCase = startCase;
      lodash2.startsWith = startsWith;
      lodash2.subtract = subtract;
      lodash2.sum = sum;
      lodash2.sumBy = sumBy;
      lodash2.template = template;
      lodash2.times = times;
      lodash2.toFinite = toFinite;
      lodash2.toInteger = toInteger2;
      lodash2.toLength = toLength;
      lodash2.toLower = toLower;
      lodash2.toNumber = toNumber2;
      lodash2.toSafeInteger = toSafeInteger;
      lodash2.toString = toString3;
      lodash2.toUpper = toUpper;
      lodash2.trim = trim2;
      lodash2.trimEnd = trimEnd;
      lodash2.trimStart = trimStart;
      lodash2.truncate = truncate;
      lodash2.unescape = unescape2;
      lodash2.uniqueId = uniqueId;
      lodash2.upperCase = upperCase;
      lodash2.upperFirst = upperFirst;
      lodash2.each = forEach2;
      lodash2.eachRight = forEachRight;
      lodash2.first = head;
      mixin(lodash2, function() {
        var source = {};
        baseForOwn(lodash2, function(func, methodName) {
          if (!hasOwnProperty2.call(lodash2.prototype, methodName)) {
            source[methodName] = func;
          }
        });
        return source;
      }(), { "chain": false });
      lodash2.VERSION = VERSION2;
      arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
        lodash2[methodName].placeholder = lodash2;
      });
      arrayEach(["drop", "take"], function(methodName, index2) {
        LazyWrapper.prototype[methodName] = function(n2) {
          n2 = n2 === undefined$1 ? 1 : nativeMax(toInteger2(n2), 0);
          var result2 = this.__filtered__ && !index2 ? new LazyWrapper(this) : this.clone();
          if (result2.__filtered__) {
            result2.__takeCount__ = nativeMin(n2, result2.__takeCount__);
          } else {
            result2.__views__.push({
              "size": nativeMin(n2, MAX_ARRAY_LENGTH),
              "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
            });
          }
          return result2;
        };
        LazyWrapper.prototype[methodName + "Right"] = function(n2) {
          return this.reverse()[methodName](n2).reverse();
        };
      });
      arrayEach(["filter", "map", "takeWhile"], function(methodName, index2) {
        var type = index2 + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
        LazyWrapper.prototype[methodName] = function(iteratee2) {
          var result2 = this.clone();
          result2.__iteratees__.push({
            "iteratee": getIteratee(iteratee2, 3),
            "type": type
          });
          result2.__filtered__ = result2.__filtered__ || isFilter;
          return result2;
        };
      });
      arrayEach(["head", "last"], function(methodName, index2) {
        var takeName = "take" + (index2 ? "Right" : "");
        LazyWrapper.prototype[methodName] = function() {
          return this[takeName](1).value()[0];
        };
      });
      arrayEach(["initial", "tail"], function(methodName, index2) {
        var dropName = "drop" + (index2 ? "" : "Right");
        LazyWrapper.prototype[methodName] = function() {
          return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
        };
      });
      LazyWrapper.prototype.compact = function() {
        return this.filter(identity);
      };
      LazyWrapper.prototype.find = function(predicate) {
        return this.filter(predicate).head();
      };
      LazyWrapper.prototype.findLast = function(predicate) {
        return this.reverse().find(predicate);
      };
      LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
        if (typeof path == "function") {
          return new LazyWrapper(this);
        }
        return this.map(function(value) {
          return baseInvoke(value, path, args);
        });
      });
      LazyWrapper.prototype.reject = function(predicate) {
        return this.filter(negate(getIteratee(predicate)));
      };
      LazyWrapper.prototype.slice = function(start, end) {
        start = toInteger2(start);
        var result2 = this;
        if (result2.__filtered__ && (start > 0 || end < 0)) {
          return new LazyWrapper(result2);
        }
        if (start < 0) {
          result2 = result2.takeRight(-start);
        } else if (start) {
          result2 = result2.drop(start);
        }
        if (end !== undefined$1) {
          end = toInteger2(end);
          result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
        }
        return result2;
      };
      LazyWrapper.prototype.takeRightWhile = function(predicate) {
        return this.reverse().takeWhile(predicate).reverse();
      };
      LazyWrapper.prototype.toArray = function() {
        return this.take(MAX_ARRAY_LENGTH);
      };
      baseForOwn(LazyWrapper.prototype, function(func, methodName) {
        var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash2[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
        if (!lodashFunc) {
          return;
        }
        lodash2.prototype[methodName] = function() {
          var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy2 = isLazy || isArray2(value);
          var interceptor = function(value2) {
            var result3 = lodashFunc.apply(lodash2, arrayPush([value2], args));
            return isTaker && chainAll ? result3[0] : result3;
          };
          if (useLazy2 && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
            isLazy = useLazy2 = false;
          }
          var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
          if (!retUnwrapped && useLazy2) {
            value = onlyLazy ? value : new LazyWrapper(this);
            var result2 = func.apply(value, args);
            result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined$1 });
            return new LodashWrapper(result2, chainAll);
          }
          if (isUnwrapped && onlyLazy) {
            return func.apply(this, args);
          }
          result2 = this.thru(interceptor);
          return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
        };
      });
      arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
        var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
        lodash2.prototype[methodName] = function() {
          var args = arguments;
          if (retUnwrapped && !this.__chain__) {
            var value = this.value();
            return func.apply(isArray2(value) ? value : [], args);
          }
          return this[chainName](function(value2) {
            return func.apply(isArray2(value2) ? value2 : [], args);
          });
        };
      });
      baseForOwn(LazyWrapper.prototype, function(func, methodName) {
        var lodashFunc = lodash2[methodName];
        if (lodashFunc) {
          var key = lodashFunc.name + "";
          if (!hasOwnProperty2.call(realNames, key)) {
            realNames[key] = [];
          }
          realNames[key].push({ "name": methodName, "func": lodashFunc });
        }
      });
      realNames[createHybrid(undefined$1, WRAP_BIND_KEY_FLAG).name] = [{
        "name": "wrapper",
        "func": undefined$1
      }];
      LazyWrapper.prototype.clone = lazyClone;
      LazyWrapper.prototype.reverse = lazyReverse;
      LazyWrapper.prototype.value = lazyValue;
      lodash2.prototype.at = wrapperAt;
      lodash2.prototype.chain = wrapperChain;
      lodash2.prototype.commit = wrapperCommit;
      lodash2.prototype.next = wrapperNext;
      lodash2.prototype.plant = wrapperPlant;
      lodash2.prototype.reverse = wrapperReverse;
      lodash2.prototype.toJSON = lodash2.prototype.valueOf = lodash2.prototype.value = wrapperValue;
      lodash2.prototype.first = lodash2.prototype.head;
      if (symIterator) {
        lodash2.prototype[symIterator] = wrapperToIterator;
      }
      return lodash2;
    };
    var _2 = runInContext();
    if (freeModule) {
      (freeModule.exports = _2)._ = _2;
      freeExports._ = _2;
    } else {
      root._ = _2;
    }
  }).call(commonjsGlobal);
})(lodash, lodash.exports);
const _ = lodash.exports;
function e(e3) {
  this.message = e3;
}
e.prototype = new Error(), e.prototype.name = "InvalidCharacterError";
var r = "undefined" != typeof window && window.atob && window.atob.bind(window) || function(r2) {
  var t3 = String(r2).replace(/=+$/, "");
  if (t3.length % 4 == 1)
    throw new e("'atob' failed: The string to be decoded is not correctly encoded.");
  for (var n2, o2, a3 = 0, i2 = 0, c2 = ""; o2 = t3.charAt(i2++); ~o2 && (n2 = a3 % 4 ? 64 * n2 + o2 : o2, a3++ % 4) ? c2 += String.fromCharCode(255 & n2 >> (-2 * a3 & 6)) : 0)
    o2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(o2);
  return c2;
};
function t(e3) {
  var t3 = e3.replace(/-/g, "+").replace(/_/g, "/");
  switch (t3.length % 4) {
    case 0:
      break;
    case 2:
      t3 += "==";
      break;
    case 3:
      t3 += "=";
      break;
    default:
      throw "Illegal base64url string!";
  }
  try {
    return function(e4) {
      return decodeURIComponent(r(e4).replace(/(.)/g, function(e5, r2) {
        var t4 = r2.charCodeAt(0).toString(16).toUpperCase();
        return t4.length < 2 && (t4 = "0" + t4), "%" + t4;
      }));
    }(t3);
  } catch (e4) {
    return r(t3);
  }
}
function n(e3) {
  this.message = e3;
}
function o(e3, r2) {
  if ("string" != typeof e3)
    throw new n("Invalid token specified");
  var o2 = true === (r2 = r2 || {}).header ? 0 : 1;
  try {
    return JSON.parse(t(e3.split(".")[o2]));
  } catch (e4) {
    throw new n("Invalid token specified: " + e4.message);
  }
}
n.prototype = new Error(), n.prototype.name = "InvalidTokenError";
function makeMap(str, expectsLowerCase) {
  const map = /* @__PURE__ */ Object.create(null);
  const list = str.split(",");
  for (let i2 = 0; i2 < list.length; i2++) {
    map[list[i2]] = true;
  }
  return expectsLowerCase ? (val) => !!map[val.toLowerCase()] : (val) => !!map[val];
}
function normalizeStyle(value) {
  if (isArray$1(value)) {
    const res = {};
    for (let i2 = 0; i2 < value.length; i2++) {
      const item = value[i2];
      const normalized = isString$1(item) ? parseStringStyle(item) : normalizeStyle(item);
      if (normalized) {
        for (const key in normalized) {
          res[key] = normalized[key];
        }
      }
    }
    return res;
  } else if (isString$1(value)) {
    return value;
  } else if (isObject$2(value)) {
    return value;
  }
}
const listDelimiterRE = /;(?![^(]*\))/g;
const propertyDelimiterRE = /:([^]+)/;
const styleCommentRE = /\/\*.*?\*\//gs;
function parseStringStyle(cssText) {
  const ret = {};
  cssText.replace(styleCommentRE, "").split(listDelimiterRE).forEach((item) => {
    if (item) {
      const tmp = item.split(propertyDelimiterRE);
      tmp.length > 1 && (ret[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return ret;
}
function normalizeClass(value) {
  let res = "";
  if (isString$1(value)) {
    res = value;
  } else if (isArray$1(value)) {
    for (let i2 = 0; i2 < value.length; i2++) {
      const normalized = normalizeClass(value[i2]);
      if (normalized) {
        res += normalized + " ";
      }
    }
  } else if (isObject$2(value)) {
    for (const name2 in value) {
      if (value[name2]) {
        res += name2 + " ";
      }
    }
  }
  return res.trim();
}
function normalizeProps(props) {
  if (!props)
    return null;
  let { class: klass, style } = props;
  if (klass && !isString$1(klass)) {
    props.class = normalizeClass(klass);
  }
  if (style) {
    props.style = normalizeStyle(style);
  }
  return props;
}
const specialBooleanAttrs = `itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly`;
const isSpecialBooleanAttr = /* @__PURE__ */ makeMap(specialBooleanAttrs);
function includeBooleanAttr(value) {
  return !!value || value === "";
}
const toDisplayString = (val) => {
  return isString$1(val) ? val : val == null ? "" : isArray$1(val) || isObject$2(val) && (val.toString === objectToString || !isFunction$1(val.toString)) ? JSON.stringify(val, replacer, 2) : String(val);
};
const replacer = (_key, val) => {
  if (val && val.__v_isRef) {
    return replacer(_key, val.value);
  } else if (isMap(val)) {
    return {
      [`Map(${val.size})`]: [...val.entries()].reduce((entries, [key, val2]) => {
        entries[`${key} =>`] = val2;
        return entries;
      }, {})
    };
  } else if (isSet(val)) {
    return {
      [`Set(${val.size})`]: [...val.values()]
    };
  } else if (isObject$2(val) && !isArray$1(val) && !isPlainObject$1(val)) {
    return String(val);
  }
  return val;
};
const EMPTY_OBJ = {};
const EMPTY_ARR = [];
const NOOP = () => {
};
const NO = () => false;
const onRE$1 = /^on[^a-z]/;
const isOn$1 = (key) => onRE$1.test(key);
const isModelListener = (key) => key.startsWith("onUpdate:");
const extend$1 = Object.assign;
const remove = (arr, el2) => {
  const i2 = arr.indexOf(el2);
  if (i2 > -1) {
    arr.splice(i2, 1);
  }
};
const hasOwnProperty$3 = Object.prototype.hasOwnProperty;
const hasOwn = (val, key) => hasOwnProperty$3.call(val, key);
const isArray$1 = Array.isArray;
const isMap = (val) => toTypeString(val) === "[object Map]";
const isSet = (val) => toTypeString(val) === "[object Set]";
const isFunction$1 = (val) => typeof val === "function";
const isString$1 = (val) => typeof val === "string";
const isSymbol = (val) => typeof val === "symbol";
const isObject$2 = (val) => val !== null && typeof val === "object";
const isPromise = (val) => {
  return isObject$2(val) && isFunction$1(val.then) && isFunction$1(val.catch);
};
const objectToString = Object.prototype.toString;
const toTypeString = (value) => objectToString.call(value);
const toRawType = (value) => {
  return toTypeString(value).slice(8, -1);
};
const isPlainObject$1 = (val) => toTypeString(val) === "[object Object]";
const isIntegerKey = (key) => isString$1(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
const isReservedProp = /* @__PURE__ */ makeMap(
  ",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"
);
const cacheStringFunction = (fn2) => {
  const cache = /* @__PURE__ */ Object.create(null);
  return (str) => {
    const hit = cache[str];
    return hit || (cache[str] = fn2(str));
  };
};
const camelizeRE = /-(\w)/g;
const camelize = cacheStringFunction((str) => {
  return str.replace(camelizeRE, (_2, c2) => c2 ? c2.toUpperCase() : "");
});
const hyphenateRE = /\B([A-Z])/g;
const hyphenate = cacheStringFunction((str) => str.replace(hyphenateRE, "-$1").toLowerCase());
const capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));
const toHandlerKey = cacheStringFunction((str) => str ? `on${capitalize(str)}` : ``);
const hasChanged = (value, oldValue) => !Object.is(value, oldValue);
const invokeArrayFns = (fns, arg) => {
  for (let i2 = 0; i2 < fns.length; i2++) {
    fns[i2](arg);
  }
};
const def = (obj, key, value) => {
  Object.defineProperty(obj, key, {
    configurable: true,
    enumerable: false,
    value
  });
};
const looseToNumber = (val) => {
  const n2 = parseFloat(val);
  return isNaN(n2) ? val : n2;
};
const toNumber = (val) => {
  const n2 = isString$1(val) ? Number(val) : NaN;
  return isNaN(n2) ? val : n2;
};
let _globalThis;
const getGlobalThis = () => {
  return _globalThis || (_globalThis = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {});
};
let activeEffectScope;
class EffectScope {
  constructor(detached = false) {
    this.detached = detached;
    this._active = true;
    this.effects = [];
    this.cleanups = [];
    this.parent = activeEffectScope;
    if (!detached && activeEffectScope) {
      this.index = (activeEffectScope.scopes || (activeEffectScope.scopes = [])).push(this) - 1;
    }
  }
  get active() {
    return this._active;
  }
  run(fn2) {
    if (this._active) {
      const currentEffectScope = activeEffectScope;
      try {
        activeEffectScope = this;
        return fn2();
      } finally {
        activeEffectScope = currentEffectScope;
      }
    }
  }
  on() {
    activeEffectScope = this;
  }
  off() {
    activeEffectScope = this.parent;
  }
  stop(fromParent) {
    if (this._active) {
      let i2, l;
      for (i2 = 0, l = this.effects.length; i2 < l; i2++) {
        this.effects[i2].stop();
      }
      for (i2 = 0, l = this.cleanups.length; i2 < l; i2++) {
        this.cleanups[i2]();
      }
      if (this.scopes) {
        for (i2 = 0, l = this.scopes.length; i2 < l; i2++) {
          this.scopes[i2].stop(true);
        }
      }
      if (!this.detached && this.parent && !fromParent) {
        const last = this.parent.scopes.pop();
        if (last && last !== this) {
          this.parent.scopes[this.index] = last;
          last.index = this.index;
        }
      }
      this.parent = void 0;
      this._active = false;
    }
  }
}
function effectScope(detached) {
  return new EffectScope(detached);
}
function recordEffectScope(effect, scope = activeEffectScope) {
  if (scope && scope.active) {
    scope.effects.push(effect);
  }
}
function getCurrentScope() {
  return activeEffectScope;
}
function onScopeDispose(fn2) {
  if (activeEffectScope) {
    activeEffectScope.cleanups.push(fn2);
  }
}
const createDep = (effects) => {
  const dep = new Set(effects);
  dep.w = 0;
  dep.n = 0;
  return dep;
};
const wasTracked = (dep) => (dep.w & trackOpBit) > 0;
const newTracked = (dep) => (dep.n & trackOpBit) > 0;
const initDepMarkers = ({ deps }) => {
  if (deps.length) {
    for (let i2 = 0; i2 < deps.length; i2++) {
      deps[i2].w |= trackOpBit;
    }
  }
};
const finalizeDepMarkers = (effect) => {
  const { deps } = effect;
  if (deps.length) {
    let ptr = 0;
    for (let i2 = 0; i2 < deps.length; i2++) {
      const dep = deps[i2];
      if (wasTracked(dep) && !newTracked(dep)) {
        dep.delete(effect);
      } else {
        deps[ptr++] = dep;
      }
      dep.w &= ~trackOpBit;
      dep.n &= ~trackOpBit;
    }
    deps.length = ptr;
  }
};
const targetMap = /* @__PURE__ */ new WeakMap();
let effectTrackDepth = 0;
let trackOpBit = 1;
const maxMarkerBits = 30;
let activeEffect;
const ITERATE_KEY = Symbol("");
const MAP_KEY_ITERATE_KEY = Symbol("");
class ReactiveEffect {
  constructor(fn2, scheduler = null, scope) {
    this.fn = fn2;
    this.scheduler = scheduler;
    this.active = true;
    this.deps = [];
    this.parent = void 0;
    recordEffectScope(this, scope);
  }
  run() {
    if (!this.active) {
      return this.fn();
    }
    let parent = activeEffect;
    let lastShouldTrack = shouldTrack;
    while (parent) {
      if (parent === this) {
        return;
      }
      parent = parent.parent;
    }
    try {
      this.parent = activeEffect;
      activeEffect = this;
      shouldTrack = true;
      trackOpBit = 1 << ++effectTrackDepth;
      if (effectTrackDepth <= maxMarkerBits) {
        initDepMarkers(this);
      } else {
        cleanupEffect(this);
      }
      return this.fn();
    } finally {
      if (effectTrackDepth <= maxMarkerBits) {
        finalizeDepMarkers(this);
      }
      trackOpBit = 1 << --effectTrackDepth;
      activeEffect = this.parent;
      shouldTrack = lastShouldTrack;
      this.parent = void 0;
      if (this.deferStop) {
        this.stop();
      }
    }
  }
  stop() {
    if (activeEffect === this) {
      this.deferStop = true;
    } else if (this.active) {
      cleanupEffect(this);
      if (this.onStop) {
        this.onStop();
      }
      this.active = false;
    }
  }
}
function cleanupEffect(effect) {
  const { deps } = effect;
  if (deps.length) {
    for (let i2 = 0; i2 < deps.length; i2++) {
      deps[i2].delete(effect);
    }
    deps.length = 0;
  }
}
let shouldTrack = true;
const trackStack = [];
function pauseTracking() {
  trackStack.push(shouldTrack);
  shouldTrack = false;
}
function resetTracking() {
  const last = trackStack.pop();
  shouldTrack = last === void 0 ? true : last;
}
function track(target, type, key) {
  if (shouldTrack && activeEffect) {
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
    }
    let dep = depsMap.get(key);
    if (!dep) {
      depsMap.set(key, dep = createDep());
    }
    trackEffects(dep);
  }
}
function trackEffects(dep, debuggerEventExtraInfo) {
  let shouldTrack2 = false;
  if (effectTrackDepth <= maxMarkerBits) {
    if (!newTracked(dep)) {
      dep.n |= trackOpBit;
      shouldTrack2 = !wasTracked(dep);
    }
  } else {
    shouldTrack2 = !dep.has(activeEffect);
  }
  if (shouldTrack2) {
    dep.add(activeEffect);
    activeEffect.deps.push(dep);
  }
}
function trigger(target, type, key, newValue, oldValue, oldTarget) {
  const depsMap = targetMap.get(target);
  if (!depsMap) {
    return;
  }
  let deps = [];
  if (type === "clear") {
    deps = [...depsMap.values()];
  } else if (key === "length" && isArray$1(target)) {
    const newLength = Number(newValue);
    depsMap.forEach((dep, key2) => {
      if (key2 === "length" || key2 >= newLength) {
        deps.push(dep);
      }
    });
  } else {
    if (key !== void 0) {
      deps.push(depsMap.get(key));
    }
    switch (type) {
      case "add":
        if (!isArray$1(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        } else if (isIntegerKey(key)) {
          deps.push(depsMap.get("length"));
        }
        break;
      case "delete":
        if (!isArray$1(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
          if (isMap(target)) {
            deps.push(depsMap.get(MAP_KEY_ITERATE_KEY));
          }
        }
        break;
      case "set":
        if (isMap(target)) {
          deps.push(depsMap.get(ITERATE_KEY));
        }
        break;
    }
  }
  if (deps.length === 1) {
    if (deps[0]) {
      {
        triggerEffects(deps[0]);
      }
    }
  } else {
    const effects = [];
    for (const dep of deps) {
      if (dep) {
        effects.push(...dep);
      }
    }
    {
      triggerEffects(createDep(effects));
    }
  }
}
function triggerEffects(dep, debuggerEventExtraInfo) {
  const effects = isArray$1(dep) ? dep : [...dep];
  for (const effect of effects) {
    if (effect.computed) {
      triggerEffect(effect);
    }
  }
  for (const effect of effects) {
    if (!effect.computed) {
      triggerEffect(effect);
    }
  }
}
function triggerEffect(effect, debuggerEventExtraInfo) {
  if (effect !== activeEffect || effect.allowRecurse) {
    if (effect.scheduler) {
      effect.scheduler();
    } else {
      effect.run();
    }
  }
}
function getDepFromReactive(object, key) {
  var _a2;
  return (_a2 = targetMap.get(object)) === null || _a2 === void 0 ? void 0 : _a2.get(key);
}
const isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
const builtInSymbols = new Set(
  /* @__PURE__ */ Object.getOwnPropertyNames(Symbol).filter((key) => key !== "arguments" && key !== "caller").map((key) => Symbol[key]).filter(isSymbol)
);
const get$1 = /* @__PURE__ */ createGetter();
const shallowGet = /* @__PURE__ */ createGetter(false, true);
const readonlyGet = /* @__PURE__ */ createGetter(true);
const arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
function createArrayInstrumentations() {
  const instrumentations = {};
  ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
    instrumentations[key] = function(...args) {
      const arr = toRaw(this);
      for (let i2 = 0, l = this.length; i2 < l; i2++) {
        track(arr, "get", i2 + "");
      }
      const res = arr[key](...args);
      if (res === -1 || res === false) {
        return arr[key](...args.map(toRaw));
      } else {
        return res;
      }
    };
  });
  ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
    instrumentations[key] = function(...args) {
      pauseTracking();
      const res = toRaw(this)[key].apply(this, args);
      resetTracking();
      return res;
    };
  });
  return instrumentations;
}
function hasOwnProperty$2(key) {
  const obj = toRaw(this);
  track(obj, "has", key);
  return obj.hasOwnProperty(key);
}
function createGetter(isReadonly2 = false, shallow = false) {
  return function get2(target, key, receiver) {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_isShallow") {
      return shallow;
    } else if (key === "__v_raw" && receiver === (isReadonly2 ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {
      return target;
    }
    const targetIsArray = isArray$1(target);
    if (!isReadonly2) {
      if (targetIsArray && hasOwn(arrayInstrumentations, key)) {
        return Reflect.get(arrayInstrumentations, key, receiver);
      }
      if (key === "hasOwnProperty") {
        return hasOwnProperty$2;
      }
    }
    const res = Reflect.get(target, key, receiver);
    if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
      return res;
    }
    if (!isReadonly2) {
      track(target, "get", key);
    }
    if (shallow) {
      return res;
    }
    if (isRef(res)) {
      return targetIsArray && isIntegerKey(key) ? res : res.value;
    }
    if (isObject$2(res)) {
      return isReadonly2 ? readonly(res) : reactive(res);
    }
    return res;
  };
}
const set$1 = /* @__PURE__ */ createSetter();
const shallowSet = /* @__PURE__ */ createSetter(true);
function createSetter(shallow = false) {
  return function set2(target, key, value, receiver) {
    let oldValue = target[key];
    if (isReadonly(oldValue) && isRef(oldValue) && !isRef(value)) {
      return false;
    }
    if (!shallow) {
      if (!isShallow(value) && !isReadonly(value)) {
        oldValue = toRaw(oldValue);
        value = toRaw(value);
      }
      if (!isArray$1(target) && isRef(oldValue) && !isRef(value)) {
        oldValue.value = value;
        return true;
      }
    }
    const hadKey = isArray$1(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
    const result = Reflect.set(target, key, value, receiver);
    if (target === toRaw(receiver)) {
      if (!hadKey) {
        trigger(target, "add", key, value);
      } else if (hasChanged(value, oldValue)) {
        trigger(target, "set", key, value);
      }
    }
    return result;
  };
}
function deleteProperty(target, key) {
  const hadKey = hasOwn(target, key);
  target[key];
  const result = Reflect.deleteProperty(target, key);
  if (result && hadKey) {
    trigger(target, "delete", key, void 0);
  }
  return result;
}
function has$1(target, key) {
  const result = Reflect.has(target, key);
  if (!isSymbol(key) || !builtInSymbols.has(key)) {
    track(target, "has", key);
  }
  return result;
}
function ownKeys(target) {
  track(target, "iterate", isArray$1(target) ? "length" : ITERATE_KEY);
  return Reflect.ownKeys(target);
}
const mutableHandlers = {
  get: get$1,
  set: set$1,
  deleteProperty,
  has: has$1,
  ownKeys
};
const readonlyHandlers = {
  get: readonlyGet,
  set(target, key) {
    return true;
  },
  deleteProperty(target, key) {
    return true;
  }
};
const shallowReactiveHandlers = /* @__PURE__ */ extend$1({}, mutableHandlers, {
  get: shallowGet,
  set: shallowSet
});
const toShallow = (value) => value;
const getProto = (v) => Reflect.getPrototypeOf(v);
function get(target, key, isReadonly2 = false, isShallow2 = false) {
  target = target["__v_raw"];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (!isReadonly2) {
    if (key !== rawKey) {
      track(rawTarget, "get", key);
    }
    track(rawTarget, "get", rawKey);
  }
  const { has: has2 } = getProto(rawTarget);
  const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
  if (has2.call(rawTarget, key)) {
    return wrap(target.get(key));
  } else if (has2.call(rawTarget, rawKey)) {
    return wrap(target.get(rawKey));
  } else if (target !== rawTarget) {
    target.get(key);
  }
}
function has(key, isReadonly2 = false) {
  const target = this["__v_raw"];
  const rawTarget = toRaw(target);
  const rawKey = toRaw(key);
  if (!isReadonly2) {
    if (key !== rawKey) {
      track(rawTarget, "has", key);
    }
    track(rawTarget, "has", rawKey);
  }
  return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
}
function size(target, isReadonly2 = false) {
  target = target["__v_raw"];
  !isReadonly2 && track(toRaw(target), "iterate", ITERATE_KEY);
  return Reflect.get(target, "size", target);
}
function add$1(value) {
  value = toRaw(value);
  const target = toRaw(this);
  const proto = getProto(target);
  const hadKey = proto.has.call(target, value);
  if (!hadKey) {
    target.add(value);
    trigger(target, "add", value, value);
  }
  return this;
}
function set$2(key, value) {
  value = toRaw(value);
  const target = toRaw(this);
  const { has: has2, get: get2 } = getProto(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  }
  const oldValue = get2.call(target, key);
  target.set(key, value);
  if (!hadKey) {
    trigger(target, "add", key, value);
  } else if (hasChanged(value, oldValue)) {
    trigger(target, "set", key, value);
  }
  return this;
}
function deleteEntry(key) {
  const target = toRaw(this);
  const { has: has2, get: get2 } = getProto(target);
  let hadKey = has2.call(target, key);
  if (!hadKey) {
    key = toRaw(key);
    hadKey = has2.call(target, key);
  }
  get2 ? get2.call(target, key) : void 0;
  const result = target.delete(key);
  if (hadKey) {
    trigger(target, "delete", key, void 0);
  }
  return result;
}
function clear() {
  const target = toRaw(this);
  const hadItems = target.size !== 0;
  const result = target.clear();
  if (hadItems) {
    trigger(target, "clear", void 0, void 0);
  }
  return result;
}
function createForEach(isReadonly2, isShallow2) {
  return function forEach2(callback, thisArg) {
    const observed = this;
    const target = observed["__v_raw"];
    const rawTarget = toRaw(target);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(rawTarget, "iterate", ITERATE_KEY);
    return target.forEach((value, key) => {
      return callback.call(thisArg, wrap(value), wrap(key), observed);
    });
  };
}
function createIterableMethod(method, isReadonly2, isShallow2) {
  return function(...args) {
    const target = this["__v_raw"];
    const rawTarget = toRaw(target);
    const targetIsMap = isMap(rawTarget);
    const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
    const isKeyOnly = method === "keys" && targetIsMap;
    const innerIterator = target[method](...args);
    const wrap = isShallow2 ? toShallow : isReadonly2 ? toReadonly : toReactive;
    !isReadonly2 && track(rawTarget, "iterate", isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);
    return {
      next() {
        const { value, done } = innerIterator.next();
        return done ? { value, done } : {
          value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
          done
        };
      },
      [Symbol.iterator]() {
        return this;
      }
    };
  };
}
function createReadonlyMethod(type) {
  return function(...args) {
    return type === "delete" ? false : this;
  };
}
function createInstrumentations() {
  const mutableInstrumentations2 = {
    get(key) {
      return get(this, key);
    },
    get size() {
      return size(this);
    },
    has,
    add: add$1,
    set: set$2,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, false)
  };
  const shallowInstrumentations2 = {
    get(key) {
      return get(this, key, false, true);
    },
    get size() {
      return size(this);
    },
    has,
    add: add$1,
    set: set$2,
    delete: deleteEntry,
    clear,
    forEach: createForEach(false, true)
  };
  const readonlyInstrumentations2 = {
    get(key) {
      return get(this, key, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, false)
  };
  const shallowReadonlyInstrumentations2 = {
    get(key) {
      return get(this, key, true, true);
    },
    get size() {
      return size(this, true);
    },
    has(key) {
      return has.call(this, key, true);
    },
    add: createReadonlyMethod("add"),
    set: createReadonlyMethod("set"),
    delete: createReadonlyMethod("delete"),
    clear: createReadonlyMethod("clear"),
    forEach: createForEach(true, true)
  };
  const iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
  iteratorMethods.forEach((method) => {
    mutableInstrumentations2[method] = createIterableMethod(method, false, false);
    readonlyInstrumentations2[method] = createIterableMethod(method, true, false);
    shallowInstrumentations2[method] = createIterableMethod(method, false, true);
    shallowReadonlyInstrumentations2[method] = createIterableMethod(method, true, true);
  });
  return [
    mutableInstrumentations2,
    readonlyInstrumentations2,
    shallowInstrumentations2,
    shallowReadonlyInstrumentations2
  ];
}
const [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = /* @__PURE__ */ createInstrumentations();
function createInstrumentationGetter(isReadonly2, shallow) {
  const instrumentations = shallow ? isReadonly2 ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly2 ? readonlyInstrumentations : mutableInstrumentations;
  return (target, key, receiver) => {
    if (key === "__v_isReactive") {
      return !isReadonly2;
    } else if (key === "__v_isReadonly") {
      return isReadonly2;
    } else if (key === "__v_raw") {
      return target;
    }
    return Reflect.get(hasOwn(instrumentations, key) && key in target ? instrumentations : target, key, receiver);
  };
}
const mutableCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, false)
};
const shallowCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(false, true)
};
const readonlyCollectionHandlers = {
  get: /* @__PURE__ */ createInstrumentationGetter(true, false)
};
const reactiveMap = /* @__PURE__ */ new WeakMap();
const shallowReactiveMap = /* @__PURE__ */ new WeakMap();
const readonlyMap = /* @__PURE__ */ new WeakMap();
const shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
function targetTypeMap(rawType) {
  switch (rawType) {
    case "Object":
    case "Array":
      return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
      return 2;
    default:
      return 0;
  }
}
function getTargetType(value) {
  return value["__v_skip"] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
}
function reactive(target) {
  if (isReadonly(target)) {
    return target;
  }
  return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);
}
function shallowReactive(target) {
  return createReactiveObject(target, false, shallowReactiveHandlers, shallowCollectionHandlers, shallowReactiveMap);
}
function readonly(target) {
  return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);
}
function createReactiveObject(target, isReadonly2, baseHandlers, collectionHandlers, proxyMap) {
  if (!isObject$2(target)) {
    return target;
  }
  if (target["__v_raw"] && !(isReadonly2 && target["__v_isReactive"])) {
    return target;
  }
  const existingProxy = proxyMap.get(target);
  if (existingProxy) {
    return existingProxy;
  }
  const targetType = getTargetType(target);
  if (targetType === 0) {
    return target;
  }
  const proxy = new Proxy(target, targetType === 2 ? collectionHandlers : baseHandlers);
  proxyMap.set(target, proxy);
  return proxy;
}
function isReactive(value) {
  if (isReadonly(value)) {
    return isReactive(value["__v_raw"]);
  }
  return !!(value && value["__v_isReactive"]);
}
function isReadonly(value) {
  return !!(value && value["__v_isReadonly"]);
}
function isShallow(value) {
  return !!(value && value["__v_isShallow"]);
}
function isProxy(value) {
  return isReactive(value) || isReadonly(value);
}
function toRaw(observed) {
  const raw = observed && observed["__v_raw"];
  return raw ? toRaw(raw) : observed;
}
function markRaw(value) {
  def(value, "__v_skip", true);
  return value;
}
const toReactive = (value) => isObject$2(value) ? reactive(value) : value;
const toReadonly = (value) => isObject$2(value) ? readonly(value) : value;
function trackRefValue(ref2) {
  if (shouldTrack && activeEffect) {
    ref2 = toRaw(ref2);
    {
      trackEffects(ref2.dep || (ref2.dep = createDep()));
    }
  }
}
function triggerRefValue(ref2, newVal) {
  ref2 = toRaw(ref2);
  const dep = ref2.dep;
  if (dep) {
    {
      triggerEffects(dep);
    }
  }
}
function isRef(r2) {
  return !!(r2 && r2.__v_isRef === true);
}
function ref(value) {
  return createRef(value, false);
}
function shallowRef(value) {
  return createRef(value, true);
}
function createRef(rawValue, shallow) {
  if (isRef(rawValue)) {
    return rawValue;
  }
  return new RefImpl(rawValue, shallow);
}
class RefImpl {
  constructor(value, __v_isShallow) {
    this.__v_isShallow = __v_isShallow;
    this.dep = void 0;
    this.__v_isRef = true;
    this._rawValue = __v_isShallow ? value : toRaw(value);
    this._value = __v_isShallow ? value : toReactive(value);
  }
  get value() {
    trackRefValue(this);
    return this._value;
  }
  set value(newVal) {
    const useDirectValue = this.__v_isShallow || isShallow(newVal) || isReadonly(newVal);
    newVal = useDirectValue ? newVal : toRaw(newVal);
    if (hasChanged(newVal, this._rawValue)) {
      this._rawValue = newVal;
      this._value = useDirectValue ? newVal : toReactive(newVal);
      triggerRefValue(this);
    }
  }
}
function unref(ref2) {
  return isRef(ref2) ? ref2.value : ref2;
}
const shallowUnwrapHandlers = {
  get: (target, key, receiver) => unref(Reflect.get(target, key, receiver)),
  set: (target, key, value, receiver) => {
    const oldValue = target[key];
    if (isRef(oldValue) && !isRef(value)) {
      oldValue.value = value;
      return true;
    } else {
      return Reflect.set(target, key, value, receiver);
    }
  }
};
function proxyRefs(objectWithRefs) {
  return isReactive(objectWithRefs) ? objectWithRefs : new Proxy(objectWithRefs, shallowUnwrapHandlers);
}
function toRefs(object) {
  const ret = isArray$1(object) ? new Array(object.length) : {};
  for (const key in object) {
    ret[key] = toRef(object, key);
  }
  return ret;
}
class ObjectRefImpl {
  constructor(_object, _key, _defaultValue) {
    this._object = _object;
    this._key = _key;
    this._defaultValue = _defaultValue;
    this.__v_isRef = true;
  }
  get value() {
    const val = this._object[this._key];
    return val === void 0 ? this._defaultValue : val;
  }
  set value(newVal) {
    this._object[this._key] = newVal;
  }
  get dep() {
    return getDepFromReactive(toRaw(this._object), this._key);
  }
}
function toRef(object, key, defaultValue) {
  const val = object[key];
  return isRef(val) ? val : new ObjectRefImpl(object, key, defaultValue);
}
var _a$1;
class ComputedRefImpl {
  constructor(getter, _setter, isReadonly2, isSSR) {
    this._setter = _setter;
    this.dep = void 0;
    this.__v_isRef = true;
    this[_a$1] = false;
    this._dirty = true;
    this.effect = new ReactiveEffect(getter, () => {
      if (!this._dirty) {
        this._dirty = true;
        triggerRefValue(this);
      }
    });
    this.effect.computed = this;
    this.effect.active = this._cacheable = !isSSR;
    this["__v_isReadonly"] = isReadonly2;
  }
  get value() {
    const self2 = toRaw(this);
    trackRefValue(self2);
    if (self2._dirty || !self2._cacheable) {
      self2._dirty = false;
      self2._value = self2.effect.run();
    }
    return self2._value;
  }
  set value(newValue) {
    this._setter(newValue);
  }
}
_a$1 = "__v_isReadonly";
function computed$1(getterOrOptions, debugOptions, isSSR = false) {
  let getter;
  let setter;
  const onlyGetter = isFunction$1(getterOrOptions);
  if (onlyGetter) {
    getter = getterOrOptions;
    setter = NOOP;
  } else {
    getter = getterOrOptions.get;
    setter = getterOrOptions.set;
  }
  const cRef = new ComputedRefImpl(getter, setter, onlyGetter || !setter, isSSR);
  return cRef;
}
function warn(msg, ...args) {
  return;
}
function callWithErrorHandling(fn2, instance, type, args) {
  let res;
  try {
    res = args ? fn2(...args) : fn2();
  } catch (err) {
    handleError(err, instance, type);
  }
  return res;
}
function callWithAsyncErrorHandling(fn2, instance, type, args) {
  if (isFunction$1(fn2)) {
    const res = callWithErrorHandling(fn2, instance, type, args);
    if (res && isPromise(res)) {
      res.catch((err) => {
        handleError(err, instance, type);
      });
    }
    return res;
  }
  const values = [];
  for (let i2 = 0; i2 < fn2.length; i2++) {
    values.push(callWithAsyncErrorHandling(fn2[i2], instance, type, args));
  }
  return values;
}
function handleError(err, instance, type, throwInDev = true) {
  const contextVNode = instance ? instance.vnode : null;
  if (instance) {
    let cur = instance.parent;
    const exposedInstance = instance.proxy;
    const errorInfo = type;
    while (cur) {
      const errorCapturedHooks = cur.ec;
      if (errorCapturedHooks) {
        for (let i2 = 0; i2 < errorCapturedHooks.length; i2++) {
          if (errorCapturedHooks[i2](err, exposedInstance, errorInfo) === false) {
            return;
          }
        }
      }
      cur = cur.parent;
    }
    const appErrorHandler = instance.appContext.config.errorHandler;
    if (appErrorHandler) {
      callWithErrorHandling(appErrorHandler, null, 10, [err, exposedInstance, errorInfo]);
      return;
    }
  }
  logError(err, type, contextVNode, throwInDev);
}
function logError(err, type, contextVNode, throwInDev = true) {
  {
    console.error(err);
  }
}
let isFlushing = false;
let isFlushPending = false;
const queue = [];
let flushIndex = 0;
const pendingPostFlushCbs = [];
let activePostFlushCbs = null;
let postFlushIndex = 0;
const resolvedPromise = /* @__PURE__ */ Promise.resolve();
let currentFlushPromise = null;
function nextTick(fn2) {
  const p2 = currentFlushPromise || resolvedPromise;
  return fn2 ? p2.then(this ? fn2.bind(this) : fn2) : p2;
}
function findInsertionIndex(id) {
  let start = flushIndex + 1;
  let end = queue.length;
  while (start < end) {
    const middle = start + end >>> 1;
    const middleJobId = getId(queue[middle]);
    middleJobId < id ? start = middle + 1 : end = middle;
  }
  return start;
}
function queueJob(job) {
  if (!queue.length || !queue.includes(job, isFlushing && job.allowRecurse ? flushIndex + 1 : flushIndex)) {
    if (job.id == null) {
      queue.push(job);
    } else {
      queue.splice(findInsertionIndex(job.id), 0, job);
    }
    queueFlush();
  }
}
function queueFlush() {
  if (!isFlushing && !isFlushPending) {
    isFlushPending = true;
    currentFlushPromise = resolvedPromise.then(flushJobs);
  }
}
function invalidateJob(job) {
  const i2 = queue.indexOf(job);
  if (i2 > flushIndex) {
    queue.splice(i2, 1);
  }
}
function queuePostFlushCb(cb) {
  if (!isArray$1(cb)) {
    if (!activePostFlushCbs || !activePostFlushCbs.includes(cb, cb.allowRecurse ? postFlushIndex + 1 : postFlushIndex)) {
      pendingPostFlushCbs.push(cb);
    }
  } else {
    pendingPostFlushCbs.push(...cb);
  }
  queueFlush();
}
function flushPreFlushCbs(seen2, i2 = isFlushing ? flushIndex + 1 : 0) {
  for (; i2 < queue.length; i2++) {
    const cb = queue[i2];
    if (cb && cb.pre) {
      queue.splice(i2, 1);
      i2--;
      cb();
    }
  }
}
function flushPostFlushCbs(seen2) {
  if (pendingPostFlushCbs.length) {
    const deduped = [...new Set(pendingPostFlushCbs)];
    pendingPostFlushCbs.length = 0;
    if (activePostFlushCbs) {
      activePostFlushCbs.push(...deduped);
      return;
    }
    activePostFlushCbs = deduped;
    activePostFlushCbs.sort((a3, b3) => getId(a3) - getId(b3));
    for (postFlushIndex = 0; postFlushIndex < activePostFlushCbs.length; postFlushIndex++) {
      activePostFlushCbs[postFlushIndex]();
    }
    activePostFlushCbs = null;
    postFlushIndex = 0;
  }
}
const getId = (job) => job.id == null ? Infinity : job.id;
const comparator = (a3, b3) => {
  const diff = getId(a3) - getId(b3);
  if (diff === 0) {
    if (a3.pre && !b3.pre)
      return -1;
    if (b3.pre && !a3.pre)
      return 1;
  }
  return diff;
};
function flushJobs(seen2) {
  isFlushPending = false;
  isFlushing = true;
  queue.sort(comparator);
  const check = NOOP;
  try {
    for (flushIndex = 0; flushIndex < queue.length; flushIndex++) {
      const job = queue[flushIndex];
      if (job && job.active !== false) {
        if (false)
          ;
        callWithErrorHandling(job, null, 14);
      }
    }
  } finally {
    flushIndex = 0;
    queue.length = 0;
    flushPostFlushCbs();
    isFlushing = false;
    currentFlushPromise = null;
    if (queue.length || pendingPostFlushCbs.length) {
      flushJobs();
    }
  }
}
function emit(instance, event, ...rawArgs) {
  if (instance.isUnmounted)
    return;
  const props = instance.vnode.props || EMPTY_OBJ;
  let args = rawArgs;
  const isModelListener2 = event.startsWith("update:");
  const modelArg = isModelListener2 && event.slice(7);
  if (modelArg && modelArg in props) {
    const modifiersKey = `${modelArg === "modelValue" ? "model" : modelArg}Modifiers`;
    const { number, trim: trim2 } = props[modifiersKey] || EMPTY_OBJ;
    if (trim2) {
      args = rawArgs.map((a3) => isString$1(a3) ? a3.trim() : a3);
    }
    if (number) {
      args = rawArgs.map(looseToNumber);
    }
  }
  let handlerName;
  let handler = props[handlerName = toHandlerKey(event)] || props[handlerName = toHandlerKey(camelize(event))];
  if (!handler && isModelListener2) {
    handler = props[handlerName = toHandlerKey(hyphenate(event))];
  }
  if (handler) {
    callWithAsyncErrorHandling(handler, instance, 6, args);
  }
  const onceHandler = props[handlerName + `Once`];
  if (onceHandler) {
    if (!instance.emitted) {
      instance.emitted = {};
    } else if (instance.emitted[handlerName]) {
      return;
    }
    instance.emitted[handlerName] = true;
    callWithAsyncErrorHandling(onceHandler, instance, 6, args);
  }
}
function normalizeEmitsOptions(comp, appContext, asMixin = false) {
  const cache = appContext.emitsCache;
  const cached = cache.get(comp);
  if (cached !== void 0) {
    return cached;
  }
  const raw = comp.emits;
  let normalized = {};
  let hasExtends = false;
  if (!isFunction$1(comp)) {
    const extendEmits = (raw2) => {
      const normalizedFromExtend = normalizeEmitsOptions(raw2, appContext, true);
      if (normalizedFromExtend) {
        hasExtends = true;
        extend$1(normalized, normalizedFromExtend);
      }
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendEmits);
    }
    if (comp.extends) {
      extendEmits(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendEmits);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject$2(comp)) {
      cache.set(comp, null);
    }
    return null;
  }
  if (isArray$1(raw)) {
    raw.forEach((key) => normalized[key] = null);
  } else {
    extend$1(normalized, raw);
  }
  if (isObject$2(comp)) {
    cache.set(comp, normalized);
  }
  return normalized;
}
function isEmitListener(options, key) {
  if (!options || !isOn$1(key)) {
    return false;
  }
  key = key.slice(2).replace(/Once$/, "");
  return hasOwn(options, key[0].toLowerCase() + key.slice(1)) || hasOwn(options, hyphenate(key)) || hasOwn(options, key);
}
let currentRenderingInstance = null;
let currentScopeId = null;
function setCurrentRenderingInstance(instance) {
  const prev = currentRenderingInstance;
  currentRenderingInstance = instance;
  currentScopeId = instance && instance.type.__scopeId || null;
  return prev;
}
function pushScopeId(id) {
  currentScopeId = id;
}
function popScopeId() {
  currentScopeId = null;
}
function withCtx(fn2, ctx = currentRenderingInstance, isNonScopedSlot) {
  if (!ctx)
    return fn2;
  if (fn2._n) {
    return fn2;
  }
  const renderFnWithContext = (...args) => {
    if (renderFnWithContext._d) {
      setBlockTracking(-1);
    }
    const prevInstance = setCurrentRenderingInstance(ctx);
    let res;
    try {
      res = fn2(...args);
    } finally {
      setCurrentRenderingInstance(prevInstance);
      if (renderFnWithContext._d) {
        setBlockTracking(1);
      }
    }
    return res;
  };
  renderFnWithContext._n = true;
  renderFnWithContext._c = true;
  renderFnWithContext._d = true;
  return renderFnWithContext;
}
function markAttrsAccessed() {
}
function renderComponentRoot(instance) {
  const { type: Component, vnode, proxy, withProxy, props, propsOptions: [propsOptions], slots, attrs, emit: emit2, render, renderCache, data, setupState, ctx, inheritAttrs } = instance;
  let result;
  let fallthroughAttrs;
  const prev = setCurrentRenderingInstance(instance);
  try {
    if (vnode.shapeFlag & 4) {
      const proxyToUse = withProxy || proxy;
      result = normalizeVNode(render.call(proxyToUse, proxyToUse, renderCache, props, setupState, data, ctx));
      fallthroughAttrs = attrs;
    } else {
      const render2 = Component;
      if (false)
        ;
      result = normalizeVNode(render2.length > 1 ? render2(props, false ? {
        get attrs() {
          markAttrsAccessed();
          return attrs;
        },
        slots,
        emit: emit2
      } : { attrs, slots, emit: emit2 }) : render2(props, null));
      fallthroughAttrs = Component.props ? attrs : getFunctionalFallthrough(attrs);
    }
  } catch (err) {
    blockStack.length = 0;
    handleError(err, instance, 1);
    result = createVNode(Comment);
  }
  let root = result;
  if (fallthroughAttrs && inheritAttrs !== false) {
    const keys = Object.keys(fallthroughAttrs);
    const { shapeFlag } = root;
    if (keys.length) {
      if (shapeFlag & (1 | 6)) {
        if (propsOptions && keys.some(isModelListener)) {
          fallthroughAttrs = filterModelListeners(fallthroughAttrs, propsOptions);
        }
        root = cloneVNode(root, fallthroughAttrs);
      }
    }
  }
  if (vnode.dirs) {
    root = cloneVNode(root);
    root.dirs = root.dirs ? root.dirs.concat(vnode.dirs) : vnode.dirs;
  }
  if (vnode.transition) {
    root.transition = vnode.transition;
  }
  {
    result = root;
  }
  setCurrentRenderingInstance(prev);
  return result;
}
const getFunctionalFallthrough = (attrs) => {
  let res;
  for (const key in attrs) {
    if (key === "class" || key === "style" || isOn$1(key)) {
      (res || (res = {}))[key] = attrs[key];
    }
  }
  return res;
};
const filterModelListeners = (attrs, props) => {
  const res = {};
  for (const key in attrs) {
    if (!isModelListener(key) || !(key.slice(9) in props)) {
      res[key] = attrs[key];
    }
  }
  return res;
};
function shouldUpdateComponent(prevVNode, nextVNode, optimized) {
  const { props: prevProps, children: prevChildren, component } = prevVNode;
  const { props: nextProps, children: nextChildren, patchFlag } = nextVNode;
  const emits = component.emitsOptions;
  if (nextVNode.dirs || nextVNode.transition) {
    return true;
  }
  if (optimized && patchFlag >= 0) {
    if (patchFlag & 1024) {
      return true;
    }
    if (patchFlag & 16) {
      if (!prevProps) {
        return !!nextProps;
      }
      return hasPropsChanged(prevProps, nextProps, emits);
    } else if (patchFlag & 8) {
      const dynamicProps = nextVNode.dynamicProps;
      for (let i2 = 0; i2 < dynamicProps.length; i2++) {
        const key = dynamicProps[i2];
        if (nextProps[key] !== prevProps[key] && !isEmitListener(emits, key)) {
          return true;
        }
      }
    }
  } else {
    if (prevChildren || nextChildren) {
      if (!nextChildren || !nextChildren.$stable) {
        return true;
      }
    }
    if (prevProps === nextProps) {
      return false;
    }
    if (!prevProps) {
      return !!nextProps;
    }
    if (!nextProps) {
      return true;
    }
    return hasPropsChanged(prevProps, nextProps, emits);
  }
  return false;
}
function hasPropsChanged(prevProps, nextProps, emitsOptions) {
  const nextKeys = Object.keys(nextProps);
  if (nextKeys.length !== Object.keys(prevProps).length) {
    return true;
  }
  for (let i2 = 0; i2 < nextKeys.length; i2++) {
    const key = nextKeys[i2];
    if (nextProps[key] !== prevProps[key] && !isEmitListener(emitsOptions, key)) {
      return true;
    }
  }
  return false;
}
function updateHOCHostEl({ vnode, parent }, el2) {
  while (parent && parent.subTree === vnode) {
    (vnode = parent.vnode).el = el2;
    parent = parent.parent;
  }
}
const isSuspense = (type) => type.__isSuspense;
function queueEffectWithSuspense(fn2, suspense) {
  if (suspense && suspense.pendingBranch) {
    if (isArray$1(fn2)) {
      suspense.effects.push(...fn2);
    } else {
      suspense.effects.push(fn2);
    }
  } else {
    queuePostFlushCb(fn2);
  }
}
function provide(key, value) {
  if (!currentInstance)
    ;
  else {
    let provides = currentInstance.provides;
    const parentProvides = currentInstance.parent && currentInstance.parent.provides;
    if (parentProvides === provides) {
      provides = currentInstance.provides = Object.create(parentProvides);
    }
    provides[key] = value;
  }
}
function inject$1(key, defaultValue, treatDefaultAsFactory = false) {
  const instance = currentInstance || currentRenderingInstance;
  if (instance) {
    const provides = instance.parent == null ? instance.vnode.appContext && instance.vnode.appContext.provides : instance.parent.provides;
    if (provides && key in provides) {
      return provides[key];
    } else if (arguments.length > 1) {
      return treatDefaultAsFactory && isFunction$1(defaultValue) ? defaultValue.call(instance.proxy) : defaultValue;
    } else
      ;
  }
}
function watchEffect(effect, options) {
  return doWatch(effect, null, options);
}
const INITIAL_WATCHER_VALUE = {};
function watch(source, cb, options) {
  return doWatch(source, cb, options);
}
function doWatch(source, cb, { immediate, deep, flush, onTrack, onTrigger } = EMPTY_OBJ) {
  const instance = getCurrentScope() === (currentInstance === null || currentInstance === void 0 ? void 0 : currentInstance.scope) ? currentInstance : null;
  let getter;
  let forceTrigger = false;
  let isMultiSource = false;
  if (isRef(source)) {
    getter = () => source.value;
    forceTrigger = isShallow(source);
  } else if (isReactive(source)) {
    getter = () => source;
    deep = true;
  } else if (isArray$1(source)) {
    isMultiSource = true;
    forceTrigger = source.some((s3) => isReactive(s3) || isShallow(s3));
    getter = () => source.map((s3) => {
      if (isRef(s3)) {
        return s3.value;
      } else if (isReactive(s3)) {
        return traverse(s3);
      } else if (isFunction$1(s3)) {
        return callWithErrorHandling(s3, instance, 2);
      } else
        ;
    });
  } else if (isFunction$1(source)) {
    if (cb) {
      getter = () => callWithErrorHandling(source, instance, 2);
    } else {
      getter = () => {
        if (instance && instance.isUnmounted) {
          return;
        }
        if (cleanup) {
          cleanup();
        }
        return callWithAsyncErrorHandling(source, instance, 3, [onCleanup]);
      };
    }
  } else {
    getter = NOOP;
  }
  if (cb && deep) {
    const baseGetter = getter;
    getter = () => traverse(baseGetter());
  }
  let cleanup;
  let onCleanup = (fn2) => {
    cleanup = effect.onStop = () => {
      callWithErrorHandling(fn2, instance, 4);
    };
  };
  let ssrCleanup;
  if (isInSSRComponentSetup) {
    onCleanup = NOOP;
    if (!cb) {
      getter();
    } else if (immediate) {
      callWithAsyncErrorHandling(cb, instance, 3, [
        getter(),
        isMultiSource ? [] : void 0,
        onCleanup
      ]);
    }
    if (flush === "sync") {
      const ctx = useSSRContext();
      ssrCleanup = ctx.__watcherHandles || (ctx.__watcherHandles = []);
    } else {
      return NOOP;
    }
  }
  let oldValue = isMultiSource ? new Array(source.length).fill(INITIAL_WATCHER_VALUE) : INITIAL_WATCHER_VALUE;
  const job = () => {
    if (!effect.active) {
      return;
    }
    if (cb) {
      const newValue = effect.run();
      if (deep || forceTrigger || (isMultiSource ? newValue.some((v, i2) => hasChanged(v, oldValue[i2])) : hasChanged(newValue, oldValue)) || false) {
        if (cleanup) {
          cleanup();
        }
        callWithAsyncErrorHandling(cb, instance, 3, [
          newValue,
          oldValue === INITIAL_WATCHER_VALUE ? void 0 : isMultiSource && oldValue[0] === INITIAL_WATCHER_VALUE ? [] : oldValue,
          onCleanup
        ]);
        oldValue = newValue;
      }
    } else {
      effect.run();
    }
  };
  job.allowRecurse = !!cb;
  let scheduler;
  if (flush === "sync") {
    scheduler = job;
  } else if (flush === "post") {
    scheduler = () => queuePostRenderEffect(job, instance && instance.suspense);
  } else {
    job.pre = true;
    if (instance)
      job.id = instance.uid;
    scheduler = () => queueJob(job);
  }
  const effect = new ReactiveEffect(getter, scheduler);
  if (cb) {
    if (immediate) {
      job();
    } else {
      oldValue = effect.run();
    }
  } else if (flush === "post") {
    queuePostRenderEffect(effect.run.bind(effect), instance && instance.suspense);
  } else {
    effect.run();
  }
  const unwatch = () => {
    effect.stop();
    if (instance && instance.scope) {
      remove(instance.scope.effects, effect);
    }
  };
  if (ssrCleanup)
    ssrCleanup.push(unwatch);
  return unwatch;
}
function instanceWatch(source, value, options) {
  const publicThis = this.proxy;
  const getter = isString$1(source) ? source.includes(".") ? createPathGetter(publicThis, source) : () => publicThis[source] : source.bind(publicThis, publicThis);
  let cb;
  if (isFunction$1(value)) {
    cb = value;
  } else {
    cb = value.handler;
    options = value;
  }
  const cur = currentInstance;
  setCurrentInstance(this);
  const res = doWatch(getter, cb.bind(publicThis), options);
  if (cur) {
    setCurrentInstance(cur);
  } else {
    unsetCurrentInstance();
  }
  return res;
}
function createPathGetter(ctx, path) {
  const segments = path.split(".");
  return () => {
    let cur = ctx;
    for (let i2 = 0; i2 < segments.length && cur; i2++) {
      cur = cur[segments[i2]];
    }
    return cur;
  };
}
function traverse(value, seen2) {
  if (!isObject$2(value) || value["__v_skip"]) {
    return value;
  }
  seen2 = seen2 || /* @__PURE__ */ new Set();
  if (seen2.has(value)) {
    return value;
  }
  seen2.add(value);
  if (isRef(value)) {
    traverse(value.value, seen2);
  } else if (isArray$1(value)) {
    for (let i2 = 0; i2 < value.length; i2++) {
      traverse(value[i2], seen2);
    }
  } else if (isSet(value) || isMap(value)) {
    value.forEach((v) => {
      traverse(v, seen2);
    });
  } else if (isPlainObject$1(value)) {
    for (const key in value) {
      traverse(value[key], seen2);
    }
  }
  return value;
}
function useTransitionState() {
  const state = {
    isMounted: false,
    isLeaving: false,
    isUnmounting: false,
    leavingVNodes: /* @__PURE__ */ new Map()
  };
  onMounted(() => {
    state.isMounted = true;
  });
  onBeforeUnmount(() => {
    state.isUnmounting = true;
  });
  return state;
}
const TransitionHookValidator = [Function, Array];
const BaseTransitionImpl = {
  name: `BaseTransition`,
  props: {
    mode: String,
    appear: Boolean,
    persisted: Boolean,
    onBeforeEnter: TransitionHookValidator,
    onEnter: TransitionHookValidator,
    onAfterEnter: TransitionHookValidator,
    onEnterCancelled: TransitionHookValidator,
    onBeforeLeave: TransitionHookValidator,
    onLeave: TransitionHookValidator,
    onAfterLeave: TransitionHookValidator,
    onLeaveCancelled: TransitionHookValidator,
    onBeforeAppear: TransitionHookValidator,
    onAppear: TransitionHookValidator,
    onAfterAppear: TransitionHookValidator,
    onAppearCancelled: TransitionHookValidator
  },
  setup(props, { slots }) {
    const instance = getCurrentInstance$1();
    const state = useTransitionState();
    let prevTransitionKey;
    return () => {
      const children = slots.default && getTransitionRawChildren(slots.default(), true);
      if (!children || !children.length) {
        return;
      }
      let child = children[0];
      if (children.length > 1) {
        for (const c2 of children) {
          if (c2.type !== Comment) {
            child = c2;
            break;
          }
        }
      }
      const rawProps = toRaw(props);
      const { mode } = rawProps;
      if (state.isLeaving) {
        return emptyPlaceholder(child);
      }
      const innerChild = getKeepAliveChild(child);
      if (!innerChild) {
        return emptyPlaceholder(child);
      }
      const enterHooks = resolveTransitionHooks(innerChild, rawProps, state, instance);
      setTransitionHooks(innerChild, enterHooks);
      const oldChild = instance.subTree;
      const oldInnerChild = oldChild && getKeepAliveChild(oldChild);
      let transitionKeyChanged = false;
      const { getTransitionKey } = innerChild.type;
      if (getTransitionKey) {
        const key = getTransitionKey();
        if (prevTransitionKey === void 0) {
          prevTransitionKey = key;
        } else if (key !== prevTransitionKey) {
          prevTransitionKey = key;
          transitionKeyChanged = true;
        }
      }
      if (oldInnerChild && oldInnerChild.type !== Comment && (!isSameVNodeType(innerChild, oldInnerChild) || transitionKeyChanged)) {
        const leavingHooks = resolveTransitionHooks(oldInnerChild, rawProps, state, instance);
        setTransitionHooks(oldInnerChild, leavingHooks);
        if (mode === "out-in") {
          state.isLeaving = true;
          leavingHooks.afterLeave = () => {
            state.isLeaving = false;
            if (instance.update.active !== false) {
              instance.update();
            }
          };
          return emptyPlaceholder(child);
        } else if (mode === "in-out" && innerChild.type !== Comment) {
          leavingHooks.delayLeave = (el2, earlyRemove, delayedLeave) => {
            const leavingVNodesCache = getLeavingNodesForType(state, oldInnerChild);
            leavingVNodesCache[String(oldInnerChild.key)] = oldInnerChild;
            el2._leaveCb = () => {
              earlyRemove();
              el2._leaveCb = void 0;
              delete enterHooks.delayedLeave;
            };
            enterHooks.delayedLeave = delayedLeave;
          };
        }
      }
      return child;
    };
  }
};
const BaseTransition = BaseTransitionImpl;
function getLeavingNodesForType(state, vnode) {
  const { leavingVNodes } = state;
  let leavingVNodesCache = leavingVNodes.get(vnode.type);
  if (!leavingVNodesCache) {
    leavingVNodesCache = /* @__PURE__ */ Object.create(null);
    leavingVNodes.set(vnode.type, leavingVNodesCache);
  }
  return leavingVNodesCache;
}
function resolveTransitionHooks(vnode, props, state, instance) {
  const { appear, mode, persisted = false, onBeforeEnter, onEnter, onAfterEnter, onEnterCancelled, onBeforeLeave, onLeave, onAfterLeave, onLeaveCancelled, onBeforeAppear, onAppear, onAfterAppear, onAppearCancelled } = props;
  const key = String(vnode.key);
  const leavingVNodesCache = getLeavingNodesForType(state, vnode);
  const callHook2 = (hook, args) => {
    hook && callWithAsyncErrorHandling(hook, instance, 9, args);
  };
  const callAsyncHook = (hook, args) => {
    const done = args[1];
    callHook2(hook, args);
    if (isArray$1(hook)) {
      if (hook.every((hook2) => hook2.length <= 1))
        done();
    } else if (hook.length <= 1) {
      done();
    }
  };
  const hooks = {
    mode,
    persisted,
    beforeEnter(el2) {
      let hook = onBeforeEnter;
      if (!state.isMounted) {
        if (appear) {
          hook = onBeforeAppear || onBeforeEnter;
        } else {
          return;
        }
      }
      if (el2._leaveCb) {
        el2._leaveCb(true);
      }
      const leavingVNode = leavingVNodesCache[key];
      if (leavingVNode && isSameVNodeType(vnode, leavingVNode) && leavingVNode.el._leaveCb) {
        leavingVNode.el._leaveCb();
      }
      callHook2(hook, [el2]);
    },
    enter(el2) {
      let hook = onEnter;
      let afterHook = onAfterEnter;
      let cancelHook = onEnterCancelled;
      if (!state.isMounted) {
        if (appear) {
          hook = onAppear || onEnter;
          afterHook = onAfterAppear || onAfterEnter;
          cancelHook = onAppearCancelled || onEnterCancelled;
        } else {
          return;
        }
      }
      let called = false;
      const done = el2._enterCb = (cancelled) => {
        if (called)
          return;
        called = true;
        if (cancelled) {
          callHook2(cancelHook, [el2]);
        } else {
          callHook2(afterHook, [el2]);
        }
        if (hooks.delayedLeave) {
          hooks.delayedLeave();
        }
        el2._enterCb = void 0;
      };
      if (hook) {
        callAsyncHook(hook, [el2, done]);
      } else {
        done();
      }
    },
    leave(el2, remove2) {
      const key2 = String(vnode.key);
      if (el2._enterCb) {
        el2._enterCb(true);
      }
      if (state.isUnmounting) {
        return remove2();
      }
      callHook2(onBeforeLeave, [el2]);
      let called = false;
      const done = el2._leaveCb = (cancelled) => {
        if (called)
          return;
        called = true;
        remove2();
        if (cancelled) {
          callHook2(onLeaveCancelled, [el2]);
        } else {
          callHook2(onAfterLeave, [el2]);
        }
        el2._leaveCb = void 0;
        if (leavingVNodesCache[key2] === vnode) {
          delete leavingVNodesCache[key2];
        }
      };
      leavingVNodesCache[key2] = vnode;
      if (onLeave) {
        callAsyncHook(onLeave, [el2, done]);
      } else {
        done();
      }
    },
    clone(vnode2) {
      return resolveTransitionHooks(vnode2, props, state, instance);
    }
  };
  return hooks;
}
function emptyPlaceholder(vnode) {
  if (isKeepAlive(vnode)) {
    vnode = cloneVNode(vnode);
    vnode.children = null;
    return vnode;
  }
}
function getKeepAliveChild(vnode) {
  return isKeepAlive(vnode) ? vnode.children ? vnode.children[0] : void 0 : vnode;
}
function setTransitionHooks(vnode, hooks) {
  if (vnode.shapeFlag & 6 && vnode.component) {
    setTransitionHooks(vnode.component.subTree, hooks);
  } else if (vnode.shapeFlag & 128) {
    vnode.ssContent.transition = hooks.clone(vnode.ssContent);
    vnode.ssFallback.transition = hooks.clone(vnode.ssFallback);
  } else {
    vnode.transition = hooks;
  }
}
function getTransitionRawChildren(children, keepComment = false, parentKey) {
  let ret = [];
  let keyedFragmentCount = 0;
  for (let i2 = 0; i2 < children.length; i2++) {
    let child = children[i2];
    const key = parentKey == null ? child.key : String(parentKey) + String(child.key != null ? child.key : i2);
    if (child.type === Fragment) {
      if (child.patchFlag & 128)
        keyedFragmentCount++;
      ret = ret.concat(getTransitionRawChildren(child.children, keepComment, key));
    } else if (keepComment || child.type !== Comment) {
      ret.push(key != null ? cloneVNode(child, { key }) : child);
    }
  }
  if (keyedFragmentCount > 1) {
    for (let i2 = 0; i2 < ret.length; i2++) {
      ret[i2].patchFlag = -2;
    }
  }
  return ret;
}
function defineComponent$1(options) {
  return isFunction$1(options) ? { setup: options, name: options.name } : options;
}
const isAsyncWrapper = (i2) => !!i2.type.__asyncLoader;
const isKeepAlive = (vnode) => vnode.type.__isKeepAlive;
function onActivated(hook, target) {
  registerKeepAliveHook(hook, "a", target);
}
function onDeactivated(hook, target) {
  registerKeepAliveHook(hook, "da", target);
}
function registerKeepAliveHook(hook, type, target = currentInstance) {
  const wrappedHook = hook.__wdc || (hook.__wdc = () => {
    let current = target;
    while (current) {
      if (current.isDeactivated) {
        return;
      }
      current = current.parent;
    }
    return hook();
  });
  injectHook(type, wrappedHook, target);
  if (target) {
    let current = target.parent;
    while (current && current.parent) {
      if (isKeepAlive(current.parent.vnode)) {
        injectToKeepAliveRoot(wrappedHook, type, target, current);
      }
      current = current.parent;
    }
  }
}
function injectToKeepAliveRoot(hook, type, target, keepAliveRoot) {
  const injected = injectHook(type, hook, keepAliveRoot, true);
  onUnmounted(() => {
    remove(keepAliveRoot[type], injected);
  }, target);
}
function injectHook(type, hook, target = currentInstance, prepend = false) {
  if (target) {
    const hooks = target[type] || (target[type] = []);
    const wrappedHook = hook.__weh || (hook.__weh = (...args) => {
      if (target.isUnmounted) {
        return;
      }
      pauseTracking();
      setCurrentInstance(target);
      const res = callWithAsyncErrorHandling(hook, target, type, args);
      unsetCurrentInstance();
      resetTracking();
      return res;
    });
    if (prepend) {
      hooks.unshift(wrappedHook);
    } else {
      hooks.push(wrappedHook);
    }
    return wrappedHook;
  }
}
const createHook = (lifecycle) => (hook, target = currentInstance) => (!isInSSRComponentSetup || lifecycle === "sp") && injectHook(lifecycle, (...args) => hook(...args), target);
const onBeforeMount = createHook("bm");
const onMounted = createHook("m");
const onBeforeUpdate = createHook("bu");
const onUpdated = createHook("u");
const onBeforeUnmount = createHook("bum");
const onUnmounted = createHook("um");
const onServerPrefetch = createHook("sp");
const onRenderTriggered = createHook("rtg");
const onRenderTracked = createHook("rtc");
function onErrorCaptured(hook, target = currentInstance) {
  injectHook("ec", hook, target);
}
function withDirectives(vnode, directives) {
  const internalInstance = currentRenderingInstance;
  if (internalInstance === null) {
    return vnode;
  }
  const instance = getExposeProxy(internalInstance) || internalInstance.proxy;
  const bindings = vnode.dirs || (vnode.dirs = []);
  for (let i2 = 0; i2 < directives.length; i2++) {
    let [dir, value, arg, modifiers = EMPTY_OBJ] = directives[i2];
    if (dir) {
      if (isFunction$1(dir)) {
        dir = {
          mounted: dir,
          updated: dir
        };
      }
      if (dir.deep) {
        traverse(value);
      }
      bindings.push({
        dir,
        instance,
        value,
        oldValue: void 0,
        arg,
        modifiers
      });
    }
  }
  return vnode;
}
function invokeDirectiveHook(vnode, prevVNode, instance, name2) {
  const bindings = vnode.dirs;
  const oldBindings = prevVNode && prevVNode.dirs;
  for (let i2 = 0; i2 < bindings.length; i2++) {
    const binding = bindings[i2];
    if (oldBindings) {
      binding.oldValue = oldBindings[i2].value;
    }
    let hook = binding.dir[name2];
    if (hook) {
      pauseTracking();
      callWithAsyncErrorHandling(hook, instance, 8, [
        vnode.el,
        binding,
        vnode,
        prevVNode
      ]);
      resetTracking();
    }
  }
}
const COMPONENTS = "components";
const DIRECTIVES = "directives";
function resolveComponent(name2, maybeSelfReference) {
  return resolveAsset(COMPONENTS, name2, true, maybeSelfReference) || name2;
}
const NULL_DYNAMIC_COMPONENT = Symbol();
function resolveDynamicComponent(component) {
  if (isString$1(component)) {
    return resolveAsset(COMPONENTS, component, false) || component;
  } else {
    return component || NULL_DYNAMIC_COMPONENT;
  }
}
function resolveDirective(name2) {
  return resolveAsset(DIRECTIVES, name2);
}
function resolveAsset(type, name2, warnMissing = true, maybeSelfReference = false) {
  const instance = currentRenderingInstance || currentInstance;
  if (instance) {
    const Component = instance.type;
    if (type === COMPONENTS) {
      const selfName = getComponentName(Component, false);
      if (selfName && (selfName === name2 || selfName === camelize(name2) || selfName === capitalize(camelize(name2)))) {
        return Component;
      }
    }
    const res = resolve(instance[type] || Component[type], name2) || resolve(instance.appContext[type], name2);
    if (!res && maybeSelfReference) {
      return Component;
    }
    return res;
  }
}
function resolve(registry, name2) {
  return registry && (registry[name2] || registry[camelize(name2)] || registry[capitalize(camelize(name2))]);
}
function renderList(source, renderItem, cache, index2) {
  let ret;
  const cached = cache && cache[index2];
  if (isArray$1(source) || isString$1(source)) {
    ret = new Array(source.length);
    for (let i2 = 0, l = source.length; i2 < l; i2++) {
      ret[i2] = renderItem(source[i2], i2, void 0, cached && cached[i2]);
    }
  } else if (typeof source === "number") {
    ret = new Array(source);
    for (let i2 = 0; i2 < source; i2++) {
      ret[i2] = renderItem(i2 + 1, i2, void 0, cached && cached[i2]);
    }
  } else if (isObject$2(source)) {
    if (source[Symbol.iterator]) {
      ret = Array.from(source, (item, i2) => renderItem(item, i2, void 0, cached && cached[i2]));
    } else {
      const keys = Object.keys(source);
      ret = new Array(keys.length);
      for (let i2 = 0, l = keys.length; i2 < l; i2++) {
        const key = keys[i2];
        ret[i2] = renderItem(source[key], key, i2, cached && cached[i2]);
      }
    }
  } else {
    ret = [];
  }
  if (cache) {
    cache[index2] = ret;
  }
  return ret;
}
function createSlots(slots, dynamicSlots) {
  for (let i2 = 0; i2 < dynamicSlots.length; i2++) {
    const slot = dynamicSlots[i2];
    if (isArray$1(slot)) {
      for (let j = 0; j < slot.length; j++) {
        slots[slot[j].name] = slot[j].fn;
      }
    } else if (slot) {
      slots[slot.name] = slot.key ? (...args) => {
        const res = slot.fn(...args);
        if (res)
          res.key = slot.key;
        return res;
      } : slot.fn;
    }
  }
  return slots;
}
function renderSlot(slots, name2, props = {}, fallback, noSlotted) {
  if (currentRenderingInstance.isCE || currentRenderingInstance.parent && isAsyncWrapper(currentRenderingInstance.parent) && currentRenderingInstance.parent.isCE) {
    if (name2 !== "default")
      props.name = name2;
    return createVNode("slot", props, fallback && fallback());
  }
  let slot = slots[name2];
  if (slot && slot._c) {
    slot._d = false;
  }
  openBlock();
  const validSlotContent = slot && ensureValidVNode(slot(props));
  const rendered = createBlock(Fragment, {
    key: props.key || validSlotContent && validSlotContent.key || `_${name2}`
  }, validSlotContent || (fallback ? fallback() : []), validSlotContent && slots._ === 1 ? 64 : -2);
  if (!noSlotted && rendered.scopeId) {
    rendered.slotScopeIds = [rendered.scopeId + "-s"];
  }
  if (slot && slot._c) {
    slot._d = true;
  }
  return rendered;
}
function ensureValidVNode(vnodes) {
  return vnodes.some((child) => {
    if (!isVNode(child))
      return true;
    if (child.type === Comment)
      return false;
    if (child.type === Fragment && !ensureValidVNode(child.children))
      return false;
    return true;
  }) ? vnodes : null;
}
function toHandlers(obj, preserveCaseIfNecessary) {
  const ret = {};
  for (const key in obj) {
    ret[preserveCaseIfNecessary && /[A-Z]/.test(key) ? `on:${key}` : toHandlerKey(key)] = obj[key];
  }
  return ret;
}
const getPublicInstance = (i2) => {
  if (!i2)
    return null;
  if (isStatefulComponent(i2))
    return getExposeProxy(i2) || i2.proxy;
  return getPublicInstance(i2.parent);
};
const publicPropertiesMap = /* @__PURE__ */ extend$1(/* @__PURE__ */ Object.create(null), {
  $: (i2) => i2,
  $el: (i2) => i2.vnode.el,
  $data: (i2) => i2.data,
  $props: (i2) => i2.props,
  $attrs: (i2) => i2.attrs,
  $slots: (i2) => i2.slots,
  $refs: (i2) => i2.refs,
  $parent: (i2) => getPublicInstance(i2.parent),
  $root: (i2) => getPublicInstance(i2.root),
  $emit: (i2) => i2.emit,
  $options: (i2) => resolveMergedOptions(i2),
  $forceUpdate: (i2) => i2.f || (i2.f = () => queueJob(i2.update)),
  $nextTick: (i2) => i2.n || (i2.n = nextTick.bind(i2.proxy)),
  $watch: (i2) => instanceWatch.bind(i2)
});
const hasSetupBinding = (state, key) => state !== EMPTY_OBJ && !state.__isScriptSetup && hasOwn(state, key);
const PublicInstanceProxyHandlers = {
  get({ _: instance }, key) {
    const { ctx, setupState, data, props, accessCache, type, appContext } = instance;
    let normalizedProps;
    if (key[0] !== "$") {
      const n2 = accessCache[key];
      if (n2 !== void 0) {
        switch (n2) {
          case 1:
            return setupState[key];
          case 2:
            return data[key];
          case 4:
            return ctx[key];
          case 3:
            return props[key];
        }
      } else if (hasSetupBinding(setupState, key)) {
        accessCache[key] = 1;
        return setupState[key];
      } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
        accessCache[key] = 2;
        return data[key];
      } else if ((normalizedProps = instance.propsOptions[0]) && hasOwn(normalizedProps, key)) {
        accessCache[key] = 3;
        return props[key];
      } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
        accessCache[key] = 4;
        return ctx[key];
      } else if (shouldCacheAccess) {
        accessCache[key] = 0;
      }
    }
    const publicGetter = publicPropertiesMap[key];
    let cssModule, globalProperties;
    if (publicGetter) {
      if (key === "$attrs") {
        track(instance, "get", key);
      }
      return publicGetter(instance);
    } else if ((cssModule = type.__cssModules) && (cssModule = cssModule[key])) {
      return cssModule;
    } else if (ctx !== EMPTY_OBJ && hasOwn(ctx, key)) {
      accessCache[key] = 4;
      return ctx[key];
    } else if (globalProperties = appContext.config.globalProperties, hasOwn(globalProperties, key)) {
      {
        return globalProperties[key];
      }
    } else
      ;
  },
  set({ _: instance }, key, value) {
    const { data, setupState, ctx } = instance;
    if (hasSetupBinding(setupState, key)) {
      setupState[key] = value;
      return true;
    } else if (data !== EMPTY_OBJ && hasOwn(data, key)) {
      data[key] = value;
      return true;
    } else if (hasOwn(instance.props, key)) {
      return false;
    }
    if (key[0] === "$" && key.slice(1) in instance) {
      return false;
    } else {
      {
        ctx[key] = value;
      }
    }
    return true;
  },
  has({ _: { data, setupState, accessCache, ctx, appContext, propsOptions } }, key) {
    let normalizedProps;
    return !!accessCache[key] || data !== EMPTY_OBJ && hasOwn(data, key) || hasSetupBinding(setupState, key) || (normalizedProps = propsOptions[0]) && hasOwn(normalizedProps, key) || hasOwn(ctx, key) || hasOwn(publicPropertiesMap, key) || hasOwn(appContext.config.globalProperties, key);
  },
  defineProperty(target, key, descriptor) {
    if (descriptor.get != null) {
      target._.accessCache[key] = 0;
    } else if (hasOwn(descriptor, "value")) {
      this.set(target, key, descriptor.value, null);
    }
    return Reflect.defineProperty(target, key, descriptor);
  }
};
let shouldCacheAccess = true;
function applyOptions(instance) {
  const options = resolveMergedOptions(instance);
  const publicThis = instance.proxy;
  const ctx = instance.ctx;
  shouldCacheAccess = false;
  if (options.beforeCreate) {
    callHook$1(options.beforeCreate, instance, "bc");
  }
  const {
    data: dataOptions,
    computed: computedOptions,
    methods,
    watch: watchOptions,
    provide: provideOptions,
    inject: injectOptions,
    created,
    beforeMount,
    mounted: mounted2,
    beforeUpdate,
    updated: updated2,
    activated,
    deactivated,
    beforeDestroy,
    beforeUnmount,
    destroyed,
    unmounted: unmounted2,
    render,
    renderTracked,
    renderTriggered,
    errorCaptured,
    serverPrefetch,
    expose,
    inheritAttrs,
    components,
    directives,
    filters
  } = options;
  const checkDuplicateProperties = null;
  if (injectOptions) {
    resolveInjections(injectOptions, ctx, checkDuplicateProperties, instance.appContext.config.unwrapInjectedRef);
  }
  if (methods) {
    for (const key in methods) {
      const methodHandler = methods[key];
      if (isFunction$1(methodHandler)) {
        {
          ctx[key] = methodHandler.bind(publicThis);
        }
      }
    }
  }
  if (dataOptions) {
    const data = dataOptions.call(publicThis, publicThis);
    if (!isObject$2(data))
      ;
    else {
      instance.data = reactive(data);
    }
  }
  shouldCacheAccess = true;
  if (computedOptions) {
    for (const key in computedOptions) {
      const opt = computedOptions[key];
      const get2 = isFunction$1(opt) ? opt.bind(publicThis, publicThis) : isFunction$1(opt.get) ? opt.get.bind(publicThis, publicThis) : NOOP;
      const set2 = !isFunction$1(opt) && isFunction$1(opt.set) ? opt.set.bind(publicThis) : NOOP;
      const c2 = computed({
        get: get2,
        set: set2
      });
      Object.defineProperty(ctx, key, {
        enumerable: true,
        configurable: true,
        get: () => c2.value,
        set: (v) => c2.value = v
      });
    }
  }
  if (watchOptions) {
    for (const key in watchOptions) {
      createWatcher(watchOptions[key], ctx, publicThis, key);
    }
  }
  if (provideOptions) {
    const provides = isFunction$1(provideOptions) ? provideOptions.call(publicThis) : provideOptions;
    Reflect.ownKeys(provides).forEach((key) => {
      provide(key, provides[key]);
    });
  }
  if (created) {
    callHook$1(created, instance, "c");
  }
  function registerLifecycleHook(register, hook) {
    if (isArray$1(hook)) {
      hook.forEach((_hook) => register(_hook.bind(publicThis)));
    } else if (hook) {
      register(hook.bind(publicThis));
    }
  }
  registerLifecycleHook(onBeforeMount, beforeMount);
  registerLifecycleHook(onMounted, mounted2);
  registerLifecycleHook(onBeforeUpdate, beforeUpdate);
  registerLifecycleHook(onUpdated, updated2);
  registerLifecycleHook(onActivated, activated);
  registerLifecycleHook(onDeactivated, deactivated);
  registerLifecycleHook(onErrorCaptured, errorCaptured);
  registerLifecycleHook(onRenderTracked, renderTracked);
  registerLifecycleHook(onRenderTriggered, renderTriggered);
  registerLifecycleHook(onBeforeUnmount, beforeUnmount);
  registerLifecycleHook(onUnmounted, unmounted2);
  registerLifecycleHook(onServerPrefetch, serverPrefetch);
  if (isArray$1(expose)) {
    if (expose.length) {
      const exposed = instance.exposed || (instance.exposed = {});
      expose.forEach((key) => {
        Object.defineProperty(exposed, key, {
          get: () => publicThis[key],
          set: (val) => publicThis[key] = val
        });
      });
    } else if (!instance.exposed) {
      instance.exposed = {};
    }
  }
  if (render && instance.render === NOOP) {
    instance.render = render;
  }
  if (inheritAttrs != null) {
    instance.inheritAttrs = inheritAttrs;
  }
  if (components)
    instance.components = components;
  if (directives)
    instance.directives = directives;
}
function resolveInjections(injectOptions, ctx, checkDuplicateProperties = NOOP, unwrapRef = false) {
  if (isArray$1(injectOptions)) {
    injectOptions = normalizeInject(injectOptions);
  }
  for (const key in injectOptions) {
    const opt = injectOptions[key];
    let injected;
    if (isObject$2(opt)) {
      if ("default" in opt) {
        injected = inject$1(opt.from || key, opt.default, true);
      } else {
        injected = inject$1(opt.from || key);
      }
    } else {
      injected = inject$1(opt);
    }
    if (isRef(injected)) {
      if (unwrapRef) {
        Object.defineProperty(ctx, key, {
          enumerable: true,
          configurable: true,
          get: () => injected.value,
          set: (v) => injected.value = v
        });
      } else {
        ctx[key] = injected;
      }
    } else {
      ctx[key] = injected;
    }
  }
}
function callHook$1(hook, instance, type) {
  callWithAsyncErrorHandling(isArray$1(hook) ? hook.map((h4) => h4.bind(instance.proxy)) : hook.bind(instance.proxy), instance, type);
}
function createWatcher(raw, ctx, publicThis, key) {
  const getter = key.includes(".") ? createPathGetter(publicThis, key) : () => publicThis[key];
  if (isString$1(raw)) {
    const handler = ctx[raw];
    if (isFunction$1(handler)) {
      watch(getter, handler);
    }
  } else if (isFunction$1(raw)) {
    watch(getter, raw.bind(publicThis));
  } else if (isObject$2(raw)) {
    if (isArray$1(raw)) {
      raw.forEach((r2) => createWatcher(r2, ctx, publicThis, key));
    } else {
      const handler = isFunction$1(raw.handler) ? raw.handler.bind(publicThis) : ctx[raw.handler];
      if (isFunction$1(handler)) {
        watch(getter, handler, raw);
      }
    }
  } else
    ;
}
function resolveMergedOptions(instance) {
  const base = instance.type;
  const { mixins, extends: extendsOptions } = base;
  const { mixins: globalMixins, optionsCache: cache, config: { optionMergeStrategies } } = instance.appContext;
  const cached = cache.get(base);
  let resolved;
  if (cached) {
    resolved = cached;
  } else if (!globalMixins.length && !mixins && !extendsOptions) {
    {
      resolved = base;
    }
  } else {
    resolved = {};
    if (globalMixins.length) {
      globalMixins.forEach((m3) => mergeOptions(resolved, m3, optionMergeStrategies, true));
    }
    mergeOptions(resolved, base, optionMergeStrategies);
  }
  if (isObject$2(base)) {
    cache.set(base, resolved);
  }
  return resolved;
}
function mergeOptions(to, from, strats, asMixin = false) {
  const { mixins, extends: extendsOptions } = from;
  if (extendsOptions) {
    mergeOptions(to, extendsOptions, strats, true);
  }
  if (mixins) {
    mixins.forEach((m3) => mergeOptions(to, m3, strats, true));
  }
  for (const key in from) {
    if (asMixin && key === "expose")
      ;
    else {
      const strat = internalOptionMergeStrats[key] || strats && strats[key];
      to[key] = strat ? strat(to[key], from[key]) : from[key];
    }
  }
  return to;
}
const internalOptionMergeStrats = {
  data: mergeDataFn,
  props: mergeObjectOptions,
  emits: mergeObjectOptions,
  methods: mergeObjectOptions,
  computed: mergeObjectOptions,
  beforeCreate: mergeAsArray,
  created: mergeAsArray,
  beforeMount: mergeAsArray,
  mounted: mergeAsArray,
  beforeUpdate: mergeAsArray,
  updated: mergeAsArray,
  beforeDestroy: mergeAsArray,
  beforeUnmount: mergeAsArray,
  destroyed: mergeAsArray,
  unmounted: mergeAsArray,
  activated: mergeAsArray,
  deactivated: mergeAsArray,
  errorCaptured: mergeAsArray,
  serverPrefetch: mergeAsArray,
  components: mergeObjectOptions,
  directives: mergeObjectOptions,
  watch: mergeWatchOptions,
  provide: mergeDataFn,
  inject: mergeInject
};
function mergeDataFn(to, from) {
  if (!from) {
    return to;
  }
  if (!to) {
    return from;
  }
  return function mergedDataFn() {
    return extend$1(isFunction$1(to) ? to.call(this, this) : to, isFunction$1(from) ? from.call(this, this) : from);
  };
}
function mergeInject(to, from) {
  return mergeObjectOptions(normalizeInject(to), normalizeInject(from));
}
function normalizeInject(raw) {
  if (isArray$1(raw)) {
    const res = {};
    for (let i2 = 0; i2 < raw.length; i2++) {
      res[raw[i2]] = raw[i2];
    }
    return res;
  }
  return raw;
}
function mergeAsArray(to, from) {
  return to ? [...new Set([].concat(to, from))] : from;
}
function mergeObjectOptions(to, from) {
  return to ? extend$1(extend$1(/* @__PURE__ */ Object.create(null), to), from) : from;
}
function mergeWatchOptions(to, from) {
  if (!to)
    return from;
  if (!from)
    return to;
  const merged = extend$1(/* @__PURE__ */ Object.create(null), to);
  for (const key in from) {
    merged[key] = mergeAsArray(to[key], from[key]);
  }
  return merged;
}
function initProps(instance, rawProps, isStateful, isSSR = false) {
  const props = {};
  const attrs = {};
  def(attrs, InternalObjectKey, 1);
  instance.propsDefaults = /* @__PURE__ */ Object.create(null);
  setFullProps(instance, rawProps, props, attrs);
  for (const key in instance.propsOptions[0]) {
    if (!(key in props)) {
      props[key] = void 0;
    }
  }
  if (isStateful) {
    instance.props = isSSR ? props : shallowReactive(props);
  } else {
    if (!instance.type.props) {
      instance.props = attrs;
    } else {
      instance.props = props;
    }
  }
  instance.attrs = attrs;
}
function updateProps(instance, rawProps, rawPrevProps, optimized) {
  const { props, attrs, vnode: { patchFlag } } = instance;
  const rawCurrentProps = toRaw(props);
  const [options] = instance.propsOptions;
  let hasAttrsChanged = false;
  if ((optimized || patchFlag > 0) && !(patchFlag & 16)) {
    if (patchFlag & 8) {
      const propsToUpdate = instance.vnode.dynamicProps;
      for (let i2 = 0; i2 < propsToUpdate.length; i2++) {
        let key = propsToUpdate[i2];
        if (isEmitListener(instance.emitsOptions, key)) {
          continue;
        }
        const value = rawProps[key];
        if (options) {
          if (hasOwn(attrs, key)) {
            if (value !== attrs[key]) {
              attrs[key] = value;
              hasAttrsChanged = true;
            }
          } else {
            const camelizedKey = camelize(key);
            props[camelizedKey] = resolvePropValue(options, rawCurrentProps, camelizedKey, value, instance, false);
          }
        } else {
          if (value !== attrs[key]) {
            attrs[key] = value;
            hasAttrsChanged = true;
          }
        }
      }
    }
  } else {
    if (setFullProps(instance, rawProps, props, attrs)) {
      hasAttrsChanged = true;
    }
    let kebabKey;
    for (const key in rawCurrentProps) {
      if (!rawProps || !hasOwn(rawProps, key) && ((kebabKey = hyphenate(key)) === key || !hasOwn(rawProps, kebabKey))) {
        if (options) {
          if (rawPrevProps && (rawPrevProps[key] !== void 0 || rawPrevProps[kebabKey] !== void 0)) {
            props[key] = resolvePropValue(options, rawCurrentProps, key, void 0, instance, true);
          }
        } else {
          delete props[key];
        }
      }
    }
    if (attrs !== rawCurrentProps) {
      for (const key in attrs) {
        if (!rawProps || !hasOwn(rawProps, key) && true) {
          delete attrs[key];
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (hasAttrsChanged) {
    trigger(instance, "set", "$attrs");
  }
}
function setFullProps(instance, rawProps, props, attrs) {
  const [options, needCastKeys] = instance.propsOptions;
  let hasAttrsChanged = false;
  let rawCastValues;
  if (rawProps) {
    for (let key in rawProps) {
      if (isReservedProp(key)) {
        continue;
      }
      const value = rawProps[key];
      let camelKey;
      if (options && hasOwn(options, camelKey = camelize(key))) {
        if (!needCastKeys || !needCastKeys.includes(camelKey)) {
          props[camelKey] = value;
        } else {
          (rawCastValues || (rawCastValues = {}))[camelKey] = value;
        }
      } else if (!isEmitListener(instance.emitsOptions, key)) {
        if (!(key in attrs) || value !== attrs[key]) {
          attrs[key] = value;
          hasAttrsChanged = true;
        }
      }
    }
  }
  if (needCastKeys) {
    const rawCurrentProps = toRaw(props);
    const castValues = rawCastValues || EMPTY_OBJ;
    for (let i2 = 0; i2 < needCastKeys.length; i2++) {
      const key = needCastKeys[i2];
      props[key] = resolvePropValue(options, rawCurrentProps, key, castValues[key], instance, !hasOwn(castValues, key));
    }
  }
  return hasAttrsChanged;
}
function resolvePropValue(options, props, key, value, instance, isAbsent) {
  const opt = options[key];
  if (opt != null) {
    const hasDefault = hasOwn(opt, "default");
    if (hasDefault && value === void 0) {
      const defaultValue = opt.default;
      if (opt.type !== Function && isFunction$1(defaultValue)) {
        const { propsDefaults } = instance;
        if (key in propsDefaults) {
          value = propsDefaults[key];
        } else {
          setCurrentInstance(instance);
          value = propsDefaults[key] = defaultValue.call(null, props);
          unsetCurrentInstance();
        }
      } else {
        value = defaultValue;
      }
    }
    if (opt[0]) {
      if (isAbsent && !hasDefault) {
        value = false;
      } else if (opt[1] && (value === "" || value === hyphenate(key))) {
        value = true;
      }
    }
  }
  return value;
}
function normalizePropsOptions(comp, appContext, asMixin = false) {
  const cache = appContext.propsCache;
  const cached = cache.get(comp);
  if (cached) {
    return cached;
  }
  const raw = comp.props;
  const normalized = {};
  const needCastKeys = [];
  let hasExtends = false;
  if (!isFunction$1(comp)) {
    const extendProps = (raw2) => {
      hasExtends = true;
      const [props, keys] = normalizePropsOptions(raw2, appContext, true);
      extend$1(normalized, props);
      if (keys)
        needCastKeys.push(...keys);
    };
    if (!asMixin && appContext.mixins.length) {
      appContext.mixins.forEach(extendProps);
    }
    if (comp.extends) {
      extendProps(comp.extends);
    }
    if (comp.mixins) {
      comp.mixins.forEach(extendProps);
    }
  }
  if (!raw && !hasExtends) {
    if (isObject$2(comp)) {
      cache.set(comp, EMPTY_ARR);
    }
    return EMPTY_ARR;
  }
  if (isArray$1(raw)) {
    for (let i2 = 0; i2 < raw.length; i2++) {
      const normalizedKey = camelize(raw[i2]);
      if (validatePropName(normalizedKey)) {
        normalized[normalizedKey] = EMPTY_OBJ;
      }
    }
  } else if (raw) {
    for (const key in raw) {
      const normalizedKey = camelize(key);
      if (validatePropName(normalizedKey)) {
        const opt = raw[key];
        const prop = normalized[normalizedKey] = isArray$1(opt) || isFunction$1(opt) ? { type: opt } : Object.assign({}, opt);
        if (prop) {
          const booleanIndex = getTypeIndex(Boolean, prop.type);
          const stringIndex = getTypeIndex(String, prop.type);
          prop[0] = booleanIndex > -1;
          prop[1] = stringIndex < 0 || booleanIndex < stringIndex;
          if (booleanIndex > -1 || hasOwn(prop, "default")) {
            needCastKeys.push(normalizedKey);
          }
        }
      }
    }
  }
  const res = [normalized, needCastKeys];
  if (isObject$2(comp)) {
    cache.set(comp, res);
  }
  return res;
}
function validatePropName(key) {
  if (key[0] !== "$") {
    return true;
  }
  return false;
}
function getType(ctor) {
  const match2 = ctor && ctor.toString().match(/^\s*(function|class) (\w+)/);
  return match2 ? match2[2] : ctor === null ? "null" : "";
}
function isSameType(a3, b3) {
  return getType(a3) === getType(b3);
}
function getTypeIndex(type, expectedTypes) {
  if (isArray$1(expectedTypes)) {
    return expectedTypes.findIndex((t3) => isSameType(t3, type));
  } else if (isFunction$1(expectedTypes)) {
    return isSameType(expectedTypes, type) ? 0 : -1;
  }
  return -1;
}
const isInternalKey = (key) => key[0] === "_" || key === "$stable";
const normalizeSlotValue = (value) => isArray$1(value) ? value.map(normalizeVNode) : [normalizeVNode(value)];
const normalizeSlot = (key, rawSlot, ctx) => {
  if (rawSlot._n) {
    return rawSlot;
  }
  const normalized = withCtx((...args) => {
    if (false)
      ;
    return normalizeSlotValue(rawSlot(...args));
  }, ctx);
  normalized._c = false;
  return normalized;
};
const normalizeObjectSlots = (rawSlots, slots, instance) => {
  const ctx = rawSlots._ctx;
  for (const key in rawSlots) {
    if (isInternalKey(key))
      continue;
    const value = rawSlots[key];
    if (isFunction$1(value)) {
      slots[key] = normalizeSlot(key, value, ctx);
    } else if (value != null) {
      const normalized = normalizeSlotValue(value);
      slots[key] = () => normalized;
    }
  }
};
const normalizeVNodeSlots = (instance, children) => {
  const normalized = normalizeSlotValue(children);
  instance.slots.default = () => normalized;
};
const initSlots = (instance, children) => {
  if (instance.vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      instance.slots = toRaw(children);
      def(children, "_", type);
    } else {
      normalizeObjectSlots(children, instance.slots = {});
    }
  } else {
    instance.slots = {};
    if (children) {
      normalizeVNodeSlots(instance, children);
    }
  }
  def(instance.slots, InternalObjectKey, 1);
};
const updateSlots = (instance, children, optimized) => {
  const { vnode, slots } = instance;
  let needDeletionCheck = true;
  let deletionComparisonTarget = EMPTY_OBJ;
  if (vnode.shapeFlag & 32) {
    const type = children._;
    if (type) {
      if (optimized && type === 1) {
        needDeletionCheck = false;
      } else {
        extend$1(slots, children);
        if (!optimized && type === 1) {
          delete slots._;
        }
      }
    } else {
      needDeletionCheck = !children.$stable;
      normalizeObjectSlots(children, slots);
    }
    deletionComparisonTarget = children;
  } else if (children) {
    normalizeVNodeSlots(instance, children);
    deletionComparisonTarget = { default: 1 };
  }
  if (needDeletionCheck) {
    for (const key in slots) {
      if (!isInternalKey(key) && !(key in deletionComparisonTarget)) {
        delete slots[key];
      }
    }
  }
};
function createAppContext() {
  return {
    app: null,
    config: {
      isNativeTag: NO,
      performance: false,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: /* @__PURE__ */ Object.create(null),
    optionsCache: /* @__PURE__ */ new WeakMap(),
    propsCache: /* @__PURE__ */ new WeakMap(),
    emitsCache: /* @__PURE__ */ new WeakMap()
  };
}
let uid$1 = 0;
function createAppAPI(render, hydrate) {
  return function createApp2(rootComponent, rootProps = null) {
    if (!isFunction$1(rootComponent)) {
      rootComponent = Object.assign({}, rootComponent);
    }
    if (rootProps != null && !isObject$2(rootProps)) {
      rootProps = null;
    }
    const context = createAppContext();
    const installedPlugins = /* @__PURE__ */ new Set();
    let isMounted = false;
    const app2 = context.app = {
      _uid: uid$1++,
      _component: rootComponent,
      _props: rootProps,
      _container: null,
      _context: context,
      _instance: null,
      version: version$4,
      get config() {
        return context.config;
      },
      set config(v) {
      },
      use(plugin2, ...options) {
        if (installedPlugins.has(plugin2))
          ;
        else if (plugin2 && isFunction$1(plugin2.install)) {
          installedPlugins.add(plugin2);
          plugin2.install(app2, ...options);
        } else if (isFunction$1(plugin2)) {
          installedPlugins.add(plugin2);
          plugin2(app2, ...options);
        } else
          ;
        return app2;
      },
      mixin(mixin) {
        {
          if (!context.mixins.includes(mixin)) {
            context.mixins.push(mixin);
          }
        }
        return app2;
      },
      component(name2, component) {
        if (!component) {
          return context.components[name2];
        }
        context.components[name2] = component;
        return app2;
      },
      directive(name2, directive2) {
        if (!directive2) {
          return context.directives[name2];
        }
        context.directives[name2] = directive2;
        return app2;
      },
      mount(rootContainer, isHydrate, isSVG) {
        if (!isMounted) {
          const vnode = createVNode(rootComponent, rootProps);
          vnode.appContext = context;
          if (isHydrate && hydrate) {
            hydrate(vnode, rootContainer);
          } else {
            render(vnode, rootContainer, isSVG);
          }
          isMounted = true;
          app2._container = rootContainer;
          rootContainer.__vue_app__ = app2;
          return getExposeProxy(vnode.component) || vnode.component.proxy;
        }
      },
      unmount() {
        if (isMounted) {
          render(null, app2._container);
          delete app2._container.__vue_app__;
        }
      },
      provide(key, value) {
        context.provides[key] = value;
        return app2;
      }
    };
    return app2;
  };
}
function setRef(rawRef, oldRawRef, parentSuspense, vnode, isUnmount = false) {
  if (isArray$1(rawRef)) {
    rawRef.forEach((r2, i2) => setRef(r2, oldRawRef && (isArray$1(oldRawRef) ? oldRawRef[i2] : oldRawRef), parentSuspense, vnode, isUnmount));
    return;
  }
  if (isAsyncWrapper(vnode) && !isUnmount) {
    return;
  }
  const refValue = vnode.shapeFlag & 4 ? getExposeProxy(vnode.component) || vnode.component.proxy : vnode.el;
  const value = isUnmount ? null : refValue;
  const { i: owner, r: ref2 } = rawRef;
  const oldRef = oldRawRef && oldRawRef.r;
  const refs = owner.refs === EMPTY_OBJ ? owner.refs = {} : owner.refs;
  const setupState = owner.setupState;
  if (oldRef != null && oldRef !== ref2) {
    if (isString$1(oldRef)) {
      refs[oldRef] = null;
      if (hasOwn(setupState, oldRef)) {
        setupState[oldRef] = null;
      }
    } else if (isRef(oldRef)) {
      oldRef.value = null;
    }
  }
  if (isFunction$1(ref2)) {
    callWithErrorHandling(ref2, owner, 12, [value, refs]);
  } else {
    const _isString = isString$1(ref2);
    const _isRef = isRef(ref2);
    if (_isString || _isRef) {
      const doSet = () => {
        if (rawRef.f) {
          const existing = _isString ? hasOwn(setupState, ref2) ? setupState[ref2] : refs[ref2] : ref2.value;
          if (isUnmount) {
            isArray$1(existing) && remove(existing, refValue);
          } else {
            if (!isArray$1(existing)) {
              if (_isString) {
                refs[ref2] = [refValue];
                if (hasOwn(setupState, ref2)) {
                  setupState[ref2] = refs[ref2];
                }
              } else {
                ref2.value = [refValue];
                if (rawRef.k)
                  refs[rawRef.k] = ref2.value;
              }
            } else if (!existing.includes(refValue)) {
              existing.push(refValue);
            }
          }
        } else if (_isString) {
          refs[ref2] = value;
          if (hasOwn(setupState, ref2)) {
            setupState[ref2] = value;
          }
        } else if (_isRef) {
          ref2.value = value;
          if (rawRef.k)
            refs[rawRef.k] = value;
        } else
          ;
      };
      if (value) {
        doSet.id = -1;
        queuePostRenderEffect(doSet, parentSuspense);
      } else {
        doSet();
      }
    }
  }
}
const queuePostRenderEffect = queueEffectWithSuspense;
function createRenderer(options) {
  return baseCreateRenderer(options);
}
function baseCreateRenderer(options, createHydrationFns) {
  const target = getGlobalThis();
  target.__VUE__ = true;
  const { insert: hostInsert, remove: hostRemove, patchProp: hostPatchProp, createElement: hostCreateElement, createText: hostCreateText, createComment: hostCreateComment, setText: hostSetText, setElementText: hostSetElementText, parentNode: hostParentNode, nextSibling: hostNextSibling, setScopeId: hostSetScopeId = NOOP, insertStaticContent: hostInsertStaticContent } = options;
  const patch = (n1, n2, container, anchor = null, parentComponent = null, parentSuspense = null, isSVG = false, slotScopeIds = null, optimized = !!n2.dynamicChildren) => {
    if (n1 === n2) {
      return;
    }
    if (n1 && !isSameVNodeType(n1, n2)) {
      anchor = getNextHostNode(n1);
      unmount(n1, parentComponent, parentSuspense, true);
      n1 = null;
    }
    if (n2.patchFlag === -2) {
      optimized = false;
      n2.dynamicChildren = null;
    }
    const { type, ref: ref2, shapeFlag } = n2;
    switch (type) {
      case Text:
        processText(n1, n2, container, anchor);
        break;
      case Comment:
        processCommentNode(n1, n2, container, anchor);
        break;
      case Static:
        if (n1 == null) {
          mountStaticNode(n2, container, anchor, isSVG);
        }
        break;
      case Fragment:
        processFragment(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        break;
      default:
        if (shapeFlag & 1) {
          processElement(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else if (shapeFlag & 6) {
          processComponent(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else if (shapeFlag & 64) {
          type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
        } else if (shapeFlag & 128) {
          type.process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals);
        } else
          ;
    }
    if (ref2 != null && parentComponent) {
      setRef(ref2, n1 && n1.ref, parentSuspense, n2 || n1, !n2);
    }
  };
  const processText = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(n2.el = hostCreateText(n2.children), container, anchor);
    } else {
      const el2 = n2.el = n1.el;
      if (n2.children !== n1.children) {
        hostSetText(el2, n2.children);
      }
    }
  };
  const processCommentNode = (n1, n2, container, anchor) => {
    if (n1 == null) {
      hostInsert(n2.el = hostCreateComment(n2.children || ""), container, anchor);
    } else {
      n2.el = n1.el;
    }
  };
  const mountStaticNode = (n2, container, anchor, isSVG) => {
    [n2.el, n2.anchor] = hostInsertStaticContent(n2.children, container, anchor, isSVG, n2.el, n2.anchor);
  };
  const moveStaticNode = ({ el: el2, anchor }, container, nextSibling) => {
    let next;
    while (el2 && el2 !== anchor) {
      next = hostNextSibling(el2);
      hostInsert(el2, container, nextSibling);
      el2 = next;
    }
    hostInsert(anchor, container, nextSibling);
  };
  const removeStaticNode = ({ el: el2, anchor }) => {
    let next;
    while (el2 && el2 !== anchor) {
      next = hostNextSibling(el2);
      hostRemove(el2);
      el2 = next;
    }
    hostRemove(anchor);
  };
  const processElement = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    isSVG = isSVG || n2.type === "svg";
    if (n1 == null) {
      mountElement(n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    } else {
      patchElement(n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    }
  };
  const mountElement = (vnode, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    let el2;
    let vnodeHook;
    const { type, props, shapeFlag, transition, dirs } = vnode;
    el2 = vnode.el = hostCreateElement(vnode.type, isSVG, props && props.is, props);
    if (shapeFlag & 8) {
      hostSetElementText(el2, vnode.children);
    } else if (shapeFlag & 16) {
      mountChildren(vnode.children, el2, null, parentComponent, parentSuspense, isSVG && type !== "foreignObject", slotScopeIds, optimized);
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "created");
    }
    setScopeId(el2, vnode, vnode.scopeId, slotScopeIds, parentComponent);
    if (props) {
      for (const key in props) {
        if (key !== "value" && !isReservedProp(key)) {
          hostPatchProp(el2, key, null, props[key], isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
        }
      }
      if ("value" in props) {
        hostPatchProp(el2, "value", null, props.value);
      }
      if (vnodeHook = props.onVnodeBeforeMount) {
        invokeVNodeHook(vnodeHook, parentComponent, vnode);
      }
    }
    if (dirs) {
      invokeDirectiveHook(vnode, null, parentComponent, "beforeMount");
    }
    const needCallTransitionHooks = (!parentSuspense || parentSuspense && !parentSuspense.pendingBranch) && transition && !transition.persisted;
    if (needCallTransitionHooks) {
      transition.beforeEnter(el2);
    }
    hostInsert(el2, container, anchor);
    if ((vnodeHook = props && props.onVnodeMounted) || needCallTransitionHooks || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        needCallTransitionHooks && transition.enter(el2);
        dirs && invokeDirectiveHook(vnode, null, parentComponent, "mounted");
      }, parentSuspense);
    }
  };
  const setScopeId = (el2, vnode, scopeId, slotScopeIds, parentComponent) => {
    if (scopeId) {
      hostSetScopeId(el2, scopeId);
    }
    if (slotScopeIds) {
      for (let i2 = 0; i2 < slotScopeIds.length; i2++) {
        hostSetScopeId(el2, slotScopeIds[i2]);
      }
    }
    if (parentComponent) {
      let subTree = parentComponent.subTree;
      if (vnode === subTree) {
        const parentVNode = parentComponent.vnode;
        setScopeId(el2, parentVNode, parentVNode.scopeId, parentVNode.slotScopeIds, parentComponent.parent);
      }
    }
  };
  const mountChildren = (children, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, start = 0) => {
    for (let i2 = start; i2 < children.length; i2++) {
      const child = children[i2] = optimized ? cloneIfMounted(children[i2]) : normalizeVNode(children[i2]);
      patch(null, child, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    }
  };
  const patchElement = (n1, n2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    const el2 = n2.el = n1.el;
    let { patchFlag, dynamicChildren, dirs } = n2;
    patchFlag |= n1.patchFlag & 16;
    const oldProps = n1.props || EMPTY_OBJ;
    const newProps = n2.props || EMPTY_OBJ;
    let vnodeHook;
    parentComponent && toggleRecurse(parentComponent, false);
    if (vnodeHook = newProps.onVnodeBeforeUpdate) {
      invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
    }
    if (dirs) {
      invokeDirectiveHook(n2, n1, parentComponent, "beforeUpdate");
    }
    parentComponent && toggleRecurse(parentComponent, true);
    const areChildrenSVG = isSVG && n2.type !== "foreignObject";
    if (dynamicChildren) {
      patchBlockChildren(n1.dynamicChildren, dynamicChildren, el2, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds);
    } else if (!optimized) {
      patchChildren(n1, n2, el2, null, parentComponent, parentSuspense, areChildrenSVG, slotScopeIds, false);
    }
    if (patchFlag > 0) {
      if (patchFlag & 16) {
        patchProps(el2, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
      } else {
        if (patchFlag & 2) {
          if (oldProps.class !== newProps.class) {
            hostPatchProp(el2, "class", null, newProps.class, isSVG);
          }
        }
        if (patchFlag & 4) {
          hostPatchProp(el2, "style", oldProps.style, newProps.style, isSVG);
        }
        if (patchFlag & 8) {
          const propsToUpdate = n2.dynamicProps;
          for (let i2 = 0; i2 < propsToUpdate.length; i2++) {
            const key = propsToUpdate[i2];
            const prev = oldProps[key];
            const next = newProps[key];
            if (next !== prev || key === "value") {
              hostPatchProp(el2, key, prev, next, isSVG, n1.children, parentComponent, parentSuspense, unmountChildren);
            }
          }
        }
      }
      if (patchFlag & 1) {
        if (n1.children !== n2.children) {
          hostSetElementText(el2, n2.children);
        }
      }
    } else if (!optimized && dynamicChildren == null) {
      patchProps(el2, n2, oldProps, newProps, parentComponent, parentSuspense, isSVG);
    }
    if ((vnodeHook = newProps.onVnodeUpdated) || dirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, n2, n1);
        dirs && invokeDirectiveHook(n2, n1, parentComponent, "updated");
      }, parentSuspense);
    }
  };
  const patchBlockChildren = (oldChildren, newChildren, fallbackContainer, parentComponent, parentSuspense, isSVG, slotScopeIds) => {
    for (let i2 = 0; i2 < newChildren.length; i2++) {
      const oldVNode = oldChildren[i2];
      const newVNode = newChildren[i2];
      const container = oldVNode.el && (oldVNode.type === Fragment || !isSameVNodeType(oldVNode, newVNode) || oldVNode.shapeFlag & (6 | 64)) ? hostParentNode(oldVNode.el) : fallbackContainer;
      patch(oldVNode, newVNode, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, true);
    }
  };
  const patchProps = (el2, vnode, oldProps, newProps, parentComponent, parentSuspense, isSVG) => {
    if (oldProps !== newProps) {
      if (oldProps !== EMPTY_OBJ) {
        for (const key in oldProps) {
          if (!isReservedProp(key) && !(key in newProps)) {
            hostPatchProp(el2, key, oldProps[key], null, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
          }
        }
      }
      for (const key in newProps) {
        if (isReservedProp(key))
          continue;
        const next = newProps[key];
        const prev = oldProps[key];
        if (next !== prev && key !== "value") {
          hostPatchProp(el2, key, prev, next, isSVG, vnode.children, parentComponent, parentSuspense, unmountChildren);
        }
      }
      if ("value" in newProps) {
        hostPatchProp(el2, "value", oldProps.value, newProps.value);
      }
    }
  };
  const processFragment = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    const fragmentStartAnchor = n2.el = n1 ? n1.el : hostCreateText("");
    const fragmentEndAnchor = n2.anchor = n1 ? n1.anchor : hostCreateText("");
    let { patchFlag, dynamicChildren, slotScopeIds: fragmentSlotScopeIds } = n2;
    if (fragmentSlotScopeIds) {
      slotScopeIds = slotScopeIds ? slotScopeIds.concat(fragmentSlotScopeIds) : fragmentSlotScopeIds;
    }
    if (n1 == null) {
      hostInsert(fragmentStartAnchor, container, anchor);
      hostInsert(fragmentEndAnchor, container, anchor);
      mountChildren(n2.children, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    } else {
      if (patchFlag > 0 && patchFlag & 64 && dynamicChildren && n1.dynamicChildren) {
        patchBlockChildren(n1.dynamicChildren, dynamicChildren, container, parentComponent, parentSuspense, isSVG, slotScopeIds);
        if (n2.key != null || parentComponent && n2 === parentComponent.subTree) {
          traverseStaticChildren(n1, n2, true);
        }
      } else {
        patchChildren(n1, n2, container, fragmentEndAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      }
    }
  };
  const processComponent = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    n2.slotScopeIds = slotScopeIds;
    if (n1 == null) {
      if (n2.shapeFlag & 512) {
        parentComponent.ctx.activate(n2, container, anchor, isSVG, optimized);
      } else {
        mountComponent(n2, container, anchor, parentComponent, parentSuspense, isSVG, optimized);
      }
    } else {
      updateComponent(n1, n2, optimized);
    }
  };
  const mountComponent = (initialVNode, container, anchor, parentComponent, parentSuspense, isSVG, optimized) => {
    const instance = initialVNode.component = createComponentInstance(initialVNode, parentComponent, parentSuspense);
    if (isKeepAlive(initialVNode)) {
      instance.ctx.renderer = internals;
    }
    {
      setupComponent(instance);
    }
    if (instance.asyncDep) {
      parentSuspense && parentSuspense.registerDep(instance, setupRenderEffect);
      if (!initialVNode.el) {
        const placeholder = instance.subTree = createVNode(Comment);
        processCommentNode(null, placeholder, container, anchor);
      }
      return;
    }
    setupRenderEffect(instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized);
  };
  const updateComponent = (n1, n2, optimized) => {
    const instance = n2.component = n1.component;
    if (shouldUpdateComponent(n1, n2, optimized)) {
      if (instance.asyncDep && !instance.asyncResolved) {
        updateComponentPreRender(instance, n2, optimized);
        return;
      } else {
        instance.next = n2;
        invalidateJob(instance.update);
        instance.update();
      }
    } else {
      n2.el = n1.el;
      instance.vnode = n2;
    }
  };
  const setupRenderEffect = (instance, initialVNode, container, anchor, parentSuspense, isSVG, optimized) => {
    const componentUpdateFn = () => {
      if (!instance.isMounted) {
        let vnodeHook;
        const { el: el2, props } = initialVNode;
        const { bm, m: m3, parent } = instance;
        const isAsyncWrapperVNode = isAsyncWrapper(initialVNode);
        toggleRecurse(instance, false);
        if (bm) {
          invokeArrayFns(bm);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeBeforeMount)) {
          invokeVNodeHook(vnodeHook, parent, initialVNode);
        }
        toggleRecurse(instance, true);
        if (el2 && hydrateNode) {
          const hydrateSubTree = () => {
            instance.subTree = renderComponentRoot(instance);
            hydrateNode(el2, instance.subTree, instance, parentSuspense, null);
          };
          if (isAsyncWrapperVNode) {
            initialVNode.type.__asyncLoader().then(
              () => !instance.isUnmounted && hydrateSubTree()
            );
          } else {
            hydrateSubTree();
          }
        } else {
          const subTree = instance.subTree = renderComponentRoot(instance);
          patch(null, subTree, container, anchor, instance, parentSuspense, isSVG);
          initialVNode.el = subTree.el;
        }
        if (m3) {
          queuePostRenderEffect(m3, parentSuspense);
        }
        if (!isAsyncWrapperVNode && (vnodeHook = props && props.onVnodeMounted)) {
          const scopedInitialVNode = initialVNode;
          queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, scopedInitialVNode), parentSuspense);
        }
        if (initialVNode.shapeFlag & 256 || parent && isAsyncWrapper(parent.vnode) && parent.vnode.shapeFlag & 256) {
          instance.a && queuePostRenderEffect(instance.a, parentSuspense);
        }
        instance.isMounted = true;
        initialVNode = container = anchor = null;
      } else {
        let { next, bu, u: u2, parent, vnode } = instance;
        let originNext = next;
        let vnodeHook;
        toggleRecurse(instance, false);
        if (next) {
          next.el = vnode.el;
          updateComponentPreRender(instance, next, optimized);
        } else {
          next = vnode;
        }
        if (bu) {
          invokeArrayFns(bu);
        }
        if (vnodeHook = next.props && next.props.onVnodeBeforeUpdate) {
          invokeVNodeHook(vnodeHook, parent, next, vnode);
        }
        toggleRecurse(instance, true);
        const nextTree = renderComponentRoot(instance);
        const prevTree = instance.subTree;
        instance.subTree = nextTree;
        patch(
          prevTree,
          nextTree,
          hostParentNode(prevTree.el),
          getNextHostNode(prevTree),
          instance,
          parentSuspense,
          isSVG
        );
        next.el = nextTree.el;
        if (originNext === null) {
          updateHOCHostEl(instance, nextTree.el);
        }
        if (u2) {
          queuePostRenderEffect(u2, parentSuspense);
        }
        if (vnodeHook = next.props && next.props.onVnodeUpdated) {
          queuePostRenderEffect(() => invokeVNodeHook(vnodeHook, parent, next, vnode), parentSuspense);
        }
      }
    };
    const effect = instance.effect = new ReactiveEffect(
      componentUpdateFn,
      () => queueJob(update),
      instance.scope
    );
    const update = instance.update = () => effect.run();
    update.id = instance.uid;
    toggleRecurse(instance, true);
    update();
  };
  const updateComponentPreRender = (instance, nextVNode, optimized) => {
    nextVNode.component = instance;
    const prevProps = instance.vnode.props;
    instance.vnode = nextVNode;
    instance.next = null;
    updateProps(instance, nextVNode.props, prevProps, optimized);
    updateSlots(instance, nextVNode.children, optimized);
    pauseTracking();
    flushPreFlushCbs();
    resetTracking();
  };
  const patchChildren = (n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized = false) => {
    const c1 = n1 && n1.children;
    const prevShapeFlag = n1 ? n1.shapeFlag : 0;
    const c2 = n2.children;
    const { patchFlag, shapeFlag } = n2;
    if (patchFlag > 0) {
      if (patchFlag & 128) {
        patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        return;
      } else if (patchFlag & 256) {
        patchUnkeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        return;
      }
    }
    if (shapeFlag & 8) {
      if (prevShapeFlag & 16) {
        unmountChildren(c1, parentComponent, parentSuspense);
      }
      if (c2 !== c1) {
        hostSetElementText(container, c2);
      }
    } else {
      if (prevShapeFlag & 16) {
        if (shapeFlag & 16) {
          patchKeyedChildren(c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else {
          unmountChildren(c1, parentComponent, parentSuspense, true);
        }
      } else {
        if (prevShapeFlag & 8) {
          hostSetElementText(container, "");
        }
        if (shapeFlag & 16) {
          mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
      }
    }
  };
  const patchUnkeyedChildren = (c1, c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    c1 = c1 || EMPTY_ARR;
    c2 = c2 || EMPTY_ARR;
    const oldLength = c1.length;
    const newLength = c2.length;
    const commonLength = Math.min(oldLength, newLength);
    let i2;
    for (i2 = 0; i2 < commonLength; i2++) {
      const nextChild = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
      patch(c1[i2], nextChild, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
    }
    if (oldLength > newLength) {
      unmountChildren(c1, parentComponent, parentSuspense, true, false, commonLength);
    } else {
      mountChildren(c2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, commonLength);
    }
  };
  const patchKeyedChildren = (c1, c2, container, parentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized) => {
    let i2 = 0;
    const l2 = c2.length;
    let e1 = c1.length - 1;
    let e22 = l2 - 1;
    while (i2 <= e1 && i2 <= e22) {
      const n1 = c1[i2];
      const n2 = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
      if (isSameVNodeType(n1, n2)) {
        patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      } else {
        break;
      }
      i2++;
    }
    while (i2 <= e1 && i2 <= e22) {
      const n1 = c1[e1];
      const n2 = c2[e22] = optimized ? cloneIfMounted(c2[e22]) : normalizeVNode(c2[e22]);
      if (isSameVNodeType(n1, n2)) {
        patch(n1, n2, container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
      } else {
        break;
      }
      e1--;
      e22--;
    }
    if (i2 > e1) {
      if (i2 <= e22) {
        const nextPos = e22 + 1;
        const anchor = nextPos < l2 ? c2[nextPos].el : parentAnchor;
        while (i2 <= e22) {
          patch(null, c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]), container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          i2++;
        }
      }
    } else if (i2 > e22) {
      while (i2 <= e1) {
        unmount(c1[i2], parentComponent, parentSuspense, true);
        i2++;
      }
    } else {
      const s1 = i2;
      const s22 = i2;
      const keyToNewIndexMap = /* @__PURE__ */ new Map();
      for (i2 = s22; i2 <= e22; i2++) {
        const nextChild = c2[i2] = optimized ? cloneIfMounted(c2[i2]) : normalizeVNode(c2[i2]);
        if (nextChild.key != null) {
          keyToNewIndexMap.set(nextChild.key, i2);
        }
      }
      let j;
      let patched = 0;
      const toBePatched = e22 - s22 + 1;
      let moved = false;
      let maxNewIndexSoFar = 0;
      const newIndexToOldIndexMap = new Array(toBePatched);
      for (i2 = 0; i2 < toBePatched; i2++)
        newIndexToOldIndexMap[i2] = 0;
      for (i2 = s1; i2 <= e1; i2++) {
        const prevChild = c1[i2];
        if (patched >= toBePatched) {
          unmount(prevChild, parentComponent, parentSuspense, true);
          continue;
        }
        let newIndex;
        if (prevChild.key != null) {
          newIndex = keyToNewIndexMap.get(prevChild.key);
        } else {
          for (j = s22; j <= e22; j++) {
            if (newIndexToOldIndexMap[j - s22] === 0 && isSameVNodeType(prevChild, c2[j])) {
              newIndex = j;
              break;
            }
          }
        }
        if (newIndex === void 0) {
          unmount(prevChild, parentComponent, parentSuspense, true);
        } else {
          newIndexToOldIndexMap[newIndex - s22] = i2 + 1;
          if (newIndex >= maxNewIndexSoFar) {
            maxNewIndexSoFar = newIndex;
          } else {
            moved = true;
          }
          patch(prevChild, c2[newIndex], container, null, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
          patched++;
        }
      }
      const increasingNewIndexSequence = moved ? getSequence(newIndexToOldIndexMap) : EMPTY_ARR;
      j = increasingNewIndexSequence.length - 1;
      for (i2 = toBePatched - 1; i2 >= 0; i2--) {
        const nextIndex = s22 + i2;
        const nextChild = c2[nextIndex];
        const anchor = nextIndex + 1 < l2 ? c2[nextIndex + 1].el : parentAnchor;
        if (newIndexToOldIndexMap[i2] === 0) {
          patch(null, nextChild, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        } else if (moved) {
          if (j < 0 || i2 !== increasingNewIndexSequence[j]) {
            move(nextChild, container, anchor, 2);
          } else {
            j--;
          }
        }
      }
    }
  };
  const move = (vnode, container, anchor, moveType, parentSuspense = null) => {
    const { el: el2, type, transition, children, shapeFlag } = vnode;
    if (shapeFlag & 6) {
      move(vnode.component.subTree, container, anchor, moveType);
      return;
    }
    if (shapeFlag & 128) {
      vnode.suspense.move(container, anchor, moveType);
      return;
    }
    if (shapeFlag & 64) {
      type.move(vnode, container, anchor, internals);
      return;
    }
    if (type === Fragment) {
      hostInsert(el2, container, anchor);
      for (let i2 = 0; i2 < children.length; i2++) {
        move(children[i2], container, anchor, moveType);
      }
      hostInsert(vnode.anchor, container, anchor);
      return;
    }
    if (type === Static) {
      moveStaticNode(vnode, container, anchor);
      return;
    }
    const needTransition = moveType !== 2 && shapeFlag & 1 && transition;
    if (needTransition) {
      if (moveType === 0) {
        transition.beforeEnter(el2);
        hostInsert(el2, container, anchor);
        queuePostRenderEffect(() => transition.enter(el2), parentSuspense);
      } else {
        const { leave, delayLeave, afterLeave } = transition;
        const remove3 = () => hostInsert(el2, container, anchor);
        const performLeave = () => {
          leave(el2, () => {
            remove3();
            afterLeave && afterLeave();
          });
        };
        if (delayLeave) {
          delayLeave(el2, remove3, performLeave);
        } else {
          performLeave();
        }
      }
    } else {
      hostInsert(el2, container, anchor);
    }
  };
  const unmount = (vnode, parentComponent, parentSuspense, doRemove = false, optimized = false) => {
    const { type, props, ref: ref2, children, dynamicChildren, shapeFlag, patchFlag, dirs } = vnode;
    if (ref2 != null) {
      setRef(ref2, null, parentSuspense, vnode, true);
    }
    if (shapeFlag & 256) {
      parentComponent.ctx.deactivate(vnode);
      return;
    }
    const shouldInvokeDirs = shapeFlag & 1 && dirs;
    const shouldInvokeVnodeHook = !isAsyncWrapper(vnode);
    let vnodeHook;
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeBeforeUnmount)) {
      invokeVNodeHook(vnodeHook, parentComponent, vnode);
    }
    if (shapeFlag & 6) {
      unmountComponent(vnode.component, parentSuspense, doRemove);
    } else {
      if (shapeFlag & 128) {
        vnode.suspense.unmount(parentSuspense, doRemove);
        return;
      }
      if (shouldInvokeDirs) {
        invokeDirectiveHook(vnode, null, parentComponent, "beforeUnmount");
      }
      if (shapeFlag & 64) {
        vnode.type.remove(vnode, parentComponent, parentSuspense, optimized, internals, doRemove);
      } else if (dynamicChildren && (type !== Fragment || patchFlag > 0 && patchFlag & 64)) {
        unmountChildren(dynamicChildren, parentComponent, parentSuspense, false, true);
      } else if (type === Fragment && patchFlag & (128 | 256) || !optimized && shapeFlag & 16) {
        unmountChildren(children, parentComponent, parentSuspense);
      }
      if (doRemove) {
        remove2(vnode);
      }
    }
    if (shouldInvokeVnodeHook && (vnodeHook = props && props.onVnodeUnmounted) || shouldInvokeDirs) {
      queuePostRenderEffect(() => {
        vnodeHook && invokeVNodeHook(vnodeHook, parentComponent, vnode);
        shouldInvokeDirs && invokeDirectiveHook(vnode, null, parentComponent, "unmounted");
      }, parentSuspense);
    }
  };
  const remove2 = (vnode) => {
    const { type, el: el2, anchor, transition } = vnode;
    if (type === Fragment) {
      {
        removeFragment(el2, anchor);
      }
      return;
    }
    if (type === Static) {
      removeStaticNode(vnode);
      return;
    }
    const performRemove = () => {
      hostRemove(el2);
      if (transition && !transition.persisted && transition.afterLeave) {
        transition.afterLeave();
      }
    };
    if (vnode.shapeFlag & 1 && transition && !transition.persisted) {
      const { leave, delayLeave } = transition;
      const performLeave = () => leave(el2, performRemove);
      if (delayLeave) {
        delayLeave(vnode.el, performRemove, performLeave);
      } else {
        performLeave();
      }
    } else {
      performRemove();
    }
  };
  const removeFragment = (cur, end) => {
    let next;
    while (cur !== end) {
      next = hostNextSibling(cur);
      hostRemove(cur);
      cur = next;
    }
    hostRemove(end);
  };
  const unmountComponent = (instance, parentSuspense, doRemove) => {
    const { bum, scope, update, subTree, um } = instance;
    if (bum) {
      invokeArrayFns(bum);
    }
    scope.stop();
    if (update) {
      update.active = false;
      unmount(subTree, instance, parentSuspense, doRemove);
    }
    if (um) {
      queuePostRenderEffect(um, parentSuspense);
    }
    queuePostRenderEffect(() => {
      instance.isUnmounted = true;
    }, parentSuspense);
    if (parentSuspense && parentSuspense.pendingBranch && !parentSuspense.isUnmounted && instance.asyncDep && !instance.asyncResolved && instance.suspenseId === parentSuspense.pendingId) {
      parentSuspense.deps--;
      if (parentSuspense.deps === 0) {
        parentSuspense.resolve();
      }
    }
  };
  const unmountChildren = (children, parentComponent, parentSuspense, doRemove = false, optimized = false, start = 0) => {
    for (let i2 = start; i2 < children.length; i2++) {
      unmount(children[i2], parentComponent, parentSuspense, doRemove, optimized);
    }
  };
  const getNextHostNode = (vnode) => {
    if (vnode.shapeFlag & 6) {
      return getNextHostNode(vnode.component.subTree);
    }
    if (vnode.shapeFlag & 128) {
      return vnode.suspense.next();
    }
    return hostNextSibling(vnode.anchor || vnode.el);
  };
  const render = (vnode, container, isSVG) => {
    if (vnode == null) {
      if (container._vnode) {
        unmount(container._vnode, null, null, true);
      }
    } else {
      patch(container._vnode || null, vnode, container, null, null, null, isSVG);
    }
    flushPreFlushCbs();
    flushPostFlushCbs();
    container._vnode = vnode;
  };
  const internals = {
    p: patch,
    um: unmount,
    m: move,
    r: remove2,
    mt: mountComponent,
    mc: mountChildren,
    pc: patchChildren,
    pbc: patchBlockChildren,
    n: getNextHostNode,
    o: options
  };
  let hydrate;
  let hydrateNode;
  if (createHydrationFns) {
    [hydrate, hydrateNode] = createHydrationFns(internals);
  }
  return {
    render,
    hydrate,
    createApp: createAppAPI(render, hydrate)
  };
}
function toggleRecurse({ effect, update }, allowed) {
  effect.allowRecurse = update.allowRecurse = allowed;
}
function traverseStaticChildren(n1, n2, shallow = false) {
  const ch1 = n1.children;
  const ch2 = n2.children;
  if (isArray$1(ch1) && isArray$1(ch2)) {
    for (let i2 = 0; i2 < ch1.length; i2++) {
      const c1 = ch1[i2];
      let c2 = ch2[i2];
      if (c2.shapeFlag & 1 && !c2.dynamicChildren) {
        if (c2.patchFlag <= 0 || c2.patchFlag === 32) {
          c2 = ch2[i2] = cloneIfMounted(ch2[i2]);
          c2.el = c1.el;
        }
        if (!shallow)
          traverseStaticChildren(c1, c2);
      }
      if (c2.type === Text) {
        c2.el = c1.el;
      }
    }
  }
}
function getSequence(arr) {
  const p2 = arr.slice();
  const result = [0];
  let i2, j, u2, v, c2;
  const len = arr.length;
  for (i2 = 0; i2 < len; i2++) {
    const arrI = arr[i2];
    if (arrI !== 0) {
      j = result[result.length - 1];
      if (arr[j] < arrI) {
        p2[i2] = j;
        result.push(i2);
        continue;
      }
      u2 = 0;
      v = result.length - 1;
      while (u2 < v) {
        c2 = u2 + v >> 1;
        if (arr[result[c2]] < arrI) {
          u2 = c2 + 1;
        } else {
          v = c2;
        }
      }
      if (arrI < arr[result[u2]]) {
        if (u2 > 0) {
          p2[i2] = result[u2 - 1];
        }
        result[u2] = i2;
      }
    }
  }
  u2 = result.length;
  v = result[u2 - 1];
  while (u2-- > 0) {
    result[u2] = v;
    v = p2[v];
  }
  return result;
}
const isTeleport = (type) => type.__isTeleport;
const isTeleportDisabled = (props) => props && (props.disabled || props.disabled === "");
const isTargetSVG = (target) => typeof SVGElement !== "undefined" && target instanceof SVGElement;
const resolveTarget = (props, select) => {
  const targetSelector = props && props.to;
  if (isString$1(targetSelector)) {
    if (!select) {
      return null;
    } else {
      const target = select(targetSelector);
      return target;
    }
  } else {
    return targetSelector;
  }
};
const TeleportImpl = {
  __isTeleport: true,
  process(n1, n2, container, anchor, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized, internals) {
    const { mc: mountChildren, pc: patchChildren, pbc: patchBlockChildren, o: { insert, querySelector, createText, createComment } } = internals;
    const disabled = isTeleportDisabled(n2.props);
    let { shapeFlag, children, dynamicChildren } = n2;
    if (n1 == null) {
      const placeholder = n2.el = createText("");
      const mainAnchor = n2.anchor = createText("");
      insert(placeholder, container, anchor);
      insert(mainAnchor, container, anchor);
      const target = n2.target = resolveTarget(n2.props, querySelector);
      const targetAnchor = n2.targetAnchor = createText("");
      if (target) {
        insert(targetAnchor, target);
        isSVG = isSVG || isTargetSVG(target);
      }
      const mount = (container2, anchor2) => {
        if (shapeFlag & 16) {
          mountChildren(children, container2, anchor2, parentComponent, parentSuspense, isSVG, slotScopeIds, optimized);
        }
      };
      if (disabled) {
        mount(container, mainAnchor);
      } else if (target) {
        mount(target, targetAnchor);
      }
    } else {
      n2.el = n1.el;
      const mainAnchor = n2.anchor = n1.anchor;
      const target = n2.target = n1.target;
      const targetAnchor = n2.targetAnchor = n1.targetAnchor;
      const wasDisabled = isTeleportDisabled(n1.props);
      const currentContainer = wasDisabled ? container : target;
      const currentAnchor = wasDisabled ? mainAnchor : targetAnchor;
      isSVG = isSVG || isTargetSVG(target);
      if (dynamicChildren) {
        patchBlockChildren(n1.dynamicChildren, dynamicChildren, currentContainer, parentComponent, parentSuspense, isSVG, slotScopeIds);
        traverseStaticChildren(n1, n2, true);
      } else if (!optimized) {
        patchChildren(n1, n2, currentContainer, currentAnchor, parentComponent, parentSuspense, isSVG, slotScopeIds, false);
      }
      if (disabled) {
        if (!wasDisabled) {
          moveTeleport(n2, container, mainAnchor, internals, 1);
        }
      } else {
        if ((n2.props && n2.props.to) !== (n1.props && n1.props.to)) {
          const nextTarget = n2.target = resolveTarget(n2.props, querySelector);
          if (nextTarget) {
            moveTeleport(n2, nextTarget, null, internals, 0);
          }
        } else if (wasDisabled) {
          moveTeleport(n2, target, targetAnchor, internals, 1);
        }
      }
    }
    updateCssVars(n2);
  },
  remove(vnode, parentComponent, parentSuspense, optimized, { um: unmount, o: { remove: hostRemove } }, doRemove) {
    const { shapeFlag, children, anchor, targetAnchor, target, props } = vnode;
    if (target) {
      hostRemove(targetAnchor);
    }
    if (doRemove || !isTeleportDisabled(props)) {
      hostRemove(anchor);
      if (shapeFlag & 16) {
        for (let i2 = 0; i2 < children.length; i2++) {
          const child = children[i2];
          unmount(child, parentComponent, parentSuspense, true, !!child.dynamicChildren);
        }
      }
    }
  },
  move: moveTeleport,
  hydrate: hydrateTeleport
};
function moveTeleport(vnode, container, parentAnchor, { o: { insert }, m: move }, moveType = 2) {
  if (moveType === 0) {
    insert(vnode.targetAnchor, container, parentAnchor);
  }
  const { el: el2, anchor, shapeFlag, children, props } = vnode;
  const isReorder = moveType === 2;
  if (isReorder) {
    insert(el2, container, parentAnchor);
  }
  if (!isReorder || isTeleportDisabled(props)) {
    if (shapeFlag & 16) {
      for (let i2 = 0; i2 < children.length; i2++) {
        move(children[i2], container, parentAnchor, 2);
      }
    }
  }
  if (isReorder) {
    insert(anchor, container, parentAnchor);
  }
}
function hydrateTeleport(node, vnode, parentComponent, parentSuspense, slotScopeIds, optimized, { o: { nextSibling, parentNode, querySelector } }, hydrateChildren) {
  const target = vnode.target = resolveTarget(vnode.props, querySelector);
  if (target) {
    const targetNode = target._lpa || target.firstChild;
    if (vnode.shapeFlag & 16) {
      if (isTeleportDisabled(vnode.props)) {
        vnode.anchor = hydrateChildren(nextSibling(node), vnode, parentNode(node), parentComponent, parentSuspense, slotScopeIds, optimized);
        vnode.targetAnchor = targetNode;
      } else {
        vnode.anchor = nextSibling(node);
        let targetAnchor = targetNode;
        while (targetAnchor) {
          targetAnchor = nextSibling(targetAnchor);
          if (targetAnchor && targetAnchor.nodeType === 8 && targetAnchor.data === "teleport anchor") {
            vnode.targetAnchor = targetAnchor;
            target._lpa = vnode.targetAnchor && nextSibling(vnode.targetAnchor);
            break;
          }
        }
        hydrateChildren(targetNode, vnode, target, parentComponent, parentSuspense, slotScopeIds, optimized);
      }
    }
    updateCssVars(vnode);
  }
  return vnode.anchor && nextSibling(vnode.anchor);
}
const Teleport = TeleportImpl;
function updateCssVars(vnode) {
  const ctx = vnode.ctx;
  if (ctx && ctx.ut) {
    let node = vnode.children[0].el;
    while (node !== vnode.targetAnchor) {
      if (node.nodeType === 1)
        node.setAttribute("data-v-owner", ctx.uid);
      node = node.nextSibling;
    }
    ctx.ut();
  }
}
const Fragment = Symbol(void 0);
const Text = Symbol(void 0);
const Comment = Symbol(void 0);
const Static = Symbol(void 0);
const blockStack = [];
let currentBlock = null;
function openBlock(disableTracking = false) {
  blockStack.push(currentBlock = disableTracking ? null : []);
}
function closeBlock() {
  blockStack.pop();
  currentBlock = blockStack[blockStack.length - 1] || null;
}
let isBlockTreeEnabled = 1;
function setBlockTracking(value) {
  isBlockTreeEnabled += value;
}
function setupBlock(vnode) {
  vnode.dynamicChildren = isBlockTreeEnabled > 0 ? currentBlock || EMPTY_ARR : null;
  closeBlock();
  if (isBlockTreeEnabled > 0 && currentBlock) {
    currentBlock.push(vnode);
  }
  return vnode;
}
function createElementBlock(type, props, children, patchFlag, dynamicProps, shapeFlag) {
  return setupBlock(createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, true));
}
function createBlock(type, props, children, patchFlag, dynamicProps) {
  return setupBlock(createVNode(type, props, children, patchFlag, dynamicProps, true));
}
function isVNode(value) {
  return value ? value.__v_isVNode === true : false;
}
function isSameVNodeType(n1, n2) {
  return n1.type === n2.type && n1.key === n2.key;
}
const InternalObjectKey = `__vInternal`;
const normalizeKey = ({ key }) => key != null ? key : null;
const normalizeRef = ({ ref: ref2, ref_key, ref_for }) => {
  return ref2 != null ? isString$1(ref2) || isRef(ref2) || isFunction$1(ref2) ? { i: currentRenderingInstance, r: ref2, k: ref_key, f: !!ref_for } : ref2 : null;
};
function createBaseVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, shapeFlag = type === Fragment ? 0 : 1, isBlockNode = false, needFullChildrenNormalization = false) {
  const vnode = {
    __v_isVNode: true,
    __v_skip: true,
    type,
    props,
    key: props && normalizeKey(props),
    ref: props && normalizeRef(props),
    scopeId: currentScopeId,
    slotScopeIds: null,
    children,
    component: null,
    suspense: null,
    ssContent: null,
    ssFallback: null,
    dirs: null,
    transition: null,
    el: null,
    anchor: null,
    target: null,
    targetAnchor: null,
    staticCount: 0,
    shapeFlag,
    patchFlag,
    dynamicProps,
    dynamicChildren: null,
    appContext: null,
    ctx: currentRenderingInstance
  };
  if (needFullChildrenNormalization) {
    normalizeChildren(vnode, children);
    if (shapeFlag & 128) {
      type.normalize(vnode);
    }
  } else if (children) {
    vnode.shapeFlag |= isString$1(children) ? 8 : 16;
  }
  if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock && (vnode.patchFlag > 0 || shapeFlag & 6) && vnode.patchFlag !== 32) {
    currentBlock.push(vnode);
  }
  return vnode;
}
const createVNode = _createVNode;
function _createVNode(type, props = null, children = null, patchFlag = 0, dynamicProps = null, isBlockNode = false) {
  if (!type || type === NULL_DYNAMIC_COMPONENT) {
    type = Comment;
  }
  if (isVNode(type)) {
    const cloned = cloneVNode(type, props, true);
    if (children) {
      normalizeChildren(cloned, children);
    }
    if (isBlockTreeEnabled > 0 && !isBlockNode && currentBlock) {
      if (cloned.shapeFlag & 6) {
        currentBlock[currentBlock.indexOf(type)] = cloned;
      } else {
        currentBlock.push(cloned);
      }
    }
    cloned.patchFlag |= -2;
    return cloned;
  }
  if (isClassComponent(type)) {
    type = type.__vccOpts;
  }
  if (props) {
    props = guardReactiveProps(props);
    let { class: klass, style } = props;
    if (klass && !isString$1(klass)) {
      props.class = normalizeClass(klass);
    }
    if (isObject$2(style)) {
      if (isProxy(style) && !isArray$1(style)) {
        style = extend$1({}, style);
      }
      props.style = normalizeStyle(style);
    }
  }
  const shapeFlag = isString$1(type) ? 1 : isSuspense(type) ? 128 : isTeleport(type) ? 64 : isObject$2(type) ? 4 : isFunction$1(type) ? 2 : 0;
  return createBaseVNode(type, props, children, patchFlag, dynamicProps, shapeFlag, isBlockNode, true);
}
function guardReactiveProps(props) {
  if (!props)
    return null;
  return isProxy(props) || InternalObjectKey in props ? extend$1({}, props) : props;
}
function cloneVNode(vnode, extraProps, mergeRef = false) {
  const { props, ref: ref2, patchFlag, children } = vnode;
  const mergedProps = extraProps ? mergeProps(props || {}, extraProps) : props;
  const cloned = {
    __v_isVNode: true,
    __v_skip: true,
    type: vnode.type,
    props: mergedProps,
    key: mergedProps && normalizeKey(mergedProps),
    ref: extraProps && extraProps.ref ? mergeRef && ref2 ? isArray$1(ref2) ? ref2.concat(normalizeRef(extraProps)) : [ref2, normalizeRef(extraProps)] : normalizeRef(extraProps) : ref2,
    scopeId: vnode.scopeId,
    slotScopeIds: vnode.slotScopeIds,
    children,
    target: vnode.target,
    targetAnchor: vnode.targetAnchor,
    staticCount: vnode.staticCount,
    shapeFlag: vnode.shapeFlag,
    patchFlag: extraProps && vnode.type !== Fragment ? patchFlag === -1 ? 16 : patchFlag | 16 : patchFlag,
    dynamicProps: vnode.dynamicProps,
    dynamicChildren: vnode.dynamicChildren,
    appContext: vnode.appContext,
    dirs: vnode.dirs,
    transition: vnode.transition,
    component: vnode.component,
    suspense: vnode.suspense,
    ssContent: vnode.ssContent && cloneVNode(vnode.ssContent),
    ssFallback: vnode.ssFallback && cloneVNode(vnode.ssFallback),
    el: vnode.el,
    anchor: vnode.anchor,
    ctx: vnode.ctx,
    ce: vnode.ce
  };
  return cloned;
}
function createTextVNode(text = " ", flag = 0) {
  return createVNode(Text, null, text, flag);
}
function createCommentVNode(text = "", asBlock = false) {
  return asBlock ? (openBlock(), createBlock(Comment, null, text)) : createVNode(Comment, null, text);
}
function normalizeVNode(child) {
  if (child == null || typeof child === "boolean") {
    return createVNode(Comment);
  } else if (isArray$1(child)) {
    return createVNode(
      Fragment,
      null,
      child.slice()
    );
  } else if (typeof child === "object") {
    return cloneIfMounted(child);
  } else {
    return createVNode(Text, null, String(child));
  }
}
function cloneIfMounted(child) {
  return child.el === null && child.patchFlag !== -1 || child.memo ? child : cloneVNode(child);
}
function normalizeChildren(vnode, children) {
  let type = 0;
  const { shapeFlag } = vnode;
  if (children == null) {
    children = null;
  } else if (isArray$1(children)) {
    type = 16;
  } else if (typeof children === "object") {
    if (shapeFlag & (1 | 64)) {
      const slot = children.default;
      if (slot) {
        slot._c && (slot._d = false);
        normalizeChildren(vnode, slot());
        slot._c && (slot._d = true);
      }
      return;
    } else {
      type = 32;
      const slotFlag = children._;
      if (!slotFlag && !(InternalObjectKey in children)) {
        children._ctx = currentRenderingInstance;
      } else if (slotFlag === 3 && currentRenderingInstance) {
        if (currentRenderingInstance.slots._ === 1) {
          children._ = 1;
        } else {
          children._ = 2;
          vnode.patchFlag |= 1024;
        }
      }
    }
  } else if (isFunction$1(children)) {
    children = { default: children, _ctx: currentRenderingInstance };
    type = 32;
  } else {
    children = String(children);
    if (shapeFlag & 64) {
      type = 16;
      children = [createTextVNode(children)];
    } else {
      type = 8;
    }
  }
  vnode.children = children;
  vnode.shapeFlag |= type;
}
function mergeProps(...args) {
  const ret = {};
  for (let i2 = 0; i2 < args.length; i2++) {
    const toMerge = args[i2];
    for (const key in toMerge) {
      if (key === "class") {
        if (ret.class !== toMerge.class) {
          ret.class = normalizeClass([ret.class, toMerge.class]);
        }
      } else if (key === "style") {
        ret.style = normalizeStyle([ret.style, toMerge.style]);
      } else if (isOn$1(key)) {
        const existing = ret[key];
        const incoming = toMerge[key];
        if (incoming && existing !== incoming && !(isArray$1(existing) && existing.includes(incoming))) {
          ret[key] = existing ? [].concat(existing, incoming) : incoming;
        }
      } else if (key !== "") {
        ret[key] = toMerge[key];
      }
    }
  }
  return ret;
}
function invokeVNodeHook(hook, instance, vnode, prevVNode = null) {
  callWithAsyncErrorHandling(hook, instance, 7, [
    vnode,
    prevVNode
  ]);
}
const emptyAppContext = createAppContext();
let uid = 0;
function createComponentInstance(vnode, parent, suspense) {
  const type = vnode.type;
  const appContext = (parent ? parent.appContext : vnode.appContext) || emptyAppContext;
  const instance = {
    uid: uid++,
    vnode,
    type,
    parent,
    appContext,
    root: null,
    next: null,
    subTree: null,
    effect: null,
    update: null,
    scope: new EffectScope(true),
    render: null,
    proxy: null,
    exposed: null,
    exposeProxy: null,
    withProxy: null,
    provides: parent ? parent.provides : Object.create(appContext.provides),
    accessCache: null,
    renderCache: [],
    components: null,
    directives: null,
    propsOptions: normalizePropsOptions(type, appContext),
    emitsOptions: normalizeEmitsOptions(type, appContext),
    emit: null,
    emitted: null,
    propsDefaults: EMPTY_OBJ,
    inheritAttrs: type.inheritAttrs,
    ctx: EMPTY_OBJ,
    data: EMPTY_OBJ,
    props: EMPTY_OBJ,
    attrs: EMPTY_OBJ,
    slots: EMPTY_OBJ,
    refs: EMPTY_OBJ,
    setupState: EMPTY_OBJ,
    setupContext: null,
    suspense,
    suspenseId: suspense ? suspense.pendingId : 0,
    asyncDep: null,
    asyncResolved: false,
    isMounted: false,
    isUnmounted: false,
    isDeactivated: false,
    bc: null,
    c: null,
    bm: null,
    m: null,
    bu: null,
    u: null,
    um: null,
    bum: null,
    da: null,
    a: null,
    rtg: null,
    rtc: null,
    ec: null,
    sp: null
  };
  {
    instance.ctx = { _: instance };
  }
  instance.root = parent ? parent.root : instance;
  instance.emit = emit.bind(null, instance);
  if (vnode.ce) {
    vnode.ce(instance);
  }
  return instance;
}
let currentInstance = null;
const getCurrentInstance$1 = () => currentInstance || currentRenderingInstance;
const setCurrentInstance = (instance) => {
  currentInstance = instance;
  instance.scope.on();
};
const unsetCurrentInstance = () => {
  currentInstance && currentInstance.scope.off();
  currentInstance = null;
};
function isStatefulComponent(instance) {
  return instance.vnode.shapeFlag & 4;
}
let isInSSRComponentSetup = false;
function setupComponent(instance, isSSR = false) {
  isInSSRComponentSetup = isSSR;
  const { props, children } = instance.vnode;
  const isStateful = isStatefulComponent(instance);
  initProps(instance, props, isStateful, isSSR);
  initSlots(instance, children);
  const setupResult = isStateful ? setupStatefulComponent(instance, isSSR) : void 0;
  isInSSRComponentSetup = false;
  return setupResult;
}
function setupStatefulComponent(instance, isSSR) {
  const Component = instance.type;
  instance.accessCache = /* @__PURE__ */ Object.create(null);
  instance.proxy = markRaw(new Proxy(instance.ctx, PublicInstanceProxyHandlers));
  const { setup } = Component;
  if (setup) {
    const setupContext = instance.setupContext = setup.length > 1 ? createSetupContext(instance) : null;
    setCurrentInstance(instance);
    pauseTracking();
    const setupResult = callWithErrorHandling(setup, instance, 0, [instance.props, setupContext]);
    resetTracking();
    unsetCurrentInstance();
    if (isPromise(setupResult)) {
      setupResult.then(unsetCurrentInstance, unsetCurrentInstance);
      if (isSSR) {
        return setupResult.then((resolvedResult) => {
          handleSetupResult(instance, resolvedResult, isSSR);
        }).catch((e3) => {
          handleError(e3, instance, 0);
        });
      } else {
        instance.asyncDep = setupResult;
      }
    } else {
      handleSetupResult(instance, setupResult, isSSR);
    }
  } else {
    finishComponentSetup(instance, isSSR);
  }
}
function handleSetupResult(instance, setupResult, isSSR) {
  if (isFunction$1(setupResult)) {
    if (instance.type.__ssrInlineRender) {
      instance.ssrRender = setupResult;
    } else {
      instance.render = setupResult;
    }
  } else if (isObject$2(setupResult)) {
    instance.setupState = proxyRefs(setupResult);
  } else
    ;
  finishComponentSetup(instance, isSSR);
}
let compile;
function finishComponentSetup(instance, isSSR, skipOptions) {
  const Component = instance.type;
  if (!instance.render) {
    if (!isSSR && compile && !Component.render) {
      const template = Component.template || resolveMergedOptions(instance).template;
      if (template) {
        const { isCustomElement, compilerOptions } = instance.appContext.config;
        const { delimiters, compilerOptions: componentCompilerOptions } = Component;
        const finalCompilerOptions = extend$1(extend$1({
          isCustomElement,
          delimiters
        }, compilerOptions), componentCompilerOptions);
        Component.render = compile(template, finalCompilerOptions);
      }
    }
    instance.render = Component.render || NOOP;
  }
  {
    setCurrentInstance(instance);
    pauseTracking();
    applyOptions(instance);
    resetTracking();
    unsetCurrentInstance();
  }
}
function createAttrsProxy(instance) {
  return new Proxy(instance.attrs, {
    get(target, key) {
      track(instance, "get", "$attrs");
      return target[key];
    }
  });
}
function createSetupContext(instance) {
  const expose = (exposed) => {
    instance.exposed = exposed || {};
  };
  let attrs;
  {
    return {
      get attrs() {
        return attrs || (attrs = createAttrsProxy(instance));
      },
      slots: instance.slots,
      emit: instance.emit,
      expose
    };
  }
}
function getExposeProxy(instance) {
  if (instance.exposed) {
    return instance.exposeProxy || (instance.exposeProxy = new Proxy(proxyRefs(markRaw(instance.exposed)), {
      get(target, key) {
        if (key in target) {
          return target[key];
        } else if (key in publicPropertiesMap) {
          return publicPropertiesMap[key](instance);
        }
      },
      has(target, key) {
        return key in target || key in publicPropertiesMap;
      }
    }));
  }
}
function getComponentName(Component, includeInferred = true) {
  return isFunction$1(Component) ? Component.displayName || Component.name : Component.name || includeInferred && Component.__name;
}
function isClassComponent(value) {
  return isFunction$1(value) && "__vccOpts" in value;
}
const computed = (getterOrOptions, debugOptions) => {
  return computed$1(getterOrOptions, debugOptions, isInSSRComponentSetup);
};
function useSlots() {
  return getContext().slots;
}
function getContext() {
  const i2 = getCurrentInstance$1();
  return i2.setupContext || (i2.setupContext = createSetupContext(i2));
}
function h(type, propsOrChildren, children) {
  const l = arguments.length;
  if (l === 2) {
    if (isObject$2(propsOrChildren) && !isArray$1(propsOrChildren)) {
      if (isVNode(propsOrChildren)) {
        return createVNode(type, null, [propsOrChildren]);
      }
      return createVNode(type, propsOrChildren);
    } else {
      return createVNode(type, null, propsOrChildren);
    }
  } else {
    if (l > 3) {
      children = Array.prototype.slice.call(arguments, 2);
    } else if (l === 3 && isVNode(children)) {
      children = [children];
    }
    return createVNode(type, propsOrChildren, children);
  }
}
const ssrContextKey = Symbol(``);
const useSSRContext = () => {
  {
    const ctx = inject$1(ssrContextKey);
    return ctx;
  }
};
const version$4 = "3.2.47";
const svgNS = "http://www.w3.org/2000/svg";
const doc = typeof document !== "undefined" ? document : null;
const templateContainer = doc && /* @__PURE__ */ doc.createElement("template");
const nodeOps = {
  insert: (child, parent, anchor) => {
    parent.insertBefore(child, anchor || null);
  },
  remove: (child) => {
    const parent = child.parentNode;
    if (parent) {
      parent.removeChild(child);
    }
  },
  createElement: (tag, isSVG, is, props) => {
    const el2 = isSVG ? doc.createElementNS(svgNS, tag) : doc.createElement(tag, is ? { is } : void 0);
    if (tag === "select" && props && props.multiple != null) {
      el2.setAttribute("multiple", props.multiple);
    }
    return el2;
  },
  createText: (text) => doc.createTextNode(text),
  createComment: (text) => doc.createComment(text),
  setText: (node, text) => {
    node.nodeValue = text;
  },
  setElementText: (el2, text) => {
    el2.textContent = text;
  },
  parentNode: (node) => node.parentNode,
  nextSibling: (node) => node.nextSibling,
  querySelector: (selector) => doc.querySelector(selector),
  setScopeId(el2, id) {
    el2.setAttribute(id, "");
  },
  insertStaticContent(content, parent, anchor, isSVG, start, end) {
    const before = anchor ? anchor.previousSibling : parent.lastChild;
    if (start && (start === end || start.nextSibling)) {
      while (true) {
        parent.insertBefore(start.cloneNode(true), anchor);
        if (start === end || !(start = start.nextSibling))
          break;
      }
    } else {
      templateContainer.innerHTML = isSVG ? `<svg>${content}</svg>` : content;
      const template = templateContainer.content;
      if (isSVG) {
        const wrapper = template.firstChild;
        while (wrapper.firstChild) {
          template.appendChild(wrapper.firstChild);
        }
        template.removeChild(wrapper);
      }
      parent.insertBefore(template, anchor);
    }
    return [
      before ? before.nextSibling : parent.firstChild,
      anchor ? anchor.previousSibling : parent.lastChild
    ];
  }
};
function patchClass(el2, value, isSVG) {
  const transitionClasses = el2._vtc;
  if (transitionClasses) {
    value = (value ? [value, ...transitionClasses] : [...transitionClasses]).join(" ");
  }
  if (value == null) {
    el2.removeAttribute("class");
  } else if (isSVG) {
    el2.setAttribute("class", value);
  } else {
    el2.className = value;
  }
}
function patchStyle(el2, prev, next) {
  const style = el2.style;
  const isCssString = isString$1(next);
  if (next && !isCssString) {
    if (prev && !isString$1(prev)) {
      for (const key in prev) {
        if (next[key] == null) {
          setStyle(style, key, "");
        }
      }
    }
    for (const key in next) {
      setStyle(style, key, next[key]);
    }
  } else {
    const currentDisplay = style.display;
    if (isCssString) {
      if (prev !== next) {
        style.cssText = next;
      }
    } else if (prev) {
      el2.removeAttribute("style");
    }
    if ("_vod" in el2) {
      style.display = currentDisplay;
    }
  }
}
const importantRE = /\s*!important$/;
function setStyle(style, name2, val) {
  if (isArray$1(val)) {
    val.forEach((v) => setStyle(style, name2, v));
  } else {
    if (val == null)
      val = "";
    if (name2.startsWith("--")) {
      style.setProperty(name2, val);
    } else {
      const prefixed = autoPrefix(style, name2);
      if (importantRE.test(val)) {
        style.setProperty(hyphenate(prefixed), val.replace(importantRE, ""), "important");
      } else {
        style[prefixed] = val;
      }
    }
  }
}
const prefixes = ["Webkit", "Moz", "ms"];
const prefixCache = {};
function autoPrefix(style, rawName) {
  const cached = prefixCache[rawName];
  if (cached) {
    return cached;
  }
  let name2 = camelize(rawName);
  if (name2 !== "filter" && name2 in style) {
    return prefixCache[rawName] = name2;
  }
  name2 = capitalize(name2);
  for (let i2 = 0; i2 < prefixes.length; i2++) {
    const prefixed = prefixes[i2] + name2;
    if (prefixed in style) {
      return prefixCache[rawName] = prefixed;
    }
  }
  return rawName;
}
const xlinkNS = "http://www.w3.org/1999/xlink";
function patchAttr(el2, key, value, isSVG, instance) {
  if (isSVG && key.startsWith("xlink:")) {
    if (value == null) {
      el2.removeAttributeNS(xlinkNS, key.slice(6, key.length));
    } else {
      el2.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    const isBoolean2 = isSpecialBooleanAttr(key);
    if (value == null || isBoolean2 && !includeBooleanAttr(value)) {
      el2.removeAttribute(key);
    } else {
      el2.setAttribute(key, isBoolean2 ? "" : value);
    }
  }
}
function patchDOMProp(el2, key, value, prevChildren, parentComponent, parentSuspense, unmountChildren) {
  if (key === "innerHTML" || key === "textContent") {
    if (prevChildren) {
      unmountChildren(prevChildren, parentComponent, parentSuspense);
    }
    el2[key] = value == null ? "" : value;
    return;
  }
  if (key === "value" && el2.tagName !== "PROGRESS" && !el2.tagName.includes("-")) {
    el2._value = value;
    const newValue = value == null ? "" : value;
    if (el2.value !== newValue || el2.tagName === "OPTION") {
      el2.value = newValue;
    }
    if (value == null) {
      el2.removeAttribute(key);
    }
    return;
  }
  let needRemove = false;
  if (value === "" || value == null) {
    const type = typeof el2[key];
    if (type === "boolean") {
      value = includeBooleanAttr(value);
    } else if (value == null && type === "string") {
      value = "";
      needRemove = true;
    } else if (type === "number") {
      value = 0;
      needRemove = true;
    }
  }
  try {
    el2[key] = value;
  } catch (e3) {
  }
  needRemove && el2.removeAttribute(key);
}
function addEventListener(el2, event, handler, options) {
  el2.addEventListener(event, handler, options);
}
function removeEventListener(el2, event, handler, options) {
  el2.removeEventListener(event, handler, options);
}
function patchEvent(el2, rawName, prevValue, nextValue, instance = null) {
  const invokers = el2._vei || (el2._vei = {});
  const existingInvoker = invokers[rawName];
  if (nextValue && existingInvoker) {
    existingInvoker.value = nextValue;
  } else {
    const [name2, options] = parseName(rawName);
    if (nextValue) {
      const invoker = invokers[rawName] = createInvoker(nextValue, instance);
      addEventListener(el2, name2, invoker, options);
    } else if (existingInvoker) {
      removeEventListener(el2, name2, existingInvoker, options);
      invokers[rawName] = void 0;
    }
  }
}
const optionsModifierRE = /(?:Once|Passive|Capture)$/;
function parseName(name2) {
  let options;
  if (optionsModifierRE.test(name2)) {
    options = {};
    let m3;
    while (m3 = name2.match(optionsModifierRE)) {
      name2 = name2.slice(0, name2.length - m3[0].length);
      options[m3[0].toLowerCase()] = true;
    }
  }
  const event = name2[2] === ":" ? name2.slice(3) : hyphenate(name2.slice(2));
  return [event, options];
}
let cachedNow = 0;
const p = /* @__PURE__ */ Promise.resolve();
const getNow = () => cachedNow || (p.then(() => cachedNow = 0), cachedNow = Date.now());
function createInvoker(initialValue, instance) {
  const invoker = (e3) => {
    if (!e3._vts) {
      e3._vts = Date.now();
    } else if (e3._vts <= invoker.attached) {
      return;
    }
    callWithAsyncErrorHandling(patchStopImmediatePropagation(e3, invoker.value), instance, 5, [e3]);
  };
  invoker.value = initialValue;
  invoker.attached = getNow();
  return invoker;
}
function patchStopImmediatePropagation(e3, value) {
  if (isArray$1(value)) {
    const originalStop = e3.stopImmediatePropagation;
    e3.stopImmediatePropagation = () => {
      originalStop.call(e3);
      e3._stopped = true;
    };
    return value.map((fn2) => (e4) => !e4._stopped && fn2 && fn2(e4));
  } else {
    return value;
  }
}
const nativeOnRE = /^on[a-z]/;
const patchProp = (el2, key, prevValue, nextValue, isSVG = false, prevChildren, parentComponent, parentSuspense, unmountChildren) => {
  if (key === "class") {
    patchClass(el2, nextValue, isSVG);
  } else if (key === "style") {
    patchStyle(el2, prevValue, nextValue);
  } else if (isOn$1(key)) {
    if (!isModelListener(key)) {
      patchEvent(el2, key, prevValue, nextValue, parentComponent);
    }
  } else if (key[0] === "." ? (key = key.slice(1), true) : key[0] === "^" ? (key = key.slice(1), false) : shouldSetAsProp(el2, key, nextValue, isSVG)) {
    patchDOMProp(el2, key, nextValue, prevChildren, parentComponent, parentSuspense, unmountChildren);
  } else {
    if (key === "true-value") {
      el2._trueValue = nextValue;
    } else if (key === "false-value") {
      el2._falseValue = nextValue;
    }
    patchAttr(el2, key, nextValue, isSVG);
  }
};
function shouldSetAsProp(el2, key, value, isSVG) {
  if (isSVG) {
    if (key === "innerHTML" || key === "textContent") {
      return true;
    }
    if (key in el2 && nativeOnRE.test(key) && isFunction$1(value)) {
      return true;
    }
    return false;
  }
  if (key === "spellcheck" || key === "draggable" || key === "translate") {
    return false;
  }
  if (key === "form") {
    return false;
  }
  if (key === "list" && el2.tagName === "INPUT") {
    return false;
  }
  if (key === "type" && el2.tagName === "TEXTAREA") {
    return false;
  }
  if (nativeOnRE.test(key) && isString$1(value)) {
    return false;
  }
  return key in el2;
}
const TRANSITION = "transition";
const ANIMATION = "animation";
const Transition = (props, { slots }) => h(BaseTransition, resolveTransitionProps(props), slots);
Transition.displayName = "Transition";
const DOMTransitionPropsValidators = {
  name: String,
  type: String,
  css: {
    type: Boolean,
    default: true
  },
  duration: [String, Number, Object],
  enterFromClass: String,
  enterActiveClass: String,
  enterToClass: String,
  appearFromClass: String,
  appearActiveClass: String,
  appearToClass: String,
  leaveFromClass: String,
  leaveActiveClass: String,
  leaveToClass: String
};
const TransitionPropsValidators = Transition.props = /* @__PURE__ */ extend$1({}, BaseTransition.props, DOMTransitionPropsValidators);
const callHook = (hook, args = []) => {
  if (isArray$1(hook)) {
    hook.forEach((h4) => h4(...args));
  } else if (hook) {
    hook(...args);
  }
};
const hasExplicitCallback = (hook) => {
  return hook ? isArray$1(hook) ? hook.some((h4) => h4.length > 1) : hook.length > 1 : false;
};
function resolveTransitionProps(rawProps) {
  const baseProps = {};
  for (const key in rawProps) {
    if (!(key in DOMTransitionPropsValidators)) {
      baseProps[key] = rawProps[key];
    }
  }
  if (rawProps.css === false) {
    return baseProps;
  }
  const { name: name2 = "v", type, duration, enterFromClass = `${name2}-enter-from`, enterActiveClass = `${name2}-enter-active`, enterToClass = `${name2}-enter-to`, appearFromClass = enterFromClass, appearActiveClass = enterActiveClass, appearToClass = enterToClass, leaveFromClass = `${name2}-leave-from`, leaveActiveClass = `${name2}-leave-active`, leaveToClass = `${name2}-leave-to` } = rawProps;
  const durations = normalizeDuration(duration);
  const enterDuration = durations && durations[0];
  const leaveDuration = durations && durations[1];
  const { onBeforeEnter, onEnter, onEnterCancelled, onLeave, onLeaveCancelled, onBeforeAppear = onBeforeEnter, onAppear = onEnter, onAppearCancelled = onEnterCancelled } = baseProps;
  const finishEnter = (el2, isAppear, done) => {
    removeTransitionClass(el2, isAppear ? appearToClass : enterToClass);
    removeTransitionClass(el2, isAppear ? appearActiveClass : enterActiveClass);
    done && done();
  };
  const finishLeave = (el2, done) => {
    el2._isLeaving = false;
    removeTransitionClass(el2, leaveFromClass);
    removeTransitionClass(el2, leaveToClass);
    removeTransitionClass(el2, leaveActiveClass);
    done && done();
  };
  const makeEnterHook = (isAppear) => {
    return (el2, done) => {
      const hook = isAppear ? onAppear : onEnter;
      const resolve2 = () => finishEnter(el2, isAppear, done);
      callHook(hook, [el2, resolve2]);
      nextFrame(() => {
        removeTransitionClass(el2, isAppear ? appearFromClass : enterFromClass);
        addTransitionClass(el2, isAppear ? appearToClass : enterToClass);
        if (!hasExplicitCallback(hook)) {
          whenTransitionEnds(el2, type, enterDuration, resolve2);
        }
      });
    };
  };
  return extend$1(baseProps, {
    onBeforeEnter(el2) {
      callHook(onBeforeEnter, [el2]);
      addTransitionClass(el2, enterFromClass);
      addTransitionClass(el2, enterActiveClass);
    },
    onBeforeAppear(el2) {
      callHook(onBeforeAppear, [el2]);
      addTransitionClass(el2, appearFromClass);
      addTransitionClass(el2, appearActiveClass);
    },
    onEnter: makeEnterHook(false),
    onAppear: makeEnterHook(true),
    onLeave(el2, done) {
      el2._isLeaving = true;
      const resolve2 = () => finishLeave(el2, done);
      addTransitionClass(el2, leaveFromClass);
      forceReflow();
      addTransitionClass(el2, leaveActiveClass);
      nextFrame(() => {
        if (!el2._isLeaving) {
          return;
        }
        removeTransitionClass(el2, leaveFromClass);
        addTransitionClass(el2, leaveToClass);
        if (!hasExplicitCallback(onLeave)) {
          whenTransitionEnds(el2, type, leaveDuration, resolve2);
        }
      });
      callHook(onLeave, [el2, resolve2]);
    },
    onEnterCancelled(el2) {
      finishEnter(el2, false);
      callHook(onEnterCancelled, [el2]);
    },
    onAppearCancelled(el2) {
      finishEnter(el2, true);
      callHook(onAppearCancelled, [el2]);
    },
    onLeaveCancelled(el2) {
      finishLeave(el2);
      callHook(onLeaveCancelled, [el2]);
    }
  });
}
function normalizeDuration(duration) {
  if (duration == null) {
    return null;
  } else if (isObject$2(duration)) {
    return [NumberOf(duration.enter), NumberOf(duration.leave)];
  } else {
    const n2 = NumberOf(duration);
    return [n2, n2];
  }
}
function NumberOf(val) {
  const res = toNumber(val);
  return res;
}
function addTransitionClass(el2, cls) {
  cls.split(/\s+/).forEach((c2) => c2 && el2.classList.add(c2));
  (el2._vtc || (el2._vtc = /* @__PURE__ */ new Set())).add(cls);
}
function removeTransitionClass(el2, cls) {
  cls.split(/\s+/).forEach((c2) => c2 && el2.classList.remove(c2));
  const { _vtc } = el2;
  if (_vtc) {
    _vtc.delete(cls);
    if (!_vtc.size) {
      el2._vtc = void 0;
    }
  }
}
function nextFrame(cb) {
  requestAnimationFrame(() => {
    requestAnimationFrame(cb);
  });
}
let endId = 0;
function whenTransitionEnds(el2, expectedType, explicitTimeout, resolve2) {
  const id = el2._endId = ++endId;
  const resolveIfNotStale = () => {
    if (id === el2._endId) {
      resolve2();
    }
  };
  if (explicitTimeout) {
    return setTimeout(resolveIfNotStale, explicitTimeout);
  }
  const { type, timeout, propCount } = getTransitionInfo(el2, expectedType);
  if (!type) {
    return resolve2();
  }
  const endEvent = type + "end";
  let ended = 0;
  const end = () => {
    el2.removeEventListener(endEvent, onEnd);
    resolveIfNotStale();
  };
  const onEnd = (e3) => {
    if (e3.target === el2 && ++ended >= propCount) {
      end();
    }
  };
  setTimeout(() => {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el2.addEventListener(endEvent, onEnd);
}
function getTransitionInfo(el2, expectedType) {
  const styles = window.getComputedStyle(el2);
  const getStyleProperties = (key) => (styles[key] || "").split(", ");
  const transitionDelays = getStyleProperties(`${TRANSITION}Delay`);
  const transitionDurations = getStyleProperties(`${TRANSITION}Duration`);
  const transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  const animationDelays = getStyleProperties(`${ANIMATION}Delay`);
  const animationDurations = getStyleProperties(`${ANIMATION}Duration`);
  const animationTimeout = getTimeout(animationDelays, animationDurations);
  let type = null;
  let timeout = 0;
  let propCount = 0;
  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
  }
  const hasTransform = type === TRANSITION && /\b(transform|all)(,|$)/.test(getStyleProperties(`${TRANSITION}Property`).toString());
  return {
    type,
    timeout,
    propCount,
    hasTransform
  };
}
function getTimeout(delays, durations) {
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }
  return Math.max(...durations.map((d3, i2) => toMs(d3) + toMs(delays[i2])));
}
function toMs(s3) {
  return Number(s3.slice(0, -1).replace(",", ".")) * 1e3;
}
function forceReflow() {
  return document.body.offsetHeight;
}
const positionMap = /* @__PURE__ */ new WeakMap();
const newPositionMap = /* @__PURE__ */ new WeakMap();
const TransitionGroupImpl = {
  name: "TransitionGroup",
  props: /* @__PURE__ */ extend$1({}, TransitionPropsValidators, {
    tag: String,
    moveClass: String
  }),
  setup(props, { slots }) {
    const instance = getCurrentInstance$1();
    const state = useTransitionState();
    let prevChildren;
    let children;
    onUpdated(() => {
      if (!prevChildren.length) {
        return;
      }
      const moveClass = props.moveClass || `${props.name || "v"}-move`;
      if (!hasCSSTransform(prevChildren[0].el, instance.vnode.el, moveClass)) {
        return;
      }
      prevChildren.forEach(callPendingCbs);
      prevChildren.forEach(recordPosition);
      const movedChildren = prevChildren.filter(applyTranslation);
      forceReflow();
      movedChildren.forEach((c2) => {
        const el2 = c2.el;
        const style = el2.style;
        addTransitionClass(el2, moveClass);
        style.transform = style.webkitTransform = style.transitionDuration = "";
        const cb = el2._moveCb = (e3) => {
          if (e3 && e3.target !== el2) {
            return;
          }
          if (!e3 || /transform$/.test(e3.propertyName)) {
            el2.removeEventListener("transitionend", cb);
            el2._moveCb = null;
            removeTransitionClass(el2, moveClass);
          }
        };
        el2.addEventListener("transitionend", cb);
      });
    });
    return () => {
      const rawProps = toRaw(props);
      const cssTransitionProps = resolveTransitionProps(rawProps);
      let tag = rawProps.tag || Fragment;
      prevChildren = children;
      children = slots.default ? getTransitionRawChildren(slots.default()) : [];
      for (let i2 = 0; i2 < children.length; i2++) {
        const child = children[i2];
        if (child.key != null) {
          setTransitionHooks(child, resolveTransitionHooks(child, cssTransitionProps, state, instance));
        }
      }
      if (prevChildren) {
        for (let i2 = 0; i2 < prevChildren.length; i2++) {
          const child = prevChildren[i2];
          setTransitionHooks(child, resolveTransitionHooks(child, cssTransitionProps, state, instance));
          positionMap.set(child, child.el.getBoundingClientRect());
        }
      }
      return createVNode(tag, null, children);
    };
  }
};
const removeMode = (props) => delete props.mode;
/* @__PURE__ */ removeMode(TransitionGroupImpl.props);
const TransitionGroup = TransitionGroupImpl;
function callPendingCbs(c2) {
  const el2 = c2.el;
  if (el2._moveCb) {
    el2._moveCb();
  }
  if (el2._enterCb) {
    el2._enterCb();
  }
}
function recordPosition(c2) {
  newPositionMap.set(c2, c2.el.getBoundingClientRect());
}
function applyTranslation(c2) {
  const oldPos = positionMap.get(c2);
  const newPos = newPositionMap.get(c2);
  const dx = oldPos.left - newPos.left;
  const dy = oldPos.top - newPos.top;
  if (dx || dy) {
    const s3 = c2.el.style;
    s3.transform = s3.webkitTransform = `translate(${dx}px,${dy}px)`;
    s3.transitionDuration = "0s";
    return c2;
  }
}
function hasCSSTransform(el2, root, moveClass) {
  const clone = el2.cloneNode();
  if (el2._vtc) {
    el2._vtc.forEach((cls) => {
      cls.split(/\s+/).forEach((c2) => c2 && clone.classList.remove(c2));
    });
  }
  moveClass.split(/\s+/).forEach((c2) => c2 && clone.classList.add(c2));
  clone.style.display = "none";
  const container = root.nodeType === 1 ? root : root.parentNode;
  container.appendChild(clone);
  const { hasTransform } = getTransitionInfo(clone);
  container.removeChild(clone);
  return hasTransform;
}
const getModelAssigner = (vnode) => {
  const fn2 = vnode.props["onUpdate:modelValue"] || false;
  return isArray$1(fn2) ? (value) => invokeArrayFns(fn2, value) : fn2;
};
function onCompositionStart(e3) {
  e3.target.composing = true;
}
function onCompositionEnd(e3) {
  const target = e3.target;
  if (target.composing) {
    target.composing = false;
    target.dispatchEvent(new Event("input"));
  }
}
const vModelText = {
  created(el2, { modifiers: { lazy, trim: trim2, number } }, vnode) {
    el2._assign = getModelAssigner(vnode);
    const castToNumber = number || vnode.props && vnode.props.type === "number";
    addEventListener(el2, lazy ? "change" : "input", (e3) => {
      if (e3.target.composing)
        return;
      let domValue = el2.value;
      if (trim2) {
        domValue = domValue.trim();
      }
      if (castToNumber) {
        domValue = looseToNumber(domValue);
      }
      el2._assign(domValue);
    });
    if (trim2) {
      addEventListener(el2, "change", () => {
        el2.value = el2.value.trim();
      });
    }
    if (!lazy) {
      addEventListener(el2, "compositionstart", onCompositionStart);
      addEventListener(el2, "compositionend", onCompositionEnd);
      addEventListener(el2, "change", onCompositionEnd);
    }
  },
  mounted(el2, { value }) {
    el2.value = value == null ? "" : value;
  },
  beforeUpdate(el2, { value, modifiers: { lazy, trim: trim2, number } }, vnode) {
    el2._assign = getModelAssigner(vnode);
    if (el2.composing)
      return;
    if (document.activeElement === el2 && el2.type !== "range") {
      if (lazy) {
        return;
      }
      if (trim2 && el2.value.trim() === value) {
        return;
      }
      if ((number || el2.type === "number") && looseToNumber(el2.value) === value) {
        return;
      }
    }
    const newValue = value == null ? "" : value;
    if (el2.value !== newValue) {
      el2.value = newValue;
    }
  }
};
const systemModifiers = ["ctrl", "shift", "alt", "meta"];
const modifierGuards = {
  stop: (e3) => e3.stopPropagation(),
  prevent: (e3) => e3.preventDefault(),
  self: (e3) => e3.target !== e3.currentTarget,
  ctrl: (e3) => !e3.ctrlKey,
  shift: (e3) => !e3.shiftKey,
  alt: (e3) => !e3.altKey,
  meta: (e3) => !e3.metaKey,
  left: (e3) => "button" in e3 && e3.button !== 0,
  middle: (e3) => "button" in e3 && e3.button !== 1,
  right: (e3) => "button" in e3 && e3.button !== 2,
  exact: (e3, modifiers) => systemModifiers.some((m3) => e3[`${m3}Key`] && !modifiers.includes(m3))
};
const withModifiers = (fn2, modifiers) => {
  return (event, ...args) => {
    for (let i2 = 0; i2 < modifiers.length; i2++) {
      const guard = modifierGuards[modifiers[i2]];
      if (guard && guard(event, modifiers))
        return;
    }
    return fn2(event, ...args);
  };
};
const keyNames = {
  esc: "escape",
  space: " ",
  up: "arrow-up",
  left: "arrow-left",
  right: "arrow-right",
  down: "arrow-down",
  delete: "backspace"
};
const withKeys = (fn2, modifiers) => {
  return (event) => {
    if (!("key" in event)) {
      return;
    }
    const eventKey = hyphenate(event.key);
    if (modifiers.some((k2) => k2 === eventKey || keyNames[k2] === eventKey)) {
      return fn2(event);
    }
  };
};
const vShow = {
  beforeMount(el2, { value }, { transition }) {
    el2._vod = el2.style.display === "none" ? "" : el2.style.display;
    if (transition && value) {
      transition.beforeEnter(el2);
    } else {
      setDisplay(el2, value);
    }
  },
  mounted(el2, { value }, { transition }) {
    if (transition && value) {
      transition.enter(el2);
    }
  },
  updated(el2, { value, oldValue }, { transition }) {
    if (!value === !oldValue)
      return;
    if (transition) {
      if (value) {
        transition.beforeEnter(el2);
        setDisplay(el2, true);
        transition.enter(el2);
      } else {
        transition.leave(el2, () => {
          setDisplay(el2, false);
        });
      }
    } else {
      setDisplay(el2, value);
    }
  },
  beforeUnmount(el2, { value }) {
    setDisplay(el2, value);
  }
};
function setDisplay(el2, value) {
  el2.style.display = value ? el2._vod : "none";
}
const rendererOptions = /* @__PURE__ */ extend$1({ patchProp }, nodeOps);
let renderer;
function ensureRenderer() {
  return renderer || (renderer = createRenderer(rendererOptions));
}
const createApp = (...args) => {
  const app2 = ensureRenderer().createApp(...args);
  const { mount } = app2;
  app2.mount = (containerOrSelector) => {
    const container = normalizeContainer(containerOrSelector);
    if (!container)
      return;
    const component = app2._component;
    if (!isFunction$1(component) && !component.render && !component.template) {
      component.template = container.innerHTML;
    }
    container.innerHTML = "";
    const proxy = mount(container, false, container instanceof SVGElement);
    if (container instanceof Element) {
      container.removeAttribute("v-cloak");
      container.setAttribute("data-v-app", "");
    }
    return proxy;
  };
  return app2;
};
function normalizeContainer(container) {
  if (isString$1(container)) {
    const res = document.querySelector(container);
    return res;
  }
  return container;
}
const SideBar_vue_vue_type_style_index_0_scoped_cd244289_lang = "";
const _export_sfc = (sfc, props) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props) {
    target[key] = val;
  }
  return target;
};
const _sfc_main$r = {
  name: "SideBar",
  props: {
    orgLogo: {
      type: String,
      required: true
    },
    activePageKey: { type: String, required: true },
    PAGES_CONFIG: { type: Object, required: true },
    PAGE_KEYS: { type: Object, required: true },
    isSidebarCollapsed: { type: Boolean, default: false }
  },
  emits: ["pageSelected"],
  data() {
    return {
      menuItems: []
    };
  },
  methods: {
    menuItemClickHandler(pageKey) {
      this.$emit("pageSelected", pageKey);
    }
  }
};
const _hoisted_1$o = { class: "logo-area" };
const _hoisted_2$m = { class: "logo" };
const _hoisted_3$m = ["src"];
const _hoisted_4$m = { class: "menu-area" };
const _hoisted_5$j = ["onClick"];
const _hoisted_6$i = { class: "menu-item-content" };
const _hoisted_7$g = { class: "menu-item-content-image" };
const _hoisted_8$g = ["src"];
const _hoisted_9$f = ["src"];
function _sfc_render$r(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock(Fragment, null, [
    createBaseVNode("div", _hoisted_1$o, [
      createBaseVNode("div", _hoisted_2$m, [
        createBaseVNode("img", {
          class: normalizeClass($props.isSidebarCollapsed ? "logoImageSmall" : "logoImageLarge"),
          src: $props.orgLogo
        }, null, 10, _hoisted_3$m)
      ])
    ]),
    createBaseVNode("div", _hoisted_4$m, [
      (openBlock(true), createElementBlock(Fragment, null, renderList($props.PAGE_KEYS, (pageKey) => {
        return openBlock(), createElementBlock("div", {
          key: pageKey,
          class: normalizeClass(`menu-item ${pageKey === $props.activePageKey ? "menu-item-selected" : ""}`),
          onClick: ($event) => $options.menuItemClickHandler(pageKey)
        }, [
          createBaseVNode("div", _hoisted_6$i, [
            createBaseVNode("div", _hoisted_7$g, [
              pageKey === $props.activePageKey ? (openBlock(), createElementBlock("img", {
                key: 0,
                src: $props.PAGES_CONFIG[pageKey].icon_active
              }, null, 8, _hoisted_8$g)) : (openBlock(), createElementBlock("img", {
                key: 1,
                src: $props.PAGES_CONFIG[pageKey].icon
              }, null, 8, _hoisted_9$f))
            ]),
            createBaseVNode("div", null, toDisplayString($props.PAGES_CONFIG[pageKey].label), 1)
          ])
        ], 10, _hoisted_5$j);
      }), 128))
    ])
  ], 64);
}
const SideBar = /* @__PURE__ */ _export_sfc(_sfc_main$r, [["render", _sfc_render$r], ["__scopeId", "data-v-cd244289"]]);
const AnyUser = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACIAAAAhCAYAAAC803lsAAAKNGlDQ1BJQ0MgUHJvZmlsZQAASImVlgdQU+kWx7970xuBJIQOoXekE0B6jYAgVRCVkECoMYQqYEMWV3AtqEizgasgCq4uRdaKBQsioICKuiCLgLIuFkAFzV5k1y1v5r15/5lvzm/O/e655ysz9w8A6RBXJEqCpQFIFqaJA71cWcvDI1i454AIaIABpIEll5cqcgkI8AWI/oz/1HQfgObjPeP5Wv/5/L+Kxo9J5QEARSKcwE/lJSN8A2E7nkicBgCMRlgzM000z3oIM8RIgwgvnmfBAgfMc/QC87/MCQ50QzgLADyZyxULACDmI3lWBk+A1CEeQdhUyI8XInwfYUdeHBd5j8RA2Cg5ec08OyOsh8wXIRyHMDv6bzUF/6gf/bU+lyv4ygvr+iJpb3c/DsuNmxQfLeamxfD/zy3630pOSv/zW/MnQY4RhgQhURUZysAbuAM/wAEs4Aa4IAnEg2ggRigNxACklbSYrLT5F93WiNaK4wVxaSwX5BRjWBwhz8SIZW5qbg7A/J1YKP824MsXIOaFv3JrqpDtmQIAteuvXHQJAM1bAJB/9FdO6wAAVGRvmtp46eKMhdz88QIMctuoyG1TQDrWBHrAGJgDa2APnIEHWAL8QTAIB6sAD8SBZKTzTJALNoECUAR2gr2gHBwE1aAGnASnQTM4By6D6+A26AK9YAAMghHwEkyCaTALQRAOokB0SAFSg7QhQ8gcYkOOkAfkCwVC4VAUJICEUDqUC22GiqBiqBw6DNVCP0BnocvQTagbeggNQePQG+gjjILJMANWgXXgRTAbdoF94GB4JSyAU+BsOB/eDpfCVfAJuAm+DN+Ge+FB+CU8hQIoEoqJUkcZo9goN5Q/KgIVixKj1qMKUSWoKlQ9qhXVjrqHGkRNoD6gsWg6moU2RtujvdEhaB46Bb0evQ1djq5BN6Gvou+hh9CT6M8YCkYZY4ixw3AwyzECTCamAFOCOYppxFzD9GJGMNNYLJaJ1cXaYL2x4dgEbA52G3Y/tgF7CduNHcZO4XA4BZwhzgHnj+Pi0nAFuDLcCdxFXA9uBPceT8Kr4c3xnvgIvBCfhy/BH8dfwPfgR/GzBGmCNsGO4E/gE9YSdhCOEFoJdwkjhFmiDFGX6EAMJiYQNxFLifXEa8THxLckEkmDZEtaRoonbSSVkk6RbpCGSB/INLIB2Y0cSU4nbycfI18iPyS/pVAoOhRnSgQljbKdUku5QnlKeS9FlzKR4kjxpTZIVUg1SfVIvaISqNpUF+oqaja1hHqGepc6IU2Q1pF2k+ZKr5eukD4r3S89JUOXMZPxl0mW2SZzXOamzBgNR9OhedD4tHxaNe0KbZiOomvS3eg8+mb6Efo1+ggDy9BlcBgJjCLGSUYnY1KWJmspGyqbJVshe152kIli6jA5zCTmDuZpZh/zo5yKnItcjNxWuXq5HrkZeSV5Z/kY+UL5Bvle+Y8KLAUPhUSFXQrNCk8U0YoGissUMxUPKF5TnFBiKNkr8ZQKlU4rPVKGlQ2UA5VzlKuVO5SnVFRVvFREKmUqV1QmVJmqzqoJqntUL6iOq9HVHNXi1faoXVR7wZJlubCSWKWsq6xJdWV1b/V09cPqneqzGroaIRp5Gg0aTzSJmmzNWM09mm2ak1pqWn5auVp1Wo+0Cdps7Tjtfdrt2jM6ujphOlt0mnXGdOV1ObrZunW6j/Uoek56KXpVevf1sfps/UT9/fpdBrCBlUGcQYXBXUPY0Now3nC/YbcRxsjWSGhUZdRvTDZ2Mc4wrjMeMmGa+JrkmTSbvFqktShi0a5F7Ys+m1qZJpkeMR0wo5ktMcszazV7Y25gzjOvML9vQbHwtNhg0WLx2tLQMsbygOUDK7qVn9UWqzarT9Y21mLreutxGy2bKJtKm342gx3A3sa+YYuxdbXdYHvO9oOdtV2a3Wm73+yN7RPtj9uPLdZdHLP4yOJhBw0HrsNhh0FHlmOU4yHHQSd1J65TldMzZ01nvvNR51EXfZcElxMur1xNXcWuja4zbnZu69wuuaPcvdwL3Ts9aB4hHuUeTz01PAWedZ6TXlZeOV6XvDHePt67vPs5Khwep5YzucRmybolV33IPkE+5T7PfA18xb6tfrDfEr/dfo+Xai8VLm32B/4c/93+TwJ0A1ICflqGXRawrGLZ80CzwNzA9iB60Oqg40HTwa7BO4IHQvRC0kPaQqmhkaG1oTNh7mHFYYPLFy1ft/x2uGJ4fHhLBC4iNOJoxNQKjxV7V4xEWkUWRPat1F2ZtfLmKsVVSavOr6au5q4+E4WJCos6HjXH9edWcaeiOdGV0ZM8N94+3ku+M38PfzzGIaY4ZjTWIbY4dkzgINgtGI9ziiuJm4h3iy+Pf53gnXAwYSbRP/FYoiQpLKkhGZ8clXxWSBMmCq+uUV2TtaZbZCgqEA2m2KXsTZkU+4iPpkKpK1Nb0hjIz7cjXS/9m/ShDMeMioz3maGZZ7JksoRZHWsN1m5dO5rtmf19DjqHl9OWq567KXdoncu6w+uh9dHr2zZobsjfMLLRa2PNJuKmxE138kzzivPebQ7b3Jqvkr8xf/gbr2/qCqQKxAX9W+y3HPwW/W38t51bLbaWbf1cyC+8VWRaVFI0t4237dZ3Zt+VfifZHru9c4f1jgM7sTuFO/t2Oe2qKZYpzi4e3u23u2kPa0/hnnd7V++9WWJZcnAfcV/6vsFS39KWMq2ynWVz5XHlvRWuFQ2VypVbK2f28/f3HHA+UH9Q5WDRwY+H4g89OOx1uKlKp6qkGludUf38SOiR9u/Z39ceVTxadPTTMeGxwZrAmqu1NrW1x5WP76iD69Lrxk9Enug66X6ypd64/nADs6HoFDiVfurFD1E/9J32Od12hn2m/kftHysb6Y2FTVDT2qbJ5rjmwZbwlu6zS862tdq3Nv5k8tOxc+rnKs7Lnt9xgXgh/4LkYvbFqUuiSxOXBZeH21a3DVxZfuX+1WVXO6/5XLtx3fP6lXaX9os3HG6cu2l38+wt9q3m29a3mzqsOhrvWN1p7LTubLprc7ely7artXtx94Uep57L99zvXb/PuX+7d2lvd19I34P+yP7BB/wHYw+THr5+lPFodmDjY8zjwifST0qeKj+t+ln/54ZB68HzQ+5DHc+Cng0M84Zf/pL6y9xI/nPK85JRtdHaMfOxc+Oe410vVrwYeSl6OTtR8KvMr5Wv9F79+Jvzbx2TyydHXotfS95se6vw9tg7y3dtUwFTT6eTp2dnCt8rvK/5wP7Q/jHs4+hs5hxurvST/qfWzz6fH0uSJRIRV8z9YgVQyIBjYwF4cwwASjgA9C7ES61Y8Gx/eBtIzWIBJXNf+Ysf+ZqXLPi6L7IGoLofgOAcAHzvAFBWDoAOUp+KeM0AKpK3B9A0+uv4Q6mxFuYLdckuiDV5IpG8RXwnrhiATzslktkqieRTNdLsAACXsha84rx83wGgrTNPA8O+r/7tzxZ85N/W+O8Ivnbwj/g7oifQY3gB+70AAAA4ZVhJZk1NACoAAAAIAAGHaQAEAAAAAQAAABoAAAAAAAKgAgAEAAAAAQAAACKgAwAEAAAAAQAAACEAAAAAZhL5vgAAAwdJREFUWAnNl0ty2kAQhnnErHjIO6qMiXIDfILADbzNynADbhD7BKmcIOQEjk8ANwjZZZcJ9oKsgl1eucom3x8krBIjaSSSKnfVMDM93T2feloju1R6IVIuwuEh9Xq9V6lU+qH/er2eX19ffwnnefvcIN1u9z2bjGmeZTODbrJYLC4sa6kqZxBlodFoXJbL5b4ikoEZ428MVzRBvaX1aJL53d3dYIVsptm/r7JNNhYRCPP09DS6ubmZxX2Pj49PgfuAvtdqtS7hGMRtkuaVpIWong2GQSYMdTGwQcheNaJ1hoaM9TnGcTRO2tgJBAjVheTcIH9HCT9aV8aC5dAvwfpZnVkjR0dHvWq1+hUXQxG+eXZNH5GN31h4ZOgEtnm6damUmREC+UEQFWYeuZLx4+NjWMCpvpkgeHtBBD3hfxMXkJV2p0589a5Csb6WLb1x8ckEoT5mCqS3QHeJS9B2u+0Hb1np/v5+7uKTCUKhrYCYKRh3idNbcHBwcC57ZOJ6qWWCKBpZGdGteMpxcMVLbRWtY3emRQr9wmpkUVYtuh2VnqrZbP5ig1MW+4x92i3XuAmNO51On9v0EzZD6cjiiNd9prGLlF2MQpvIFe6HOnpD82mh6ChHeb/EThkJdyAD3w8PD6/Y6Ce6dtDCAjbMP3Ic78iEU4Fiv5VtRoLvgscmhvT6snh4eJgsl0ujcZL4CGsrFXWSjd6iWq021Ho0PsDn0kmiID+Y+xRmj9twwrhHM8AMsmCwS5QAYoqBT5uTsRHfIn0ySoBs9995ayC+xXggJ5qeZKpgjHOLBUJxrZnbAdFuSvO+MDaItOOzguwLkxdC+yWCJMHozwKtJUkRCMVKBZFB/Jgo5mkSjPSqKdx8mgpzkHYc2GwlE0SWMRjPBhP8AVUIQns4gWTBRCA8bHNlQrElziAytmWGi/BMGWK5MIRi5wKRQxwG1YS2FwT++UHkJBhuxRMuv8+aI4WOY+O6+XX+ByvqFI75wg75Is/oJ6GuaJ/7aOIb/QsIxdwbJA5WdP5iQP4ABFJSR4UL5eYAAAAASUVORK5CYII=";
var runtime = { exports: {} };
(function(module2) {
  var runtime2 = function(exports) {
    var Op = Object.prototype;
    var hasOwn2 = Op.hasOwnProperty;
    var defineProperty = Object.defineProperty || function(obj, key, desc) {
      obj[key] = desc.value;
    };
    var undefined$1;
    var $Symbol = typeof Symbol === "function" ? Symbol : {};
    var iteratorSymbol = $Symbol.iterator || "@@iterator";
    var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
    var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
    function define(obj, key, value) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
      return obj[key];
    }
    try {
      define({}, "");
    } catch (err) {
      define = function(obj, key, value) {
        return obj[key] = value;
      };
    }
    function wrap(innerFn, outerFn, self2, tryLocsList) {
      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
      var generator = Object.create(protoGenerator.prototype);
      var context = new Context(tryLocsList || []);
      defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self2, context) });
      return generator;
    }
    exports.wrap = wrap;
    function tryCatch(fn2, obj, arg) {
      try {
        return { type: "normal", arg: fn2.call(obj, arg) };
      } catch (err) {
        return { type: "throw", arg: err };
      }
    }
    var GenStateSuspendedStart = "suspendedStart";
    var GenStateSuspendedYield = "suspendedYield";
    var GenStateExecuting = "executing";
    var GenStateCompleted = "completed";
    var ContinueSentinel = {};
    function Generator() {
    }
    function GeneratorFunction() {
    }
    function GeneratorFunctionPrototype() {
    }
    var IteratorPrototype = {};
    define(IteratorPrototype, iteratorSymbol, function() {
      return this;
    });
    var getProto2 = Object.getPrototypeOf;
    var NativeIteratorPrototype = getProto2 && getProto2(getProto2(values([])));
    if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn2.call(NativeIteratorPrototype, iteratorSymbol)) {
      IteratorPrototype = NativeIteratorPrototype;
    }
    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
    GeneratorFunction.prototype = GeneratorFunctionPrototype;
    defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: true });
    defineProperty(
      GeneratorFunctionPrototype,
      "constructor",
      { value: GeneratorFunction, configurable: true }
    );
    GeneratorFunction.displayName = define(
      GeneratorFunctionPrototype,
      toStringTagSymbol,
      "GeneratorFunction"
    );
    function defineIteratorMethods(prototype2) {
      ["next", "throw", "return"].forEach(function(method) {
        define(prototype2, method, function(arg) {
          return this._invoke(method, arg);
        });
      });
    }
    exports.isGeneratorFunction = function(genFun) {
      var ctor = typeof genFun === "function" && genFun.constructor;
      return ctor ? ctor === GeneratorFunction || (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
    };
    exports.mark = function(genFun) {
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
      } else {
        genFun.__proto__ = GeneratorFunctionPrototype;
        define(genFun, toStringTagSymbol, "GeneratorFunction");
      }
      genFun.prototype = Object.create(Gp);
      return genFun;
    };
    exports.awrap = function(arg) {
      return { __await: arg };
    };
    function AsyncIterator(generator, PromiseImpl) {
      function invoke(method, arg, resolve2, reject) {
        var record = tryCatch(generator[method], generator, arg);
        if (record.type === "throw") {
          reject(record.arg);
        } else {
          var result = record.arg;
          var value = result.value;
          if (value && typeof value === "object" && hasOwn2.call(value, "__await")) {
            return PromiseImpl.resolve(value.__await).then(function(value2) {
              invoke("next", value2, resolve2, reject);
            }, function(err) {
              invoke("throw", err, resolve2, reject);
            });
          }
          return PromiseImpl.resolve(value).then(function(unwrapped) {
            result.value = unwrapped;
            resolve2(result);
          }, function(error) {
            return invoke("throw", error, resolve2, reject);
          });
        }
      }
      var previousPromise;
      function enqueue(method, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function(resolve2, reject) {
            invoke(method, arg, resolve2, reject);
          });
        }
        return previousPromise = previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
      }
      defineProperty(this, "_invoke", { value: enqueue });
    }
    defineIteratorMethods(AsyncIterator.prototype);
    define(AsyncIterator.prototype, asyncIteratorSymbol, function() {
      return this;
    });
    exports.AsyncIterator = AsyncIterator;
    exports.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
      if (PromiseImpl === void 0)
        PromiseImpl = Promise;
      var iter = new AsyncIterator(
        wrap(innerFn, outerFn, self2, tryLocsList),
        PromiseImpl
      );
      return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
        return result.done ? result.value : iter.next();
      });
    };
    function makeInvokeMethod(innerFn, self2, context) {
      var state = GenStateSuspendedStart;
      return function invoke(method, arg) {
        if (state === GenStateExecuting) {
          throw new Error("Generator is already running");
        }
        if (state === GenStateCompleted) {
          if (method === "throw") {
            throw arg;
          }
          return doneResult();
        }
        context.method = method;
        context.arg = arg;
        while (true) {
          var delegate = context.delegate;
          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context);
            if (delegateResult) {
              if (delegateResult === ContinueSentinel)
                continue;
              return delegateResult;
            }
          }
          if (context.method === "next") {
            context.sent = context._sent = context.arg;
          } else if (context.method === "throw") {
            if (state === GenStateSuspendedStart) {
              state = GenStateCompleted;
              throw context.arg;
            }
            context.dispatchException(context.arg);
          } else if (context.method === "return") {
            context.abrupt("return", context.arg);
          }
          state = GenStateExecuting;
          var record = tryCatch(innerFn, self2, context);
          if (record.type === "normal") {
            state = context.done ? GenStateCompleted : GenStateSuspendedYield;
            if (record.arg === ContinueSentinel) {
              continue;
            }
            return {
              value: record.arg,
              done: context.done
            };
          } else if (record.type === "throw") {
            state = GenStateCompleted;
            context.method = "throw";
            context.arg = record.arg;
          }
        }
      };
    }
    function maybeInvokeDelegate(delegate, context) {
      var methodName = context.method;
      var method = delegate.iterator[methodName];
      if (method === undefined$1) {
        context.delegate = null;
        if (methodName === "throw" && delegate.iterator["return"]) {
          context.method = "return";
          context.arg = undefined$1;
          maybeInvokeDelegate(delegate, context);
          if (context.method === "throw") {
            return ContinueSentinel;
          }
        }
        if (methodName !== "return") {
          context.method = "throw";
          context.arg = new TypeError(
            "The iterator does not provide a '" + methodName + "' method"
          );
        }
        return ContinueSentinel;
      }
      var record = tryCatch(method, delegate.iterator, context.arg);
      if (record.type === "throw") {
        context.method = "throw";
        context.arg = record.arg;
        context.delegate = null;
        return ContinueSentinel;
      }
      var info = record.arg;
      if (!info) {
        context.method = "throw";
        context.arg = new TypeError("iterator result is not an object");
        context.delegate = null;
        return ContinueSentinel;
      }
      if (info.done) {
        context[delegate.resultName] = info.value;
        context.next = delegate.nextLoc;
        if (context.method !== "return") {
          context.method = "next";
          context.arg = undefined$1;
        }
      } else {
        return info;
      }
      context.delegate = null;
      return ContinueSentinel;
    }
    defineIteratorMethods(Gp);
    define(Gp, toStringTagSymbol, "Generator");
    define(Gp, iteratorSymbol, function() {
      return this;
    });
    define(Gp, "toString", function() {
      return "[object Generator]";
    });
    function pushTryEntry(locs) {
      var entry = { tryLoc: locs[0] };
      if (1 in locs) {
        entry.catchLoc = locs[1];
      }
      if (2 in locs) {
        entry.finallyLoc = locs[2];
        entry.afterLoc = locs[3];
      }
      this.tryEntries.push(entry);
    }
    function resetTryEntry(entry) {
      var record = entry.completion || {};
      record.type = "normal";
      delete record.arg;
      entry.completion = record;
    }
    function Context(tryLocsList) {
      this.tryEntries = [{ tryLoc: "root" }];
      tryLocsList.forEach(pushTryEntry, this);
      this.reset(true);
    }
    exports.keys = function(val) {
      var object = Object(val);
      var keys = [];
      for (var key in object) {
        keys.push(key);
      }
      keys.reverse();
      return function next() {
        while (keys.length) {
          var key2 = keys.pop();
          if (key2 in object) {
            next.value = key2;
            next.done = false;
            return next;
          }
        }
        next.done = true;
        return next;
      };
    };
    function values(iterable) {
      if (iterable) {
        var iteratorMethod = iterable[iteratorSymbol];
        if (iteratorMethod) {
          return iteratorMethod.call(iterable);
        }
        if (typeof iterable.next === "function") {
          return iterable;
        }
        if (!isNaN(iterable.length)) {
          var i2 = -1, next = function next2() {
            while (++i2 < iterable.length) {
              if (hasOwn2.call(iterable, i2)) {
                next2.value = iterable[i2];
                next2.done = false;
                return next2;
              }
            }
            next2.value = undefined$1;
            next2.done = true;
            return next2;
          };
          return next.next = next;
        }
      }
      return { next: doneResult };
    }
    exports.values = values;
    function doneResult() {
      return { value: undefined$1, done: true };
    }
    Context.prototype = {
      constructor: Context,
      reset: function(skipTempReset) {
        this.prev = 0;
        this.next = 0;
        this.sent = this._sent = undefined$1;
        this.done = false;
        this.delegate = null;
        this.method = "next";
        this.arg = undefined$1;
        this.tryEntries.forEach(resetTryEntry);
        if (!skipTempReset) {
          for (var name2 in this) {
            if (name2.charAt(0) === "t" && hasOwn2.call(this, name2) && !isNaN(+name2.slice(1))) {
              this[name2] = undefined$1;
            }
          }
        }
      },
      stop: function() {
        this.done = true;
        var rootEntry = this.tryEntries[0];
        var rootRecord = rootEntry.completion;
        if (rootRecord.type === "throw") {
          throw rootRecord.arg;
        }
        return this.rval;
      },
      dispatchException: function(exception) {
        if (this.done) {
          throw exception;
        }
        var context = this;
        function handle(loc, caught) {
          record.type = "throw";
          record.arg = exception;
          context.next = loc;
          if (caught) {
            context.method = "next";
            context.arg = undefined$1;
          }
          return !!caught;
        }
        for (var i2 = this.tryEntries.length - 1; i2 >= 0; --i2) {
          var entry = this.tryEntries[i2];
          var record = entry.completion;
          if (entry.tryLoc === "root") {
            return handle("end");
          }
          if (entry.tryLoc <= this.prev) {
            var hasCatch = hasOwn2.call(entry, "catchLoc");
            var hasFinally = hasOwn2.call(entry, "finallyLoc");
            if (hasCatch && hasFinally) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              } else if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }
            } else if (hasCatch) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              }
            } else if (hasFinally) {
              if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }
            } else {
              throw new Error("try statement without catch or finally");
            }
          }
        }
      },
      abrupt: function(type, arg) {
        for (var i2 = this.tryEntries.length - 1; i2 >= 0; --i2) {
          var entry = this.tryEntries[i2];
          if (entry.tryLoc <= this.prev && hasOwn2.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
            var finallyEntry = entry;
            break;
          }
        }
        if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
          finallyEntry = null;
        }
        var record = finallyEntry ? finallyEntry.completion : {};
        record.type = type;
        record.arg = arg;
        if (finallyEntry) {
          this.method = "next";
          this.next = finallyEntry.finallyLoc;
          return ContinueSentinel;
        }
        return this.complete(record);
      },
      complete: function(record, afterLoc) {
        if (record.type === "throw") {
          throw record.arg;
        }
        if (record.type === "break" || record.type === "continue") {
          this.next = record.arg;
        } else if (record.type === "return") {
          this.rval = this.arg = record.arg;
          this.method = "return";
          this.next = "end";
        } else if (record.type === "normal" && afterLoc) {
          this.next = afterLoc;
        }
        return ContinueSentinel;
      },
      finish: function(finallyLoc) {
        for (var i2 = this.tryEntries.length - 1; i2 >= 0; --i2) {
          var entry = this.tryEntries[i2];
          if (entry.finallyLoc === finallyLoc) {
            this.complete(entry.completion, entry.afterLoc);
            resetTryEntry(entry);
            return ContinueSentinel;
          }
        }
      },
      "catch": function(tryLoc) {
        for (var i2 = this.tryEntries.length - 1; i2 >= 0; --i2) {
          var entry = this.tryEntries[i2];
          if (entry.tryLoc === tryLoc) {
            var record = entry.completion;
            if (record.type === "throw") {
              var thrown = record.arg;
              resetTryEntry(entry);
            }
            return thrown;
          }
        }
        throw new Error("illegal catch attempt");
      },
      delegateYield: function(iterable, resultName, nextLoc) {
        this.delegate = {
          iterator: values(iterable),
          resultName,
          nextLoc
        };
        if (this.method === "next") {
          this.arg = undefined$1;
        }
        return ContinueSentinel;
      }
    };
    return exports;
  }(
    module2.exports
  );
  try {
    regeneratorRuntime = runtime2;
  } catch (accidentalStrictMode) {
    if (typeof globalThis === "object") {
      globalThis.regeneratorRuntime = runtime2;
    } else {
      Function("r", "regeneratorRuntime = r")(runtime2);
    }
  }
})(runtime);
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$4 = function(d3, b3) {
  extendStatics$4 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b4) {
    d4.__proto__ = b4;
  } || function(d4, b4) {
    for (var p2 in b4)
      if (b4.hasOwnProperty(p2))
        d4[p2] = b4[p2];
  };
  return extendStatics$4(d3, b3);
};
function __extends$4(d3, b3) {
  extendStatics$4(d3, b3);
  function __() {
    this.constructor = d3;
  }
  d3.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __());
}
var __assign$c = function() {
  __assign$c = Object.assign || function __assign2(t3) {
    for (var s3, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s3 = arguments[i2];
      for (var p2 in s3)
        if (Object.prototype.hasOwnProperty.call(s3, p2))
          t3[p2] = s3[p2];
    }
    return t3;
  };
  return __assign$c.apply(this, arguments);
};
function __awaiter$e(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator$e(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t3[0] & 1)
      throw t3[1];
    return t3[1];
  }, trys: [], ops: [] }, f, y3, t3, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n2) {
    return function(v) {
      return step([n2, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_2)
      try {
        if (f = 1, y3 && (t3 = op[0] & 2 ? y3["return"] : op[0] ? y3["throw"] || ((t3 = y3["return"]) && t3.call(y3), 0) : y3.next) && !(t3 = t3.call(y3, op[1])).done)
          return t3;
        if (y3 = 0, t3)
          op = [op[0] & 2, t3.value];
        switch (op[0]) {
          case 0:
          case 1:
            t3 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y3 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t3 = _2.trys, t3 = t3.length > 0 && t3[t3.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t3 || op[1] > t3[0] && op[1] < t3[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t3[1]) {
              _2.label = t3[1];
              t3 = op;
              break;
            }
            if (t3 && _2.label < t3[2]) {
              _2.label = t3[2];
              _2.ops.push(op);
              break;
            }
            if (t3[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e3) {
        op = [6, e3];
        y3 = 0;
      } finally {
        f = t3 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __values$5(o2) {
  var s3 = typeof Symbol === "function" && Symbol.iterator, m3 = s3 && o2[s3], i2 = 0;
  if (m3)
    return m3.call(o2);
  if (o2 && typeof o2.length === "number")
    return {
      next: function() {
        if (o2 && i2 >= o2.length)
          o2 = void 0;
        return { value: o2 && o2[i2++], done: !o2 };
      }
    };
  throw new TypeError(s3 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read$b(o2, n2) {
  var m3 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m3)
    return o2;
  var i2 = m3.call(o2), r2, ar2 = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
      ar2.push(r2.value);
  } catch (error) {
    e3 = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m3 = i2["return"]))
        m3.call(i2);
    } finally {
      if (e3)
        throw e3.error;
    }
  }
  return ar2;
}
function __spread$6() {
  for (var ar2 = [], i2 = 0; i2 < arguments.length; i2++)
    ar2 = ar2.concat(__read$b(arguments[i2]));
  return ar2;
}
var AWS_CLOUDWATCH_CATEGORY = "Logging";
var LOG_LEVELS = {
  VERBOSE: 1,
  DEBUG: 2,
  INFO: 3,
  WARN: 4,
  ERROR: 5
};
var LOG_TYPE;
(function(LOG_TYPE2) {
  LOG_TYPE2["DEBUG"] = "DEBUG";
  LOG_TYPE2["ERROR"] = "ERROR";
  LOG_TYPE2["INFO"] = "INFO";
  LOG_TYPE2["WARN"] = "WARN";
  LOG_TYPE2["VERBOSE"] = "VERBOSE";
})(LOG_TYPE || (LOG_TYPE = {}));
var ConsoleLogger = function() {
  function ConsoleLogger2(name2, level) {
    if (level === void 0) {
      level = LOG_TYPE.WARN;
    }
    this.name = name2;
    this.level = level;
    this._pluggables = [];
  }
  ConsoleLogger2.prototype._padding = function(n2) {
    return n2 < 10 ? "0" + n2 : "" + n2;
  };
  ConsoleLogger2.prototype._ts = function() {
    var dt = new Date();
    return [this._padding(dt.getMinutes()), this._padding(dt.getSeconds())].join(":") + "." + dt.getMilliseconds();
  };
  ConsoleLogger2.prototype.configure = function(config) {
    if (!config)
      return this._config;
    this._config = config;
    return this._config;
  };
  ConsoleLogger2.prototype._log = function(type) {
    var e_1, _a2;
    var msg = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      msg[_i - 1] = arguments[_i];
    }
    var logger_level_name = this.level;
    if (ConsoleLogger2.LOG_LEVEL) {
      logger_level_name = ConsoleLogger2.LOG_LEVEL;
    }
    if (typeof window !== "undefined" && window.LOG_LEVEL) {
      logger_level_name = window.LOG_LEVEL;
    }
    var logger_level = LOG_LEVELS[logger_level_name];
    var type_level = LOG_LEVELS[type];
    if (!(type_level >= logger_level)) {
      return;
    }
    var log = console.log.bind(console);
    if (type === LOG_TYPE.ERROR && console.error) {
      log = console.error.bind(console);
    }
    if (type === LOG_TYPE.WARN && console.warn) {
      log = console.warn.bind(console);
    }
    var prefix = "[" + type + "] " + this._ts() + " " + this.name;
    var message = "";
    if (msg.length === 1 && typeof msg[0] === "string") {
      message = prefix + " - " + msg[0];
      log(message);
    } else if (msg.length === 1) {
      message = prefix + " " + msg[0];
      log(prefix, msg[0]);
    } else if (typeof msg[0] === "string") {
      var obj = msg.slice(1);
      if (obj.length === 1) {
        obj = obj[0];
      }
      message = prefix + " - " + msg[0] + " " + obj;
      log(prefix + " - " + msg[0], obj);
    } else {
      message = prefix + " " + msg;
      log(prefix, msg);
    }
    try {
      for (var _b = __values$5(this._pluggables), _c = _b.next(); !_c.done; _c = _b.next()) {
        var plugin2 = _c.value;
        var logEvent = { message, timestamp: Date.now() };
        plugin2.pushLogs([logEvent]);
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (_c && !_c.done && (_a2 = _b.return))
          _a2.call(_b);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
  };
  ConsoleLogger2.prototype.log = function() {
    var msg = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      msg[_i] = arguments[_i];
    }
    this._log.apply(this, __spread$6([LOG_TYPE.INFO], msg));
  };
  ConsoleLogger2.prototype.info = function() {
    var msg = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      msg[_i] = arguments[_i];
    }
    this._log.apply(this, __spread$6([LOG_TYPE.INFO], msg));
  };
  ConsoleLogger2.prototype.warn = function() {
    var msg = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      msg[_i] = arguments[_i];
    }
    this._log.apply(this, __spread$6([LOG_TYPE.WARN], msg));
  };
  ConsoleLogger2.prototype.error = function() {
    var msg = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      msg[_i] = arguments[_i];
    }
    this._log.apply(this, __spread$6([LOG_TYPE.ERROR], msg));
  };
  ConsoleLogger2.prototype.debug = function() {
    var msg = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      msg[_i] = arguments[_i];
    }
    this._log.apply(this, __spread$6([LOG_TYPE.DEBUG], msg));
  };
  ConsoleLogger2.prototype.verbose = function() {
    var msg = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      msg[_i] = arguments[_i];
    }
    this._log.apply(this, __spread$6([LOG_TYPE.VERBOSE], msg));
  };
  ConsoleLogger2.prototype.addPluggable = function(pluggable) {
    if (pluggable && pluggable.getCategoryName() === AWS_CLOUDWATCH_CATEGORY) {
      this._pluggables.push(pluggable);
      pluggable.configure(this._config);
    }
  };
  ConsoleLogger2.prototype.listPluggables = function() {
    return this._pluggables;
  };
  ConsoleLogger2.LOG_LEVEL = null;
  return ConsoleLogger2;
}();
var logger$a = new ConsoleLogger("Amplify");
var AmplifyClass = function() {
  function AmplifyClass2() {
    this._components = [];
    this._config = {};
    this._modules = {};
    this.Auth = null;
    this.Analytics = null;
    this.API = null;
    this.Credentials = null;
    this.Storage = null;
    this.I18n = null;
    this.Cache = null;
    this.PubSub = null;
    this.Interactions = null;
    this.Pushnotification = null;
    this.UI = null;
    this.XR = null;
    this.Predictions = null;
    this.DataStore = null;
    this.Geo = null;
    this.Notifications = null;
    this.Logger = ConsoleLogger;
    this.ServiceWorker = null;
  }
  AmplifyClass2.prototype.register = function(comp) {
    logger$a.debug("component registered in amplify", comp);
    this._components.push(comp);
    if (typeof comp.getModuleName === "function") {
      this._modules[comp.getModuleName()] = comp;
      this[comp.getModuleName()] = comp;
    } else {
      logger$a.debug("no getModuleName method for component", comp);
    }
    comp.configure(this._config);
  };
  AmplifyClass2.prototype.configure = function(config) {
    var _this = this;
    if (!config)
      return this._config;
    this._config = Object.assign(this._config, config);
    logger$a.debug("amplify config", this._config);
    Object.entries(this._modules).forEach(function(_a2) {
      var _b = __read$b(_a2, 2);
      _b[0];
      var comp = _b[1];
      Object.keys(comp).forEach(function(property) {
        if (_this._modules[property]) {
          comp[property] = _this._modules[property];
        }
      });
    });
    this._components.map(function(comp) {
      comp.configure(_this._config);
    });
    return this._config;
  };
  AmplifyClass2.prototype.addPluggable = function(pluggable) {
    if (pluggable && pluggable["getCategory"] && typeof pluggable["getCategory"] === "function") {
      this._components.map(function(comp) {
        if (comp["addPluggable"] && typeof comp["addPluggable"] === "function") {
          comp.addPluggable(pluggable);
        }
      });
    }
  };
  return AmplifyClass2;
}();
var Amplify = new AmplifyClass();
var version$3 = "5.0.13";
var BASE_USER_AGENT$1 = "aws-amplify/" + version$3;
var Platform$1 = {
  userAgent: BASE_USER_AGENT$1 + " js",
  product: "",
  navigator: null,
  isReactNative: false
};
if (typeof navigator !== "undefined" && navigator.product) {
  Platform$1.product = navigator.product || "";
  Platform$1.navigator = navigator || null;
  switch (navigator.product) {
    case "ReactNative":
      Platform$1.userAgent = BASE_USER_AGENT$1 + " react-native";
      Platform$1.isReactNative = true;
      break;
    default:
      Platform$1.userAgent = BASE_USER_AGENT$1 + " js";
      Platform$1.isReactNative = false;
      break;
  }
}
var getAmplifyUserAgent = function(content) {
  return "" + Platform$1.userAgent + (content ? content : "");
};
var logger$9 = new ConsoleLogger("Hub");
var AMPLIFY_SYMBOL$3 = typeof Symbol !== "undefined" && typeof Symbol.for === "function" ? Symbol.for("amplify_default") : "@@amplify_default";
function isLegacyCallback(callback) {
  return callback.onHubCapsule !== void 0;
}
var HubClass = function() {
  function HubClass2(name2) {
    this.listeners = [];
    this.patterns = [];
    this.protectedChannels = [
      "core",
      "auth",
      "api",
      "analytics",
      "interactions",
      "pubsub",
      "storage",
      "ui",
      "xr"
    ];
    this.name = name2;
  }
  HubClass2.prototype._remove = function(channel, listener) {
    if (channel instanceof RegExp) {
      var pattern_1 = this.patterns.find(function(_a2) {
        var pattern = _a2.pattern;
        return pattern.source === channel.source;
      });
      if (!pattern_1) {
        logger$9.warn("No listeners for " + channel);
        return;
      }
      this.patterns = __spread$6(this.patterns.filter(function(x2) {
        return x2 !== pattern_1;
      }));
    } else {
      var holder = this.listeners[channel];
      if (!holder) {
        logger$9.warn("No listeners for " + channel);
        return;
      }
      this.listeners[channel] = __spread$6(holder.filter(function(_a2) {
        var callback = _a2.callback;
        return callback !== listener;
      }));
    }
  };
  HubClass2.prototype.remove = function(channel, listener) {
    this._remove(channel, listener);
  };
  HubClass2.prototype.dispatch = function(channel, payload, source, ampSymbol) {
    if (source === void 0) {
      source = "";
    }
    if (this.protectedChannels.indexOf(channel) > -1) {
      var hasAccess = ampSymbol === AMPLIFY_SYMBOL$3;
      if (!hasAccess) {
        logger$9.warn("WARNING: " + channel + " is protected and dispatching on it can have unintended consequences");
      }
    }
    var capsule = {
      channel,
      payload: __assign$c({}, payload),
      source,
      patternInfo: []
    };
    try {
      this._toListeners(capsule);
    } catch (e3) {
      logger$9.error(e3);
    }
  };
  HubClass2.prototype.listen = function(channel, callback, listenerName) {
    var _this = this;
    if (listenerName === void 0) {
      listenerName = "noname";
    }
    var cb;
    if (isLegacyCallback(callback)) {
      logger$9.warn("WARNING onHubCapsule is Deprecated. Please pass in a callback.");
      cb = callback.onHubCapsule.bind(callback);
    } else if (typeof callback !== "function") {
      throw new Error("No callback supplied to Hub");
    } else {
      cb = callback;
    }
    if (channel instanceof RegExp) {
      this.patterns.push({
        pattern: channel,
        callback: cb
      });
    } else {
      var holder = this.listeners[channel];
      if (!holder) {
        holder = [];
        this.listeners[channel] = holder;
      }
      holder.push({
        name: listenerName,
        callback: cb
      });
    }
    return function() {
      _this._remove(channel, cb);
    };
  };
  HubClass2.prototype._toListeners = function(capsule) {
    var channel = capsule.channel, payload = capsule.payload;
    var holder = this.listeners[channel];
    if (holder) {
      holder.forEach(function(listener) {
        logger$9.debug("Dispatching to " + channel + " with ", payload);
        try {
          listener.callback(capsule);
        } catch (e3) {
          logger$9.error(e3);
        }
      });
    }
    if (this.patterns.length > 0) {
      if (!payload.message) {
        logger$9.warn("Cannot perform pattern matching without a message key");
        return;
      }
      var payloadStr_1 = payload.message;
      this.patterns.forEach(function(pattern) {
        var match2 = payloadStr_1.match(pattern.pattern);
        if (match2) {
          var _a2 = __read$b(match2), groups = _a2.slice(1);
          var dispatchingCapsule = __assign$c(__assign$c({}, capsule), { patternInfo: groups });
          try {
            pattern.callback(dispatchingCapsule);
          } catch (e3) {
            logger$9.error(e3);
          }
        }
      });
    }
  };
  return HubClass2;
}();
var Hub = new HubClass("__default__");
var makeQuerablePromise = function(promise) {
  if (promise.isResolved)
    return promise;
  var isPending = true;
  var isRejected = false;
  var isFullfilled = false;
  var result = promise.then(function(data) {
    isFullfilled = true;
    isPending = false;
    return data;
  }, function(e3) {
    isRejected = true;
    isPending = false;
    throw e3;
  });
  result.isFullfilled = function() {
    return isFullfilled;
  };
  result.isPending = function() {
    return isPending;
  };
  result.isRejected = function() {
    return isRejected;
  };
  return result;
};
var browserOrNode = function() {
  var isBrowser2 = typeof window !== "undefined" && typeof window.document !== "undefined";
  var isNode = typeof process !== "undefined" && process.versions != null && process.versions.node != null;
  return {
    isBrowser: isBrowser2,
    isNode
  };
};
var build$4 = {};
var tslib$3 = { exports: {} };
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
(function(module2) {
  var __extends2;
  var __assign2;
  var __rest2;
  var __decorate;
  var __param;
  var __metadata;
  var __awaiter2;
  var __generator2;
  var __exportStar;
  var __values2;
  var __read2;
  var __spread2;
  var __spreadArrays;
  var __await;
  var __asyncGenerator;
  var __asyncDelegator;
  var __asyncValues;
  var __makeTemplateObject;
  var __importStar;
  var __importDefault;
  var __classPrivateFieldGet;
  var __classPrivateFieldSet;
  var __createBinding;
  (function(factory) {
    var root = typeof commonjsGlobal === "object" ? commonjsGlobal : typeof self === "object" ? self : typeof this === "object" ? this : {};
    {
      factory(createExporter(root, createExporter(module2.exports)));
    }
    function createExporter(exports, previous) {
      if (exports !== root) {
        if (typeof Object.create === "function") {
          Object.defineProperty(exports, "__esModule", { value: true });
        } else {
          exports.__esModule = true;
        }
      }
      return function(id, v) {
        return exports[id] = previous ? previous(id, v) : v;
      };
    }
  })(function(exporter) {
    var extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p2 in b3)
        if (b3.hasOwnProperty(p2))
          d3[p2] = b3[p2];
    };
    __extends2 = function(d3, b3) {
      extendStatics2(d3, b3);
      function __() {
        this.constructor = d3;
      }
      d3.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __());
    };
    __assign2 = Object.assign || function(t3) {
      for (var s3, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
        s3 = arguments[i2];
        for (var p2 in s3)
          if (Object.prototype.hasOwnProperty.call(s3, p2))
            t3[p2] = s3[p2];
      }
      return t3;
    };
    __rest2 = function(s3, e3) {
      var t3 = {};
      for (var p2 in s3)
        if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
          t3[p2] = s3[p2];
      if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s3); i2 < p2.length; i2++) {
          if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i2]))
            t3[p2[i2]] = s3[p2[i2]];
        }
      return t3;
    };
    __decorate = function(decorators, target, key, desc) {
      var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r2 = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i2 = decorators.length - 1; i2 >= 0; i2--)
          if (d3 = decorators[i2])
            r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key, r2) : d3(target, key)) || r2;
      return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
    };
    __param = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    __metadata = function(metadataKey, metadataValue) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(metadataKey, metadataValue);
    };
    __awaiter2 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e3) {
            reject(e3);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e3) {
            reject(e3);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    __generator2 = function(thisArg, body) {
      var _2 = { label: 0, sent: function() {
        if (t3[0] & 1)
          throw t3[1];
        return t3[1];
      }, trys: [], ops: [] }, f, y3, t3, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n2) {
        return function(v) {
          return step([n2, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_2)
          try {
            if (f = 1, y3 && (t3 = op[0] & 2 ? y3["return"] : op[0] ? y3["throw"] || ((t3 = y3["return"]) && t3.call(y3), 0) : y3.next) && !(t3 = t3.call(y3, op[1])).done)
              return t3;
            if (y3 = 0, t3)
              op = [op[0] & 2, t3.value];
            switch (op[0]) {
              case 0:
              case 1:
                t3 = op;
                break;
              case 4:
                _2.label++;
                return { value: op[1], done: false };
              case 5:
                _2.label++;
                y3 = op[1];
                op = [0];
                continue;
              case 7:
                op = _2.ops.pop();
                _2.trys.pop();
                continue;
              default:
                if (!(t3 = _2.trys, t3 = t3.length > 0 && t3[t3.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _2 = 0;
                  continue;
                }
                if (op[0] === 3 && (!t3 || op[1] > t3[0] && op[1] < t3[3])) {
                  _2.label = op[1];
                  break;
                }
                if (op[0] === 6 && _2.label < t3[1]) {
                  _2.label = t3[1];
                  t3 = op;
                  break;
                }
                if (t3 && _2.label < t3[2]) {
                  _2.label = t3[2];
                  _2.ops.push(op);
                  break;
                }
                if (t3[2])
                  _2.ops.pop();
                _2.trys.pop();
                continue;
            }
            op = body.call(thisArg, _2);
          } catch (e3) {
            op = [6, e3];
            y3 = 0;
          } finally {
            f = t3 = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    __createBinding = function(o2, m3, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m3[k2];
    };
    __exportStar = function(m3, exports) {
      for (var p2 in m3)
        if (p2 !== "default" && !exports.hasOwnProperty(p2))
          exports[p2] = m3[p2];
    };
    __values2 = function(o2) {
      var s3 = typeof Symbol === "function" && Symbol.iterator, m3 = s3 && o2[s3], i2 = 0;
      if (m3)
        return m3.call(o2);
      if (o2 && typeof o2.length === "number")
        return {
          next: function() {
            if (o2 && i2 >= o2.length)
              o2 = void 0;
            return { value: o2 && o2[i2++], done: !o2 };
          }
        };
      throw new TypeError(s3 ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    __read2 = function(o2, n2) {
      var m3 = typeof Symbol === "function" && o2[Symbol.iterator];
      if (!m3)
        return o2;
      var i2 = m3.call(o2), r2, ar2 = [], e3;
      try {
        while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
          ar2.push(r2.value);
      } catch (error) {
        e3 = { error };
      } finally {
        try {
          if (r2 && !r2.done && (m3 = i2["return"]))
            m3.call(i2);
        } finally {
          if (e3)
            throw e3.error;
        }
      }
      return ar2;
    };
    __spread2 = function() {
      for (var ar2 = [], i2 = 0; i2 < arguments.length; i2++)
        ar2 = ar2.concat(__read2(arguments[i2]));
      return ar2;
    };
    __spreadArrays = function() {
      for (var s3 = 0, i2 = 0, il2 = arguments.length; i2 < il2; i2++)
        s3 += arguments[i2].length;
      for (var r2 = Array(s3), k2 = 0, i2 = 0; i2 < il2; i2++)
        for (var a3 = arguments[i2], j = 0, jl2 = a3.length; j < jl2; j++, k2++)
          r2[k2] = a3[j];
      return r2;
    };
    __await = function(v) {
      return this instanceof __await ? (this.v = v, this) : new __await(v);
    };
    __asyncGenerator = function(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var g = generator.apply(thisArg, _arguments || []), i2, q2 = [];
      return i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
        return this;
      }, i2;
      function verb(n2) {
        if (g[n2])
          i2[n2] = function(v) {
            return new Promise(function(a3, b3) {
              q2.push([n2, v, a3, b3]) > 1 || resume(n2, v);
            });
          };
      }
      function resume(n2, v) {
        try {
          step(g[n2](v));
        } catch (e3) {
          settle2(q2[0][3], e3);
        }
      }
      function step(r2) {
        r2.value instanceof __await ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle2(q2[0][2], r2);
      }
      function fulfill(value) {
        resume("next", value);
      }
      function reject(value) {
        resume("throw", value);
      }
      function settle2(f, v) {
        if (f(v), q2.shift(), q2.length)
          resume(q2[0][0], q2[0][1]);
      }
    };
    __asyncDelegator = function(o2) {
      var i2, p2;
      return i2 = {}, verb("next"), verb("throw", function(e3) {
        throw e3;
      }), verb("return"), i2[Symbol.iterator] = function() {
        return this;
      }, i2;
      function verb(n2, f) {
        i2[n2] = o2[n2] ? function(v) {
          return (p2 = !p2) ? { value: __await(o2[n2](v)), done: n2 === "return" } : f ? f(v) : v;
        } : f;
      }
    };
    __asyncValues = function(o2) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var m3 = o2[Symbol.asyncIterator], i2;
      return m3 ? m3.call(o2) : (o2 = typeof __values2 === "function" ? __values2(o2) : o2[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
        return this;
      }, i2);
      function verb(n2) {
        i2[n2] = o2[n2] && function(v) {
          return new Promise(function(resolve2, reject) {
            v = o2[n2](v), settle2(resolve2, reject, v.done, v.value);
          });
        };
      }
      function settle2(resolve2, reject, d3, v) {
        Promise.resolve(v).then(function(v2) {
          resolve2({ value: v2, done: d3 });
        }, reject);
      }
    };
    __makeTemplateObject = function(cooked, raw) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", { value: raw });
      } else {
        cooked.raw = raw;
      }
      return cooked;
    };
    __importStar = function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod)
          if (Object.hasOwnProperty.call(mod, k2))
            result[k2] = mod[k2];
      }
      result["default"] = mod;
      return result;
    };
    __importDefault = function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    __classPrivateFieldGet = function(receiver, privateMap) {
      if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
      }
      return privateMap.get(receiver);
    };
    __classPrivateFieldSet = function(receiver, privateMap, value) {
      if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
      }
      privateMap.set(receiver, value);
      return value;
    };
    exporter("__extends", __extends2);
    exporter("__assign", __assign2);
    exporter("__rest", __rest2);
    exporter("__decorate", __decorate);
    exporter("__param", __param);
    exporter("__metadata", __metadata);
    exporter("__awaiter", __awaiter2);
    exporter("__generator", __generator2);
    exporter("__exportStar", __exportStar);
    exporter("__createBinding", __createBinding);
    exporter("__values", __values2);
    exporter("__read", __read2);
    exporter("__spread", __spread2);
    exporter("__spreadArrays", __spreadArrays);
    exporter("__await", __await);
    exporter("__asyncGenerator", __asyncGenerator);
    exporter("__asyncDelegator", __asyncDelegator);
    exporter("__asyncValues", __asyncValues);
    exporter("__makeTemplateObject", __makeTemplateObject);
    exporter("__importStar", __importStar);
    exporter("__importDefault", __importDefault);
    exporter("__classPrivateFieldGet", __classPrivateFieldGet);
    exporter("__classPrivateFieldSet", __classPrivateFieldSet);
  });
})(tslib$3);
var jsSha256 = {};
var constants$1 = {};
Object.defineProperty(constants$1, "__esModule", { value: true });
constants$1.MAX_HASHABLE_LENGTH = constants$1.INIT = constants$1.KEY = constants$1.DIGEST_LENGTH = constants$1.BLOCK_SIZE = void 0;
constants$1.BLOCK_SIZE = 64;
constants$1.DIGEST_LENGTH = 32;
constants$1.KEY = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
constants$1.INIT = [
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
];
constants$1.MAX_HASHABLE_LENGTH = Math.pow(2, 53) - 1;
var RawSha256$1 = {};
Object.defineProperty(RawSha256$1, "__esModule", { value: true });
RawSha256$1.RawSha256 = void 0;
var constants_1$3 = constants$1;
var RawSha256 = function() {
  function RawSha2562() {
    this.state = Int32Array.from(constants_1$3.INIT);
    this.temp = new Int32Array(64);
    this.buffer = new Uint8Array(64);
    this.bufferLength = 0;
    this.bytesHashed = 0;
    this.finished = false;
  }
  RawSha2562.prototype.update = function(data) {
    if (this.finished) {
      throw new Error("Attempted to update an already finished hash.");
    }
    var position = 0;
    var byteLength2 = data.byteLength;
    this.bytesHashed += byteLength2;
    if (this.bytesHashed * 8 > constants_1$3.MAX_HASHABLE_LENGTH) {
      throw new Error("Cannot hash more than 2^53 - 1 bits");
    }
    while (byteLength2 > 0) {
      this.buffer[this.bufferLength++] = data[position++];
      byteLength2--;
      if (this.bufferLength === constants_1$3.BLOCK_SIZE) {
        this.hashBuffer();
        this.bufferLength = 0;
      }
    }
  };
  RawSha2562.prototype.digest = function() {
    if (!this.finished) {
      var bitsHashed = this.bytesHashed * 8;
      var bufferView = new DataView(this.buffer.buffer, this.buffer.byteOffset, this.buffer.byteLength);
      var undecoratedLength = this.bufferLength;
      bufferView.setUint8(this.bufferLength++, 128);
      if (undecoratedLength % constants_1$3.BLOCK_SIZE >= constants_1$3.BLOCK_SIZE - 8) {
        for (var i2 = this.bufferLength; i2 < constants_1$3.BLOCK_SIZE; i2++) {
          bufferView.setUint8(i2, 0);
        }
        this.hashBuffer();
        this.bufferLength = 0;
      }
      for (var i2 = this.bufferLength; i2 < constants_1$3.BLOCK_SIZE - 8; i2++) {
        bufferView.setUint8(i2, 0);
      }
      bufferView.setUint32(constants_1$3.BLOCK_SIZE - 8, Math.floor(bitsHashed / 4294967296), true);
      bufferView.setUint32(constants_1$3.BLOCK_SIZE - 4, bitsHashed);
      this.hashBuffer();
      this.finished = true;
    }
    var out = new Uint8Array(constants_1$3.DIGEST_LENGTH);
    for (var i2 = 0; i2 < 8; i2++) {
      out[i2 * 4] = this.state[i2] >>> 24 & 255;
      out[i2 * 4 + 1] = this.state[i2] >>> 16 & 255;
      out[i2 * 4 + 2] = this.state[i2] >>> 8 & 255;
      out[i2 * 4 + 3] = this.state[i2] >>> 0 & 255;
    }
    return out;
  };
  RawSha2562.prototype.hashBuffer = function() {
    var _a2 = this, buffer2 = _a2.buffer, state = _a2.state;
    var state0 = state[0], state1 = state[1], state2 = state[2], state3 = state[3], state4 = state[4], state5 = state[5], state6 = state[6], state7 = state[7];
    for (var i2 = 0; i2 < constants_1$3.BLOCK_SIZE; i2++) {
      if (i2 < 16) {
        this.temp[i2] = (buffer2[i2 * 4] & 255) << 24 | (buffer2[i2 * 4 + 1] & 255) << 16 | (buffer2[i2 * 4 + 2] & 255) << 8 | buffer2[i2 * 4 + 3] & 255;
      } else {
        var u2 = this.temp[i2 - 2];
        var t1_1 = (u2 >>> 17 | u2 << 15) ^ (u2 >>> 19 | u2 << 13) ^ u2 >>> 10;
        u2 = this.temp[i2 - 15];
        var t2_1 = (u2 >>> 7 | u2 << 25) ^ (u2 >>> 18 | u2 << 14) ^ u2 >>> 3;
        this.temp[i2] = (t1_1 + this.temp[i2 - 7] | 0) + (t2_1 + this.temp[i2 - 16] | 0);
      }
      var t1 = (((state4 >>> 6 | state4 << 26) ^ (state4 >>> 11 | state4 << 21) ^ (state4 >>> 25 | state4 << 7)) + (state4 & state5 ^ ~state4 & state6) | 0) + (state7 + (constants_1$3.KEY[i2] + this.temp[i2] | 0) | 0) | 0;
      var t22 = ((state0 >>> 2 | state0 << 30) ^ (state0 >>> 13 | state0 << 19) ^ (state0 >>> 22 | state0 << 10)) + (state0 & state1 ^ state0 & state2 ^ state1 & state2) | 0;
      state7 = state6;
      state6 = state5;
      state5 = state4;
      state4 = state3 + t1 | 0;
      state3 = state2;
      state2 = state1;
      state1 = state0;
      state0 = t1 + t22 | 0;
    }
    state[0] += state0;
    state[1] += state1;
    state[2] += state2;
    state[3] += state3;
    state[4] += state4;
    state[5] += state5;
    state[6] += state6;
    state[7] += state7;
  };
  return RawSha2562;
}();
RawSha256$1.RawSha256 = RawSha256;
var build$3 = {};
var convertToBuffer$1 = {};
var fromUtf8$3 = function(input) {
  var bytes = [];
  for (var i2 = 0, len = input.length; i2 < len; i2++) {
    var value = input.charCodeAt(i2);
    if (value < 128) {
      bytes.push(value);
    } else if (value < 2048) {
      bytes.push(value >> 6 | 192, value & 63 | 128);
    } else if (i2 + 1 < input.length && (value & 64512) === 55296 && (input.charCodeAt(i2 + 1) & 64512) === 56320) {
      var surrogatePair = 65536 + ((value & 1023) << 10) + (input.charCodeAt(++i2) & 1023);
      bytes.push(surrogatePair >> 18 | 240, surrogatePair >> 12 & 63 | 128, surrogatePair >> 6 & 63 | 128, surrogatePair & 63 | 128);
    } else {
      bytes.push(value >> 12 | 224, value >> 6 & 63 | 128, value & 63 | 128);
    }
  }
  return Uint8Array.from(bytes);
};
var toUtf8$2 = function(input) {
  var decoded = "";
  for (var i2 = 0, len = input.length; i2 < len; i2++) {
    var byte = input[i2];
    if (byte < 128) {
      decoded += String.fromCharCode(byte);
    } else if (192 <= byte && byte < 224) {
      var nextByte = input[++i2];
      decoded += String.fromCharCode((byte & 31) << 6 | nextByte & 63);
    } else if (240 <= byte && byte < 365) {
      var surrogatePair = [byte, input[++i2], input[++i2], input[++i2]];
      var encoded = "%" + surrogatePair.map(function(byteValue) {
        return byteValue.toString(16);
      }).join("%");
      decoded += decodeURIComponent(encoded);
    } else {
      decoded += String.fromCharCode((byte & 15) << 12 | (input[++i2] & 63) << 6 | input[++i2] & 63);
    }
  }
  return decoded;
};
function fromUtf8$2(input) {
  return new TextEncoder().encode(input);
}
function toUtf8$1(input) {
  return new TextDecoder("utf-8").decode(input);
}
var fromUtf8$1 = function(input) {
  return typeof TextEncoder === "function" ? fromUtf8$2(input) : fromUtf8$3(input);
};
var toUtf8 = function(input) {
  return typeof TextDecoder === "function" ? toUtf8$1(input) : toUtf8$2(input);
};
const es = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  fromUtf8: fromUtf8$1,
  toUtf8
}, Symbol.toStringTag, { value: "Module" }));
const require$$0$1 = /* @__PURE__ */ getAugmentedNamespace(es);
Object.defineProperty(convertToBuffer$1, "__esModule", { value: true });
convertToBuffer$1.convertToBuffer = void 0;
var util_utf8_browser_1$1 = require$$0$1;
var fromUtf8 = typeof Buffer !== "undefined" && Buffer.from ? function(input) {
  return Buffer.from(input, "utf8");
} : util_utf8_browser_1$1.fromUtf8;
function convertToBuffer(data) {
  if (data instanceof Uint8Array)
    return data;
  if (typeof data === "string") {
    return fromUtf8(data);
  }
  if (ArrayBuffer.isView(data)) {
    return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
  }
  return new Uint8Array(data);
}
convertToBuffer$1.convertToBuffer = convertToBuffer;
var isEmptyData$3 = {};
Object.defineProperty(isEmptyData$3, "__esModule", { value: true });
isEmptyData$3.isEmptyData = void 0;
function isEmptyData$2(data) {
  if (typeof data === "string") {
    return data.length === 0;
  }
  return data.byteLength === 0;
}
isEmptyData$3.isEmptyData = isEmptyData$2;
var numToUint8$1 = {};
Object.defineProperty(numToUint8$1, "__esModule", { value: true });
numToUint8$1.numToUint8 = void 0;
function numToUint8(num) {
  return new Uint8Array([
    (num & 4278190080) >> 24,
    (num & 16711680) >> 16,
    (num & 65280) >> 8,
    num & 255
  ]);
}
numToUint8$1.numToUint8 = numToUint8;
var uint32ArrayFrom$1 = {};
Object.defineProperty(uint32ArrayFrom$1, "__esModule", { value: true });
uint32ArrayFrom$1.uint32ArrayFrom = void 0;
function uint32ArrayFrom(a_lookUpTable) {
  if (!Array.from) {
    var return_array = new Uint32Array(a_lookUpTable.length);
    var a_index = 0;
    while (a_index < a_lookUpTable.length) {
      return_array[a_index] = a_lookUpTable[a_index];
    }
    return return_array;
  }
  return Uint32Array.from(a_lookUpTable);
}
uint32ArrayFrom$1.uint32ArrayFrom = uint32ArrayFrom;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.uint32ArrayFrom = exports.numToUint8 = exports.isEmptyData = exports.convertToBuffer = void 0;
  var convertToBuffer_1 = convertToBuffer$1;
  Object.defineProperty(exports, "convertToBuffer", { enumerable: true, get: function() {
    return convertToBuffer_1.convertToBuffer;
  } });
  var isEmptyData_12 = isEmptyData$3;
  Object.defineProperty(exports, "isEmptyData", { enumerable: true, get: function() {
    return isEmptyData_12.isEmptyData;
  } });
  var numToUint8_1 = numToUint8$1;
  Object.defineProperty(exports, "numToUint8", { enumerable: true, get: function() {
    return numToUint8_1.numToUint8;
  } });
  var uint32ArrayFrom_1 = uint32ArrayFrom$1;
  Object.defineProperty(exports, "uint32ArrayFrom", { enumerable: true, get: function() {
    return uint32ArrayFrom_1.uint32ArrayFrom;
  } });
})(build$3);
Object.defineProperty(jsSha256, "__esModule", { value: true });
jsSha256.Sha256 = void 0;
var tslib_1 = tslib$3.exports;
var constants_1$2 = constants$1;
var RawSha256_1 = RawSha256$1;
var util_1$1 = build$3;
var Sha256$3 = function() {
  function Sha2562(secret) {
    this.hash = new RawSha256_1.RawSha256();
    if (secret) {
      this.outer = new RawSha256_1.RawSha256();
      var inner = bufferFromSecret(secret);
      var outer = new Uint8Array(constants_1$2.BLOCK_SIZE);
      outer.set(inner);
      for (var i2 = 0; i2 < constants_1$2.BLOCK_SIZE; i2++) {
        inner[i2] ^= 54;
        outer[i2] ^= 92;
      }
      this.hash.update(inner);
      this.outer.update(outer);
      for (var i2 = 0; i2 < inner.byteLength; i2++) {
        inner[i2] = 0;
      }
    }
  }
  Sha2562.prototype.update = function(toHash) {
    if ((0, util_1$1.isEmptyData)(toHash) || this.error) {
      return;
    }
    try {
      this.hash.update((0, util_1$1.convertToBuffer)(toHash));
    } catch (e3) {
      this.error = e3;
    }
  };
  Sha2562.prototype.digestSync = function() {
    if (this.error) {
      throw this.error;
    }
    if (this.outer) {
      if (!this.outer.finished) {
        this.outer.update(this.hash.digest());
      }
      return this.outer.digest();
    }
    return this.hash.digest();
  };
  Sha2562.prototype.digest = function() {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function() {
      return (0, tslib_1.__generator)(this, function(_a2) {
        return [2, this.digestSync()];
      });
    });
  };
  return Sha2562;
}();
jsSha256.Sha256 = Sha256$3;
function bufferFromSecret(secret) {
  var input = (0, util_1$1.convertToBuffer)(secret);
  if (input.byteLength > constants_1$2.BLOCK_SIZE) {
    var bufferHash = new RawSha256_1.RawSha256();
    bufferHash.update(input);
    input = bufferHash.digest();
  }
  var buffer2 = new Uint8Array(constants_1$2.BLOCK_SIZE);
  buffer2.set(input);
  return buffer2;
}
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tslib_12 = tslib$3.exports;
  (0, tslib_12.__exportStar)(jsSha256, exports);
})(build$4);
var SHORT_TO_HEX = {};
for (var i$3 = 0; i$3 < 256; i$3++) {
  var encodedByte = i$3.toString(16).toLowerCase();
  if (encodedByte.length === 1) {
    encodedByte = "0" + encodedByte;
  }
  SHORT_TO_HEX[i$3] = encodedByte;
}
function toHex$1(bytes) {
  var out = "";
  for (var i2 = 0; i2 < bytes.byteLength; i2++) {
    out += SHORT_TO_HEX[bytes[i2]];
  }
  return out;
}
var punycode$1 = { exports: {} };
/*! https://mths.be/punycode v1.3.2 by @mathias */
(function(module2, exports) {
  (function(root) {
    var freeExports = exports && !exports.nodeType && exports;
    var freeModule = module2 && !module2.nodeType && module2;
    var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal;
    if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
      root = freeGlobal;
    }
    var punycode2, maxInt = 2147483647, base = 36, tMin = 1, tMax = 26, skew = 38, damp = 700, initialBias = 72, initialN = 128, delimiter = "-", regexPunycode = /^xn--/, regexNonASCII = /[^\x20-\x7E]/, regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, errors = {
      "overflow": "Overflow: input needs wider integers to process",
      "not-basic": "Illegal input >= 0x80 (not a basic code point)",
      "invalid-input": "Invalid input"
    }, baseMinusTMin = base - tMin, floor = Math.floor, stringFromCharCode = String.fromCharCode, key;
    function error(type) {
      throw RangeError(errors[type]);
    }
    function map(array, fn2) {
      var length = array.length;
      var result = [];
      while (length--) {
        result[length] = fn2(array[length]);
      }
      return result;
    }
    function mapDomain(string, fn2) {
      var parts = string.split("@");
      var result = "";
      if (parts.length > 1) {
        result = parts[0] + "@";
        string = parts[1];
      }
      string = string.replace(regexSeparators, ".");
      var labels = string.split(".");
      var encoded = map(labels, fn2).join(".");
      return result + encoded;
    }
    function ucs2decode(string) {
      var output = [], counter = 0, length = string.length, value, extra;
      while (counter < length) {
        value = string.charCodeAt(counter++);
        if (value >= 55296 && value <= 56319 && counter < length) {
          extra = string.charCodeAt(counter++);
          if ((extra & 64512) == 56320) {
            output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
          } else {
            output.push(value);
            counter--;
          }
        } else {
          output.push(value);
        }
      }
      return output;
    }
    function ucs2encode(array) {
      return map(array, function(value) {
        var output = "";
        if (value > 65535) {
          value -= 65536;
          output += stringFromCharCode(value >>> 10 & 1023 | 55296);
          value = 56320 | value & 1023;
        }
        output += stringFromCharCode(value);
        return output;
      }).join("");
    }
    function basicToDigit(codePoint) {
      if (codePoint - 48 < 10) {
        return codePoint - 22;
      }
      if (codePoint - 65 < 26) {
        return codePoint - 65;
      }
      if (codePoint - 97 < 26) {
        return codePoint - 97;
      }
      return base;
    }
    function digitToBasic(digit, flag) {
      return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
    }
    function adapt(delta2, numPoints, firstTime) {
      var k2 = 0;
      delta2 = firstTime ? floor(delta2 / damp) : delta2 >> 1;
      delta2 += floor(delta2 / numPoints);
      for (; delta2 > baseMinusTMin * tMax >> 1; k2 += base) {
        delta2 = floor(delta2 / baseMinusTMin);
      }
      return floor(k2 + (baseMinusTMin + 1) * delta2 / (delta2 + skew));
    }
    function decode2(input) {
      var output = [], inputLength = input.length, out, i2 = 0, n2 = initialN, bias = initialBias, basic, j, index2, oldi, w2, k2, digit, t3, baseMinusT;
      basic = input.lastIndexOf(delimiter);
      if (basic < 0) {
        basic = 0;
      }
      for (j = 0; j < basic; ++j) {
        if (input.charCodeAt(j) >= 128) {
          error("not-basic");
        }
        output.push(input.charCodeAt(j));
      }
      for (index2 = basic > 0 ? basic + 1 : 0; index2 < inputLength; ) {
        for (oldi = i2, w2 = 1, k2 = base; ; k2 += base) {
          if (index2 >= inputLength) {
            error("invalid-input");
          }
          digit = basicToDigit(input.charCodeAt(index2++));
          if (digit >= base || digit > floor((maxInt - i2) / w2)) {
            error("overflow");
          }
          i2 += digit * w2;
          t3 = k2 <= bias ? tMin : k2 >= bias + tMax ? tMax : k2 - bias;
          if (digit < t3) {
            break;
          }
          baseMinusT = base - t3;
          if (w2 > floor(maxInt / baseMinusT)) {
            error("overflow");
          }
          w2 *= baseMinusT;
        }
        out = output.length + 1;
        bias = adapt(i2 - oldi, out, oldi == 0);
        if (floor(i2 / out) > maxInt - n2) {
          error("overflow");
        }
        n2 += floor(i2 / out);
        i2 %= out;
        output.splice(i2++, 0, n2);
      }
      return ucs2encode(output);
    }
    function encode2(input) {
      var n2, delta2, handledCPCount, basicLength, bias, j, m3, q2, k2, t3, currentValue, output = [], inputLength, handledCPCountPlusOne, baseMinusT, qMinusT;
      input = ucs2decode(input);
      inputLength = input.length;
      n2 = initialN;
      delta2 = 0;
      bias = initialBias;
      for (j = 0; j < inputLength; ++j) {
        currentValue = input[j];
        if (currentValue < 128) {
          output.push(stringFromCharCode(currentValue));
        }
      }
      handledCPCount = basicLength = output.length;
      if (basicLength) {
        output.push(delimiter);
      }
      while (handledCPCount < inputLength) {
        for (m3 = maxInt, j = 0; j < inputLength; ++j) {
          currentValue = input[j];
          if (currentValue >= n2 && currentValue < m3) {
            m3 = currentValue;
          }
        }
        handledCPCountPlusOne = handledCPCount + 1;
        if (m3 - n2 > floor((maxInt - delta2) / handledCPCountPlusOne)) {
          error("overflow");
        }
        delta2 += (m3 - n2) * handledCPCountPlusOne;
        n2 = m3;
        for (j = 0; j < inputLength; ++j) {
          currentValue = input[j];
          if (currentValue < n2 && ++delta2 > maxInt) {
            error("overflow");
          }
          if (currentValue == n2) {
            for (q2 = delta2, k2 = base; ; k2 += base) {
              t3 = k2 <= bias ? tMin : k2 >= bias + tMax ? tMax : k2 - bias;
              if (q2 < t3) {
                break;
              }
              qMinusT = q2 - t3;
              baseMinusT = base - t3;
              output.push(
                stringFromCharCode(digitToBasic(t3 + qMinusT % baseMinusT, 0))
              );
              q2 = floor(qMinusT / baseMinusT);
            }
            output.push(stringFromCharCode(digitToBasic(q2, 0)));
            bias = adapt(delta2, handledCPCountPlusOne, handledCPCount == basicLength);
            delta2 = 0;
            ++handledCPCount;
          }
        }
        ++delta2;
        ++n2;
      }
      return output.join("");
    }
    function toUnicode(input) {
      return mapDomain(input, function(string) {
        return regexPunycode.test(string) ? decode2(string.slice(4).toLowerCase()) : string;
      });
    }
    function toASCII(input) {
      return mapDomain(input, function(string) {
        return regexNonASCII.test(string) ? "xn--" + encode2(string) : string;
      });
    }
    punycode2 = {
      "version": "1.3.2",
      "ucs2": {
        "decode": ucs2decode,
        "encode": ucs2encode
      },
      "decode": decode2,
      "encode": encode2,
      "toASCII": toASCII,
      "toUnicode": toUnicode
    };
    if (freeExports && freeModule) {
      if (module2.exports == freeExports) {
        freeModule.exports = punycode2;
      } else {
        for (key in punycode2) {
          punycode2.hasOwnProperty(key) && (freeExports[key] = punycode2[key]);
        }
      }
    } else {
      root.punycode = punycode2;
    }
  })(commonjsGlobal);
})(punycode$1, punycode$1.exports);
var util$1 = {
  isString: function(arg) {
    return typeof arg === "string";
  },
  isObject: function(arg) {
    return typeof arg === "object" && arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};
var querystring$1 = {};
function hasOwnProperty$1(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
var decode$1 = function(qs, sep, eq, options) {
  sep = sep || "&";
  eq = eq || "=";
  var obj = {};
  if (typeof qs !== "string" || qs.length === 0) {
    return obj;
  }
  var regexp = /\+/g;
  qs = qs.split(sep);
  var maxKeys = 1e3;
  if (options && typeof options.maxKeys === "number") {
    maxKeys = options.maxKeys;
  }
  var len = qs.length;
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }
  for (var i2 = 0; i2 < len; ++i2) {
    var x2 = qs[i2].replace(regexp, "%20"), idx = x2.indexOf(eq), kstr, vstr, k2, v;
    if (idx >= 0) {
      kstr = x2.substr(0, idx);
      vstr = x2.substr(idx + 1);
    } else {
      kstr = x2;
      vstr = "";
    }
    k2 = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);
    if (!hasOwnProperty$1(obj, k2)) {
      obj[k2] = v;
    } else if (Array.isArray(obj[k2])) {
      obj[k2].push(v);
    } else {
      obj[k2] = [obj[k2], v];
    }
  }
  return obj;
};
var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case "string":
      return v;
    case "boolean":
      return v ? "true" : "false";
    case "number":
      return isFinite(v) ? v : "";
    default:
      return "";
  }
};
var encode$3 = function(obj, sep, eq, name2) {
  sep = sep || "&";
  eq = eq || "=";
  if (obj === null) {
    obj = void 0;
  }
  if (typeof obj === "object") {
    return Object.keys(obj).map(function(k2) {
      var ks = encodeURIComponent(stringifyPrimitive(k2)) + eq;
      if (Array.isArray(obj[k2])) {
        return obj[k2].map(function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k2]));
      }
    }).join(sep);
  }
  if (!name2)
    return "";
  return encodeURIComponent(stringifyPrimitive(name2)) + eq + encodeURIComponent(stringifyPrimitive(obj));
};
querystring$1.decode = querystring$1.parse = decode$1;
querystring$1.encode = querystring$1.stringify = encode$3;
var punycode = punycode$1.exports;
var util = util$1;
var parse$2 = urlParse;
function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}
var protocolPattern = /^([a-z0-9.+-]+:)/i, portPattern = /:[0-9]*$/, simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, delims = ["<", ">", '"', "`", " ", "\r", "\n", "	"], unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims), autoEscape = ["'"].concat(unwise), nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape), hostEndingChars = ["/", "?", "#"], hostnameMaxLen = 255, hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/, hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, unsafeProtocol = {
  "javascript": true,
  "javascript:": true
}, hostlessProtocol = {
  "javascript": true,
  "javascript:": true
}, slashedProtocol = {
  "http": true,
  "https": true,
  "ftp": true,
  "gopher": true,
  "file": true,
  "http:": true,
  "https:": true,
  "ftp:": true,
  "gopher:": true,
  "file:": true
}, querystring = querystring$1;
function urlParse(url, parseQueryString2, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url)
    return url;
  var u2 = new Url();
  u2.parse(url, parseQueryString2, slashesDenoteHost);
  return u2;
}
Url.prototype.parse = function(url, parseQueryString2, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }
  var queryIndex = url.indexOf("?"), splitter = queryIndex !== -1 && queryIndex < url.indexOf("#") ? "?" : "#", uSplit = url.split(splitter), slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, "/");
  url = uSplit.join(splitter);
  var rest = url;
  rest = rest.trim();
  if (!slashesDenoteHost && url.split("#").length === 1) {
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString2) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString2) {
        this.search = "";
        this.query = {};
      }
      return this;
    }
  }
  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === "//";
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }
  if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
    var hostEnd = -1;
    for (var i2 = 0; i2 < hostEndingChars.length; i2++) {
      var hec = rest.indexOf(hostEndingChars[i2]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    var auth, atSign;
    if (hostEnd === -1) {
      atSign = rest.lastIndexOf("@");
    } else {
      atSign = rest.lastIndexOf("@", hostEnd);
    }
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }
    hostEnd = -1;
    for (var i2 = 0; i2 < nonHostChars.length; i2++) {
      var hec = rest.indexOf(nonHostChars[i2]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    if (hostEnd === -1)
      hostEnd = rest.length;
    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);
    this.parseHost();
    this.hostname = this.hostname || "";
    var ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i2 = 0, l = hostparts.length; i2 < l; i2++) {
        var part = hostparts[i2];
        if (!part)
          continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = "";
          for (var j = 0, k2 = part.length; j < k2; j++) {
            if (part.charCodeAt(j) > 127) {
              newpart += "x";
            } else {
              newpart += part[j];
            }
          }
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i2);
            var notHost = hostparts.slice(i2 + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = "/" + notHost.join(".") + rest;
            }
            this.hostname = validParts.join(".");
            break;
          }
        }
      }
    }
    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = "";
    } else {
      this.hostname = this.hostname.toLowerCase();
    }
    if (!ipv6Hostname) {
      this.hostname = punycode.toASCII(this.hostname);
    }
    var p2 = this.port ? ":" + this.port : "";
    var h4 = this.hostname || "";
    this.host = h4 + p2;
    this.href += this.host;
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== "/") {
        rest = "/" + rest;
      }
    }
  }
  if (!unsafeProtocol[lowerProto]) {
    for (var i2 = 0, l = autoEscape.length; i2 < l; i2++) {
      var ae = autoEscape[i2];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }
  var hash2 = rest.indexOf("#");
  if (hash2 !== -1) {
    this.hash = rest.substr(hash2);
    rest = rest.slice(0, hash2);
  }
  var qm = rest.indexOf("?");
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString2) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString2) {
    this.search = "";
    this.query = {};
  }
  if (rest)
    this.pathname = rest;
  if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
    this.pathname = "/";
  }
  if (this.pathname || this.search) {
    var p2 = this.pathname || "";
    var s3 = this.search || "";
    this.path = p2 + s3;
  }
  this.href = this.format();
  return this;
};
Url.prototype.format = function() {
  var auth = this.auth || "";
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ":");
    auth += "@";
  }
  var protocol = this.protocol || "", pathname = this.pathname || "", hash2 = this.hash || "", host = false, query = "";
  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]");
    if (this.port) {
      host += ":" + this.port;
    }
  }
  if (this.query && util.isObject(this.query) && Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }
  var search = this.search || query && "?" + query || "";
  if (protocol && protocol.substr(-1) !== ":")
    protocol += ":";
  if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = "//" + (host || "");
    if (pathname && pathname.charAt(0) !== "/")
      pathname = "/" + pathname;
  } else if (!host) {
    host = "";
  }
  if (hash2 && hash2.charAt(0) !== "#")
    hash2 = "#" + hash2;
  if (search && search.charAt(0) !== "?")
    search = "?" + search;
  pathname = pathname.replace(/[?#]/g, function(match2) {
    return encodeURIComponent(match2);
  });
  search = search.replace("#", "%23");
  return protocol + host + pathname + search + hash2;
};
Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};
Url.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }
  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }
  result.hash = relative.hash;
  if (relative.href === "") {
    result.href = result.format();
    return result;
  }
  if (relative.slashes && !relative.protocol) {
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== "protocol")
        result[rkey] = relative[rkey];
    }
    if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
      result.path = result.pathname = "/";
    }
    result.href = result.format();
    return result;
  }
  if (relative.protocol && relative.protocol !== result.protocol) {
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k2 = keys[v];
        result[k2] = relative[k2];
      }
      result.href = result.format();
      return result;
    }
    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || "").split("/");
      while (relPath.length && !(relative.host = relPath.shift()))
        ;
      if (!relative.host)
        relative.host = "";
      if (!relative.hostname)
        relative.hostname = "";
      if (relPath[0] !== "")
        relPath.unshift("");
      if (relPath.length < 2)
        relPath.unshift("");
      result.pathname = relPath.join("/");
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || "";
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    if (result.pathname || result.search) {
      var p2 = result.pathname || "";
      var s3 = result.search || "";
      result.path = p2 + s3;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }
  var isSourceAbs = result.pathname && result.pathname.charAt(0) === "/", isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === "/", mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname, removeAllDots = mustEndAbs, srcPath = result.pathname && result.pathname.split("/") || [], relPath = relative.pathname && relative.pathname.split("/") || [], psychotic = result.protocol && !slashedProtocol[result.protocol];
  if (psychotic) {
    result.hostname = "";
    result.port = null;
    if (result.host) {
      if (srcPath[0] === "")
        srcPath[0] = result.host;
      else
        srcPath.unshift(result.host);
    }
    result.host = "";
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === "")
          relPath[0] = relative.host;
        else
          relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
  }
  if (isRelAbs) {
    result.host = relative.host || relative.host === "" ? relative.host : result.host;
    result.hostname = relative.hostname || relative.hostname === "" ? relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
  } else if (relPath.length) {
    if (!srcPath)
      srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
    }
    result.href = result.format();
    return result;
  }
  if (!srcPath.length) {
    result.pathname = null;
    if (result.search) {
      result.path = "/" + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === "." || last === "..") || last === "";
  var up = 0;
  for (var i2 = srcPath.length; i2 >= 0; i2--) {
    last = srcPath[i2];
    if (last === ".") {
      srcPath.splice(i2, 1);
    } else if (last === "..") {
      srcPath.splice(i2, 1);
      up++;
    } else if (up) {
      srcPath.splice(i2, 1);
      up--;
    }
  }
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift("..");
    }
  }
  if (mustEndAbs && srcPath[0] !== "" && (!srcPath[0] || srcPath[0].charAt(0) !== "/")) {
    srcPath.unshift("");
  }
  if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/") {
    srcPath.push("");
  }
  var isAbsolute = srcPath[0] === "" || srcPath[0] && srcPath[0].charAt(0) === "/";
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? "" : srcPath.length ? srcPath.shift() : "";
    var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }
  mustEndAbs = mustEndAbs || result.host && srcPath.length;
  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift("");
  }
  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join("/");
  }
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};
Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ":") {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host)
    this.hostname = host;
};
var logger$8 = new ConsoleLogger("Util");
var NonRetryableError = function(_super) {
  __extends$4(NonRetryableError2, _super);
  function NonRetryableError2(message) {
    var _this = _super.call(this, message) || this;
    _this.nonRetryable = true;
    return _this;
  }
  return NonRetryableError2;
}(Error);
var isNonRetryableError$1 = function(obj) {
  var key = "nonRetryable";
  return obj && obj[key];
};
function retry$1(functionToRetry, args, delayFn, onTerminate) {
  return __awaiter$e(this, void 0, void 0, function() {
    var _this = this;
    return __generator$e(this, function(_a2) {
      if (typeof functionToRetry !== "function") {
        throw Error("functionToRetry must be a function");
      }
      return [2, new Promise(function(resolve2, reject) {
        return __awaiter$e(_this, void 0, void 0, function() {
          var attempt, terminated, timeout, wakeUp, lastError, _loop_1, state_1;
          return __generator$e(this, function(_a3) {
            switch (_a3.label) {
              case 0:
                attempt = 0;
                terminated = false;
                wakeUp = function() {
                };
                onTerminate && onTerminate.then(function() {
                  terminated = true;
                  clearTimeout(timeout);
                  wakeUp();
                });
                _loop_1 = function() {
                  var _a4, _b, err_1, retryIn_1;
                  return __generator$e(this, function(_c) {
                    switch (_c.label) {
                      case 0:
                        attempt++;
                        logger$8.debug(functionToRetry.name + " attempt #" + attempt + " with this vars: " + JSON.stringify(args));
                        _c.label = 1;
                      case 1:
                        _c.trys.push([1, 3, , 7]);
                        _a4 = {};
                        _b = resolve2;
                        return [4, functionToRetry.apply(void 0, __spread$6(args))];
                      case 2:
                        return [2, (_a4.value = _b.apply(void 0, [_c.sent()]), _a4)];
                      case 3:
                        err_1 = _c.sent();
                        lastError = err_1;
                        logger$8.debug("error on " + functionToRetry.name, err_1);
                        if (isNonRetryableError$1(err_1)) {
                          logger$8.debug(functionToRetry.name + " non retryable error", err_1);
                          return [2, { value: reject(err_1) }];
                        }
                        retryIn_1 = delayFn(attempt, args, err_1);
                        logger$8.debug(functionToRetry.name + " retrying in " + retryIn_1 + " ms");
                        if (!(retryIn_1 === false || terminated))
                          return [3, 4];
                        return [2, { value: reject(err_1) }];
                      case 4:
                        return [4, new Promise(function(r2) {
                          wakeUp = r2;
                          timeout = setTimeout(wakeUp, retryIn_1);
                        })];
                      case 5:
                        _c.sent();
                        _c.label = 6;
                      case 6:
                        return [3, 7];
                      case 7:
                        return [2];
                    }
                  });
                };
                _a3.label = 1;
              case 1:
                if (!!terminated)
                  return [3, 3];
                return [5, _loop_1()];
              case 2:
                state_1 = _a3.sent();
                if (typeof state_1 === "object")
                  return [2, state_1.value];
                return [3, 1];
              case 3:
                reject(lastError);
                return [2];
            }
          });
        });
      })];
    });
  });
}
var MAX_DELAY_MS$1 = 5 * 60 * 1e3;
function jitteredBackoff$1(maxDelayMs) {
  if (maxDelayMs === void 0) {
    maxDelayMs = MAX_DELAY_MS$1;
  }
  var BASE_TIME_MS = 100;
  var JITTER_FACTOR = 100;
  return function(attempt) {
    var delay = Math.pow(2, attempt) * BASE_TIME_MS + JITTER_FACTOR * Math.random();
    return delay > maxDelayMs ? false : delay;
  };
}
var jitteredExponentialRetry$1 = function(functionToRetry, args, maxDelayMs, onTerminate) {
  if (maxDelayMs === void 0) {
    maxDelayMs = MAX_DELAY_MS$1;
  }
  return retry$1(functionToRetry, args, jitteredBackoff$1(maxDelayMs), onTerminate);
};
function urlSafeEncode(str) {
  return str.split("").map(function(char) {
    return char.charCodeAt(0).toString(16).padStart(2, "0");
  }).join("");
}
function urlSafeDecode(hex) {
  return hex.match(/.{2}/g).map(function(char) {
    return String.fromCharCode(parseInt(char, 16));
  }).join("");
}
var logger$7 = new ConsoleLogger("Parser");
var parseAWSExports = function(config) {
  var amplifyConfig = {};
  if (config["aws_mobile_analytics_app_id"]) {
    var Analytics = {
      AWSPinpoint: {
        appId: config["aws_mobile_analytics_app_id"],
        region: config["aws_mobile_analytics_app_region"]
      }
    };
    amplifyConfig.Analytics = Analytics;
  }
  if (config["aws_cognito_identity_pool_id"] || config["aws_user_pools_id"]) {
    amplifyConfig.Auth = {
      userPoolId: config["aws_user_pools_id"],
      userPoolWebClientId: config["aws_user_pools_web_client_id"],
      region: config["aws_cognito_region"],
      identityPoolId: config["aws_cognito_identity_pool_id"],
      identityPoolRegion: config["aws_cognito_region"],
      mandatorySignIn: config["aws_mandatory_sign_in"] === "enable",
      signUpVerificationMethod: config["aws_cognito_sign_up_verification_method"] || "code"
    };
  }
  var storageConfig;
  if (config["aws_user_files_s3_bucket"]) {
    storageConfig = {
      AWSS3: {
        bucket: config["aws_user_files_s3_bucket"],
        region: config["aws_user_files_s3_bucket_region"],
        dangerouslyConnectToHttpEndpointForTesting: config["aws_user_files_s3_dangerously_connect_to_http_endpoint_for_testing"]
      }
    };
  } else {
    storageConfig = config ? config.Storage || config : {};
  }
  if (config["Logging"]) {
    amplifyConfig.Logging = __assign$c(__assign$c({}, config["Logging"]), { region: config["aws_project_region"] });
  }
  if (config["geo"]) {
    amplifyConfig.Geo = Object.assign({}, config.geo);
    if (config.geo["amazon_location_service"]) {
      amplifyConfig.Geo = {
        AmazonLocationService: config.geo["amazon_location_service"]
      };
    }
  }
  amplifyConfig.Analytics = Object.assign({}, amplifyConfig.Analytics, config.Analytics);
  amplifyConfig.Auth = Object.assign({}, amplifyConfig.Auth, config.Auth);
  amplifyConfig.Storage = Object.assign({}, storageConfig);
  amplifyConfig.Logging = Object.assign({}, amplifyConfig.Logging, config.Logging);
  logger$7.debug("parse config", config, "to amplifyconfig", amplifyConfig);
  return amplifyConfig;
};
var extendStatics$3 = function(d3, b3) {
  extendStatics$3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b4) {
    d4.__proto__ = b4;
  } || function(d4, b4) {
    for (var p2 in b4)
      if (Object.prototype.hasOwnProperty.call(b4, p2))
        d4[p2] = b4[p2];
  };
  return extendStatics$3(d3, b3);
};
function __extends$3(d3, b3) {
  if (typeof b3 !== "function" && b3 !== null)
    throw new TypeError("Class extends value " + String(b3) + " is not a constructor or null");
  extendStatics$3(d3, b3);
  function __() {
    this.constructor = d3;
  }
  d3.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __());
}
var __assign$b = function() {
  __assign$b = Object.assign || function __assign2(t3) {
    for (var s3, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s3 = arguments[i2];
      for (var p2 in s3)
        if (Object.prototype.hasOwnProperty.call(s3, p2))
          t3[p2] = s3[p2];
    }
    return t3;
  };
  return __assign$b.apply(this, arguments);
};
function __awaiter$d(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator$d(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t3[0] & 1)
      throw t3[1];
    return t3[1];
  }, trys: [], ops: [] }, f, y3, t3, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n2) {
    return function(v) {
      return step([n2, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_2 = 0)), _2)
      try {
        if (f = 1, y3 && (t3 = op[0] & 2 ? y3["return"] : op[0] ? y3["throw"] || ((t3 = y3["return"]) && t3.call(y3), 0) : y3.next) && !(t3 = t3.call(y3, op[1])).done)
          return t3;
        if (y3 = 0, t3)
          op = [op[0] & 2, t3.value];
        switch (op[0]) {
          case 0:
          case 1:
            t3 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y3 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t3 = _2.trys, t3 = t3.length > 0 && t3[t3.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t3 || op[1] > t3[0] && op[1] < t3[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t3[1]) {
              _2.label = t3[1];
              t3 = op;
              break;
            }
            if (t3 && _2.label < t3[2]) {
              _2.label = t3[2];
              _2.ops.push(op);
              break;
            }
            if (t3[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e3) {
        op = [6, e3];
        y3 = 0;
      } finally {
        f = t3 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __read$a(o2, n2) {
  var m3 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m3)
    return o2;
  var i2 = m3.call(o2), r2, ar2 = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
      ar2.push(r2.value);
  } catch (error) {
    e3 = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m3 = i2["return"]))
        m3.call(i2);
    } finally {
      if (e3)
        throw e3.error;
    }
  }
  return ar2;
}
var build$2 = {};
var tslib$2 = { exports: {} };
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
(function(module2) {
  var __extends2;
  var __assign2;
  var __rest2;
  var __decorate;
  var __param;
  var __metadata;
  var __awaiter2;
  var __generator2;
  var __exportStar;
  var __values2;
  var __read2;
  var __spread2;
  var __spreadArrays;
  var __await;
  var __asyncGenerator;
  var __asyncDelegator;
  var __asyncValues;
  var __makeTemplateObject;
  var __importStar;
  var __importDefault;
  var __classPrivateFieldGet;
  var __classPrivateFieldSet;
  var __createBinding;
  (function(factory) {
    var root = typeof commonjsGlobal === "object" ? commonjsGlobal : typeof self === "object" ? self : typeof this === "object" ? this : {};
    {
      factory(createExporter(root, createExporter(module2.exports)));
    }
    function createExporter(exports, previous) {
      if (exports !== root) {
        if (typeof Object.create === "function") {
          Object.defineProperty(exports, "__esModule", { value: true });
        } else {
          exports.__esModule = true;
        }
      }
      return function(id, v) {
        return exports[id] = previous ? previous(id, v) : v;
      };
    }
  })(function(exporter) {
    var extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p2 in b3)
        if (b3.hasOwnProperty(p2))
          d3[p2] = b3[p2];
    };
    __extends2 = function(d3, b3) {
      extendStatics2(d3, b3);
      function __() {
        this.constructor = d3;
      }
      d3.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __());
    };
    __assign2 = Object.assign || function(t3) {
      for (var s3, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
        s3 = arguments[i2];
        for (var p2 in s3)
          if (Object.prototype.hasOwnProperty.call(s3, p2))
            t3[p2] = s3[p2];
      }
      return t3;
    };
    __rest2 = function(s3, e3) {
      var t3 = {};
      for (var p2 in s3)
        if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
          t3[p2] = s3[p2];
      if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s3); i2 < p2.length; i2++) {
          if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i2]))
            t3[p2[i2]] = s3[p2[i2]];
        }
      return t3;
    };
    __decorate = function(decorators, target, key, desc) {
      var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r2 = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i2 = decorators.length - 1; i2 >= 0; i2--)
          if (d3 = decorators[i2])
            r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key, r2) : d3(target, key)) || r2;
      return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
    };
    __param = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    __metadata = function(metadataKey, metadataValue) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(metadataKey, metadataValue);
    };
    __awaiter2 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e3) {
            reject(e3);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e3) {
            reject(e3);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    __generator2 = function(thisArg, body) {
      var _2 = { label: 0, sent: function() {
        if (t3[0] & 1)
          throw t3[1];
        return t3[1];
      }, trys: [], ops: [] }, f, y3, t3, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n2) {
        return function(v) {
          return step([n2, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_2)
          try {
            if (f = 1, y3 && (t3 = op[0] & 2 ? y3["return"] : op[0] ? y3["throw"] || ((t3 = y3["return"]) && t3.call(y3), 0) : y3.next) && !(t3 = t3.call(y3, op[1])).done)
              return t3;
            if (y3 = 0, t3)
              op = [op[0] & 2, t3.value];
            switch (op[0]) {
              case 0:
              case 1:
                t3 = op;
                break;
              case 4:
                _2.label++;
                return { value: op[1], done: false };
              case 5:
                _2.label++;
                y3 = op[1];
                op = [0];
                continue;
              case 7:
                op = _2.ops.pop();
                _2.trys.pop();
                continue;
              default:
                if (!(t3 = _2.trys, t3 = t3.length > 0 && t3[t3.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _2 = 0;
                  continue;
                }
                if (op[0] === 3 && (!t3 || op[1] > t3[0] && op[1] < t3[3])) {
                  _2.label = op[1];
                  break;
                }
                if (op[0] === 6 && _2.label < t3[1]) {
                  _2.label = t3[1];
                  t3 = op;
                  break;
                }
                if (t3 && _2.label < t3[2]) {
                  _2.label = t3[2];
                  _2.ops.push(op);
                  break;
                }
                if (t3[2])
                  _2.ops.pop();
                _2.trys.pop();
                continue;
            }
            op = body.call(thisArg, _2);
          } catch (e3) {
            op = [6, e3];
            y3 = 0;
          } finally {
            f = t3 = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    __createBinding = function(o2, m3, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m3[k2];
    };
    __exportStar = function(m3, exports) {
      for (var p2 in m3)
        if (p2 !== "default" && !exports.hasOwnProperty(p2))
          exports[p2] = m3[p2];
    };
    __values2 = function(o2) {
      var s3 = typeof Symbol === "function" && Symbol.iterator, m3 = s3 && o2[s3], i2 = 0;
      if (m3)
        return m3.call(o2);
      if (o2 && typeof o2.length === "number")
        return {
          next: function() {
            if (o2 && i2 >= o2.length)
              o2 = void 0;
            return { value: o2 && o2[i2++], done: !o2 };
          }
        };
      throw new TypeError(s3 ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    __read2 = function(o2, n2) {
      var m3 = typeof Symbol === "function" && o2[Symbol.iterator];
      if (!m3)
        return o2;
      var i2 = m3.call(o2), r2, ar2 = [], e3;
      try {
        while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
          ar2.push(r2.value);
      } catch (error) {
        e3 = { error };
      } finally {
        try {
          if (r2 && !r2.done && (m3 = i2["return"]))
            m3.call(i2);
        } finally {
          if (e3)
            throw e3.error;
        }
      }
      return ar2;
    };
    __spread2 = function() {
      for (var ar2 = [], i2 = 0; i2 < arguments.length; i2++)
        ar2 = ar2.concat(__read2(arguments[i2]));
      return ar2;
    };
    __spreadArrays = function() {
      for (var s3 = 0, i2 = 0, il2 = arguments.length; i2 < il2; i2++)
        s3 += arguments[i2].length;
      for (var r2 = Array(s3), k2 = 0, i2 = 0; i2 < il2; i2++)
        for (var a3 = arguments[i2], j = 0, jl2 = a3.length; j < jl2; j++, k2++)
          r2[k2] = a3[j];
      return r2;
    };
    __await = function(v) {
      return this instanceof __await ? (this.v = v, this) : new __await(v);
    };
    __asyncGenerator = function(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var g = generator.apply(thisArg, _arguments || []), i2, q2 = [];
      return i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
        return this;
      }, i2;
      function verb(n2) {
        if (g[n2])
          i2[n2] = function(v) {
            return new Promise(function(a3, b3) {
              q2.push([n2, v, a3, b3]) > 1 || resume(n2, v);
            });
          };
      }
      function resume(n2, v) {
        try {
          step(g[n2](v));
        } catch (e3) {
          settle2(q2[0][3], e3);
        }
      }
      function step(r2) {
        r2.value instanceof __await ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle2(q2[0][2], r2);
      }
      function fulfill(value) {
        resume("next", value);
      }
      function reject(value) {
        resume("throw", value);
      }
      function settle2(f, v) {
        if (f(v), q2.shift(), q2.length)
          resume(q2[0][0], q2[0][1]);
      }
    };
    __asyncDelegator = function(o2) {
      var i2, p2;
      return i2 = {}, verb("next"), verb("throw", function(e3) {
        throw e3;
      }), verb("return"), i2[Symbol.iterator] = function() {
        return this;
      }, i2;
      function verb(n2, f) {
        i2[n2] = o2[n2] ? function(v) {
          return (p2 = !p2) ? { value: __await(o2[n2](v)), done: n2 === "return" } : f ? f(v) : v;
        } : f;
      }
    };
    __asyncValues = function(o2) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var m3 = o2[Symbol.asyncIterator], i2;
      return m3 ? m3.call(o2) : (o2 = typeof __values2 === "function" ? __values2(o2) : o2[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
        return this;
      }, i2);
      function verb(n2) {
        i2[n2] = o2[n2] && function(v) {
          return new Promise(function(resolve2, reject) {
            v = o2[n2](v), settle2(resolve2, reject, v.done, v.value);
          });
        };
      }
      function settle2(resolve2, reject, d3, v) {
        Promise.resolve(v).then(function(v2) {
          resolve2({ value: v2, done: d3 });
        }, reject);
      }
    };
    __makeTemplateObject = function(cooked, raw) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", { value: raw });
      } else {
        cooked.raw = raw;
      }
      return cooked;
    };
    __importStar = function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod)
          if (Object.hasOwnProperty.call(mod, k2))
            result[k2] = mod[k2];
      }
      result["default"] = mod;
      return result;
    };
    __importDefault = function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    __classPrivateFieldGet = function(receiver, privateMap) {
      if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
      }
      return privateMap.get(receiver);
    };
    __classPrivateFieldSet = function(receiver, privateMap, value) {
      if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
      }
      privateMap.set(receiver, value);
      return value;
    };
    exporter("__extends", __extends2);
    exporter("__assign", __assign2);
    exporter("__rest", __rest2);
    exporter("__decorate", __decorate);
    exporter("__param", __param);
    exporter("__metadata", __metadata);
    exporter("__awaiter", __awaiter2);
    exporter("__generator", __generator2);
    exporter("__exportStar", __exportStar);
    exporter("__createBinding", __createBinding);
    exporter("__values", __values2);
    exporter("__read", __read2);
    exporter("__spread", __spread2);
    exporter("__spreadArrays", __spreadArrays);
    exporter("__await", __await);
    exporter("__asyncGenerator", __asyncGenerator);
    exporter("__asyncDelegator", __asyncDelegator);
    exporter("__asyncValues", __asyncValues);
    exporter("__makeTemplateObject", __makeTemplateObject);
    exporter("__importStar", __importStar);
    exporter("__importDefault", __importDefault);
    exporter("__classPrivateFieldGet", __classPrivateFieldGet);
    exporter("__classPrivateFieldSet", __classPrivateFieldSet);
  });
})(tslib$2);
var crossPlatformSha256 = {};
var ie11Sha256 = {};
var isEmptyData$1 = {};
Object.defineProperty(isEmptyData$1, "__esModule", { value: true });
isEmptyData$1.isEmptyData = void 0;
function isEmptyData(data) {
  if (typeof data === "string") {
    return data.length === 0;
  }
  return data.byteLength === 0;
}
isEmptyData$1.isEmptyData = isEmptyData;
var constants = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EMPTY_DATA_SHA_256 = exports.SHA_256_HMAC_ALGO = exports.SHA_256_HASH = void 0;
  exports.SHA_256_HASH = { name: "SHA-256" };
  exports.SHA_256_HMAC_ALGO = {
    name: "HMAC",
    hash: exports.SHA_256_HASH
  };
  exports.EMPTY_DATA_SHA_256 = new Uint8Array([
    227,
    176,
    196,
    66,
    152,
    252,
    28,
    20,
    154,
    251,
    244,
    200,
    153,
    111,
    185,
    36,
    39,
    174,
    65,
    228,
    100,
    155,
    147,
    76,
    164,
    149,
    153,
    27,
    120,
    82,
    184,
    85
  ]);
})(constants);
const fallbackWindow = {};
function locateWindow() {
  if (typeof window !== "undefined") {
    return window;
  } else if (typeof self !== "undefined") {
    return self;
  }
  return fallbackWindow;
}
const distEs = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  locateWindow
}, Symbol.toStringTag, { value: "Module" }));
const require$$5 = /* @__PURE__ */ getAugmentedNamespace(distEs);
Object.defineProperty(ie11Sha256, "__esModule", { value: true });
ie11Sha256.Sha256 = void 0;
var isEmptyData_1 = isEmptyData$1;
var constants_1$1 = constants;
var util_utf8_browser_1 = require$$0$1;
var util_locate_window_1$2 = require$$5;
var Sha256$2 = function() {
  function Sha2562(secret) {
    if (secret) {
      this.operation = getKeyPromise(secret).then(function(keyData) {
        return (0, util_locate_window_1$2.locateWindow)().msCrypto.subtle.sign(constants_1$1.SHA_256_HMAC_ALGO, keyData);
      });
      this.operation.catch(function() {
      });
    } else {
      this.operation = Promise.resolve((0, util_locate_window_1$2.locateWindow)().msCrypto.subtle.digest("SHA-256"));
    }
  }
  Sha2562.prototype.update = function(toHash) {
    var _this = this;
    if ((0, isEmptyData_1.isEmptyData)(toHash)) {
      return;
    }
    this.operation = this.operation.then(function(operation) {
      operation.onerror = function() {
        _this.operation = Promise.reject(new Error("Error encountered updating hash"));
      };
      operation.process(toArrayBufferView(toHash));
      return operation;
    });
    this.operation.catch(function() {
    });
  };
  Sha2562.prototype.digest = function() {
    return this.operation.then(function(operation) {
      return new Promise(function(resolve2, reject) {
        operation.onerror = function() {
          reject(new Error("Error encountered finalizing hash"));
        };
        operation.oncomplete = function() {
          if (operation.result) {
            resolve2(new Uint8Array(operation.result));
          }
          reject(new Error("Error encountered finalizing hash"));
        };
        operation.finish();
      });
    });
  };
  return Sha2562;
}();
ie11Sha256.Sha256 = Sha256$2;
function getKeyPromise(secret) {
  return new Promise(function(resolve2, reject) {
    var keyOperation = (0, util_locate_window_1$2.locateWindow)().msCrypto.subtle.importKey("raw", toArrayBufferView(secret), constants_1$1.SHA_256_HMAC_ALGO, false, ["sign"]);
    keyOperation.oncomplete = function() {
      if (keyOperation.result) {
        resolve2(keyOperation.result);
      }
      reject(new Error("ImportKey completed without importing key."));
    };
    keyOperation.onerror = function() {
      reject(new Error("ImportKey failed to import key."));
    };
  });
}
function toArrayBufferView(data) {
  if (typeof data === "string") {
    return (0, util_utf8_browser_1.fromUtf8)(data);
  }
  if (ArrayBuffer.isView(data)) {
    return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
  }
  return new Uint8Array(data);
}
var webCryptoSha256 = {};
Object.defineProperty(webCryptoSha256, "__esModule", { value: true });
webCryptoSha256.Sha256 = void 0;
var util_1 = build$3;
var constants_1 = constants;
var util_locate_window_1$1 = require$$5;
var Sha256$1 = function() {
  function Sha2562(secret) {
    this.toHash = new Uint8Array(0);
    if (secret !== void 0) {
      this.key = new Promise(function(resolve2, reject) {
        (0, util_locate_window_1$1.locateWindow)().crypto.subtle.importKey("raw", (0, util_1.convertToBuffer)(secret), constants_1.SHA_256_HMAC_ALGO, false, ["sign"]).then(resolve2, reject);
      });
      this.key.catch(function() {
      });
    }
  }
  Sha2562.prototype.update = function(data) {
    if ((0, util_1.isEmptyData)(data)) {
      return;
    }
    var update = (0, util_1.convertToBuffer)(data);
    var typedArray = new Uint8Array(this.toHash.byteLength + update.byteLength);
    typedArray.set(this.toHash, 0);
    typedArray.set(update, this.toHash.byteLength);
    this.toHash = typedArray;
  };
  Sha2562.prototype.digest = function() {
    var _this = this;
    if (this.key) {
      return this.key.then(function(key) {
        return (0, util_locate_window_1$1.locateWindow)().crypto.subtle.sign(constants_1.SHA_256_HMAC_ALGO, key, _this.toHash).then(function(data) {
          return new Uint8Array(data);
        });
      });
    }
    if ((0, util_1.isEmptyData)(this.toHash)) {
      return Promise.resolve(constants_1.EMPTY_DATA_SHA_256);
    }
    return Promise.resolve().then(function() {
      return (0, util_locate_window_1$1.locateWindow)().crypto.subtle.digest(constants_1.SHA_256_HASH, _this.toHash);
    }).then(function(data) {
      return Promise.resolve(new Uint8Array(data));
    });
  };
  return Sha2562;
}();
webCryptoSha256.Sha256 = Sha256$1;
var build$1 = {};
var tslib$1 = { exports: {} };
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
(function(module2) {
  var __extends2;
  var __assign2;
  var __rest2;
  var __decorate;
  var __param;
  var __metadata;
  var __awaiter2;
  var __generator2;
  var __exportStar;
  var __values2;
  var __read2;
  var __spread2;
  var __spreadArrays;
  var __await;
  var __asyncGenerator;
  var __asyncDelegator;
  var __asyncValues;
  var __makeTemplateObject;
  var __importStar;
  var __importDefault;
  var __classPrivateFieldGet;
  var __classPrivateFieldSet;
  var __createBinding;
  (function(factory) {
    var root = typeof commonjsGlobal === "object" ? commonjsGlobal : typeof self === "object" ? self : typeof this === "object" ? this : {};
    {
      factory(createExporter(root, createExporter(module2.exports)));
    }
    function createExporter(exports, previous) {
      if (exports !== root) {
        if (typeof Object.create === "function") {
          Object.defineProperty(exports, "__esModule", { value: true });
        } else {
          exports.__esModule = true;
        }
      }
      return function(id, v) {
        return exports[id] = previous ? previous(id, v) : v;
      };
    }
  })(function(exporter) {
    var extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p2 in b3)
        if (b3.hasOwnProperty(p2))
          d3[p2] = b3[p2];
    };
    __extends2 = function(d3, b3) {
      extendStatics2(d3, b3);
      function __() {
        this.constructor = d3;
      }
      d3.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __());
    };
    __assign2 = Object.assign || function(t3) {
      for (var s3, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
        s3 = arguments[i2];
        for (var p2 in s3)
          if (Object.prototype.hasOwnProperty.call(s3, p2))
            t3[p2] = s3[p2];
      }
      return t3;
    };
    __rest2 = function(s3, e3) {
      var t3 = {};
      for (var p2 in s3)
        if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
          t3[p2] = s3[p2];
      if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s3); i2 < p2.length; i2++) {
          if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i2]))
            t3[p2[i2]] = s3[p2[i2]];
        }
      return t3;
    };
    __decorate = function(decorators, target, key, desc) {
      var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r2 = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i2 = decorators.length - 1; i2 >= 0; i2--)
          if (d3 = decorators[i2])
            r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key, r2) : d3(target, key)) || r2;
      return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
    };
    __param = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    __metadata = function(metadataKey, metadataValue) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(metadataKey, metadataValue);
    };
    __awaiter2 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e3) {
            reject(e3);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e3) {
            reject(e3);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    __generator2 = function(thisArg, body) {
      var _2 = { label: 0, sent: function() {
        if (t3[0] & 1)
          throw t3[1];
        return t3[1];
      }, trys: [], ops: [] }, f, y3, t3, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n2) {
        return function(v) {
          return step([n2, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_2)
          try {
            if (f = 1, y3 && (t3 = op[0] & 2 ? y3["return"] : op[0] ? y3["throw"] || ((t3 = y3["return"]) && t3.call(y3), 0) : y3.next) && !(t3 = t3.call(y3, op[1])).done)
              return t3;
            if (y3 = 0, t3)
              op = [op[0] & 2, t3.value];
            switch (op[0]) {
              case 0:
              case 1:
                t3 = op;
                break;
              case 4:
                _2.label++;
                return { value: op[1], done: false };
              case 5:
                _2.label++;
                y3 = op[1];
                op = [0];
                continue;
              case 7:
                op = _2.ops.pop();
                _2.trys.pop();
                continue;
              default:
                if (!(t3 = _2.trys, t3 = t3.length > 0 && t3[t3.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _2 = 0;
                  continue;
                }
                if (op[0] === 3 && (!t3 || op[1] > t3[0] && op[1] < t3[3])) {
                  _2.label = op[1];
                  break;
                }
                if (op[0] === 6 && _2.label < t3[1]) {
                  _2.label = t3[1];
                  t3 = op;
                  break;
                }
                if (t3 && _2.label < t3[2]) {
                  _2.label = t3[2];
                  _2.ops.push(op);
                  break;
                }
                if (t3[2])
                  _2.ops.pop();
                _2.trys.pop();
                continue;
            }
            op = body.call(thisArg, _2);
          } catch (e3) {
            op = [6, e3];
            y3 = 0;
          } finally {
            f = t3 = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    __createBinding = function(o2, m3, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m3[k2];
    };
    __exportStar = function(m3, exports) {
      for (var p2 in m3)
        if (p2 !== "default" && !exports.hasOwnProperty(p2))
          exports[p2] = m3[p2];
    };
    __values2 = function(o2) {
      var s3 = typeof Symbol === "function" && Symbol.iterator, m3 = s3 && o2[s3], i2 = 0;
      if (m3)
        return m3.call(o2);
      if (o2 && typeof o2.length === "number")
        return {
          next: function() {
            if (o2 && i2 >= o2.length)
              o2 = void 0;
            return { value: o2 && o2[i2++], done: !o2 };
          }
        };
      throw new TypeError(s3 ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    __read2 = function(o2, n2) {
      var m3 = typeof Symbol === "function" && o2[Symbol.iterator];
      if (!m3)
        return o2;
      var i2 = m3.call(o2), r2, ar2 = [], e3;
      try {
        while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
          ar2.push(r2.value);
      } catch (error) {
        e3 = { error };
      } finally {
        try {
          if (r2 && !r2.done && (m3 = i2["return"]))
            m3.call(i2);
        } finally {
          if (e3)
            throw e3.error;
        }
      }
      return ar2;
    };
    __spread2 = function() {
      for (var ar2 = [], i2 = 0; i2 < arguments.length; i2++)
        ar2 = ar2.concat(__read2(arguments[i2]));
      return ar2;
    };
    __spreadArrays = function() {
      for (var s3 = 0, i2 = 0, il2 = arguments.length; i2 < il2; i2++)
        s3 += arguments[i2].length;
      for (var r2 = Array(s3), k2 = 0, i2 = 0; i2 < il2; i2++)
        for (var a3 = arguments[i2], j = 0, jl2 = a3.length; j < jl2; j++, k2++)
          r2[k2] = a3[j];
      return r2;
    };
    __await = function(v) {
      return this instanceof __await ? (this.v = v, this) : new __await(v);
    };
    __asyncGenerator = function(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var g = generator.apply(thisArg, _arguments || []), i2, q2 = [];
      return i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
        return this;
      }, i2;
      function verb(n2) {
        if (g[n2])
          i2[n2] = function(v) {
            return new Promise(function(a3, b3) {
              q2.push([n2, v, a3, b3]) > 1 || resume(n2, v);
            });
          };
      }
      function resume(n2, v) {
        try {
          step(g[n2](v));
        } catch (e3) {
          settle2(q2[0][3], e3);
        }
      }
      function step(r2) {
        r2.value instanceof __await ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle2(q2[0][2], r2);
      }
      function fulfill(value) {
        resume("next", value);
      }
      function reject(value) {
        resume("throw", value);
      }
      function settle2(f, v) {
        if (f(v), q2.shift(), q2.length)
          resume(q2[0][0], q2[0][1]);
      }
    };
    __asyncDelegator = function(o2) {
      var i2, p2;
      return i2 = {}, verb("next"), verb("throw", function(e3) {
        throw e3;
      }), verb("return"), i2[Symbol.iterator] = function() {
        return this;
      }, i2;
      function verb(n2, f) {
        i2[n2] = o2[n2] ? function(v) {
          return (p2 = !p2) ? { value: __await(o2[n2](v)), done: n2 === "return" } : f ? f(v) : v;
        } : f;
      }
    };
    __asyncValues = function(o2) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var m3 = o2[Symbol.asyncIterator], i2;
      return m3 ? m3.call(o2) : (o2 = typeof __values2 === "function" ? __values2(o2) : o2[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
        return this;
      }, i2);
      function verb(n2) {
        i2[n2] = o2[n2] && function(v) {
          return new Promise(function(resolve2, reject) {
            v = o2[n2](v), settle2(resolve2, reject, v.done, v.value);
          });
        };
      }
      function settle2(resolve2, reject, d3, v) {
        Promise.resolve(v).then(function(v2) {
          resolve2({ value: v2, done: d3 });
        }, reject);
      }
    };
    __makeTemplateObject = function(cooked, raw) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", { value: raw });
      } else {
        cooked.raw = raw;
      }
      return cooked;
    };
    __importStar = function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod)
          if (Object.hasOwnProperty.call(mod, k2))
            result[k2] = mod[k2];
      }
      result["default"] = mod;
      return result;
    };
    __importDefault = function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    __classPrivateFieldGet = function(receiver, privateMap) {
      if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
      }
      return privateMap.get(receiver);
    };
    __classPrivateFieldSet = function(receiver, privateMap, value) {
      if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
      }
      privateMap.set(receiver, value);
      return value;
    };
    exporter("__extends", __extends2);
    exporter("__assign", __assign2);
    exporter("__rest", __rest2);
    exporter("__decorate", __decorate);
    exporter("__param", __param);
    exporter("__metadata", __metadata);
    exporter("__awaiter", __awaiter2);
    exporter("__generator", __generator2);
    exporter("__exportStar", __exportStar);
    exporter("__createBinding", __createBinding);
    exporter("__values", __values2);
    exporter("__read", __read2);
    exporter("__spread", __spread2);
    exporter("__spreadArrays", __spreadArrays);
    exporter("__await", __await);
    exporter("__asyncGenerator", __asyncGenerator);
    exporter("__asyncDelegator", __asyncDelegator);
    exporter("__asyncValues", __asyncValues);
    exporter("__makeTemplateObject", __makeTemplateObject);
    exporter("__importStar", __importStar);
    exporter("__importDefault", __importDefault);
    exporter("__classPrivateFieldGet", __classPrivateFieldGet);
    exporter("__classPrivateFieldSet", __classPrivateFieldSet);
  });
})(tslib$1);
var supportsWebCrypto = {};
var hasRequiredSupportsWebCrypto;
function requireSupportsWebCrypto() {
  if (hasRequiredSupportsWebCrypto)
    return supportsWebCrypto;
  hasRequiredSupportsWebCrypto = 1;
  Object.defineProperty(supportsWebCrypto, "__esModule", { value: true });
  supportsWebCrypto.supportsZeroByteGCM = supportsWebCrypto.supportsSubtleCrypto = supportsWebCrypto.supportsSecureRandom = supportsWebCrypto.supportsWebCrypto = void 0;
  var tslib_12 = tslib$1.exports;
  var subtleCryptoMethods = [
    "decrypt",
    "digest",
    "encrypt",
    "exportKey",
    "generateKey",
    "importKey",
    "sign",
    "verify"
  ];
  function supportsWebCrypto$1(window2) {
    if (supportsSecureRandom(window2) && typeof window2.crypto.subtle === "object") {
      var subtle = window2.crypto.subtle;
      return supportsSubtleCrypto(subtle);
    }
    return false;
  }
  supportsWebCrypto.supportsWebCrypto = supportsWebCrypto$1;
  function supportsSecureRandom(window2) {
    if (typeof window2 === "object" && typeof window2.crypto === "object") {
      var getRandomValues2 = window2.crypto.getRandomValues;
      return typeof getRandomValues2 === "function";
    }
    return false;
  }
  supportsWebCrypto.supportsSecureRandom = supportsSecureRandom;
  function supportsSubtleCrypto(subtle) {
    return subtle && subtleCryptoMethods.every(function(methodName) {
      return typeof subtle[methodName] === "function";
    });
  }
  supportsWebCrypto.supportsSubtleCrypto = supportsSubtleCrypto;
  function supportsZeroByteGCM(subtle) {
    return tslib_12.__awaiter(this, void 0, void 0, function() {
      var key, zeroByteAuthTag;
      return tslib_12.__generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            if (!supportsSubtleCrypto(subtle))
              return [2, false];
            _b.label = 1;
          case 1:
            _b.trys.push([1, 4, , 5]);
            return [4, subtle.generateKey({ name: "AES-GCM", length: 128 }, false, ["encrypt"])];
          case 2:
            key = _b.sent();
            return [4, subtle.encrypt({
              name: "AES-GCM",
              iv: new Uint8Array(Array(12)),
              additionalData: new Uint8Array(Array(16)),
              tagLength: 128
            }, key, new Uint8Array(0))];
          case 3:
            zeroByteAuthTag = _b.sent();
            return [2, zeroByteAuthTag.byteLength === 16];
          case 4:
            _b.sent();
            return [2, false];
          case 5:
            return [2];
        }
      });
    });
  }
  supportsWebCrypto.supportsZeroByteGCM = supportsZeroByteGCM;
  return supportsWebCrypto;
}
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tslib_12 = tslib$1.exports;
  tslib_12.__exportStar(requireSupportsWebCrypto(), exports);
})(build$1);
var build = {};
var tslib = { exports: {} };
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
(function(module2) {
  var __extends2;
  var __assign2;
  var __rest2;
  var __decorate;
  var __param;
  var __metadata;
  var __awaiter2;
  var __generator2;
  var __exportStar;
  var __values2;
  var __read2;
  var __spread2;
  var __spreadArrays;
  var __await;
  var __asyncGenerator;
  var __asyncDelegator;
  var __asyncValues;
  var __makeTemplateObject;
  var __importStar;
  var __importDefault;
  var __classPrivateFieldGet;
  var __classPrivateFieldSet;
  var __createBinding;
  (function(factory) {
    var root = typeof commonjsGlobal === "object" ? commonjsGlobal : typeof self === "object" ? self : typeof this === "object" ? this : {};
    {
      factory(createExporter(root, createExporter(module2.exports)));
    }
    function createExporter(exports, previous) {
      if (exports !== root) {
        if (typeof Object.create === "function") {
          Object.defineProperty(exports, "__esModule", { value: true });
        } else {
          exports.__esModule = true;
        }
      }
      return function(id, v) {
        return exports[id] = previous ? previous(id, v) : v;
      };
    }
  })(function(exporter) {
    var extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p2 in b3)
        if (b3.hasOwnProperty(p2))
          d3[p2] = b3[p2];
    };
    __extends2 = function(d3, b3) {
      extendStatics2(d3, b3);
      function __() {
        this.constructor = d3;
      }
      d3.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __());
    };
    __assign2 = Object.assign || function(t3) {
      for (var s3, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
        s3 = arguments[i2];
        for (var p2 in s3)
          if (Object.prototype.hasOwnProperty.call(s3, p2))
            t3[p2] = s3[p2];
      }
      return t3;
    };
    __rest2 = function(s3, e3) {
      var t3 = {};
      for (var p2 in s3)
        if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
          t3[p2] = s3[p2];
      if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s3); i2 < p2.length; i2++) {
          if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i2]))
            t3[p2[i2]] = s3[p2[i2]];
        }
      return t3;
    };
    __decorate = function(decorators, target, key, desc) {
      var c2 = arguments.length, r2 = c2 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d3;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r2 = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i2 = decorators.length - 1; i2 >= 0; i2--)
          if (d3 = decorators[i2])
            r2 = (c2 < 3 ? d3(r2) : c2 > 3 ? d3(target, key, r2) : d3(target, key)) || r2;
      return c2 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
    };
    __param = function(paramIndex, decorator) {
      return function(target, key) {
        decorator(target, key, paramIndex);
      };
    };
    __metadata = function(metadataKey, metadataValue) {
      if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
        return Reflect.metadata(metadataKey, metadataValue);
    };
    __awaiter2 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve2) {
          resolve2(value);
        });
      }
      return new (P || (P = Promise))(function(resolve2, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e3) {
            reject(e3);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e3) {
            reject(e3);
          }
        }
        function step(result) {
          result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    __generator2 = function(thisArg, body) {
      var _2 = { label: 0, sent: function() {
        if (t3[0] & 1)
          throw t3[1];
        return t3[1];
      }, trys: [], ops: [] }, f, y3, t3, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n2) {
        return function(v) {
          return step([n2, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_2)
          try {
            if (f = 1, y3 && (t3 = op[0] & 2 ? y3["return"] : op[0] ? y3["throw"] || ((t3 = y3["return"]) && t3.call(y3), 0) : y3.next) && !(t3 = t3.call(y3, op[1])).done)
              return t3;
            if (y3 = 0, t3)
              op = [op[0] & 2, t3.value];
            switch (op[0]) {
              case 0:
              case 1:
                t3 = op;
                break;
              case 4:
                _2.label++;
                return { value: op[1], done: false };
              case 5:
                _2.label++;
                y3 = op[1];
                op = [0];
                continue;
              case 7:
                op = _2.ops.pop();
                _2.trys.pop();
                continue;
              default:
                if (!(t3 = _2.trys, t3 = t3.length > 0 && t3[t3.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _2 = 0;
                  continue;
                }
                if (op[0] === 3 && (!t3 || op[1] > t3[0] && op[1] < t3[3])) {
                  _2.label = op[1];
                  break;
                }
                if (op[0] === 6 && _2.label < t3[1]) {
                  _2.label = t3[1];
                  t3 = op;
                  break;
                }
                if (t3 && _2.label < t3[2]) {
                  _2.label = t3[2];
                  _2.ops.push(op);
                  break;
                }
                if (t3[2])
                  _2.ops.pop();
                _2.trys.pop();
                continue;
            }
            op = body.call(thisArg, _2);
          } catch (e3) {
            op = [6, e3];
            y3 = 0;
          } finally {
            f = t3 = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    __createBinding = function(o2, m3, k2, k22) {
      if (k22 === void 0)
        k22 = k2;
      o2[k22] = m3[k2];
    };
    __exportStar = function(m3, exports) {
      for (var p2 in m3)
        if (p2 !== "default" && !exports.hasOwnProperty(p2))
          exports[p2] = m3[p2];
    };
    __values2 = function(o2) {
      var s3 = typeof Symbol === "function" && Symbol.iterator, m3 = s3 && o2[s3], i2 = 0;
      if (m3)
        return m3.call(o2);
      if (o2 && typeof o2.length === "number")
        return {
          next: function() {
            if (o2 && i2 >= o2.length)
              o2 = void 0;
            return { value: o2 && o2[i2++], done: !o2 };
          }
        };
      throw new TypeError(s3 ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    __read2 = function(o2, n2) {
      var m3 = typeof Symbol === "function" && o2[Symbol.iterator];
      if (!m3)
        return o2;
      var i2 = m3.call(o2), r2, ar2 = [], e3;
      try {
        while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
          ar2.push(r2.value);
      } catch (error) {
        e3 = { error };
      } finally {
        try {
          if (r2 && !r2.done && (m3 = i2["return"]))
            m3.call(i2);
        } finally {
          if (e3)
            throw e3.error;
        }
      }
      return ar2;
    };
    __spread2 = function() {
      for (var ar2 = [], i2 = 0; i2 < arguments.length; i2++)
        ar2 = ar2.concat(__read2(arguments[i2]));
      return ar2;
    };
    __spreadArrays = function() {
      for (var s3 = 0, i2 = 0, il2 = arguments.length; i2 < il2; i2++)
        s3 += arguments[i2].length;
      for (var r2 = Array(s3), k2 = 0, i2 = 0; i2 < il2; i2++)
        for (var a3 = arguments[i2], j = 0, jl2 = a3.length; j < jl2; j++, k2++)
          r2[k2] = a3[j];
      return r2;
    };
    __await = function(v) {
      return this instanceof __await ? (this.v = v, this) : new __await(v);
    };
    __asyncGenerator = function(thisArg, _arguments, generator) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var g = generator.apply(thisArg, _arguments || []), i2, q2 = [];
      return i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
        return this;
      }, i2;
      function verb(n2) {
        if (g[n2])
          i2[n2] = function(v) {
            return new Promise(function(a3, b3) {
              q2.push([n2, v, a3, b3]) > 1 || resume(n2, v);
            });
          };
      }
      function resume(n2, v) {
        try {
          step(g[n2](v));
        } catch (e3) {
          settle2(q2[0][3], e3);
        }
      }
      function step(r2) {
        r2.value instanceof __await ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle2(q2[0][2], r2);
      }
      function fulfill(value) {
        resume("next", value);
      }
      function reject(value) {
        resume("throw", value);
      }
      function settle2(f, v) {
        if (f(v), q2.shift(), q2.length)
          resume(q2[0][0], q2[0][1]);
      }
    };
    __asyncDelegator = function(o2) {
      var i2, p2;
      return i2 = {}, verb("next"), verb("throw", function(e3) {
        throw e3;
      }), verb("return"), i2[Symbol.iterator] = function() {
        return this;
      }, i2;
      function verb(n2, f) {
        i2[n2] = o2[n2] ? function(v) {
          return (p2 = !p2) ? { value: __await(o2[n2](v)), done: n2 === "return" } : f ? f(v) : v;
        } : f;
      }
    };
    __asyncValues = function(o2) {
      if (!Symbol.asyncIterator)
        throw new TypeError("Symbol.asyncIterator is not defined.");
      var m3 = o2[Symbol.asyncIterator], i2;
      return m3 ? m3.call(o2) : (o2 = typeof __values2 === "function" ? __values2(o2) : o2[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
        return this;
      }, i2);
      function verb(n2) {
        i2[n2] = o2[n2] && function(v) {
          return new Promise(function(resolve2, reject) {
            v = o2[n2](v), settle2(resolve2, reject, v.done, v.value);
          });
        };
      }
      function settle2(resolve2, reject, d3, v) {
        Promise.resolve(v).then(function(v2) {
          resolve2({ value: v2, done: d3 });
        }, reject);
      }
    };
    __makeTemplateObject = function(cooked, raw) {
      if (Object.defineProperty) {
        Object.defineProperty(cooked, "raw", { value: raw });
      } else {
        cooked.raw = raw;
      }
      return cooked;
    };
    __importStar = function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k2 in mod)
          if (Object.hasOwnProperty.call(mod, k2))
            result[k2] = mod[k2];
      }
      result["default"] = mod;
      return result;
    };
    __importDefault = function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    __classPrivateFieldGet = function(receiver, privateMap) {
      if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
      }
      return privateMap.get(receiver);
    };
    __classPrivateFieldSet = function(receiver, privateMap, value) {
      if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
      }
      privateMap.set(receiver, value);
      return value;
    };
    exporter("__extends", __extends2);
    exporter("__assign", __assign2);
    exporter("__rest", __rest2);
    exporter("__decorate", __decorate);
    exporter("__param", __param);
    exporter("__metadata", __metadata);
    exporter("__awaiter", __awaiter2);
    exporter("__generator", __generator2);
    exporter("__exportStar", __exportStar);
    exporter("__createBinding", __createBinding);
    exporter("__values", __values2);
    exporter("__read", __read2);
    exporter("__spread", __spread2);
    exporter("__spreadArrays", __spreadArrays);
    exporter("__await", __await);
    exporter("__asyncGenerator", __asyncGenerator);
    exporter("__asyncDelegator", __asyncDelegator);
    exporter("__asyncValues", __asyncValues);
    exporter("__makeTemplateObject", __makeTemplateObject);
    exporter("__importStar", __importStar);
    exporter("__importDefault", __importDefault);
    exporter("__classPrivateFieldGet", __classPrivateFieldGet);
    exporter("__classPrivateFieldSet", __classPrivateFieldSet);
  });
})(tslib);
var CryptoOperation = {};
var hasRequiredCryptoOperation;
function requireCryptoOperation() {
  if (hasRequiredCryptoOperation)
    return CryptoOperation;
  hasRequiredCryptoOperation = 1;
  Object.defineProperty(CryptoOperation, "__esModule", { value: true });
  return CryptoOperation;
}
var Key = {};
var hasRequiredKey;
function requireKey() {
  if (hasRequiredKey)
    return Key;
  hasRequiredKey = 1;
  Object.defineProperty(Key, "__esModule", { value: true });
  return Key;
}
var KeyOperation = {};
var hasRequiredKeyOperation;
function requireKeyOperation() {
  if (hasRequiredKeyOperation)
    return KeyOperation;
  hasRequiredKeyOperation = 1;
  Object.defineProperty(KeyOperation, "__esModule", { value: true });
  return KeyOperation;
}
var MsSubtleCrypto = {};
var hasRequiredMsSubtleCrypto;
function requireMsSubtleCrypto() {
  if (hasRequiredMsSubtleCrypto)
    return MsSubtleCrypto;
  hasRequiredMsSubtleCrypto = 1;
  Object.defineProperty(MsSubtleCrypto, "__esModule", { value: true });
  return MsSubtleCrypto;
}
var MsWindow = {};
var hasRequiredMsWindow;
function requireMsWindow() {
  if (hasRequiredMsWindow)
    return MsWindow;
  hasRequiredMsWindow = 1;
  Object.defineProperty(MsWindow, "__esModule", { value: true });
  MsWindow.isMsWindow = void 0;
  var msSubtleCryptoMethods = [
    "decrypt",
    "digest",
    "encrypt",
    "exportKey",
    "generateKey",
    "importKey",
    "sign",
    "verify"
  ];
  function quacksLikeAnMsWindow(window2) {
    return "MSInputMethodContext" in window2 && "msCrypto" in window2;
  }
  function isMsWindow(window2) {
    if (quacksLikeAnMsWindow(window2) && window2.msCrypto.subtle !== void 0) {
      var _a2 = window2.msCrypto, getRandomValues2 = _a2.getRandomValues, subtle_1 = _a2.subtle;
      return msSubtleCryptoMethods.map(function(methodName) {
        return subtle_1[methodName];
      }).concat(getRandomValues2).every(function(method) {
        return typeof method === "function";
      });
    }
    return false;
  }
  MsWindow.isMsWindow = isMsWindow;
  return MsWindow;
}
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  var tslib_12 = tslib.exports;
  tslib_12.__exportStar(requireCryptoOperation(), exports);
  tslib_12.__exportStar(requireKey(), exports);
  tslib_12.__exportStar(requireKeyOperation(), exports);
  tslib_12.__exportStar(requireMsSubtleCrypto(), exports);
  tslib_12.__exportStar(requireMsWindow(), exports);
})(build);
Object.defineProperty(crossPlatformSha256, "__esModule", { value: true });
crossPlatformSha256.Sha256 = void 0;
var ie11Sha256_1 = ie11Sha256;
var webCryptoSha256_1 = webCryptoSha256;
var sha256_js_1 = build$4;
var supports_web_crypto_1 = build$1;
var ie11_detection_1 = build;
var util_locate_window_1 = require$$5;
var Sha256 = function() {
  function Sha2562(secret) {
    if ((0, supports_web_crypto_1.supportsWebCrypto)((0, util_locate_window_1.locateWindow)())) {
      this.hash = new webCryptoSha256_1.Sha256(secret);
    } else if ((0, ie11_detection_1.isMsWindow)((0, util_locate_window_1.locateWindow)())) {
      this.hash = new ie11Sha256_1.Sha256(secret);
    } else {
      this.hash = new sha256_js_1.Sha256(secret);
    }
  }
  Sha2562.prototype.update = function(data, encoding) {
    this.hash.update(data, encoding);
  };
  Sha2562.prototype.digest = function() {
    return this.hash.digest();
  };
  return Sha2562;
}();
crossPlatformSha256.Sha256 = Sha256;
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.WebCryptoSha256 = exports.Ie11Sha256 = void 0;
  var tslib_12 = tslib$2.exports;
  (0, tslib_12.__exportStar)(crossPlatformSha256, exports);
  var ie11Sha256_12 = ie11Sha256;
  Object.defineProperty(exports, "Ie11Sha256", { enumerable: true, get: function() {
    return ie11Sha256_12.Sha256;
  } });
  var webCryptoSha256_12 = webCryptoSha256;
  Object.defineProperty(exports, "WebCryptoSha256", { enumerable: true, get: function() {
    return webCryptoSha256_12.Sha256;
  } });
})(build$2);
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function __awaiter$c(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator$c(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t3[0] & 1)
      throw t3[1];
    return t3[1];
  }, trys: [], ops: [] }, f, y3, t3, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n2) {
    return function(v) {
      return step([n2, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_2)
      try {
        if (f = 1, y3 && (t3 = op[0] & 2 ? y3["return"] : op[0] ? y3["throw"] || ((t3 = y3["return"]) && t3.call(y3), 0) : y3.next) && !(t3 = t3.call(y3, op[1])).done)
          return t3;
        if (y3 = 0, t3)
          op = [op[0] & 2, t3.value];
        switch (op[0]) {
          case 0:
          case 1:
            t3 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y3 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t3 = _2.trys, t3 = t3.length > 0 && t3[t3.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t3 || op[1] > t3[0] && op[1] < t3[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t3[1]) {
              _2.label = t3[1];
              t3 = op;
              break;
            }
            if (t3 && _2.label < t3[2]) {
              _2.label = t3[2];
              _2.ops.push(op);
              break;
            }
            if (t3[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e3) {
        op = [6, e3];
        y3 = 0;
      } finally {
        f = t3 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __values$4(o2) {
  var s3 = typeof Symbol === "function" && Symbol.iterator, m3 = s3 && o2[s3], i2 = 0;
  if (m3)
    return m3.call(o2);
  if (o2 && typeof o2.length === "number")
    return {
      next: function() {
        if (o2 && i2 >= o2.length)
          o2 = void 0;
        return { value: o2 && o2[i2++], done: !o2 };
      }
    };
  throw new TypeError(s3 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
var HttpResponse = function() {
  function HttpResponse2(options) {
    this.statusCode = options.statusCode;
    this.headers = options.headers || {};
    this.body = options.body;
  }
  HttpResponse2.isInstance = function(response) {
    if (!response)
      return false;
    var resp = response;
    return typeof resp.statusCode === "number" && typeof resp.headers === "object";
  };
  return HttpResponse2;
}();
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var __assign$a = function() {
  __assign$a = Object.assign || function __assign2(t3) {
    for (var s3, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s3 = arguments[i2];
      for (var p2 in s3)
        if (Object.prototype.hasOwnProperty.call(s3, p2))
          t3[p2] = s3[p2];
    }
    return t3;
  };
  return __assign$a.apply(this, arguments);
};
function __read$9(o2, n2) {
  var m3 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m3)
    return o2;
  var i2 = m3.call(o2), r2, ar2 = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
      ar2.push(r2.value);
  } catch (error) {
    e3 = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m3 = i2["return"]))
        m3.call(i2);
    } finally {
      if (e3)
        throw e3.error;
    }
  }
  return ar2;
}
function __spread$5() {
  for (var ar2 = [], i2 = 0; i2 < arguments.length; i2++)
    ar2 = ar2.concat(__read$9(arguments[i2]));
  return ar2;
}
var HttpRequest = function() {
  function HttpRequest2(options) {
    this.method = options.method || "GET";
    this.hostname = options.hostname || "localhost";
    this.port = options.port;
    this.query = options.query || {};
    this.headers = options.headers || {};
    this.body = options.body;
    this.protocol = options.protocol ? options.protocol.substr(-1) !== ":" ? options.protocol + ":" : options.protocol : "https:";
    this.path = options.path ? options.path.charAt(0) !== "/" ? "/" + options.path : options.path : "/";
  }
  HttpRequest2.isInstance = function(request) {
    if (!request)
      return false;
    var req = request;
    return "method" in req && "protocol" in req && "hostname" in req && "path" in req && typeof req["query"] === "object" && typeof req["headers"] === "object";
  };
  HttpRequest2.prototype.clone = function() {
    var cloned = new HttpRequest2(__assign$a(__assign$a({}, this), { headers: __assign$a({}, this.headers) }));
    if (cloned.query)
      cloned.query = cloneQuery$1(cloned.query);
    return cloned;
  };
  return HttpRequest2;
}();
function cloneQuery$1(query) {
  return Object.keys(query).reduce(function(carry, paramName) {
    var _a2;
    var param = query[paramName];
    return __assign$a(__assign$a({}, carry), (_a2 = {}, _a2[paramName] = Array.isArray(param) ? __spread$5(param) : param, _a2));
  }, {});
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function __values$3(o2) {
  var s3 = typeof Symbol === "function" && Symbol.iterator, m3 = s3 && o2[s3], i2 = 0;
  if (m3)
    return m3.call(o2);
  if (o2 && typeof o2.length === "number")
    return {
      next: function() {
        if (o2 && i2 >= o2.length)
          o2 = void 0;
        return { value: o2 && o2[i2++], done: !o2 };
      }
    };
  throw new TypeError(s3 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
var escapeUri = function(uri) {
  return encodeURIComponent(uri).replace(/[!'()*]/g, hexEncode);
};
var hexEncode = function(c2) {
  return "%" + c2.charCodeAt(0).toString(16).toUpperCase();
};
function buildQueryString(query) {
  var e_1, _a2;
  var parts = [];
  try {
    for (var _b = __values$3(Object.keys(query).sort()), _c = _b.next(); !_c.done; _c = _b.next()) {
      var key = _c.value;
      var value = query[key];
      key = escapeUri(key);
      if (Array.isArray(value)) {
        for (var i2 = 0, iLen = value.length; i2 < iLen; i2++) {
          parts.push(key + "=" + escapeUri(value[i2]));
        }
      } else {
        var qsEntry = key;
        if (value || typeof value === "string") {
          qsEntry += "=" + escapeUri(value);
        }
        parts.push(qsEntry);
      }
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (_c && !_c.done && (_a2 = _b.return))
        _a2.call(_b);
    } finally {
      if (e_1)
        throw e_1.error;
    }
  }
  return parts.join("&");
}
function requestTimeout(timeoutInMs) {
  if (timeoutInMs === void 0) {
    timeoutInMs = 0;
  }
  return new Promise(function(resolve2, reject) {
    if (timeoutInMs) {
      setTimeout(function() {
        var timeoutError = new Error("Request did not complete within " + timeoutInMs + " ms");
        timeoutError.name = "TimeoutError";
        reject(timeoutError);
      }, timeoutInMs);
    }
  });
}
var FetchHttpHandler = function() {
  function FetchHttpHandler2(_a2) {
    var _b = _a2 === void 0 ? {} : _a2, requestTimeout2 = _b.requestTimeout;
    this.requestTimeout = requestTimeout2;
  }
  FetchHttpHandler2.prototype.destroy = function() {
  };
  FetchHttpHandler2.prototype.handle = function(request, _a2) {
    var _b = _a2 === void 0 ? {} : _a2, abortSignal = _b.abortSignal;
    var requestTimeoutInMs = this.requestTimeout;
    if (abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.aborted) {
      var abortError = new Error("Request aborted");
      abortError.name = "AbortError";
      return Promise.reject(abortError);
    }
    var path = request.path;
    if (request.query) {
      var queryString = buildQueryString(request.query);
      if (queryString) {
        path += "?" + queryString;
      }
    }
    var port = request.port, method = request.method;
    var url = request.protocol + "//" + request.hostname + (port ? ":" + port : "") + path;
    var body = method === "GET" || method === "HEAD" ? void 0 : request.body;
    var requestOptions = {
      body,
      headers: new Headers(request.headers),
      method
    };
    if (typeof AbortController !== "undefined") {
      requestOptions["signal"] = abortSignal;
    }
    var fetchRequest = new Request(url, requestOptions);
    var raceOfPromises = [
      fetch(fetchRequest).then(function(response) {
        var e_1, _a3;
        var fetchHeaders = response.headers;
        var transformedHeaders = {};
        try {
          for (var _b2 = __values$4(fetchHeaders.entries()), _c = _b2.next(); !_c.done; _c = _b2.next()) {
            var pair = _c.value;
            transformedHeaders[pair[0]] = pair[1];
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a3 = _b2.return))
              _a3.call(_b2);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        var hasReadableStream = response.body !== void 0;
        if (!hasReadableStream) {
          return response.blob().then(function(body2) {
            return {
              response: new HttpResponse({
                headers: transformedHeaders,
                statusCode: response.status,
                body: body2
              })
            };
          });
        }
        return {
          response: new HttpResponse({
            headers: transformedHeaders,
            statusCode: response.status,
            body: response.body
          })
        };
      }),
      requestTimeout(requestTimeoutInMs)
    ];
    if (abortSignal) {
      raceOfPromises.push(new Promise(function(resolve2, reject) {
        abortSignal.onabort = function() {
          var abortError2 = new Error("Request aborted");
          abortError2.name = "AbortError";
          reject(abortError2);
        };
      }));
    }
    return Promise.race(raceOfPromises);
  };
  return FetchHttpHandler2;
}();
var alphabetByEncoding = {};
var alphabetByValue = new Array(64);
for (var i$2 = 0, start = "A".charCodeAt(0), limit = "Z".charCodeAt(0); i$2 + start <= limit; i$2++) {
  var char = String.fromCharCode(i$2 + start);
  alphabetByEncoding[char] = i$2;
  alphabetByValue[i$2] = char;
}
for (var i$2 = 0, start = "a".charCodeAt(0), limit = "z".charCodeAt(0); i$2 + start <= limit; i$2++) {
  var char = String.fromCharCode(i$2 + start);
  var index$1 = i$2 + 26;
  alphabetByEncoding[char] = index$1;
  alphabetByValue[index$1] = char;
}
for (var i$2 = 0; i$2 < 10; i$2++) {
  alphabetByEncoding[i$2.toString(10)] = i$2 + 52;
  var char = i$2.toString(10);
  var index$1 = i$2 + 52;
  alphabetByEncoding[char] = index$1;
  alphabetByValue[index$1] = char;
}
alphabetByEncoding["+"] = 62;
alphabetByValue[62] = "+";
alphabetByEncoding["/"] = 63;
alphabetByValue[63] = "/";
var bitsPerLetter = 6;
var bitsPerByte = 8;
var maxLetterValue = 63;
function fromBase64(input) {
  var totalByteLength = input.length / 4 * 3;
  if (input.substr(-2) === "==") {
    totalByteLength -= 2;
  } else if (input.substr(-1) === "=") {
    totalByteLength--;
  }
  var out = new ArrayBuffer(totalByteLength);
  var dataView = new DataView(out);
  for (var i2 = 0; i2 < input.length; i2 += 4) {
    var bits = 0;
    var bitLength = 0;
    for (var j = i2, limit = i2 + 3; j <= limit; j++) {
      if (input[j] !== "=") {
        bits |= alphabetByEncoding[input[j]] << (limit - j) * bitsPerLetter;
        bitLength += bitsPerLetter;
      } else {
        bits >>= bitsPerLetter;
      }
    }
    var chunkOffset = i2 / 4 * 3;
    bits >>= bitLength % bitsPerByte;
    var byteLength2 = Math.floor(bitLength / bitsPerByte);
    for (var k2 = 0; k2 < byteLength2; k2++) {
      var offset = (byteLength2 - k2 - 1) * bitsPerByte;
      dataView.setUint8(chunkOffset + k2, (bits & 255 << offset) >> offset);
    }
  }
  return new Uint8Array(out);
}
function toBase64(input) {
  var str = "";
  for (var i2 = 0; i2 < input.length; i2 += 3) {
    var bits = 0;
    var bitLength = 0;
    for (var j = i2, limit = Math.min(i2 + 3, input.length); j < limit; j++) {
      bits |= input[j] << (limit - j - 1) * bitsPerByte;
      bitLength += bitsPerByte;
    }
    var bitClusterCount = Math.ceil(bitLength / bitsPerLetter);
    bits <<= bitClusterCount * bitsPerLetter - bitLength;
    for (var k2 = 1; k2 <= bitClusterCount; k2++) {
      var offset = (bitClusterCount - k2) * bitsPerLetter;
      str += alphabetByValue[(bits & maxLetterValue << offset) >> offset];
    }
    str += "==".slice(0, 4 - bitClusterCount);
  }
  return str;
}
var streamCollector = function(stream) {
  if (typeof Blob === "function" && stream instanceof Blob) {
    return collectBlob(stream);
  }
  return collectStream(stream);
};
function collectBlob(blob) {
  return __awaiter$c(this, void 0, void 0, function() {
    var base64, arrayBuffer;
    return __generator$c(this, function(_a2) {
      switch (_a2.label) {
        case 0:
          return [4, readToBase64(blob)];
        case 1:
          base64 = _a2.sent();
          arrayBuffer = fromBase64(base64);
          return [2, new Uint8Array(arrayBuffer)];
      }
    });
  });
}
function collectStream(stream) {
  return __awaiter$c(this, void 0, void 0, function() {
    var res, reader, isDone, _a2, done, value, prior;
    return __generator$c(this, function(_b) {
      switch (_b.label) {
        case 0:
          res = new Uint8Array(0);
          reader = stream.getReader();
          isDone = false;
          _b.label = 1;
        case 1:
          if (!!isDone)
            return [3, 3];
          return [4, reader.read()];
        case 2:
          _a2 = _b.sent(), done = _a2.done, value = _a2.value;
          if (value) {
            prior = res;
            res = new Uint8Array(prior.length + value.length);
            res.set(prior);
            res.set(value, prior.length);
          }
          isDone = done;
          return [3, 1];
        case 3:
          return [2, res];
      }
    });
  });
}
function readToBase64(blob) {
  return new Promise(function(resolve2, reject) {
    var reader = new FileReader();
    reader.onloadend = function() {
      var _a2;
      if (reader.readyState !== 2) {
        return reject(new Error("Reader aborted too early"));
      }
      var result = (_a2 = reader.result) !== null && _a2 !== void 0 ? _a2 : "";
      var commaIndex = result.indexOf(",");
      var dataOffset = commaIndex > -1 ? commaIndex + 1 : result.length;
      resolve2(result.substring(dataOffset));
    };
    reader.onabort = function() {
      return reject(new Error("Read aborted"));
    };
    reader.onerror = function() {
      return reject(reader.error);
    };
    reader.readAsDataURL(blob);
  });
}
var invalidProvider = function(message) {
  return function() {
    return Promise.reject(message);
  };
};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var __assign$9 = function() {
  __assign$9 = Object.assign || function __assign2(t3) {
    for (var s3, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s3 = arguments[i2];
      for (var p2 in s3)
        if (Object.prototype.hasOwnProperty.call(s3, p2))
          t3[p2] = s3[p2];
    }
    return t3;
  };
  return __assign$9.apply(this, arguments);
};
function __awaiter$b(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator$b(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t3[0] & 1)
      throw t3[1];
    return t3[1];
  }, trys: [], ops: [] }, f, y3, t3, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n2) {
    return function(v) {
      return step([n2, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_2)
      try {
        if (f = 1, y3 && (t3 = op[0] & 2 ? y3["return"] : op[0] ? y3["throw"] || ((t3 = y3["return"]) && t3.call(y3), 0) : y3.next) && !(t3 = t3.call(y3, op[1])).done)
          return t3;
        if (y3 = 0, t3)
          op = [op[0] & 2, t3.value];
        switch (op[0]) {
          case 0:
          case 1:
            t3 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y3 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t3 = _2.trys, t3 = t3.length > 0 && t3[t3.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t3 || op[1] > t3[0] && op[1] < t3[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t3[1]) {
              _2.label = t3[1];
              t3 = op;
              break;
            }
            if (t3 && _2.label < t3[2]) {
              _2.label = t3[2];
              _2.ops.push(op);
              break;
            }
            if (t3[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e3) {
        op = [6, e3];
        y3 = 0;
      } finally {
        f = t3 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __read$8(o2, n2) {
  var m3 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m3)
    return o2;
  var i2 = m3.call(o2), r2, ar2 = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
      ar2.push(r2.value);
  } catch (error) {
    e3 = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m3 = i2["return"]))
        m3.call(i2);
    } finally {
      if (e3)
        throw e3.error;
    }
  }
  return ar2;
}
function __spread$4() {
  for (var ar2 = [], i2 = 0; i2 < arguments.length; i2++)
    ar2 = ar2.concat(__read$8(arguments[i2]));
  return ar2;
}
var retryMiddleware = function(options) {
  return function(next, context) {
    return function(args) {
      return __awaiter$b(void 0, void 0, void 0, function() {
        var _a2;
        return __generator$b(this, function(_b) {
          if ((_a2 = options === null || options === void 0 ? void 0 : options.retryStrategy) === null || _a2 === void 0 ? void 0 : _a2.mode)
            context.userAgent = __spread$4(context.userAgent || [], [["cfg/retry-mode", options.retryStrategy.mode]]);
          return [2, options.retryStrategy.retry(next, args)];
        });
      });
    };
  };
};
var retryMiddlewareOptions = {
  name: "retryMiddleware",
  tags: ["RETRY"],
  step: "finalizeRequest",
  priority: "high",
  override: true
};
var getRetryPlugin = function(options) {
  return {
    applyToStack: function(clientStack) {
      clientStack.add(retryMiddleware(options), retryMiddlewareOptions);
    }
  };
};
var DEFAULT_RETRY_DELAY_BASE = 100;
var MAXIMUM_RETRY_DELAY = 20 * 1e3;
var THROTTLING_RETRY_DELAY_BASE = 500;
var INITIAL_RETRY_TOKENS = 500;
var RETRY_COST = 5;
var TIMEOUT_RETRY_COST = 10;
var NO_RETRY_INCREMENT = 1;
var INVOCATION_ID_HEADER = "amz-sdk-invocation-id";
var REQUEST_HEADER = "amz-sdk-request";
var CLOCK_SKEW_ERROR_CODES = [
  "AuthFailure",
  "InvalidSignatureException",
  "RequestExpired",
  "RequestInTheFuture",
  "RequestTimeTooSkewed",
  "SignatureDoesNotMatch"
];
var THROTTLING_ERROR_CODES = [
  "BandwidthLimitExceeded",
  "EC2ThrottledException",
  "LimitExceededException",
  "PriorRequestNotComplete",
  "ProvisionedThroughputExceededException",
  "RequestLimitExceeded",
  "RequestThrottled",
  "RequestThrottledException",
  "SlowDown",
  "ThrottledException",
  "Throttling",
  "ThrottlingException",
  "TooManyRequestsException",
  "TransactionInProgressException"
];
var TRANSIENT_ERROR_CODES = ["AbortError", "TimeoutError", "RequestTimeout", "RequestTimeoutException"];
var TRANSIENT_ERROR_STATUS_CODES = [500, 502, 503, 504];
var isRetryableByTrait = function(error) {
  return error.$retryable !== void 0;
};
var isClockSkewError = function(error) {
  return CLOCK_SKEW_ERROR_CODES.includes(error.name);
};
var isThrottlingError = function(error) {
  var _a2, _b;
  return ((_a2 = error.$metadata) === null || _a2 === void 0 ? void 0 : _a2.httpStatusCode) === 429 || THROTTLING_ERROR_CODES.includes(error.name) || ((_b = error.$retryable) === null || _b === void 0 ? void 0 : _b.throttling) == true;
};
var isTransientError = function(error) {
  var _a2;
  return TRANSIENT_ERROR_CODES.includes(error.name) || TRANSIENT_ERROR_STATUS_CODES.includes(((_a2 = error.$metadata) === null || _a2 === void 0 ? void 0 : _a2.httpStatusCode) || 0);
};
var rngBrowser = { exports: {} };
var getRandomValues = typeof crypto != "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto != "undefined" && typeof window.msCrypto.getRandomValues == "function" && msCrypto.getRandomValues.bind(msCrypto);
if (getRandomValues) {
  var rnds8 = new Uint8Array(16);
  rngBrowser.exports = function whatwgRNG() {
    getRandomValues(rnds8);
    return rnds8;
  };
} else {
  var rnds = new Array(16);
  rngBrowser.exports = function mathRNG() {
    for (var i2 = 0, r2; i2 < 16; i2++) {
      if ((i2 & 3) === 0)
        r2 = Math.random() * 4294967296;
      rnds[i2] = r2 >>> ((i2 & 3) << 3) & 255;
    }
    return rnds;
  };
}
var byteToHex = [];
for (var i$1 = 0; i$1 < 256; ++i$1) {
  byteToHex[i$1] = (i$1 + 256).toString(16).substr(1);
}
function bytesToUuid$2(buf, offset) {
  var i2 = offset || 0;
  var bth = byteToHex;
  return [
    bth[buf[i2++]],
    bth[buf[i2++]],
    bth[buf[i2++]],
    bth[buf[i2++]],
    "-",
    bth[buf[i2++]],
    bth[buf[i2++]],
    "-",
    bth[buf[i2++]],
    bth[buf[i2++]],
    "-",
    bth[buf[i2++]],
    bth[buf[i2++]],
    "-",
    bth[buf[i2++]],
    bth[buf[i2++]],
    bth[buf[i2++]],
    bth[buf[i2++]],
    bth[buf[i2++]],
    bth[buf[i2++]]
  ].join("");
}
var bytesToUuid_1 = bytesToUuid$2;
var rng$1 = rngBrowser.exports;
var bytesToUuid$1 = bytesToUuid_1;
var _nodeId;
var _clockseq;
var _lastMSecs = 0;
var _lastNSecs = 0;
function v1$1(options, buf, offset) {
  var i2 = buf && offset || 0;
  var b3 = buf || [];
  options = options || {};
  var node = options.node || _nodeId;
  var clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
  if (node == null || clockseq == null) {
    var seedBytes = rng$1();
    if (node == null) {
      node = _nodeId = [
        seedBytes[0] | 1,
        seedBytes[1],
        seedBytes[2],
        seedBytes[3],
        seedBytes[4],
        seedBytes[5]
      ];
    }
    if (clockseq == null) {
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
    }
  }
  var msecs = options.msecs !== void 0 ? options.msecs : new Date().getTime();
  var nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
  var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
  if (dt < 0 && options.clockseq === void 0) {
    clockseq = clockseq + 1 & 16383;
  }
  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
    nsecs = 0;
  }
  if (nsecs >= 1e4) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }
  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;
  msecs += 122192928e5;
  var tl2 = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
  b3[i2++] = tl2 >>> 24 & 255;
  b3[i2++] = tl2 >>> 16 & 255;
  b3[i2++] = tl2 >>> 8 & 255;
  b3[i2++] = tl2 & 255;
  var tmh = msecs / 4294967296 * 1e4 & 268435455;
  b3[i2++] = tmh >>> 8 & 255;
  b3[i2++] = tmh & 255;
  b3[i2++] = tmh >>> 24 & 15 | 16;
  b3[i2++] = tmh >>> 16 & 255;
  b3[i2++] = clockseq >>> 8 | 128;
  b3[i2++] = clockseq & 255;
  for (var n2 = 0; n2 < 6; ++n2) {
    b3[i2 + n2] = node[n2];
  }
  return buf ? buf : bytesToUuid$1(b3);
}
var v1_1 = v1$1;
var rng = rngBrowser.exports;
var bytesToUuid = bytesToUuid_1;
function v4$1(options, buf, offset) {
  var i2 = buf && offset || 0;
  if (typeof options == "string") {
    buf = options === "binary" ? new Array(16) : null;
    options = null;
  }
  options = options || {};
  var rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    for (var ii = 0; ii < 16; ++ii) {
      buf[i2 + ii] = rnds[ii];
    }
  }
  return buf || bytesToUuid(rnds);
}
var v4_1 = v4$1;
var v1 = v1_1;
var v4 = v4_1;
var uuid = v4;
uuid.v1 = v1;
uuid.v4 = v4;
var uuid_1 = uuid;
var getDefaultRetryQuota = function(initialRetryTokens) {
  var MAX_CAPACITY = initialRetryTokens;
  var availableCapacity = initialRetryTokens;
  var getCapacityAmount = function(error) {
    return error.name === "TimeoutError" ? TIMEOUT_RETRY_COST : RETRY_COST;
  };
  var hasRetryTokens = function(error) {
    return getCapacityAmount(error) <= availableCapacity;
  };
  var retrieveRetryTokens = function(error) {
    if (!hasRetryTokens(error)) {
      throw new Error("No retry token available");
    }
    var capacityAmount = getCapacityAmount(error);
    availableCapacity -= capacityAmount;
    return capacityAmount;
  };
  var releaseRetryTokens = function(capacityReleaseAmount) {
    availableCapacity += capacityReleaseAmount !== null && capacityReleaseAmount !== void 0 ? capacityReleaseAmount : NO_RETRY_INCREMENT;
    availableCapacity = Math.min(availableCapacity, MAX_CAPACITY);
  };
  return Object.freeze({
    hasRetryTokens,
    retrieveRetryTokens,
    releaseRetryTokens
  });
};
var defaultDelayDecider = function(delayBase, attempts) {
  return Math.floor(Math.min(MAXIMUM_RETRY_DELAY, Math.random() * Math.pow(2, attempts) * delayBase));
};
var defaultRetryDecider = function(error) {
  if (!error) {
    return false;
  }
  return isRetryableByTrait(error) || isClockSkewError(error) || isThrottlingError(error) || isTransientError(error);
};
var DEFAULT_MAX_ATTEMPTS = 3;
var DEFAULT_RETRY_MODE = "standard";
var StandardRetryStrategy = function() {
  function StandardRetryStrategy2(maxAttemptsProvider, options) {
    var _a2, _b, _c;
    this.maxAttemptsProvider = maxAttemptsProvider;
    this.mode = DEFAULT_RETRY_MODE;
    this.retryDecider = (_a2 = options === null || options === void 0 ? void 0 : options.retryDecider) !== null && _a2 !== void 0 ? _a2 : defaultRetryDecider;
    this.delayDecider = (_b = options === null || options === void 0 ? void 0 : options.delayDecider) !== null && _b !== void 0 ? _b : defaultDelayDecider;
    this.retryQuota = (_c = options === null || options === void 0 ? void 0 : options.retryQuota) !== null && _c !== void 0 ? _c : getDefaultRetryQuota(INITIAL_RETRY_TOKENS);
  }
  StandardRetryStrategy2.prototype.shouldRetry = function(error, attempts, maxAttempts) {
    return attempts < maxAttempts && this.retryDecider(error) && this.retryQuota.hasRetryTokens(error);
  };
  StandardRetryStrategy2.prototype.getMaxAttempts = function() {
    return __awaiter$b(this, void 0, void 0, function() {
      var maxAttempts;
      return __generator$b(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            _a2.trys.push([0, 2, , 3]);
            return [4, this.maxAttemptsProvider()];
          case 1:
            maxAttempts = _a2.sent();
            return [3, 3];
          case 2:
            _a2.sent();
            maxAttempts = DEFAULT_MAX_ATTEMPTS;
            return [3, 3];
          case 3:
            return [2, maxAttempts];
        }
      });
    });
  };
  StandardRetryStrategy2.prototype.retry = function(next, args) {
    return __awaiter$b(this, void 0, void 0, function() {
      var retryTokenAmount, attempts, totalDelay, maxAttempts, request, _loop_1, this_1, state_1;
      return __generator$b(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            attempts = 0;
            totalDelay = 0;
            return [4, this.getMaxAttempts()];
          case 1:
            maxAttempts = _a2.sent();
            request = args.request;
            if (HttpRequest.isInstance(request)) {
              request.headers[INVOCATION_ID_HEADER] = uuid_1.v4();
            }
            _loop_1 = function() {
              var _a3, response, output, err_1, delay_1;
              return __generator$b(this, function(_b) {
                switch (_b.label) {
                  case 0:
                    _b.trys.push([0, 2, , 5]);
                    if (HttpRequest.isInstance(request)) {
                      request.headers[REQUEST_HEADER] = "attempt=" + (attempts + 1) + "; max=" + maxAttempts;
                    }
                    return [4, next(args)];
                  case 1:
                    _a3 = _b.sent(), response = _a3.response, output = _a3.output;
                    this_1.retryQuota.releaseRetryTokens(retryTokenAmount);
                    output.$metadata.attempts = attempts + 1;
                    output.$metadata.totalRetryDelay = totalDelay;
                    return [2, { value: { response, output } }];
                  case 2:
                    err_1 = _b.sent();
                    attempts++;
                    if (!this_1.shouldRetry(err_1, attempts, maxAttempts))
                      return [3, 4];
                    retryTokenAmount = this_1.retryQuota.retrieveRetryTokens(err_1);
                    delay_1 = this_1.delayDecider(isThrottlingError(err_1) ? THROTTLING_RETRY_DELAY_BASE : DEFAULT_RETRY_DELAY_BASE, attempts);
                    totalDelay += delay_1;
                    return [4, new Promise(function(resolve2) {
                      return setTimeout(resolve2, delay_1);
                    })];
                  case 3:
                    _b.sent();
                    return [2, "continue"];
                  case 4:
                    if (!err_1.$metadata) {
                      err_1.$metadata = {};
                    }
                    err_1.$metadata.attempts = attempts;
                    err_1.$metadata.totalRetryDelay = totalDelay;
                    throw err_1;
                  case 5:
                    return [2];
                }
              });
            };
            this_1 = this;
            _a2.label = 2;
          case 2:
            return [5, _loop_1()];
          case 3:
            state_1 = _a2.sent();
            if (typeof state_1 === "object")
              return [2, state_1.value];
            return [3, 2];
          case 4:
            return [2];
        }
      });
    });
  };
  return StandardRetryStrategy2;
}();
var resolveRetryConfig = function(input) {
  var maxAttempts = normalizeMaxAttempts(input.maxAttempts);
  return __assign$9(__assign$9({}, input), { maxAttempts, retryStrategy: input.retryStrategy || new StandardRetryStrategy(maxAttempts) });
};
var normalizeMaxAttempts = function(maxAttempts) {
  if (maxAttempts === void 0) {
    maxAttempts = DEFAULT_MAX_ATTEMPTS;
  }
  if (typeof maxAttempts === "number") {
    var promisified_1 = Promise.resolve(maxAttempts);
    return function() {
      return promisified_1;
    };
  }
  return maxAttempts;
};
function calculateBodyLength(body) {
  if (typeof body === "string") {
    var len = body.length;
    for (var i2 = len - 1; i2 >= 0; i2--) {
      var code2 = body.charCodeAt(i2);
      if (code2 > 127 && code2 <= 2047)
        len++;
      else if (code2 > 2047 && code2 <= 65535)
        len += 2;
    }
    return len;
  } else if (typeof body.byteLength === "number") {
    return body.byteLength;
  } else if (typeof body.size === "number") {
    return body.size;
  }
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function __awaiter$a(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator$a(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t3[0] & 1)
      throw t3[1];
    return t3[1];
  }, trys: [], ops: [] }, f, y3, t3, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n2) {
    return function(v) {
      return step([n2, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_2)
      try {
        if (f = 1, y3 && (t3 = op[0] & 2 ? y3["return"] : op[0] ? y3["throw"] || ((t3 = y3["return"]) && t3.call(y3), 0) : y3.next) && !(t3 = t3.call(y3, op[1])).done)
          return t3;
        if (y3 = 0, t3)
          op = [op[0] & 2, t3.value];
        switch (op[0]) {
          case 0:
          case 1:
            t3 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y3 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t3 = _2.trys, t3 = t3.length > 0 && t3[t3.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t3 || op[1] > t3[0] && op[1] < t3[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t3[1]) {
              _2.label = t3[1];
              t3 = op;
              break;
            }
            if (t3 && _2.label < t3[2]) {
              _2.label = t3[2];
              _2.ops.push(op);
              break;
            }
            if (t3[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e3) {
        op = [6, e3];
        y3 = 0;
      } finally {
        f = t3 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
const BROWSER_ALIASES_MAP = {
  "Amazon Silk": "amazon_silk",
  "Android Browser": "android",
  Bada: "bada",
  BlackBerry: "blackberry",
  Chrome: "chrome",
  Chromium: "chromium",
  Electron: "electron",
  Epiphany: "epiphany",
  Firefox: "firefox",
  Focus: "focus",
  Generic: "generic",
  "Google Search": "google_search",
  Googlebot: "googlebot",
  "Internet Explorer": "ie",
  "K-Meleon": "k_meleon",
  Maxthon: "maxthon",
  "Microsoft Edge": "edge",
  "MZ Browser": "mz",
  "NAVER Whale Browser": "naver",
  Opera: "opera",
  "Opera Coast": "opera_coast",
  PhantomJS: "phantomjs",
  Puffin: "puffin",
  QupZilla: "qupzilla",
  QQ: "qq",
  QQLite: "qqlite",
  Safari: "safari",
  Sailfish: "sailfish",
  "Samsung Internet for Android": "samsung_internet",
  SeaMonkey: "seamonkey",
  Sleipnir: "sleipnir",
  Swing: "swing",
  Tizen: "tizen",
  "UC Browser": "uc",
  Vivaldi: "vivaldi",
  "WebOS Browser": "webos",
  WeChat: "wechat",
  "Yandex Browser": "yandex",
  Roku: "roku"
};
const BROWSER_MAP = {
  amazon_silk: "Amazon Silk",
  android: "Android Browser",
  bada: "Bada",
  blackberry: "BlackBerry",
  chrome: "Chrome",
  chromium: "Chromium",
  electron: "Electron",
  epiphany: "Epiphany",
  firefox: "Firefox",
  focus: "Focus",
  generic: "Generic",
  googlebot: "Googlebot",
  google_search: "Google Search",
  ie: "Internet Explorer",
  k_meleon: "K-Meleon",
  maxthon: "Maxthon",
  edge: "Microsoft Edge",
  mz: "MZ Browser",
  naver: "NAVER Whale Browser",
  opera: "Opera",
  opera_coast: "Opera Coast",
  phantomjs: "PhantomJS",
  puffin: "Puffin",
  qupzilla: "QupZilla",
  qq: "QQ Browser",
  qqlite: "QQ Browser Lite",
  safari: "Safari",
  sailfish: "Sailfish",
  samsung_internet: "Samsung Internet for Android",
  seamonkey: "SeaMonkey",
  sleipnir: "Sleipnir",
  swing: "Swing",
  tizen: "Tizen",
  uc: "UC Browser",
  vivaldi: "Vivaldi",
  webos: "WebOS Browser",
  wechat: "WeChat",
  yandex: "Yandex Browser"
};
const PLATFORMS_MAP = {
  tablet: "tablet",
  mobile: "mobile",
  desktop: "desktop",
  tv: "tv"
};
const OS_MAP = {
  WindowsPhone: "Windows Phone",
  Windows: "Windows",
  MacOS: "macOS",
  iOS: "iOS",
  Android: "Android",
  WebOS: "WebOS",
  BlackBerry: "BlackBerry",
  Bada: "Bada",
  Tizen: "Tizen",
  Linux: "Linux",
  ChromeOS: "Chrome OS",
  PlayStation4: "PlayStation 4",
  Roku: "Roku"
};
const ENGINE_MAP = {
  EdgeHTML: "EdgeHTML",
  Blink: "Blink",
  Trident: "Trident",
  Presto: "Presto",
  Gecko: "Gecko",
  WebKit: "WebKit"
};
class Utils {
  static getFirstMatch(regexp, ua) {
    const match2 = ua.match(regexp);
    return match2 && match2.length > 0 && match2[1] || "";
  }
  static getSecondMatch(regexp, ua) {
    const match2 = ua.match(regexp);
    return match2 && match2.length > 1 && match2[2] || "";
  }
  static matchAndReturnConst(regexp, ua, _const) {
    if (regexp.test(ua)) {
      return _const;
    }
    return void 0;
  }
  static getWindowsVersionName(version2) {
    switch (version2) {
      case "NT":
        return "NT";
      case "XP":
        return "XP";
      case "NT 5.0":
        return "2000";
      case "NT 5.1":
        return "XP";
      case "NT 5.2":
        return "2003";
      case "NT 6.0":
        return "Vista";
      case "NT 6.1":
        return "7";
      case "NT 6.2":
        return "8";
      case "NT 6.3":
        return "8.1";
      case "NT 10.0":
        return "10";
      default:
        return void 0;
    }
  }
  static getMacOSVersionName(version2) {
    const v = version2.split(".").splice(0, 2).map((s3) => parseInt(s3, 10) || 0);
    v.push(0);
    if (v[0] !== 10)
      return void 0;
    switch (v[1]) {
      case 5:
        return "Leopard";
      case 6:
        return "Snow Leopard";
      case 7:
        return "Lion";
      case 8:
        return "Mountain Lion";
      case 9:
        return "Mavericks";
      case 10:
        return "Yosemite";
      case 11:
        return "El Capitan";
      case 12:
        return "Sierra";
      case 13:
        return "High Sierra";
      case 14:
        return "Mojave";
      case 15:
        return "Catalina";
      default:
        return void 0;
    }
  }
  static getAndroidVersionName(version2) {
    const v = version2.split(".").splice(0, 2).map((s3) => parseInt(s3, 10) || 0);
    v.push(0);
    if (v[0] === 1 && v[1] < 5)
      return void 0;
    if (v[0] === 1 && v[1] < 6)
      return "Cupcake";
    if (v[0] === 1 && v[1] >= 6)
      return "Donut";
    if (v[0] === 2 && v[1] < 2)
      return "Eclair";
    if (v[0] === 2 && v[1] === 2)
      return "Froyo";
    if (v[0] === 2 && v[1] > 2)
      return "Gingerbread";
    if (v[0] === 3)
      return "Honeycomb";
    if (v[0] === 4 && v[1] < 1)
      return "Ice Cream Sandwich";
    if (v[0] === 4 && v[1] < 4)
      return "Jelly Bean";
    if (v[0] === 4 && v[1] >= 4)
      return "KitKat";
    if (v[0] === 5)
      return "Lollipop";
    if (v[0] === 6)
      return "Marshmallow";
    if (v[0] === 7)
      return "Nougat";
    if (v[0] === 8)
      return "Oreo";
    if (v[0] === 9)
      return "Pie";
    return void 0;
  }
  static getVersionPrecision(version2) {
    return version2.split(".").length;
  }
  static compareVersions(versionA, versionB, isLoose = false) {
    const versionAPrecision = Utils.getVersionPrecision(versionA);
    const versionBPrecision = Utils.getVersionPrecision(versionB);
    let precision = Math.max(versionAPrecision, versionBPrecision);
    let lastPrecision = 0;
    const chunks = Utils.map([versionA, versionB], (version2) => {
      const delta2 = precision - Utils.getVersionPrecision(version2);
      const _version = version2 + new Array(delta2 + 1).join(".0");
      return Utils.map(_version.split("."), (chunk2) => new Array(20 - chunk2.length).join("0") + chunk2).reverse();
    });
    if (isLoose) {
      lastPrecision = precision - Math.min(versionAPrecision, versionBPrecision);
    }
    precision -= 1;
    while (precision >= lastPrecision) {
      if (chunks[0][precision] > chunks[1][precision]) {
        return 1;
      }
      if (chunks[0][precision] === chunks[1][precision]) {
        if (precision === lastPrecision) {
          return 0;
        }
        precision -= 1;
      } else if (chunks[0][precision] < chunks[1][precision]) {
        return -1;
      }
    }
    return void 0;
  }
  static map(arr, iterator) {
    const result = [];
    let i2;
    if (Array.prototype.map) {
      return Array.prototype.map.call(arr, iterator);
    }
    for (i2 = 0; i2 < arr.length; i2 += 1) {
      result.push(iterator(arr[i2]));
    }
    return result;
  }
  static find(arr, predicate) {
    let i2;
    let l;
    if (Array.prototype.find) {
      return Array.prototype.find.call(arr, predicate);
    }
    for (i2 = 0, l = arr.length; i2 < l; i2 += 1) {
      const value = arr[i2];
      if (predicate(value, i2)) {
        return value;
      }
    }
    return void 0;
  }
  static assign(obj, ...assigners) {
    const result = obj;
    let i2;
    let l;
    if (Object.assign) {
      return Object.assign(obj, ...assigners);
    }
    for (i2 = 0, l = assigners.length; i2 < l; i2 += 1) {
      const assigner = assigners[i2];
      if (typeof assigner === "object" && assigner !== null) {
        const keys = Object.keys(assigner);
        keys.forEach((key) => {
          result[key] = assigner[key];
        });
      }
    }
    return obj;
  }
  static getBrowserAlias(browserName) {
    return BROWSER_ALIASES_MAP[browserName];
  }
  static getBrowserTypeByAlias(browserAlias) {
    return BROWSER_MAP[browserAlias] || "";
  }
}
const commonVersionIdentifier = /version\/(\d+(\.?_?\d+)+)/i;
const browsersList = [
  {
    test: [/googlebot/i],
    describe(ua) {
      const browser2 = {
        name: "Googlebot"
      };
      const version2 = Utils.getFirstMatch(/googlebot\/(\d+(\.\d+))/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/opera/i],
    describe(ua) {
      const browser2 = {
        name: "Opera"
      };
      const version2 = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:opera)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/opr\/|opios/i],
    describe(ua) {
      const browser2 = {
        name: "Opera"
      };
      const version2 = Utils.getFirstMatch(/(?:opr|opios)[\s/](\S+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/SamsungBrowser/i],
    describe(ua) {
      const browser2 = {
        name: "Samsung Internet for Android"
      };
      const version2 = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:SamsungBrowser)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/Whale/i],
    describe(ua) {
      const browser2 = {
        name: "NAVER Whale Browser"
      };
      const version2 = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:whale)[\s/](\d+(?:\.\d+)+)/i, ua);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/MZBrowser/i],
    describe(ua) {
      const browser2 = {
        name: "MZ Browser"
      };
      const version2 = Utils.getFirstMatch(/(?:MZBrowser)[\s/](\d+(?:\.\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/focus/i],
    describe(ua) {
      const browser2 = {
        name: "Focus"
      };
      const version2 = Utils.getFirstMatch(/(?:focus)[\s/](\d+(?:\.\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/swing/i],
    describe(ua) {
      const browser2 = {
        name: "Swing"
      };
      const version2 = Utils.getFirstMatch(/(?:swing)[\s/](\d+(?:\.\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/coast/i],
    describe(ua) {
      const browser2 = {
        name: "Opera Coast"
      };
      const version2 = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:coast)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/opt\/\d+(?:.?_?\d+)+/i],
    describe(ua) {
      const browser2 = {
        name: "Opera Touch"
      };
      const version2 = Utils.getFirstMatch(/(?:opt)[\s/](\d+(\.?_?\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/yabrowser/i],
    describe(ua) {
      const browser2 = {
        name: "Yandex Browser"
      };
      const version2 = Utils.getFirstMatch(/(?:yabrowser)[\s/](\d+(\.?_?\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/ucbrowser/i],
    describe(ua) {
      const browser2 = {
        name: "UC Browser"
      };
      const version2 = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:ucbrowser)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/Maxthon|mxios/i],
    describe(ua) {
      const browser2 = {
        name: "Maxthon"
      };
      const version2 = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:Maxthon|mxios)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/epiphany/i],
    describe(ua) {
      const browser2 = {
        name: "Epiphany"
      };
      const version2 = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:epiphany)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/puffin/i],
    describe(ua) {
      const browser2 = {
        name: "Puffin"
      };
      const version2 = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:puffin)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/sleipnir/i],
    describe(ua) {
      const browser2 = {
        name: "Sleipnir"
      };
      const version2 = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:sleipnir)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/k-meleon/i],
    describe(ua) {
      const browser2 = {
        name: "K-Meleon"
      };
      const version2 = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/(?:k-meleon)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/micromessenger/i],
    describe(ua) {
      const browser2 = {
        name: "WeChat"
      };
      const version2 = Utils.getFirstMatch(/(?:micromessenger)[\s/](\d+(\.?_?\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/qqbrowser/i],
    describe(ua) {
      const browser2 = {
        name: /qqbrowserlite/i.test(ua) ? "QQ Browser Lite" : "QQ Browser"
      };
      const version2 = Utils.getFirstMatch(/(?:qqbrowserlite|qqbrowser)[/](\d+(\.?_?\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/msie|trident/i],
    describe(ua) {
      const browser2 = {
        name: "Internet Explorer"
      };
      const version2 = Utils.getFirstMatch(/(?:msie |rv:)(\d+(\.?_?\d+)+)/i, ua);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/\sedg\//i],
    describe(ua) {
      const browser2 = {
        name: "Microsoft Edge"
      };
      const version2 = Utils.getFirstMatch(/\sedg\/(\d+(\.?_?\d+)+)/i, ua);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/edg([ea]|ios)/i],
    describe(ua) {
      const browser2 = {
        name: "Microsoft Edge"
      };
      const version2 = Utils.getSecondMatch(/edg([ea]|ios)\/(\d+(\.?_?\d+)+)/i, ua);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/vivaldi/i],
    describe(ua) {
      const browser2 = {
        name: "Vivaldi"
      };
      const version2 = Utils.getFirstMatch(/vivaldi\/(\d+(\.?_?\d+)+)/i, ua);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/seamonkey/i],
    describe(ua) {
      const browser2 = {
        name: "SeaMonkey"
      };
      const version2 = Utils.getFirstMatch(/seamonkey\/(\d+(\.?_?\d+)+)/i, ua);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/sailfish/i],
    describe(ua) {
      const browser2 = {
        name: "Sailfish"
      };
      const version2 = Utils.getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i, ua);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/silk/i],
    describe(ua) {
      const browser2 = {
        name: "Amazon Silk"
      };
      const version2 = Utils.getFirstMatch(/silk\/(\d+(\.?_?\d+)+)/i, ua);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/phantom/i],
    describe(ua) {
      const browser2 = {
        name: "PhantomJS"
      };
      const version2 = Utils.getFirstMatch(/phantomjs\/(\d+(\.?_?\d+)+)/i, ua);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/slimerjs/i],
    describe(ua) {
      const browser2 = {
        name: "SlimerJS"
      };
      const version2 = Utils.getFirstMatch(/slimerjs\/(\d+(\.?_?\d+)+)/i, ua);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
    describe(ua) {
      const browser2 = {
        name: "BlackBerry"
      };
      const version2 = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/blackberry[\d]+\/(\d+(\.?_?\d+)+)/i, ua);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/(web|hpw)[o0]s/i],
    describe(ua) {
      const browser2 = {
        name: "WebOS Browser"
      };
      const version2 = Utils.getFirstMatch(commonVersionIdentifier, ua) || Utils.getFirstMatch(/w(?:eb)?[o0]sbrowser\/(\d+(\.?_?\d+)+)/i, ua);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/bada/i],
    describe(ua) {
      const browser2 = {
        name: "Bada"
      };
      const version2 = Utils.getFirstMatch(/dolfin\/(\d+(\.?_?\d+)+)/i, ua);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/tizen/i],
    describe(ua) {
      const browser2 = {
        name: "Tizen"
      };
      const version2 = Utils.getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.?_?\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/qupzilla/i],
    describe(ua) {
      const browser2 = {
        name: "QupZilla"
      };
      const version2 = Utils.getFirstMatch(/(?:qupzilla)[\s/](\d+(\.?_?\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/firefox|iceweasel|fxios/i],
    describe(ua) {
      const browser2 = {
        name: "Firefox"
      };
      const version2 = Utils.getFirstMatch(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/electron/i],
    describe(ua) {
      const browser2 = {
        name: "Electron"
      };
      const version2 = Utils.getFirstMatch(/(?:electron)\/(\d+(\.?_?\d+)+)/i, ua);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/MiuiBrowser/i],
    describe(ua) {
      const browser2 = {
        name: "Miui"
      };
      const version2 = Utils.getFirstMatch(/(?:MiuiBrowser)[\s/](\d+(\.?_?\d+)+)/i, ua);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/chromium/i],
    describe(ua) {
      const browser2 = {
        name: "Chromium"
      };
      const version2 = Utils.getFirstMatch(/(?:chromium)[\s/](\d+(\.?_?\d+)+)/i, ua) || Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/chrome|crios|crmo/i],
    describe(ua) {
      const browser2 = {
        name: "Chrome"
      };
      const version2 = Utils.getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.?_?\d+)+)/i, ua);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/GSA/i],
    describe(ua) {
      const browser2 = {
        name: "Google Search"
      };
      const version2 = Utils.getFirstMatch(/(?:GSA)\/(\d+(\.?_?\d+)+)/i, ua);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test(parser) {
      const notLikeAndroid = !parser.test(/like android/i);
      const butAndroid = parser.test(/android/i);
      return notLikeAndroid && butAndroid;
    },
    describe(ua) {
      const browser2 = {
        name: "Android Browser"
      };
      const version2 = Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/playstation 4/i],
    describe(ua) {
      const browser2 = {
        name: "PlayStation 4"
      };
      const version2 = Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/safari|applewebkit/i],
    describe(ua) {
      const browser2 = {
        name: "Safari"
      };
      const version2 = Utils.getFirstMatch(commonVersionIdentifier, ua);
      if (version2) {
        browser2.version = version2;
      }
      return browser2;
    }
  },
  {
    test: [/.*/i],
    describe(ua) {
      const regexpWithoutDeviceSpec = /^(.*)\/(.*) /;
      const regexpWithDeviceSpec = /^(.*)\/(.*)[ \t]\((.*)/;
      const hasDeviceSpec = ua.search("\\(") !== -1;
      const regexp = hasDeviceSpec ? regexpWithDeviceSpec : regexpWithoutDeviceSpec;
      return {
        name: Utils.getFirstMatch(regexp, ua),
        version: Utils.getSecondMatch(regexp, ua)
      };
    }
  }
];
const osParsersList = [
  {
    test: [/Roku\/DVP/],
    describe(ua) {
      const version2 = Utils.getFirstMatch(/Roku\/DVP-(\d+\.\d+)/i, ua);
      return {
        name: OS_MAP.Roku,
        version: version2
      };
    }
  },
  {
    test: [/windows phone/i],
    describe(ua) {
      const version2 = Utils.getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i, ua);
      return {
        name: OS_MAP.WindowsPhone,
        version: version2
      };
    }
  },
  {
    test: [/windows /i],
    describe(ua) {
      const version2 = Utils.getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i, ua);
      const versionName = Utils.getWindowsVersionName(version2);
      return {
        name: OS_MAP.Windows,
        version: version2,
        versionName
      };
    }
  },
  {
    test: [/Macintosh(.*?) FxiOS(.*?)\//],
    describe(ua) {
      const result = {
        name: OS_MAP.iOS
      };
      const version2 = Utils.getSecondMatch(/(Version\/)(\d[\d.]+)/, ua);
      if (version2) {
        result.version = version2;
      }
      return result;
    }
  },
  {
    test: [/macintosh/i],
    describe(ua) {
      const version2 = Utils.getFirstMatch(/mac os x (\d+(\.?_?\d+)+)/i, ua).replace(/[_\s]/g, ".");
      const versionName = Utils.getMacOSVersionName(version2);
      const os = {
        name: OS_MAP.MacOS,
        version: version2
      };
      if (versionName) {
        os.versionName = versionName;
      }
      return os;
    }
  },
  {
    test: [/(ipod|iphone|ipad)/i],
    describe(ua) {
      const version2 = Utils.getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i, ua).replace(/[_\s]/g, ".");
      return {
        name: OS_MAP.iOS,
        version: version2
      };
    }
  },
  {
    test(parser) {
      const notLikeAndroid = !parser.test(/like android/i);
      const butAndroid = parser.test(/android/i);
      return notLikeAndroid && butAndroid;
    },
    describe(ua) {
      const version2 = Utils.getFirstMatch(/android[\s/-](\d+(\.\d+)*)/i, ua);
      const versionName = Utils.getAndroidVersionName(version2);
      const os = {
        name: OS_MAP.Android,
        version: version2
      };
      if (versionName) {
        os.versionName = versionName;
      }
      return os;
    }
  },
  {
    test: [/(web|hpw)[o0]s/i],
    describe(ua) {
      const version2 = Utils.getFirstMatch(/(?:web|hpw)[o0]s\/(\d+(\.\d+)*)/i, ua);
      const os = {
        name: OS_MAP.WebOS
      };
      if (version2 && version2.length) {
        os.version = version2;
      }
      return os;
    }
  },
  {
    test: [/blackberry|\bbb\d+/i, /rim\stablet/i],
    describe(ua) {
      const version2 = Utils.getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i, ua) || Utils.getFirstMatch(/blackberry\d+\/(\d+([_\s]\d+)*)/i, ua) || Utils.getFirstMatch(/\bbb(\d+)/i, ua);
      return {
        name: OS_MAP.BlackBerry,
        version: version2
      };
    }
  },
  {
    test: [/bada/i],
    describe(ua) {
      const version2 = Utils.getFirstMatch(/bada\/(\d+(\.\d+)*)/i, ua);
      return {
        name: OS_MAP.Bada,
        version: version2
      };
    }
  },
  {
    test: [/tizen/i],
    describe(ua) {
      const version2 = Utils.getFirstMatch(/tizen[/\s](\d+(\.\d+)*)/i, ua);
      return {
        name: OS_MAP.Tizen,
        version: version2
      };
    }
  },
  {
    test: [/linux/i],
    describe() {
      return {
        name: OS_MAP.Linux
      };
    }
  },
  {
    test: [/CrOS/],
    describe() {
      return {
        name: OS_MAP.ChromeOS
      };
    }
  },
  {
    test: [/PlayStation 4/],
    describe(ua) {
      const version2 = Utils.getFirstMatch(/PlayStation 4[/\s](\d+(\.\d+)*)/i, ua);
      return {
        name: OS_MAP.PlayStation4,
        version: version2
      };
    }
  }
];
const platformParsersList = [
  {
    test: [/googlebot/i],
    describe() {
      return {
        type: "bot",
        vendor: "Google"
      };
    }
  },
  {
    test: [/huawei/i],
    describe(ua) {
      const model = Utils.getFirstMatch(/(can-l01)/i, ua) && "Nova";
      const platform2 = {
        type: PLATFORMS_MAP.mobile,
        vendor: "Huawei"
      };
      if (model) {
        platform2.model = model;
      }
      return platform2;
    }
  },
  {
    test: [/nexus\s*(?:7|8|9|10).*/i],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet,
        vendor: "Nexus"
      };
    }
  },
  {
    test: [/ipad/i],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet,
        vendor: "Apple",
        model: "iPad"
      };
    }
  },
  {
    test: [/Macintosh(.*?) FxiOS(.*?)\//],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet,
        vendor: "Apple",
        model: "iPad"
      };
    }
  },
  {
    test: [/kftt build/i],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet,
        vendor: "Amazon",
        model: "Kindle Fire HD 7"
      };
    }
  },
  {
    test: [/silk/i],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet,
        vendor: "Amazon"
      };
    }
  },
  {
    test: [/tablet(?! pc)/i],
    describe() {
      return {
        type: PLATFORMS_MAP.tablet
      };
    }
  },
  {
    test(parser) {
      const iDevice = parser.test(/ipod|iphone/i);
      const likeIDevice = parser.test(/like (ipod|iphone)/i);
      return iDevice && !likeIDevice;
    },
    describe(ua) {
      const model = Utils.getFirstMatch(/(ipod|iphone)/i, ua);
      return {
        type: PLATFORMS_MAP.mobile,
        vendor: "Apple",
        model
      };
    }
  },
  {
    test: [/nexus\s*[0-6].*/i, /galaxy nexus/i],
    describe() {
      return {
        type: PLATFORMS_MAP.mobile,
        vendor: "Nexus"
      };
    }
  },
  {
    test: [/[^-]mobi/i],
    describe() {
      return {
        type: PLATFORMS_MAP.mobile
      };
    }
  },
  {
    test(parser) {
      return parser.getBrowserName(true) === "blackberry";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.mobile,
        vendor: "BlackBerry"
      };
    }
  },
  {
    test(parser) {
      return parser.getBrowserName(true) === "bada";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.mobile
      };
    }
  },
  {
    test(parser) {
      return parser.getBrowserName() === "windows phone";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.mobile,
        vendor: "Microsoft"
      };
    }
  },
  {
    test(parser) {
      const osMajorVersion = Number(String(parser.getOSVersion()).split(".")[0]);
      return parser.getOSName(true) === "android" && osMajorVersion >= 3;
    },
    describe() {
      return {
        type: PLATFORMS_MAP.tablet
      };
    }
  },
  {
    test(parser) {
      return parser.getOSName(true) === "android";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.mobile
      };
    }
  },
  {
    test(parser) {
      return parser.getOSName(true) === "macos";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.desktop,
        vendor: "Apple"
      };
    }
  },
  {
    test(parser) {
      return parser.getOSName(true) === "windows";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.desktop
      };
    }
  },
  {
    test(parser) {
      return parser.getOSName(true) === "linux";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.desktop
      };
    }
  },
  {
    test(parser) {
      return parser.getOSName(true) === "playstation 4";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.tv
      };
    }
  },
  {
    test(parser) {
      return parser.getOSName(true) === "roku";
    },
    describe() {
      return {
        type: PLATFORMS_MAP.tv
      };
    }
  }
];
const enginesParsersList = [
  {
    test(parser) {
      return parser.getBrowserName(true) === "microsoft edge";
    },
    describe(ua) {
      const isBlinkBased = /\sedg\//i.test(ua);
      if (isBlinkBased) {
        return {
          name: ENGINE_MAP.Blink
        };
      }
      const version2 = Utils.getFirstMatch(/edge\/(\d+(\.?_?\d+)+)/i, ua);
      return {
        name: ENGINE_MAP.EdgeHTML,
        version: version2
      };
    }
  },
  {
    test: [/trident/i],
    describe(ua) {
      const engine = {
        name: ENGINE_MAP.Trident
      };
      const version2 = Utils.getFirstMatch(/trident\/(\d+(\.?_?\d+)+)/i, ua);
      if (version2) {
        engine.version = version2;
      }
      return engine;
    }
  },
  {
    test(parser) {
      return parser.test(/presto/i);
    },
    describe(ua) {
      const engine = {
        name: ENGINE_MAP.Presto
      };
      const version2 = Utils.getFirstMatch(/presto\/(\d+(\.?_?\d+)+)/i, ua);
      if (version2) {
        engine.version = version2;
      }
      return engine;
    }
  },
  {
    test(parser) {
      const isGecko = parser.test(/gecko/i);
      const likeGecko = parser.test(/like gecko/i);
      return isGecko && !likeGecko;
    },
    describe(ua) {
      const engine = {
        name: ENGINE_MAP.Gecko
      };
      const version2 = Utils.getFirstMatch(/gecko\/(\d+(\.?_?\d+)+)/i, ua);
      if (version2) {
        engine.version = version2;
      }
      return engine;
    }
  },
  {
    test: [/(apple)?webkit\/537\.36/i],
    describe() {
      return {
        name: ENGINE_MAP.Blink
      };
    }
  },
  {
    test: [/(apple)?webkit/i],
    describe(ua) {
      const engine = {
        name: ENGINE_MAP.WebKit
      };
      const version2 = Utils.getFirstMatch(/webkit\/(\d+(\.?_?\d+)+)/i, ua);
      if (version2) {
        engine.version = version2;
      }
      return engine;
    }
  }
];
class Parser$1 {
  constructor(UA, skipParsing = false) {
    if (UA === void 0 || UA === null || UA === "") {
      throw new Error("UserAgent parameter can't be empty");
    }
    this._ua = UA;
    this.parsedResult = {};
    if (skipParsing !== true) {
      this.parse();
    }
  }
  getUA() {
    return this._ua;
  }
  test(regex) {
    return regex.test(this._ua);
  }
  parseBrowser() {
    this.parsedResult.browser = {};
    const browserDescriptor = Utils.find(browsersList, (_browser) => {
      if (typeof _browser.test === "function") {
        return _browser.test(this);
      }
      if (_browser.test instanceof Array) {
        return _browser.test.some((condition) => this.test(condition));
      }
      throw new Error("Browser's test function is not valid");
    });
    if (browserDescriptor) {
      this.parsedResult.browser = browserDescriptor.describe(this.getUA());
    }
    return this.parsedResult.browser;
  }
  getBrowser() {
    if (this.parsedResult.browser) {
      return this.parsedResult.browser;
    }
    return this.parseBrowser();
  }
  getBrowserName(toLowerCase) {
    if (toLowerCase) {
      return String(this.getBrowser().name).toLowerCase() || "";
    }
    return this.getBrowser().name || "";
  }
  getBrowserVersion() {
    return this.getBrowser().version;
  }
  getOS() {
    if (this.parsedResult.os) {
      return this.parsedResult.os;
    }
    return this.parseOS();
  }
  parseOS() {
    this.parsedResult.os = {};
    const os = Utils.find(osParsersList, (_os) => {
      if (typeof _os.test === "function") {
        return _os.test(this);
      }
      if (_os.test instanceof Array) {
        return _os.test.some((condition) => this.test(condition));
      }
      throw new Error("Browser's test function is not valid");
    });
    if (os) {
      this.parsedResult.os = os.describe(this.getUA());
    }
    return this.parsedResult.os;
  }
  getOSName(toLowerCase) {
    const { name: name2 } = this.getOS();
    if (toLowerCase) {
      return String(name2).toLowerCase() || "";
    }
    return name2 || "";
  }
  getOSVersion() {
    return this.getOS().version;
  }
  getPlatform() {
    if (this.parsedResult.platform) {
      return this.parsedResult.platform;
    }
    return this.parsePlatform();
  }
  getPlatformType(toLowerCase = false) {
    const { type } = this.getPlatform();
    if (toLowerCase) {
      return String(type).toLowerCase() || "";
    }
    return type || "";
  }
  parsePlatform() {
    this.parsedResult.platform = {};
    const platform2 = Utils.find(platformParsersList, (_platform) => {
      if (typeof _platform.test === "function") {
        return _platform.test(this);
      }
      if (_platform.test instanceof Array) {
        return _platform.test.some((condition) => this.test(condition));
      }
      throw new Error("Browser's test function is not valid");
    });
    if (platform2) {
      this.parsedResult.platform = platform2.describe(this.getUA());
    }
    return this.parsedResult.platform;
  }
  getEngine() {
    if (this.parsedResult.engine) {
      return this.parsedResult.engine;
    }
    return this.parseEngine();
  }
  getEngineName(toLowerCase) {
    if (toLowerCase) {
      return String(this.getEngine().name).toLowerCase() || "";
    }
    return this.getEngine().name || "";
  }
  parseEngine() {
    this.parsedResult.engine = {};
    const engine = Utils.find(enginesParsersList, (_engine) => {
      if (typeof _engine.test === "function") {
        return _engine.test(this);
      }
      if (_engine.test instanceof Array) {
        return _engine.test.some((condition) => this.test(condition));
      }
      throw new Error("Browser's test function is not valid");
    });
    if (engine) {
      this.parsedResult.engine = engine.describe(this.getUA());
    }
    return this.parsedResult.engine;
  }
  parse() {
    this.parseBrowser();
    this.parseOS();
    this.parsePlatform();
    this.parseEngine();
    return this;
  }
  getResult() {
    return Utils.assign({}, this.parsedResult);
  }
  satisfies(checkTree) {
    const platformsAndOSes = {};
    let platformsAndOSCounter = 0;
    const browsers = {};
    let browsersCounter = 0;
    const allDefinitions = Object.keys(checkTree);
    allDefinitions.forEach((key) => {
      const currentDefinition = checkTree[key];
      if (typeof currentDefinition === "string") {
        browsers[key] = currentDefinition;
        browsersCounter += 1;
      } else if (typeof currentDefinition === "object") {
        platformsAndOSes[key] = currentDefinition;
        platformsAndOSCounter += 1;
      }
    });
    if (platformsAndOSCounter > 0) {
      const platformsAndOSNames = Object.keys(platformsAndOSes);
      const OSMatchingDefinition = Utils.find(platformsAndOSNames, (name2) => this.isOS(name2));
      if (OSMatchingDefinition) {
        const osResult = this.satisfies(platformsAndOSes[OSMatchingDefinition]);
        if (osResult !== void 0) {
          return osResult;
        }
      }
      const platformMatchingDefinition = Utils.find(
        platformsAndOSNames,
        (name2) => this.isPlatform(name2)
      );
      if (platformMatchingDefinition) {
        const platformResult = this.satisfies(platformsAndOSes[platformMatchingDefinition]);
        if (platformResult !== void 0) {
          return platformResult;
        }
      }
    }
    if (browsersCounter > 0) {
      const browserNames = Object.keys(browsers);
      const matchingDefinition = Utils.find(browserNames, (name2) => this.isBrowser(name2, true));
      if (matchingDefinition !== void 0) {
        return this.compareVersion(browsers[matchingDefinition]);
      }
    }
    return void 0;
  }
  isBrowser(browserName, includingAlias = false) {
    const defaultBrowserName = this.getBrowserName().toLowerCase();
    let browserNameLower = browserName.toLowerCase();
    const alias = Utils.getBrowserTypeByAlias(browserNameLower);
    if (includingAlias && alias) {
      browserNameLower = alias.toLowerCase();
    }
    return browserNameLower === defaultBrowserName;
  }
  compareVersion(version2) {
    let expectedResults = [0];
    let comparableVersion = version2;
    let isLoose = false;
    const currentBrowserVersion = this.getBrowserVersion();
    if (typeof currentBrowserVersion !== "string") {
      return void 0;
    }
    if (version2[0] === ">" || version2[0] === "<") {
      comparableVersion = version2.substr(1);
      if (version2[1] === "=") {
        isLoose = true;
        comparableVersion = version2.substr(2);
      } else {
        expectedResults = [];
      }
      if (version2[0] === ">") {
        expectedResults.push(1);
      } else {
        expectedResults.push(-1);
      }
    } else if (version2[0] === "=") {
      comparableVersion = version2.substr(1);
    } else if (version2[0] === "~") {
      isLoose = true;
      comparableVersion = version2.substr(1);
    }
    return expectedResults.indexOf(
      Utils.compareVersions(currentBrowserVersion, comparableVersion, isLoose)
    ) > -1;
  }
  isOS(osName) {
    return this.getOSName(true) === String(osName).toLowerCase();
  }
  isPlatform(platformType) {
    return this.getPlatformType(true) === String(platformType).toLowerCase();
  }
  isEngine(engineName) {
    return this.getEngineName(true) === String(engineName).toLowerCase();
  }
  is(anything, includingAlias = false) {
    return this.isBrowser(anything, includingAlias) || this.isOS(anything) || this.isPlatform(anything);
  }
  some(anythings = []) {
    return anythings.some((anything) => this.is(anything));
  }
}
/*!
 * Bowser - a browser detector
 * https://github.com/lancedikson/bowser
 * MIT License | (c) Dustin Diaz 2012-2015
 * MIT License | (c) Denis Demchenko 2015-2019
 */
class Bowser {
  static getParser(UA, skipParsing = false) {
    if (typeof UA !== "string") {
      throw new Error("UserAgent should be a string");
    }
    return new Parser$1(UA, skipParsing);
  }
  static parse(UA) {
    return new Parser$1(UA).getResult();
  }
  static get BROWSER_MAP() {
    return BROWSER_MAP;
  }
  static get ENGINE_MAP() {
    return ENGINE_MAP;
  }
  static get OS_MAP() {
    return OS_MAP;
  }
  static get PLATFORMS_MAP() {
    return PLATFORMS_MAP;
  }
}
var defaultUserAgent = function(_a2) {
  var serviceId = _a2.serviceId, clientVersion = _a2.clientVersion;
  return function() {
    return __awaiter$a(void 0, void 0, void 0, function() {
      var parsedUA, sections;
      var _a3, _b, _c, _d, _e2, _f, _g;
      return __generator$a(this, function(_h) {
        parsedUA = ((_a3 = window === null || window === void 0 ? void 0 : window.navigator) === null || _a3 === void 0 ? void 0 : _a3.userAgent) ? Bowser.parse(window.navigator.userAgent) : void 0;
        sections = [
          ["aws-sdk-js", clientVersion],
          ["os/" + (((_b = parsedUA === null || parsedUA === void 0 ? void 0 : parsedUA.os) === null || _b === void 0 ? void 0 : _b.name) || "other"), (_c = parsedUA === null || parsedUA === void 0 ? void 0 : parsedUA.os) === null || _c === void 0 ? void 0 : _c.version],
          ["lang/js"],
          ["md/browser", ((_e2 = (_d = parsedUA === null || parsedUA === void 0 ? void 0 : parsedUA.browser) === null || _d === void 0 ? void 0 : _d.name) !== null && _e2 !== void 0 ? _e2 : "unknown") + "_" + ((_g = (_f = parsedUA === null || parsedUA === void 0 ? void 0 : parsedUA.browser) === null || _f === void 0 ? void 0 : _f.version) !== null && _g !== void 0 ? _g : "unknown")]
        ];
        if (serviceId) {
          sections.push(["api/" + serviceId, clientVersion]);
        }
        return [2, sections];
      });
    });
  };
};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function __values$2(o2) {
  var s3 = typeof Symbol === "function" && Symbol.iterator, m3 = s3 && o2[s3], i2 = 0;
  if (m3)
    return m3.call(o2);
  if (o2 && typeof o2.length === "number")
    return {
      next: function() {
        if (o2 && i2 >= o2.length)
          o2 = void 0;
        return { value: o2 && o2[i2++], done: !o2 };
      }
    };
  throw new TypeError(s3 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read$7(o2, n2) {
  var m3 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m3)
    return o2;
  var i2 = m3.call(o2), r2, ar2 = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
      ar2.push(r2.value);
  } catch (error) {
    e3 = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m3 = i2["return"]))
        m3.call(i2);
    } finally {
      if (e3)
        throw e3.error;
    }
  }
  return ar2;
}
function parseQueryString(querystring2) {
  var e_1, _a2;
  var query = {};
  querystring2 = querystring2.replace(/^\?/, "");
  if (querystring2) {
    try {
      for (var _b = __values$2(querystring2.split("&")), _c = _b.next(); !_c.done; _c = _b.next()) {
        var pair = _c.value;
        var _d = __read$7(pair.split("="), 2), key = _d[0], _e2 = _d[1], value = _e2 === void 0 ? null : _e2;
        key = decodeURIComponent(key);
        if (value) {
          value = decodeURIComponent(value);
        }
        if (!(key in query)) {
          query[key] = value;
        } else if (Array.isArray(query[key])) {
          query[key].push(value);
        } else {
          query[key] = [query[key], value];
        }
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (_c && !_c.done && (_a2 = _b.return))
          _a2.call(_b);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
  }
  return query;
}
var parseUrl = function(url) {
  var _a2 = new URL(url), hostname = _a2.hostname, pathname = _a2.pathname, port = _a2.port, protocol = _a2.protocol, search = _a2.search;
  var query;
  if (search) {
    query = parseQueryString(search);
  }
  return {
    hostname,
    port: port ? parseInt(port) : void 0,
    protocol,
    path: pathname,
    query
  };
};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var __assign$8 = function() {
  __assign$8 = Object.assign || function __assign2(t3) {
    for (var s3, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s3 = arguments[i2];
      for (var p2 in s3)
        if (Object.prototype.hasOwnProperty.call(s3, p2))
          t3[p2] = s3[p2];
    }
    return t3;
  };
  return __assign$8.apply(this, arguments);
};
function __awaiter$9(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator$9(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t3[0] & 1)
      throw t3[1];
    return t3[1];
  }, trys: [], ops: [] }, f, y3, t3, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n2) {
    return function(v) {
      return step([n2, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_2)
      try {
        if (f = 1, y3 && (t3 = op[0] & 2 ? y3["return"] : op[0] ? y3["throw"] || ((t3 = y3["return"]) && t3.call(y3), 0) : y3.next) && !(t3 = t3.call(y3, op[1])).done)
          return t3;
        if (y3 = 0, t3)
          op = [op[0] & 2, t3.value];
        switch (op[0]) {
          case 0:
          case 1:
            t3 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y3 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t3 = _2.trys, t3 = t3.length > 0 && t3[t3.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t3 || op[1] > t3[0] && op[1] < t3[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t3[1]) {
              _2.label = t3[1];
              t3 = op;
              break;
            }
            if (t3 && _2.label < t3[2]) {
              _2.label = t3[2];
              _2.ops.push(op);
              break;
            }
            if (t3[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e3) {
        op = [6, e3];
        y3 = 0;
      } finally {
        f = t3 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
var resolveEndpointsConfig = function(input) {
  var _a2;
  return __assign$8(__assign$8({}, input), { tls: (_a2 = input.tls) !== null && _a2 !== void 0 ? _a2 : true, endpoint: input.endpoint ? normalizeEndpoint(input) : function() {
    return getEndPointFromRegion(input);
  }, isCustomEndpoint: input.endpoint ? true : false });
};
var normalizeEndpoint = function(input) {
  var endpoint = input.endpoint, urlParser = input.urlParser;
  if (typeof endpoint === "string") {
    var promisified_1 = Promise.resolve(urlParser(endpoint));
    return function() {
      return promisified_1;
    };
  } else if (typeof endpoint === "object") {
    var promisified_2 = Promise.resolve(endpoint);
    return function() {
      return promisified_2;
    };
  }
  return endpoint;
};
var getEndPointFromRegion = function(input) {
  return __awaiter$9(void 0, void 0, void 0, function() {
    var _a2, tls, region, dnsHostRegex, hostname;
    var _b;
    return __generator$9(this, function(_c) {
      switch (_c.label) {
        case 0:
          _a2 = input.tls, tls = _a2 === void 0 ? true : _a2;
          return [4, input.region()];
        case 1:
          region = _c.sent();
          dnsHostRegex = new RegExp(/^([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9])$/);
          if (!dnsHostRegex.test(region)) {
            throw new Error("Invalid region in client config");
          }
          return [4, input.regionInfoProvider(region)];
        case 2:
          hostname = ((_b = _c.sent()) !== null && _b !== void 0 ? _b : {}).hostname;
          if (!hostname) {
            throw new Error("Cannot resolve hostname from client config");
          }
          return [2, input.urlParser((tls ? "https:" : "http:") + "//" + hostname)];
      }
    });
  });
};
var resolveRegionConfig = function(input) {
  if (!input.region) {
    throw new Error("Region is missing");
  }
  return __assign$8(__assign$8({}, input), { region: normalizeRegion(input.region) });
};
var normalizeRegion = function(region) {
  if (typeof region === "string") {
    var promisified_1 = Promise.resolve(region);
    return function() {
      return promisified_1;
    };
  }
  return region;
};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var __assign$7 = function() {
  __assign$7 = Object.assign || function __assign2(t3) {
    for (var s3, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s3 = arguments[i2];
      for (var p2 in s3)
        if (Object.prototype.hasOwnProperty.call(s3, p2))
          t3[p2] = s3[p2];
    }
    return t3;
  };
  return __assign$7.apply(this, arguments);
};
function __awaiter$8(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator$8(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t3[0] & 1)
      throw t3[1];
    return t3[1];
  }, trys: [], ops: [] }, f, y3, t3, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n2) {
    return function(v) {
      return step([n2, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_2)
      try {
        if (f = 1, y3 && (t3 = op[0] & 2 ? y3["return"] : op[0] ? y3["throw"] || ((t3 = y3["return"]) && t3.call(y3), 0) : y3.next) && !(t3 = t3.call(y3, op[1])).done)
          return t3;
        if (y3 = 0, t3)
          op = [op[0] & 2, t3.value];
        switch (op[0]) {
          case 0:
          case 1:
            t3 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y3 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t3 = _2.trys, t3 = t3.length > 0 && t3[t3.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t3 || op[1] > t3[0] && op[1] < t3[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t3[1]) {
              _2.label = t3[1];
              t3 = op;
              break;
            }
            if (t3 && _2.label < t3[2]) {
              _2.label = t3[2];
              _2.ops.push(op);
              break;
            }
            if (t3[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e3) {
        op = [6, e3];
        y3 = 0;
      } finally {
        f = t3 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
var CONTENT_LENGTH_HEADER = "content-length";
function contentLengthMiddleware(bodyLengthChecker) {
  var _this = this;
  return function(next) {
    return function(args) {
      return __awaiter$8(_this, void 0, void 0, function() {
        var request, body, headers, length;
        var _a2;
        return __generator$8(this, function(_b) {
          request = args.request;
          if (HttpRequest.isInstance(request)) {
            body = request.body, headers = request.headers;
            if (body && Object.keys(headers).map(function(str) {
              return str.toLowerCase();
            }).indexOf(CONTENT_LENGTH_HEADER) === -1) {
              length = bodyLengthChecker(body);
              if (length !== void 0) {
                request.headers = __assign$7(__assign$7({}, request.headers), (_a2 = {}, _a2[CONTENT_LENGTH_HEADER] = String(length), _a2));
              }
            }
          }
          return [2, next(__assign$7(__assign$7({}, args), { request }))];
        });
      });
    };
  };
}
var contentLengthMiddlewareOptions = {
  step: "build",
  tags: ["SET_CONTENT_LENGTH", "CONTENT_LENGTH"],
  name: "contentLengthMiddleware",
  override: true
};
var getContentLengthPlugin = function(options) {
  return {
    applyToStack: function(clientStack) {
      clientStack.add(contentLengthMiddleware(options.bodyLengthChecker), contentLengthMiddlewareOptions);
    }
  };
};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function __awaiter$7(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator$7(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t3[0] & 1)
      throw t3[1];
    return t3[1];
  }, trys: [], ops: [] }, f, y3, t3, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n2) {
    return function(v) {
      return step([n2, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_2)
      try {
        if (f = 1, y3 && (t3 = op[0] & 2 ? y3["return"] : op[0] ? y3["throw"] || ((t3 = y3["return"]) && t3.call(y3), 0) : y3.next) && !(t3 = t3.call(y3, op[1])).done)
          return t3;
        if (y3 = 0, t3)
          op = [op[0] & 2, t3.value];
        switch (op[0]) {
          case 0:
          case 1:
            t3 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y3 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t3 = _2.trys, t3 = t3.length > 0 && t3[t3.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t3 || op[1] > t3[0] && op[1] < t3[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t3[1]) {
              _2.label = t3[1];
              t3 = op;
              break;
            }
            if (t3 && _2.label < t3[2]) {
              _2.label = t3[2];
              _2.ops.push(op);
              break;
            }
            if (t3[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e3) {
        op = [6, e3];
        y3 = 0;
      } finally {
        f = t3 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function resolveHostHeaderConfig(input) {
  return input;
}
var hostHeaderMiddleware = function(options) {
  return function(next) {
    return function(args) {
      return __awaiter$7(void 0, void 0, void 0, function() {
        var request, _a2, handlerProtocol;
        return __generator$7(this, function(_b) {
          if (!HttpRequest.isInstance(args.request))
            return [2, next(args)];
          request = args.request;
          _a2 = (options.requestHandler.metadata || {}).handlerProtocol, handlerProtocol = _a2 === void 0 ? "" : _a2;
          if (handlerProtocol.indexOf("h2") >= 0 && !request.headers[":authority"]) {
            delete request.headers["host"];
            request.headers[":authority"] = "";
          } else if (!request.headers["host"]) {
            request.headers["host"] = request.hostname;
          }
          return [2, next(args)];
        });
      });
    };
  };
};
var hostHeaderMiddlewareOptions = {
  name: "hostHeaderMiddleware",
  step: "build",
  priority: "low",
  tags: ["HOST"],
  override: true
};
var getHostHeaderPlugin = function(options) {
  return {
    applyToStack: function(clientStack) {
      clientStack.add(hostHeaderMiddleware(options), hostHeaderMiddlewareOptions);
    }
  };
};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function __rest$1(s3, e3) {
  var t3 = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
      t3[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s3); i2 < p2.length; i2++) {
      if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i2]))
        t3[p2[i2]] = s3[p2[i2]];
    }
  return t3;
}
function __awaiter$6(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator$6(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t3[0] & 1)
      throw t3[1];
    return t3[1];
  }, trys: [], ops: [] }, f, y3, t3, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n2) {
    return function(v) {
      return step([n2, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_2)
      try {
        if (f = 1, y3 && (t3 = op[0] & 2 ? y3["return"] : op[0] ? y3["throw"] || ((t3 = y3["return"]) && t3.call(y3), 0) : y3.next) && !(t3 = t3.call(y3, op[1])).done)
          return t3;
        if (y3 = 0, t3)
          op = [op[0] & 2, t3.value];
        switch (op[0]) {
          case 0:
          case 1:
            t3 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y3 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t3 = _2.trys, t3 = t3.length > 0 && t3[t3.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t3 || op[1] > t3[0] && op[1] < t3[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t3[1]) {
              _2.label = t3[1];
              t3 = op;
              break;
            }
            if (t3 && _2.label < t3[2]) {
              _2.label = t3[2];
              _2.ops.push(op);
              break;
            }
            if (t3[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e3) {
        op = [6, e3];
        y3 = 0;
      } finally {
        f = t3 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
var loggerMiddleware = function() {
  return function(next, context) {
    return function(args) {
      return __awaiter$6(void 0, void 0, void 0, function() {
        var clientName, commandName, inputFilterSensitiveLog, logger2, outputFilterSensitiveLog, response, _a2, $metadata, outputWithoutMetadata;
        return __generator$6(this, function(_b) {
          switch (_b.label) {
            case 0:
              clientName = context.clientName, commandName = context.commandName, inputFilterSensitiveLog = context.inputFilterSensitiveLog, logger2 = context.logger, outputFilterSensitiveLog = context.outputFilterSensitiveLog;
              return [4, next(args)];
            case 1:
              response = _b.sent();
              if (!logger2) {
                return [2, response];
              }
              if (typeof logger2.info === "function") {
                _a2 = response.output, $metadata = _a2.$metadata, outputWithoutMetadata = __rest$1(_a2, ["$metadata"]);
                logger2.info({
                  clientName,
                  commandName,
                  input: inputFilterSensitiveLog(args.input),
                  output: outputFilterSensitiveLog(outputWithoutMetadata),
                  metadata: $metadata
                });
              }
              return [2, response];
          }
        });
      });
    };
  };
};
var loggerMiddlewareOptions = {
  name: "loggerMiddleware",
  tags: ["LOGGER"],
  step: "initialize",
  override: true
};
var getLoggerPlugin = function(options) {
  return {
    applyToStack: function(clientStack) {
      clientStack.add(loggerMiddleware(), loggerMiddlewareOptions);
    }
  };
};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var __assign$6 = function() {
  __assign$6 = Object.assign || function __assign2(t3) {
    for (var s3, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s3 = arguments[i2];
      for (var p2 in s3)
        if (Object.prototype.hasOwnProperty.call(s3, p2))
          t3[p2] = s3[p2];
    }
    return t3;
  };
  return __assign$6.apply(this, arguments);
};
function __awaiter$5(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator$5(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t3[0] & 1)
      throw t3[1];
    return t3[1];
  }, trys: [], ops: [] }, f, y3, t3, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n2) {
    return function(v) {
      return step([n2, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_2)
      try {
        if (f = 1, y3 && (t3 = op[0] & 2 ? y3["return"] : op[0] ? y3["throw"] || ((t3 = y3["return"]) && t3.call(y3), 0) : y3.next) && !(t3 = t3.call(y3, op[1])).done)
          return t3;
        if (y3 = 0, t3)
          op = [op[0] & 2, t3.value];
        switch (op[0]) {
          case 0:
          case 1:
            t3 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y3 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t3 = _2.trys, t3 = t3.length > 0 && t3[t3.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t3 || op[1] > t3[0] && op[1] < t3[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t3[1]) {
              _2.label = t3[1];
              t3 = op;
              break;
            }
            if (t3 && _2.label < t3[2]) {
              _2.label = t3[2];
              _2.ops.push(op);
              break;
            }
            if (t3[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e3) {
        op = [6, e3];
        y3 = 0;
      } finally {
        f = t3 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __read$6(o2, n2) {
  var m3 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m3)
    return o2;
  var i2 = m3.call(o2), r2, ar2 = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
      ar2.push(r2.value);
  } catch (error) {
    e3 = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m3 = i2["return"]))
        m3.call(i2);
    } finally {
      if (e3)
        throw e3.error;
    }
  }
  return ar2;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var __assign$5 = function() {
  __assign$5 = Object.assign || function __assign2(t3) {
    for (var s3, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s3 = arguments[i2];
      for (var p2 in s3)
        if (Object.prototype.hasOwnProperty.call(s3, p2))
          t3[p2] = s3[p2];
    }
    return t3;
  };
  return __assign$5.apply(this, arguments);
};
function __rest(s3, e3) {
  var t3 = {};
  for (var p2 in s3)
    if (Object.prototype.hasOwnProperty.call(s3, p2) && e3.indexOf(p2) < 0)
      t3[p2] = s3[p2];
  if (s3 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s3); i2 < p2.length; i2++) {
      if (e3.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s3, p2[i2]))
        t3[p2[i2]] = s3[p2[i2]];
    }
  return t3;
}
function __awaiter$4(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator$4(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t3[0] & 1)
      throw t3[1];
    return t3[1];
  }, trys: [], ops: [] }, f, y3, t3, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n2) {
    return function(v) {
      return step([n2, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_2)
      try {
        if (f = 1, y3 && (t3 = op[0] & 2 ? y3["return"] : op[0] ? y3["throw"] || ((t3 = y3["return"]) && t3.call(y3), 0) : y3.next) && !(t3 = t3.call(y3, op[1])).done)
          return t3;
        if (y3 = 0, t3)
          op = [op[0] & 2, t3.value];
        switch (op[0]) {
          case 0:
          case 1:
            t3 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y3 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t3 = _2.trys, t3 = t3.length > 0 && t3[t3.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t3 || op[1] > t3[0] && op[1] < t3[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t3[1]) {
              _2.label = t3[1];
              t3 = op;
              break;
            }
            if (t3 && _2.label < t3[2]) {
              _2.label = t3[2];
              _2.ops.push(op);
              break;
            }
            if (t3[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e3) {
        op = [6, e3];
        y3 = 0;
      } finally {
        f = t3 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __values$1(o2) {
  var s3 = typeof Symbol === "function" && Symbol.iterator, m3 = s3 && o2[s3], i2 = 0;
  if (m3)
    return m3.call(o2);
  if (o2 && typeof o2.length === "number")
    return {
      next: function() {
        if (o2 && i2 >= o2.length)
          o2 = void 0;
        return { value: o2 && o2[i2++], done: !o2 };
      }
    };
  throw new TypeError(s3 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read$5(o2, n2) {
  var m3 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m3)
    return o2;
  var i2 = m3.call(o2), r2, ar2 = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
      ar2.push(r2.value);
  } catch (error) {
    e3 = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m3 = i2["return"]))
        m3.call(i2);
    } finally {
      if (e3)
        throw e3.error;
    }
  }
  return ar2;
}
function __spread$3() {
  for (var ar2 = [], i2 = 0; i2 < arguments.length; i2++)
    ar2 = ar2.concat(__read$5(arguments[i2]));
  return ar2;
}
var ALGORITHM_QUERY_PARAM = "X-Amz-Algorithm";
var CREDENTIAL_QUERY_PARAM = "X-Amz-Credential";
var AMZ_DATE_QUERY_PARAM = "X-Amz-Date";
var SIGNED_HEADERS_QUERY_PARAM = "X-Amz-SignedHeaders";
var EXPIRES_QUERY_PARAM = "X-Amz-Expires";
var SIGNATURE_QUERY_PARAM = "X-Amz-Signature";
var TOKEN_QUERY_PARAM = "X-Amz-Security-Token";
var AUTH_HEADER = "authorization";
var AMZ_DATE_HEADER = AMZ_DATE_QUERY_PARAM.toLowerCase();
var DATE_HEADER = "date";
var GENERATED_HEADERS = [AUTH_HEADER, AMZ_DATE_HEADER, DATE_HEADER];
var SIGNATURE_HEADER = SIGNATURE_QUERY_PARAM.toLowerCase();
var SHA256_HEADER = "x-amz-content-sha256";
var TOKEN_HEADER = TOKEN_QUERY_PARAM.toLowerCase();
var ALWAYS_UNSIGNABLE_HEADERS = {
  authorization: true,
  "cache-control": true,
  connection: true,
  expect: true,
  from: true,
  "keep-alive": true,
  "max-forwards": true,
  pragma: true,
  referer: true,
  te: true,
  trailer: true,
  "transfer-encoding": true,
  upgrade: true,
  "user-agent": true,
  "x-amzn-trace-id": true
};
var PROXY_HEADER_PATTERN = /^proxy-/;
var SEC_HEADER_PATTERN = /^sec-/;
var ALGORITHM_IDENTIFIER = "AWS4-HMAC-SHA256";
var EVENT_ALGORITHM_IDENTIFIER = "AWS4-HMAC-SHA256-PAYLOAD";
var UNSIGNED_PAYLOAD = "UNSIGNED-PAYLOAD";
var MAX_CACHE_SIZE = 50;
var KEY_TYPE_IDENTIFIER = "aws4_request";
var MAX_PRESIGNED_TTL = 60 * 60 * 24 * 7;
var signingKeyCache = {};
var cacheQueue = [];
function createScope(shortDate, region, service) {
  return shortDate + "/" + region + "/" + service + "/" + KEY_TYPE_IDENTIFIER;
}
var getSigningKey = function(sha256Constructor, credentials, shortDate, region, service) {
  return __awaiter$4(void 0, void 0, void 0, function() {
    var credsHash, cacheKey, key, _a2, _b, signable, e_1_1;
    var e_1, _c;
    return __generator$4(this, function(_d) {
      switch (_d.label) {
        case 0:
          return [4, hmac(sha256Constructor, credentials.secretAccessKey, credentials.accessKeyId)];
        case 1:
          credsHash = _d.sent();
          cacheKey = shortDate + ":" + region + ":" + service + ":" + toHex$1(credsHash) + ":" + credentials.sessionToken;
          if (cacheKey in signingKeyCache) {
            return [2, signingKeyCache[cacheKey]];
          }
          cacheQueue.push(cacheKey);
          while (cacheQueue.length > MAX_CACHE_SIZE) {
            delete signingKeyCache[cacheQueue.shift()];
          }
          key = "AWS4" + credentials.secretAccessKey;
          _d.label = 2;
        case 2:
          _d.trys.push([2, 7, 8, 9]);
          _a2 = __values$1([shortDate, region, service, KEY_TYPE_IDENTIFIER]), _b = _a2.next();
          _d.label = 3;
        case 3:
          if (!!_b.done)
            return [3, 6];
          signable = _b.value;
          return [4, hmac(sha256Constructor, key, signable)];
        case 4:
          key = _d.sent();
          _d.label = 5;
        case 5:
          _b = _a2.next();
          return [3, 3];
        case 6:
          return [3, 9];
        case 7:
          e_1_1 = _d.sent();
          e_1 = { error: e_1_1 };
          return [3, 9];
        case 8:
          try {
            if (_b && !_b.done && (_c = _a2.return))
              _c.call(_a2);
          } finally {
            if (e_1)
              throw e_1.error;
          }
          return [7];
        case 9:
          return [2, signingKeyCache[cacheKey] = key];
      }
    });
  });
};
function hmac(ctor, secret, data) {
  var hash2 = new ctor(secret);
  hash2.update(data);
  return hash2.digest();
}
function getCanonicalHeaders(_a2, unsignableHeaders, signableHeaders) {
  var e_1, _b;
  var headers = _a2.headers;
  var canonical = {};
  try {
    for (var _c = __values$1(Object.keys(headers).sort()), _d = _c.next(); !_d.done; _d = _c.next()) {
      var headerName = _d.value;
      var canonicalHeaderName = headerName.toLowerCase();
      if (canonicalHeaderName in ALWAYS_UNSIGNABLE_HEADERS || (unsignableHeaders === null || unsignableHeaders === void 0 ? void 0 : unsignableHeaders.has(canonicalHeaderName)) || PROXY_HEADER_PATTERN.test(canonicalHeaderName) || SEC_HEADER_PATTERN.test(canonicalHeaderName)) {
        if (!signableHeaders || signableHeaders && !signableHeaders.has(canonicalHeaderName)) {
          continue;
        }
      }
      canonical[canonicalHeaderName] = headers[headerName].trim().replace(/\s+/g, " ");
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (_d && !_d.done && (_b = _c.return))
        _b.call(_c);
    } finally {
      if (e_1)
        throw e_1.error;
    }
  }
  return canonical;
}
function getCanonicalQuery(_a2) {
  var e_1, _b;
  var _c = _a2.query, query = _c === void 0 ? {} : _c;
  var keys = [];
  var serialized = {};
  var _loop_1 = function(key2) {
    if (key2.toLowerCase() === SIGNATURE_HEADER) {
      return "continue";
    }
    keys.push(key2);
    var value = query[key2];
    if (typeof value === "string") {
      serialized[key2] = escapeUri(key2) + "=" + escapeUri(value);
    } else if (Array.isArray(value)) {
      serialized[key2] = value.slice(0).sort().reduce(function(encoded, value2) {
        return encoded.concat([escapeUri(key2) + "=" + escapeUri(value2)]);
      }, []).join("&");
    }
  };
  try {
    for (var _d = __values$1(Object.keys(query).sort()), _e2 = _d.next(); !_e2.done; _e2 = _d.next()) {
      var key = _e2.value;
      _loop_1(key);
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (_e2 && !_e2.done && (_b = _d.return))
        _b.call(_d);
    } finally {
      if (e_1)
        throw e_1.error;
    }
  }
  return keys.map(function(key2) {
    return serialized[key2];
  }).filter(function(serialized2) {
    return serialized2;
  }).join("&");
}
var isArrayBuffer$1 = function(arg) {
  return typeof ArrayBuffer === "function" && arg instanceof ArrayBuffer || Object.prototype.toString.call(arg) === "[object ArrayBuffer]";
};
function getPayloadHash(_a2, hashConstructor) {
  var headers = _a2.headers, body = _a2.body;
  return __awaiter$4(this, void 0, void 0, function() {
    var _b, _c, headerName, hashCtor, _d;
    var e_1, _e2;
    return __generator$4(this, function(_f) {
      switch (_f.label) {
        case 0:
          try {
            for (_b = __values$1(Object.keys(headers)), _c = _b.next(); !_c.done; _c = _b.next()) {
              headerName = _c.value;
              if (headerName.toLowerCase() === SHA256_HEADER) {
                return [2, headers[headerName]];
              }
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_c && !_c.done && (_e2 = _b.return))
                _e2.call(_b);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
          if (!(body == void 0))
            return [3, 1];
          return [2, "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855"];
        case 1:
          if (!(typeof body === "string" || ArrayBuffer.isView(body) || isArrayBuffer$1(body)))
            return [3, 3];
          hashCtor = new hashConstructor();
          hashCtor.update(body);
          _d = toHex$1;
          return [4, hashCtor.digest()];
        case 2:
          return [2, _d.apply(void 0, [_f.sent()])];
        case 3:
          return [2, UNSIGNED_PAYLOAD];
      }
    });
  });
}
function hasHeader(soughtHeader, headers) {
  var e_1, _a2;
  soughtHeader = soughtHeader.toLowerCase();
  try {
    for (var _b = __values$1(Object.keys(headers)), _c = _b.next(); !_c.done; _c = _b.next()) {
      var headerName = _c.value;
      if (soughtHeader === headerName.toLowerCase()) {
        return true;
      }
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (_c && !_c.done && (_a2 = _b.return))
        _a2.call(_b);
    } finally {
      if (e_1)
        throw e_1.error;
    }
  }
  return false;
}
function cloneRequest(_a2) {
  var headers = _a2.headers, query = _a2.query, rest = __rest(_a2, ["headers", "query"]);
  return __assign$5(__assign$5({}, rest), { headers: __assign$5({}, headers), query: query ? cloneQuery(query) : void 0 });
}
function cloneQuery(query) {
  return Object.keys(query).reduce(function(carry, paramName) {
    var _a2;
    var param = query[paramName];
    return __assign$5(__assign$5({}, carry), (_a2 = {}, _a2[paramName] = Array.isArray(param) ? __spread$3(param) : param, _a2));
  }, {});
}
function moveHeadersToQuery(request, options) {
  var e_1, _a2;
  var _b;
  if (options === void 0) {
    options = {};
  }
  var _c = typeof request.clone === "function" ? request.clone() : cloneRequest(request), headers = _c.headers, _d = _c.query, query = _d === void 0 ? {} : _d;
  try {
    for (var _e2 = __values$1(Object.keys(headers)), _f = _e2.next(); !_f.done; _f = _e2.next()) {
      var name2 = _f.value;
      var lname = name2.toLowerCase();
      if (lname.substr(0, 6) === "x-amz-" && !((_b = options.unhoistableHeaders) === null || _b === void 0 ? void 0 : _b.has(lname))) {
        query[name2] = headers[name2];
        delete headers[name2];
      }
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (_f && !_f.done && (_a2 = _e2.return))
        _a2.call(_e2);
    } finally {
      if (e_1)
        throw e_1.error;
    }
  }
  return __assign$5(__assign$5({}, request), {
    headers,
    query
  });
}
function prepareRequest(request) {
  var e_1, _a2;
  request = typeof request.clone === "function" ? request.clone() : cloneRequest(request);
  try {
    for (var _b = __values$1(Object.keys(request.headers)), _c = _b.next(); !_c.done; _c = _b.next()) {
      var headerName = _c.value;
      if (GENERATED_HEADERS.indexOf(headerName.toLowerCase()) > -1) {
        delete request.headers[headerName];
      }
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (_c && !_c.done && (_a2 = _b.return))
        _a2.call(_b);
    } finally {
      if (e_1)
        throw e_1.error;
    }
  }
  return request;
}
function iso8601(time) {
  return toDate$1(time).toISOString().replace(/\.\d{3}Z$/, "Z");
}
function toDate$1(time) {
  if (typeof time === "number") {
    return new Date(time * 1e3);
  }
  if (typeof time === "string") {
    if (Number(time)) {
      return new Date(Number(time) * 1e3);
    }
    return new Date(time);
  }
  return time;
}
var SignatureV4 = function() {
  function SignatureV42(_a2) {
    var applyChecksum = _a2.applyChecksum, credentials = _a2.credentials, region = _a2.region, service = _a2.service, sha256 = _a2.sha256, _b = _a2.uriEscapePath, uriEscapePath = _b === void 0 ? true : _b;
    this.service = service;
    this.sha256 = sha256;
    this.uriEscapePath = uriEscapePath;
    this.applyChecksum = typeof applyChecksum === "boolean" ? applyChecksum : true;
    this.regionProvider = normalizeRegionProvider(region);
    this.credentialProvider = normalizeCredentialsProvider(credentials);
  }
  SignatureV42.prototype.presign = function(originalRequest, options) {
    if (options === void 0) {
      options = {};
    }
    return __awaiter$4(this, void 0, void 0, function() {
      var _a2, signingDate, _b, expiresIn, unsignableHeaders, unhoistableHeaders, signableHeaders, signingRegion, signingService, credentials, region, _c, _d, longDate, shortDate, scope, request, canonicalHeaders, _e2, _f, _g, _h, _j, _k;
      return __generator$4(this, function(_l2) {
        switch (_l2.label) {
          case 0:
            _a2 = options.signingDate, signingDate = _a2 === void 0 ? new Date() : _a2, _b = options.expiresIn, expiresIn = _b === void 0 ? 3600 : _b, unsignableHeaders = options.unsignableHeaders, unhoistableHeaders = options.unhoistableHeaders, signableHeaders = options.signableHeaders, signingRegion = options.signingRegion, signingService = options.signingService;
            return [4, this.credentialProvider()];
          case 1:
            credentials = _l2.sent();
            if (!(signingRegion !== null && signingRegion !== void 0))
              return [3, 2];
            _c = signingRegion;
            return [3, 4];
          case 2:
            return [4, this.regionProvider()];
          case 3:
            _c = _l2.sent();
            _l2.label = 4;
          case 4:
            region = _c;
            _d = formatDate(signingDate), longDate = _d.longDate, shortDate = _d.shortDate;
            if (expiresIn > MAX_PRESIGNED_TTL) {
              return [2, Promise.reject("Signature version 4 presigned URLs must have an expiration date less than one week in the future")];
            }
            scope = createScope(shortDate, region, signingService !== null && signingService !== void 0 ? signingService : this.service);
            request = moveHeadersToQuery(prepareRequest(originalRequest), { unhoistableHeaders });
            if (credentials.sessionToken) {
              request.query[TOKEN_QUERY_PARAM] = credentials.sessionToken;
            }
            request.query[ALGORITHM_QUERY_PARAM] = ALGORITHM_IDENTIFIER;
            request.query[CREDENTIAL_QUERY_PARAM] = credentials.accessKeyId + "/" + scope;
            request.query[AMZ_DATE_QUERY_PARAM] = longDate;
            request.query[EXPIRES_QUERY_PARAM] = expiresIn.toString(10);
            canonicalHeaders = getCanonicalHeaders(request, unsignableHeaders, signableHeaders);
            request.query[SIGNED_HEADERS_QUERY_PARAM] = getCanonicalHeaderList(canonicalHeaders);
            _e2 = request.query;
            _f = SIGNATURE_QUERY_PARAM;
            _g = this.getSignature;
            _h = [
              longDate,
              scope,
              this.getSigningKey(credentials, region, shortDate, signingService)
            ];
            _j = this.createCanonicalRequest;
            _k = [request, canonicalHeaders];
            return [4, getPayloadHash(originalRequest, this.sha256)];
          case 5:
            return [4, _g.apply(this, _h.concat([_j.apply(this, _k.concat([_l2.sent()]))]))];
          case 6:
            _e2[_f] = _l2.sent();
            return [2, request];
        }
      });
    });
  };
  SignatureV42.prototype.sign = function(toSign, options) {
    return __awaiter$4(this, void 0, void 0, function() {
      return __generator$4(this, function(_a2) {
        if (typeof toSign === "string") {
          return [2, this.signString(toSign, options)];
        } else if (toSign.headers && toSign.payload) {
          return [2, this.signEvent(toSign, options)];
        } else {
          return [2, this.signRequest(toSign, options)];
        }
      });
    });
  };
  SignatureV42.prototype.signEvent = function(_a2, _b) {
    var headers = _a2.headers, payload = _a2.payload;
    var _c = _b.signingDate, signingDate = _c === void 0 ? new Date() : _c, priorSignature = _b.priorSignature, signingRegion = _b.signingRegion, signingService = _b.signingService;
    return __awaiter$4(this, void 0, void 0, function() {
      var region, _d, _e2, shortDate, longDate, scope, hashedPayload, hash2, hashedHeaders, _f, stringToSign;
      return __generator$4(this, function(_g) {
        switch (_g.label) {
          case 0:
            if (!(signingRegion !== null && signingRegion !== void 0))
              return [3, 1];
            _d = signingRegion;
            return [3, 3];
          case 1:
            return [4, this.regionProvider()];
          case 2:
            _d = _g.sent();
            _g.label = 3;
          case 3:
            region = _d;
            _e2 = formatDate(signingDate), shortDate = _e2.shortDate, longDate = _e2.longDate;
            scope = createScope(shortDate, region, signingService !== null && signingService !== void 0 ? signingService : this.service);
            return [4, getPayloadHash({ headers: {}, body: payload }, this.sha256)];
          case 4:
            hashedPayload = _g.sent();
            hash2 = new this.sha256();
            hash2.update(headers);
            _f = toHex$1;
            return [4, hash2.digest()];
          case 5:
            hashedHeaders = _f.apply(void 0, [_g.sent()]);
            stringToSign = [
              EVENT_ALGORITHM_IDENTIFIER,
              longDate,
              scope,
              priorSignature,
              hashedHeaders,
              hashedPayload
            ].join("\n");
            return [2, this.signString(stringToSign, { signingDate, signingRegion: region, signingService })];
        }
      });
    });
  };
  SignatureV42.prototype.signString = function(stringToSign, _a2) {
    var _b = _a2 === void 0 ? {} : _a2, _c = _b.signingDate, signingDate = _c === void 0 ? new Date() : _c, signingRegion = _b.signingRegion, signingService = _b.signingService;
    return __awaiter$4(this, void 0, void 0, function() {
      var credentials, region, _d, shortDate, hash2, _e2, _f, _g;
      return __generator$4(this, function(_h) {
        switch (_h.label) {
          case 0:
            return [4, this.credentialProvider()];
          case 1:
            credentials = _h.sent();
            if (!(signingRegion !== null && signingRegion !== void 0))
              return [3, 2];
            _d = signingRegion;
            return [3, 4];
          case 2:
            return [4, this.regionProvider()];
          case 3:
            _d = _h.sent();
            _h.label = 4;
          case 4:
            region = _d;
            shortDate = formatDate(signingDate).shortDate;
            _f = (_e2 = this.sha256).bind;
            return [4, this.getSigningKey(credentials, region, shortDate, signingService)];
          case 5:
            hash2 = new (_f.apply(_e2, [void 0, _h.sent()]))();
            hash2.update(stringToSign);
            _g = toHex$1;
            return [4, hash2.digest()];
          case 6:
            return [2, _g.apply(void 0, [_h.sent()])];
        }
      });
    });
  };
  SignatureV42.prototype.signRequest = function(requestToSign, _a2) {
    var _b = _a2 === void 0 ? {} : _a2, _c = _b.signingDate, signingDate = _c === void 0 ? new Date() : _c, signableHeaders = _b.signableHeaders, unsignableHeaders = _b.unsignableHeaders, signingRegion = _b.signingRegion, signingService = _b.signingService;
    return __awaiter$4(this, void 0, void 0, function() {
      var credentials, region, _d, request, _e2, longDate, shortDate, scope, payloadHash, canonicalHeaders, signature;
      return __generator$4(this, function(_f) {
        switch (_f.label) {
          case 0:
            return [4, this.credentialProvider()];
          case 1:
            credentials = _f.sent();
            if (!(signingRegion !== null && signingRegion !== void 0))
              return [3, 2];
            _d = signingRegion;
            return [3, 4];
          case 2:
            return [4, this.regionProvider()];
          case 3:
            _d = _f.sent();
            _f.label = 4;
          case 4:
            region = _d;
            request = prepareRequest(requestToSign);
            _e2 = formatDate(signingDate), longDate = _e2.longDate, shortDate = _e2.shortDate;
            scope = createScope(shortDate, region, signingService !== null && signingService !== void 0 ? signingService : this.service);
            request.headers[AMZ_DATE_HEADER] = longDate;
            if (credentials.sessionToken) {
              request.headers[TOKEN_HEADER] = credentials.sessionToken;
            }
            return [4, getPayloadHash(request, this.sha256)];
          case 5:
            payloadHash = _f.sent();
            if (!hasHeader(SHA256_HEADER, request.headers) && this.applyChecksum) {
              request.headers[SHA256_HEADER] = payloadHash;
            }
            canonicalHeaders = getCanonicalHeaders(request, unsignableHeaders, signableHeaders);
            return [4, this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService), this.createCanonicalRequest(request, canonicalHeaders, payloadHash))];
          case 6:
            signature = _f.sent();
            request.headers[AUTH_HEADER] = ALGORITHM_IDENTIFIER + " " + ("Credential=" + credentials.accessKeyId + "/" + scope + ", ") + ("SignedHeaders=" + getCanonicalHeaderList(canonicalHeaders) + ", ") + ("Signature=" + signature);
            return [2, request];
        }
      });
    });
  };
  SignatureV42.prototype.createCanonicalRequest = function(request, canonicalHeaders, payloadHash) {
    var sortedHeaders = Object.keys(canonicalHeaders).sort();
    return request.method + "\n" + this.getCanonicalPath(request) + "\n" + getCanonicalQuery(request) + "\n" + sortedHeaders.map(function(name2) {
      return name2 + ":" + canonicalHeaders[name2];
    }).join("\n") + "\n\n" + sortedHeaders.join(";") + "\n" + payloadHash;
  };
  SignatureV42.prototype.createStringToSign = function(longDate, credentialScope, canonicalRequest) {
    return __awaiter$4(this, void 0, void 0, function() {
      var hash2, hashedRequest;
      return __generator$4(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            hash2 = new this.sha256();
            hash2.update(canonicalRequest);
            return [4, hash2.digest()];
          case 1:
            hashedRequest = _a2.sent();
            return [2, ALGORITHM_IDENTIFIER + "\n" + longDate + "\n" + credentialScope + "\n" + toHex$1(hashedRequest)];
        }
      });
    });
  };
  SignatureV42.prototype.getCanonicalPath = function(_a2) {
    var path = _a2.path;
    if (this.uriEscapePath) {
      var doubleEncoded = encodeURIComponent(path.replace(/^\//, ""));
      return "/" + doubleEncoded.replace(/%2F/g, "/");
    }
    return path;
  };
  SignatureV42.prototype.getSignature = function(longDate, credentialScope, keyPromise, canonicalRequest) {
    return __awaiter$4(this, void 0, void 0, function() {
      var stringToSign, hash2, _a2, _b, _c;
      return __generator$4(this, function(_d) {
        switch (_d.label) {
          case 0:
            return [4, this.createStringToSign(longDate, credentialScope, canonicalRequest)];
          case 1:
            stringToSign = _d.sent();
            _b = (_a2 = this.sha256).bind;
            return [4, keyPromise];
          case 2:
            hash2 = new (_b.apply(_a2, [void 0, _d.sent()]))();
            hash2.update(stringToSign);
            _c = toHex$1;
            return [4, hash2.digest()];
          case 3:
            return [2, _c.apply(void 0, [_d.sent()])];
        }
      });
    });
  };
  SignatureV42.prototype.getSigningKey = function(credentials, region, shortDate, service) {
    return getSigningKey(this.sha256, credentials, shortDate, region, service || this.service);
  };
  return SignatureV42;
}();
var formatDate = function(now) {
  var longDate = iso8601(now).replace(/[\-:]/g, "");
  return {
    longDate,
    shortDate: longDate.substr(0, 8)
  };
};
var getCanonicalHeaderList = function(headers) {
  return Object.keys(headers).sort().join(";");
};
var normalizeRegionProvider = function(region) {
  if (typeof region === "string") {
    var promisified_1 = Promise.resolve(region);
    return function() {
      return promisified_1;
    };
  } else {
    return region;
  }
};
var normalizeCredentialsProvider = function(credentials) {
  if (typeof credentials === "object") {
    var promisified_2 = Promise.resolve(credentials);
    return function() {
      return promisified_2;
    };
  } else {
    return credentials;
  }
};
function resolveAwsAuthConfig(input) {
  var _this = this;
  var credentials = input.credentials || input.credentialDefaultProvider(input);
  var normalizedCreds = normalizeProvider(credentials);
  var _a2 = input.signingEscapePath, signingEscapePath = _a2 === void 0 ? true : _a2, _b = input.systemClockOffset, systemClockOffset = _b === void 0 ? input.systemClockOffset || 0 : _b, sha256 = input.sha256;
  var signer;
  if (input.signer) {
    signer = normalizeProvider(input.signer);
  } else {
    signer = function() {
      return normalizeProvider(input.region)().then(function(region) {
        return __awaiter$5(_this, void 0, void 0, function() {
          return __generator$5(this, function(_a3) {
            switch (_a3.label) {
              case 0:
                return [4, input.regionInfoProvider(region)];
              case 1:
                return [2, [_a3.sent() || {}, region]];
            }
          });
        });
      }).then(function(_a3) {
        var _b2 = __read$6(_a3, 2), regionInfo = _b2[0], region = _b2[1];
        var signingRegion = regionInfo.signingRegion, signingService = regionInfo.signingService;
        input.signingRegion = input.signingRegion || signingRegion || region;
        input.signingName = input.signingName || signingService || input.serviceId;
        return new SignatureV4({
          credentials: normalizedCreds,
          region: input.signingRegion,
          service: input.signingName,
          sha256,
          uriEscapePath: signingEscapePath
        });
      });
    };
  }
  return __assign$6(__assign$6({}, input), {
    systemClockOffset,
    signingEscapePath,
    credentials: normalizedCreds,
    signer
  });
}
function normalizeProvider(input) {
  if (typeof input === "object") {
    var promisified_1 = Promise.resolve(input);
    return function() {
      return promisified_1;
    };
  }
  return input;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var __assign$4 = function() {
  __assign$4 = Object.assign || function __assign2(t3) {
    for (var s3, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s3 = arguments[i2];
      for (var p2 in s3)
        if (Object.prototype.hasOwnProperty.call(s3, p2))
          t3[p2] = s3[p2];
    }
    return t3;
  };
  return __assign$4.apply(this, arguments);
};
function __awaiter$3(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator$3(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t3[0] & 1)
      throw t3[1];
    return t3[1];
  }, trys: [], ops: [] }, f, y3, t3, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n2) {
    return function(v) {
      return step([n2, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_2)
      try {
        if (f = 1, y3 && (t3 = op[0] & 2 ? y3["return"] : op[0] ? y3["throw"] || ((t3 = y3["return"]) && t3.call(y3), 0) : y3.next) && !(t3 = t3.call(y3, op[1])).done)
          return t3;
        if (y3 = 0, t3)
          op = [op[0] & 2, t3.value];
        switch (op[0]) {
          case 0:
          case 1:
            t3 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y3 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t3 = _2.trys, t3 = t3.length > 0 && t3[t3.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t3 || op[1] > t3[0] && op[1] < t3[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t3[1]) {
              _2.label = t3[1];
              t3 = op;
              break;
            }
            if (t3 && _2.label < t3[2]) {
              _2.label = t3[2];
              _2.ops.push(op);
              break;
            }
            if (t3[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e3) {
        op = [6, e3];
        y3 = 0;
      } finally {
        f = t3 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __read$4(o2, n2) {
  var m3 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m3)
    return o2;
  var i2 = m3.call(o2), r2, ar2 = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
      ar2.push(r2.value);
  } catch (error) {
    e3 = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m3 = i2["return"]))
        m3.call(i2);
    } finally {
      if (e3)
        throw e3.error;
    }
  }
  return ar2;
}
function __spread$2() {
  for (var ar2 = [], i2 = 0; i2 < arguments.length; i2++)
    ar2 = ar2.concat(__read$4(arguments[i2]));
  return ar2;
}
function resolveUserAgentConfig(input) {
  return __assign$4(__assign$4({}, input), { customUserAgent: typeof input.customUserAgent === "string" ? [[input.customUserAgent]] : input.customUserAgent });
}
var USER_AGENT = "user-agent";
var X_AMZ_USER_AGENT = "x-amz-user-agent";
var SPACE = " ";
var UA_ESCAPE_REGEX = /[^\!\#\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w]/g;
var userAgentMiddleware = function(options) {
  return function(next, context) {
    return function(args) {
      return __awaiter$3(void 0, void 0, void 0, function() {
        var request, headers, userAgent2, defaultUserAgent2, customUserAgent, normalUAValue;
        var _a2, _b;
        return __generator$3(this, function(_c) {
          switch (_c.label) {
            case 0:
              request = args.request;
              if (!HttpRequest.isInstance(request))
                return [2, next(args)];
              headers = request.headers;
              userAgent2 = ((_a2 = context === null || context === void 0 ? void 0 : context.userAgent) === null || _a2 === void 0 ? void 0 : _a2.map(escapeUserAgent)) || [];
              return [4, options.defaultUserAgentProvider()];
            case 1:
              defaultUserAgent2 = _c.sent().map(escapeUserAgent);
              customUserAgent = ((_b = options === null || options === void 0 ? void 0 : options.customUserAgent) === null || _b === void 0 ? void 0 : _b.map(escapeUserAgent)) || [];
              headers[X_AMZ_USER_AGENT] = __spread$2(defaultUserAgent2, userAgent2, customUserAgent).join(SPACE);
              normalUAValue = __spread$2(defaultUserAgent2.filter(function(section) {
                return section.startsWith("aws-sdk-");
              }), customUserAgent).join(SPACE);
              if (options.runtime !== "browser" && normalUAValue) {
                headers[USER_AGENT] = headers[USER_AGENT] ? headers[USER_AGENT] + " " + normalUAValue : normalUAValue;
              }
              return [2, next(__assign$4(__assign$4({}, args), { request }))];
          }
        });
      });
    };
  };
};
var escapeUserAgent = function(_a2) {
  var _b = __read$4(_a2, 2), name2 = _b[0], version2 = _b[1];
  var prefixSeparatorIndex = name2.indexOf("/");
  var prefix = name2.substring(0, prefixSeparatorIndex);
  var uaName = name2.substring(prefixSeparatorIndex + 1);
  if (prefix === "api") {
    uaName = uaName.toLowerCase();
  }
  return [prefix, uaName, version2].filter(function(item) {
    return item && item.length > 0;
  }).map(function(item) {
    return item === null || item === void 0 ? void 0 : item.replace(UA_ESCAPE_REGEX, "_");
  }).join("/");
};
var getUserAgentMiddlewareOptions = {
  name: "getUserAgentMiddleware",
  step: "build",
  priority: "low",
  tags: ["SET_USER_AGENT", "USER_AGENT"],
  override: true
};
var getUserAgentPlugin = function(config) {
  return {
    applyToStack: function(clientStack) {
      clientStack.add(userAgentMiddleware(config), getUserAgentMiddlewareOptions);
    }
  };
};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var __assign$3 = function() {
  __assign$3 = Object.assign || function __assign2(t3) {
    for (var s3, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s3 = arguments[i2];
      for (var p2 in s3)
        if (Object.prototype.hasOwnProperty.call(s3, p2))
          t3[p2] = s3[p2];
    }
    return t3;
  };
  return __assign$3.apply(this, arguments);
};
function __values(o2) {
  var s3 = typeof Symbol === "function" && Symbol.iterator, m3 = s3 && o2[s3], i2 = 0;
  if (m3)
    return m3.call(o2);
  if (o2 && typeof o2.length === "number")
    return {
      next: function() {
        if (o2 && i2 >= o2.length)
          o2 = void 0;
        return { value: o2 && o2[i2++], done: !o2 };
      }
    };
  throw new TypeError(s3 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read$3(o2, n2) {
  var m3 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m3)
    return o2;
  var i2 = m3.call(o2), r2, ar2 = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
      ar2.push(r2.value);
  } catch (error) {
    e3 = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m3 = i2["return"]))
        m3.call(i2);
    } finally {
      if (e3)
        throw e3.error;
    }
  }
  return ar2;
}
function __spread$1() {
  for (var ar2 = [], i2 = 0; i2 < arguments.length; i2++)
    ar2 = ar2.concat(__read$3(arguments[i2]));
  return ar2;
}
var constructStack = function() {
  var absoluteEntries = [];
  var relativeEntries = [];
  var entriesNameSet = /* @__PURE__ */ new Set();
  var sort = function(entries) {
    return entries.sort(function(a3, b3) {
      return stepWeights[b3.step] - stepWeights[a3.step] || priorityWeights[b3.priority || "normal"] - priorityWeights[a3.priority || "normal"];
    });
  };
  var removeByName = function(toRemove) {
    var isRemoved = false;
    var filterCb = function(entry) {
      if (entry.name && entry.name === toRemove) {
        isRemoved = true;
        entriesNameSet.delete(toRemove);
        return false;
      }
      return true;
    };
    absoluteEntries = absoluteEntries.filter(filterCb);
    relativeEntries = relativeEntries.filter(filterCb);
    return isRemoved;
  };
  var removeByReference = function(toRemove) {
    var isRemoved = false;
    var filterCb = function(entry) {
      if (entry.middleware === toRemove) {
        isRemoved = true;
        if (entry.name)
          entriesNameSet.delete(entry.name);
        return false;
      }
      return true;
    };
    absoluteEntries = absoluteEntries.filter(filterCb);
    relativeEntries = relativeEntries.filter(filterCb);
    return isRemoved;
  };
  var cloneTo = function(toStack) {
    absoluteEntries.forEach(function(entry) {
      toStack.add(entry.middleware, __assign$3({}, entry));
    });
    relativeEntries.forEach(function(entry) {
      toStack.addRelativeTo(entry.middleware, __assign$3({}, entry));
    });
    return toStack;
  };
  var expandRelativeMiddlewareList = function(from) {
    var expandedMiddlewareList = [];
    from.before.forEach(function(entry) {
      if (entry.before.length === 0 && entry.after.length === 0) {
        expandedMiddlewareList.push(entry);
      } else {
        expandedMiddlewareList.push.apply(expandedMiddlewareList, __spread$1(expandRelativeMiddlewareList(entry)));
      }
    });
    expandedMiddlewareList.push(from);
    from.after.reverse().forEach(function(entry) {
      if (entry.before.length === 0 && entry.after.length === 0) {
        expandedMiddlewareList.push(entry);
      } else {
        expandedMiddlewareList.push.apply(expandedMiddlewareList, __spread$1(expandRelativeMiddlewareList(entry)));
      }
    });
    return expandedMiddlewareList;
  };
  var getMiddlewareList = function() {
    var normalizedAbsoluteEntries = [];
    var normalizedRelativeEntries = [];
    var normalizedEntriesNameMap = {};
    absoluteEntries.forEach(function(entry) {
      var normalizedEntry = __assign$3(__assign$3({}, entry), { before: [], after: [] });
      if (normalizedEntry.name)
        normalizedEntriesNameMap[normalizedEntry.name] = normalizedEntry;
      normalizedAbsoluteEntries.push(normalizedEntry);
    });
    relativeEntries.forEach(function(entry) {
      var normalizedEntry = __assign$3(__assign$3({}, entry), { before: [], after: [] });
      if (normalizedEntry.name)
        normalizedEntriesNameMap[normalizedEntry.name] = normalizedEntry;
      normalizedRelativeEntries.push(normalizedEntry);
    });
    normalizedRelativeEntries.forEach(function(entry) {
      if (entry.toMiddleware) {
        var toMiddleware = normalizedEntriesNameMap[entry.toMiddleware];
        if (toMiddleware === void 0) {
          throw new Error(entry.toMiddleware + " is not found when adding " + (entry.name || "anonymous") + " middleware " + entry.relation + " " + entry.toMiddleware);
        }
        if (entry.relation === "after") {
          toMiddleware.after.push(entry);
        }
        if (entry.relation === "before") {
          toMiddleware.before.push(entry);
        }
      }
    });
    var mainChain = sort(normalizedAbsoluteEntries).map(expandRelativeMiddlewareList).reduce(function(wholeList, expendedMiddlewareList) {
      wholeList.push.apply(wholeList, __spread$1(expendedMiddlewareList));
      return wholeList;
    }, []);
    return mainChain.map(function(entry) {
      return entry.middleware;
    });
  };
  var stack = {
    add: function(middleware, options) {
      if (options === void 0) {
        options = {};
      }
      var name2 = options.name, override = options.override;
      var entry = __assign$3({ step: "initialize", priority: "normal", middleware }, options);
      if (name2) {
        if (entriesNameSet.has(name2)) {
          if (!override)
            throw new Error("Duplicate middleware name '" + name2 + "'");
          var toOverrideIndex = absoluteEntries.findIndex(function(entry2) {
            return entry2.name === name2;
          });
          var toOverride = absoluteEntries[toOverrideIndex];
          if (toOverride.step !== entry.step || toOverride.priority !== entry.priority) {
            throw new Error('"' + name2 + '" middleware with ' + toOverride.priority + " priority in " + toOverride.step + " step cannot be " + ("overridden by same-name middleware with " + entry.priority + " priority in " + entry.step + " step."));
          }
          absoluteEntries.splice(toOverrideIndex, 1);
        }
        entriesNameSet.add(name2);
      }
      absoluteEntries.push(entry);
    },
    addRelativeTo: function(middleware, options) {
      var name2 = options.name, override = options.override;
      var entry = __assign$3({ middleware }, options);
      if (name2) {
        if (entriesNameSet.has(name2)) {
          if (!override)
            throw new Error("Duplicate middleware name '" + name2 + "'");
          var toOverrideIndex = relativeEntries.findIndex(function(entry2) {
            return entry2.name === name2;
          });
          var toOverride = relativeEntries[toOverrideIndex];
          if (toOverride.toMiddleware !== entry.toMiddleware || toOverride.relation !== entry.relation) {
            throw new Error('"' + name2 + '" middleware ' + toOverride.relation + ' "' + toOverride.toMiddleware + '" middleware cannot be overridden ' + ("by same-name middleware " + entry.relation + ' "' + entry.toMiddleware + '" middleware.'));
          }
          relativeEntries.splice(toOverrideIndex, 1);
        }
        entriesNameSet.add(name2);
      }
      relativeEntries.push(entry);
    },
    clone: function() {
      return cloneTo(constructStack());
    },
    use: function(plugin2) {
      plugin2.applyToStack(stack);
    },
    remove: function(toRemove) {
      if (typeof toRemove === "string")
        return removeByName(toRemove);
      else
        return removeByReference(toRemove);
    },
    removeByTag: function(toRemove) {
      var isRemoved = false;
      var filterCb = function(entry) {
        var tags = entry.tags, name2 = entry.name;
        if (tags && tags.includes(toRemove)) {
          if (name2)
            entriesNameSet.delete(name2);
          isRemoved = true;
          return false;
        }
        return true;
      };
      absoluteEntries = absoluteEntries.filter(filterCb);
      relativeEntries = relativeEntries.filter(filterCb);
      return isRemoved;
    },
    concat: function(from) {
      var cloned = cloneTo(constructStack());
      cloned.use(from);
      return cloned;
    },
    applyToStack: cloneTo,
    resolve: function(handler, context) {
      var e_1, _a2;
      try {
        for (var _b = __values(getMiddlewareList().reverse()), _c = _b.next(); !_c.done; _c = _b.next()) {
          var middleware = _c.value;
          handler = middleware(handler, context);
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a2 = _b.return))
            _a2.call(_b);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      return handler;
    }
  };
  return stack;
};
var stepWeights = {
  initialize: 5,
  serialize: 4,
  build: 3,
  finalizeRequest: 2,
  deserialize: 1
};
var priorityWeights = {
  high: 3,
  normal: 2,
  low: 1
};
var Client$1 = function() {
  function Client2(config) {
    this.middlewareStack = constructStack();
    this.config = config;
  }
  Client2.prototype.send = function(command, optionsOrCb, cb) {
    var options = typeof optionsOrCb !== "function" ? optionsOrCb : void 0;
    var callback = typeof optionsOrCb === "function" ? optionsOrCb : cb;
    var handler = command.resolveMiddleware(this.middlewareStack, this.config, options);
    if (callback) {
      handler(command).then(function(result) {
        return callback(null, result.output);
      }, function(err) {
        return callback(err);
      }).catch(
        function() {
        }
      );
    } else {
      return handler(command).then(function(result) {
        return result.output;
      });
    }
  };
  Client2.prototype.destroy = function() {
    if (this.config.requestHandler.destroy)
      this.config.requestHandler.destroy();
  };
  return Client2;
}();
var Command = function() {
  function Command2() {
    this.middlewareStack = constructStack();
  }
  return Command2;
}();
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$2 = function(d3, b3) {
  extendStatics$2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b4) {
    d4.__proto__ = b4;
  } || function(d4, b4) {
    for (var p2 in b4)
      if (b4.hasOwnProperty(p2))
        d4[p2] = b4[p2];
  };
  return extendStatics$2(d3, b3);
};
function __extends$2(d3, b3) {
  extendStatics$2(d3, b3);
  function __() {
    this.constructor = d3;
  }
  d3.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __());
}
function __read$2(o2, n2) {
  var m3 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m3)
    return o2;
  var i2 = m3.call(o2), r2, ar2 = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
      ar2.push(r2.value);
  } catch (error) {
    e3 = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m3 = i2["return"]))
        m3.call(i2);
    } finally {
      if (e3)
        throw e3.error;
    }
  }
  return ar2;
}
function __spread() {
  for (var ar2 = [], i2 = 0; i2 < arguments.length; i2++)
    ar2 = ar2.concat(__read$2(arguments[i2]));
  return ar2;
}
var StringWrapper = function() {
  var Class = Object.getPrototypeOf(this).constructor;
  var Constructor = Function.bind.apply(String, __spread([null], arguments));
  var instance = new Constructor();
  Object.setPrototypeOf(instance, Class.prototype);
  return instance;
};
StringWrapper.prototype = Object.create(String.prototype, {
  constructor: {
    value: StringWrapper,
    enumerable: false,
    writable: true,
    configurable: true
  }
});
Object.setPrototypeOf(StringWrapper, String);
(function(_super) {
  __extends$2(LazyJsonString, _super);
  function LazyJsonString() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  LazyJsonString.prototype.deserializeJSON = function() {
    return JSON.parse(_super.prototype.toString.call(this));
  };
  LazyJsonString.prototype.toJSON = function() {
    return _super.prototype.toString.call(this);
  };
  LazyJsonString.fromObject = function(object) {
    if (object instanceof LazyJsonString) {
      return object;
    } else if (object instanceof String || typeof object === "string") {
      return new LazyJsonString(object);
    }
    return new LazyJsonString(JSON.stringify(object));
  };
  return LazyJsonString;
})(StringWrapper);
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var __assign$2 = function() {
  __assign$2 = Object.assign || function __assign2(t3) {
    for (var s3, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s3 = arguments[i2];
      for (var p2 in s3)
        if (Object.prototype.hasOwnProperty.call(s3, p2))
          t3[p2] = s3[p2];
    }
    return t3;
  };
  return __assign$2.apply(this, arguments);
};
function __awaiter$2(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator$2(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t3[0] & 1)
      throw t3[1];
    return t3[1];
  }, trys: [], ops: [] }, f, y3, t3, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n2) {
    return function(v) {
      return step([n2, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_2)
      try {
        if (f = 1, y3 && (t3 = op[0] & 2 ? y3["return"] : op[0] ? y3["throw"] || ((t3 = y3["return"]) && t3.call(y3), 0) : y3.next) && !(t3 = t3.call(y3, op[1])).done)
          return t3;
        if (y3 = 0, t3)
          op = [op[0] & 2, t3.value];
        switch (op[0]) {
          case 0:
          case 1:
            t3 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y3 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t3 = _2.trys, t3 = t3.length > 0 && t3[t3.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t3 || op[1] > t3[0] && op[1] < t3[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t3[1]) {
              _2.label = t3[1];
              t3 = op;
              break;
            }
            if (t3 && _2.label < t3[2]) {
              _2.label = t3[2];
              _2.ops.push(op);
              break;
            }
            if (t3[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e3) {
        op = [6, e3];
        y3 = 0;
      } finally {
        f = t3 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
var deserializerMiddleware = function(options, deserializer) {
  return function(next, context) {
    return function(args) {
      return __awaiter$2(void 0, void 0, void 0, function() {
        var response, parsed;
        return __generator$2(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, next(args)];
            case 1:
              response = _a2.sent().response;
              return [4, deserializer(response, options)];
            case 2:
              parsed = _a2.sent();
              return [2, {
                response,
                output: parsed
              }];
          }
        });
      });
    };
  };
};
var serializerMiddleware = function(options, serializer) {
  return function(next, context) {
    return function(args) {
      return __awaiter$2(void 0, void 0, void 0, function() {
        var request;
        return __generator$2(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              return [4, serializer(args.input, options)];
            case 1:
              request = _a2.sent();
              return [2, next(__assign$2(__assign$2({}, args), { request }))];
          }
        });
      });
    };
  };
};
var deserializerMiddlewareOption = {
  name: "deserializerMiddleware",
  step: "deserialize",
  tags: ["DESERIALIZER"],
  override: true
};
var serializerMiddlewareOption = {
  name: "serializerMiddleware",
  step: "serialize",
  tags: ["SERIALIZER"],
  override: true
};
function getSerdePlugin(config, serializer, deserializer) {
  return {
    applyToStack: function(commandStack) {
      commandStack.add(deserializerMiddleware(config, deserializer), deserializerMiddlewareOption);
      commandStack.add(serializerMiddleware(config, serializer), serializerMiddlewareOption);
    }
  };
}
var logger$6 = new ConsoleLogger("CognitoCredentials");
var waitForInit$1 = new Promise(function(res, rej) {
  if (!browserOrNode().isBrowser) {
    logger$6.debug("not in the browser, directly resolved");
    return res();
  }
  var ga2 = window["gapi"] && window["gapi"].auth2 ? window["gapi"].auth2 : null;
  if (ga2) {
    logger$6.debug("google api already loaded");
    return res();
  } else {
    setTimeout(function() {
      return res();
    }, 2e3);
  }
});
var GoogleOAuth$1 = function() {
  function GoogleOAuth2() {
    this.initialized = false;
    this.refreshGoogleToken = this.refreshGoogleToken.bind(this);
    this._refreshGoogleTokenImpl = this._refreshGoogleTokenImpl.bind(this);
  }
  GoogleOAuth2.prototype.refreshGoogleToken = function() {
    return __awaiter$e(this, void 0, void 0, function() {
      return __generator$e(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            if (!!this.initialized)
              return [3, 2];
            logger$6.debug("need to wait for the Google SDK loaded");
            return [4, waitForInit$1];
          case 1:
            _a2.sent();
            this.initialized = true;
            logger$6.debug("finish waiting");
            _a2.label = 2;
          case 2:
            return [2, this._refreshGoogleTokenImpl()];
        }
      });
    });
  };
  GoogleOAuth2.prototype._refreshGoogleTokenImpl = function() {
    var ga2 = null;
    if (browserOrNode().isBrowser)
      ga2 = window["gapi"] && window["gapi"].auth2 ? window["gapi"].auth2 : null;
    if (!ga2) {
      logger$6.debug("no gapi auth2 available");
      return Promise.reject("no gapi auth2 available");
    }
    return new Promise(function(res, rej) {
      ga2.getAuthInstance().then(function(googleAuth) {
        if (!googleAuth) {
          logger$6.debug("google Auth undefined");
          rej(new NonRetryableError("google Auth undefined"));
        }
        var googleUser = googleAuth.currentUser.get();
        if (googleUser.isSignedIn()) {
          logger$6.debug("refreshing the google access token");
          googleUser.reloadAuthResponse().then(function(authResponse) {
            var id_token = authResponse.id_token, expires_at = authResponse.expires_at;
            res({ token: id_token, expires_at });
          }).catch(function(err) {
            if (err && err.error === "network_error") {
              rej("Network error reloading google auth response");
            } else {
              rej(new NonRetryableError("Failed to reload google auth response"));
            }
          });
        } else {
          rej(new NonRetryableError("User is not signed in with Google"));
        }
      }).catch(function(err) {
        logger$6.debug("Failed to refresh google token", err);
        rej(new NonRetryableError("Failed to refresh google token"));
      });
    });
  };
  return GoogleOAuth2;
}();
var logger$5 = new ConsoleLogger("CognitoCredentials");
var waitForInit = new Promise(function(res, rej) {
  if (!browserOrNode().isBrowser) {
    logger$5.debug("not in the browser, directly resolved");
    return res();
  }
  var fb = window["FB"];
  if (fb) {
    logger$5.debug("FB SDK already loaded");
    return res();
  } else {
    setTimeout(function() {
      return res();
    }, 2e3);
  }
});
var FacebookOAuth$1 = function() {
  function FacebookOAuth2() {
    this.initialized = false;
    this.refreshFacebookToken = this.refreshFacebookToken.bind(this);
    this._refreshFacebookTokenImpl = this._refreshFacebookTokenImpl.bind(this);
  }
  FacebookOAuth2.prototype.refreshFacebookToken = function() {
    return __awaiter$e(this, void 0, void 0, function() {
      return __generator$e(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            if (!!this.initialized)
              return [3, 2];
            logger$5.debug("need to wait for the Facebook SDK loaded");
            return [4, waitForInit];
          case 1:
            _a2.sent();
            this.initialized = true;
            logger$5.debug("finish waiting");
            _a2.label = 2;
          case 2:
            return [2, this._refreshFacebookTokenImpl()];
        }
      });
    });
  };
  FacebookOAuth2.prototype._refreshFacebookTokenImpl = function() {
    var fb = null;
    if (browserOrNode().isBrowser)
      fb = window["FB"];
    if (!fb) {
      var errorMessage = "no fb sdk available";
      logger$5.debug(errorMessage);
      return Promise.reject(new NonRetryableError(errorMessage));
    }
    return new Promise(function(res, rej) {
      fb.getLoginStatus(function(fbResponse) {
        if (!fbResponse || !fbResponse.authResponse) {
          var errorMessage2 = "no response from facebook when refreshing the jwt token";
          logger$5.debug(errorMessage2);
          rej(new NonRetryableError(errorMessage2));
        } else {
          var response = fbResponse.authResponse;
          var accessToken = response.accessToken, expiresIn = response.expiresIn;
          var date = new Date();
          var expires_at = expiresIn * 1e3 + date.getTime();
          if (!accessToken) {
            var errorMessage2 = "the jwtToken is undefined";
            logger$5.debug(errorMessage2);
            rej(new NonRetryableError(errorMessage2));
          }
          res({
            token: accessToken,
            expires_at
          });
        }
      }, { scope: "public_profile,email" });
    });
  };
  return FacebookOAuth2;
}();
var GoogleOAuth = new GoogleOAuth$1();
var FacebookOAuth = new FacebookOAuth$1();
var dataMemory$1 = {};
var MemoryStorage$1 = function() {
  function MemoryStorage2() {
  }
  MemoryStorage2.setItem = function(key, value) {
    dataMemory$1[key] = value;
    return dataMemory$1[key];
  };
  MemoryStorage2.getItem = function(key) {
    return Object.prototype.hasOwnProperty.call(dataMemory$1, key) ? dataMemory$1[key] : void 0;
  };
  MemoryStorage2.removeItem = function(key) {
    return delete dataMemory$1[key];
  };
  MemoryStorage2.clear = function() {
    dataMemory$1 = {};
    return dataMemory$1;
  };
  return MemoryStorage2;
}();
var StorageHelper$1 = function() {
  function StorageHelper2() {
    try {
      this.storageWindow = window.localStorage;
      this.storageWindow.setItem("aws.amplify.test-ls", 1);
      this.storageWindow.removeItem("aws.amplify.test-ls");
    } catch (exception) {
      this.storageWindow = MemoryStorage$1;
    }
  }
  StorageHelper2.prototype.getStorage = function() {
    return this.storageWindow;
  };
  return StorageHelper2;
}();
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function __awaiter$1(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator$1(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t3[0] & 1)
      throw t3[1];
    return t3[1];
  }, trys: [], ops: [] }, f, y3, t3, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n2) {
    return function(v) {
      return step([n2, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_2)
      try {
        if (f = 1, y3 && (t3 = op[0] & 2 ? y3["return"] : op[0] ? y3["throw"] || ((t3 = y3["return"]) && t3.call(y3), 0) : y3.next) && !(t3 = t3.call(y3, op[1])).done)
          return t3;
        if (y3 = 0, t3)
          op = [op[0] & 2, t3.value];
        switch (op[0]) {
          case 0:
          case 1:
            t3 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y3 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t3 = _2.trys, t3 = t3.length > 0 && t3[t3.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t3 || op[1] > t3[0] && op[1] < t3[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t3[1]) {
              _2.label = t3[1];
              t3 = op;
              break;
            }
            if (t3 && _2.label < t3[2]) {
              _2.label = t3[2];
              _2.ops.push(op);
              break;
            }
            if (t3[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e3) {
        op = [6, e3];
        y3 = 0;
      } finally {
        f = t3 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __read$1(o2, n2) {
  var m3 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m3)
    return o2;
  var i2 = m3.call(o2), r2, ar2 = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
      ar2.push(r2.value);
  } catch (error) {
    e3 = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m3 = i2["return"]))
        m3.call(i2);
    } finally {
      if (e3)
        throw e3.error;
    }
  }
  return ar2;
}
const name = "@aws-sdk/client-cognito-identity";
const description = "AWS SDK for JavaScript Cognito Identity Client for Node.js, Browser and React Native";
const version$2 = "3.6.1";
const scripts = {
  clean: "yarn remove-definitions && yarn remove-dist && yarn remove-documentation",
  "build-documentation": "yarn remove-documentation && typedoc ./",
  prepublishOnly: "yarn build",
  pretest: "yarn build:cjs",
  "remove-definitions": "rimraf ./types",
  "remove-dist": "rimraf ./dist",
  "remove-documentation": "rimraf ./docs",
  "test:unit": "mocha **/cjs/**/*.spec.js",
  "test:e2e": "mocha **/cjs/**/*.ispec.js && karma start karma.conf.js",
  test: "yarn test:unit",
  "build:cjs": "tsc -p tsconfig.json",
  "build:es": "tsc -p tsconfig.es.json",
  build: "yarn build:cjs && yarn build:es",
  postbuild: "downlevel-dts types types/ts3.4"
};
const main$2 = "./dist/cjs/index.js";
const types = "./types/index.d.ts";
const module = "./dist/es/index.js";
const browser = {
  "./runtimeConfig": "./runtimeConfig.browser"
};
const sideEffects = false;
const dependencies = {
  "@aws-crypto/sha256-browser": "^1.0.0",
  "@aws-crypto/sha256-js": "^1.0.0",
  "@aws-sdk/config-resolver": "3.6.1",
  "@aws-sdk/credential-provider-node": "3.6.1",
  "@aws-sdk/fetch-http-handler": "3.6.1",
  "@aws-sdk/hash-node": "3.6.1",
  "@aws-sdk/invalid-dependency": "3.6.1",
  "@aws-sdk/middleware-content-length": "3.6.1",
  "@aws-sdk/middleware-host-header": "3.6.1",
  "@aws-sdk/middleware-logger": "3.6.1",
  "@aws-sdk/middleware-retry": "3.6.1",
  "@aws-sdk/middleware-serde": "3.6.1",
  "@aws-sdk/middleware-signing": "3.6.1",
  "@aws-sdk/middleware-stack": "3.6.1",
  "@aws-sdk/middleware-user-agent": "3.6.1",
  "@aws-sdk/node-config-provider": "3.6.1",
  "@aws-sdk/node-http-handler": "3.6.1",
  "@aws-sdk/protocol-http": "3.6.1",
  "@aws-sdk/smithy-client": "3.6.1",
  "@aws-sdk/types": "3.6.1",
  "@aws-sdk/url-parser": "3.6.1",
  "@aws-sdk/url-parser-native": "3.6.1",
  "@aws-sdk/util-base64-browser": "3.6.1",
  "@aws-sdk/util-base64-node": "3.6.1",
  "@aws-sdk/util-body-length-browser": "3.6.1",
  "@aws-sdk/util-body-length-node": "3.6.1",
  "@aws-sdk/util-user-agent-browser": "3.6.1",
  "@aws-sdk/util-user-agent-node": "3.6.1",
  "@aws-sdk/util-utf8-browser": "3.6.1",
  "@aws-sdk/util-utf8-node": "3.6.1",
  tslib: "^2.0.0"
};
const devDependencies = {
  "@aws-sdk/client-documentation-generator": "3.6.1",
  "@aws-sdk/client-iam": "3.6.1",
  "@types/chai": "^4.2.11",
  "@types/mocha": "^8.0.4",
  "@types/node": "^12.7.5",
  "downlevel-dts": "0.7.0",
  jest: "^26.1.0",
  rimraf: "^3.0.0",
  typedoc: "^0.19.2",
  typescript: "~4.1.2"
};
const engines = {
  node: ">=10.0.0"
};
const typesVersions = {
  "<4.0": {
    "types/*": [
      "types/ts3.4/*"
    ]
  }
};
const author = {
  name: "AWS SDK for JavaScript Team",
  url: "https://aws.amazon.com/javascript/"
};
const license = "Apache-2.0";
const homepage = "https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-cognito-identity";
const repository = {
  type: "git",
  url: "https://github.com/aws/aws-sdk-js-v3.git",
  directory: "clients/client-cognito-identity"
};
const packageInfo = {
  name,
  description,
  version: version$2,
  scripts,
  main: main$2,
  types,
  module,
  browser,
  "react-native": {
    "./runtimeConfig": "./runtimeConfig.native"
  },
  sideEffects,
  dependencies,
  devDependencies,
  engines,
  typesVersions,
  author,
  license,
  homepage,
  repository
};
var AWS_TEMPLATE = "cognito-identity.{region}.amazonaws.com";
var AWS_CN_TEMPLATE = "cognito-identity.{region}.amazonaws.com.cn";
var AWS_ISO_TEMPLATE = "cognito-identity.{region}.c2s.ic.gov";
var AWS_ISO_B_TEMPLATE = "cognito-identity.{region}.sc2s.sgov.gov";
var AWS_US_GOV_TEMPLATE = "cognito-identity.{region}.amazonaws.com";
var AWS_REGIONS = /* @__PURE__ */ new Set([
  "af-south-1",
  "ap-east-1",
  "ap-northeast-1",
  "ap-northeast-2",
  "ap-south-1",
  "ap-southeast-1",
  "ap-southeast-2",
  "ca-central-1",
  "eu-central-1",
  "eu-north-1",
  "eu-south-1",
  "eu-west-1",
  "eu-west-2",
  "eu-west-3",
  "me-south-1",
  "sa-east-1",
  "us-east-1",
  "us-east-2",
  "us-west-1",
  "us-west-2"
]);
var AWS_CN_REGIONS = /* @__PURE__ */ new Set(["cn-north-1", "cn-northwest-1"]);
var AWS_ISO_REGIONS = /* @__PURE__ */ new Set(["us-iso-east-1"]);
var AWS_ISO_B_REGIONS = /* @__PURE__ */ new Set(["us-isob-east-1"]);
var AWS_US_GOV_REGIONS = /* @__PURE__ */ new Set(["us-gov-east-1", "us-gov-west-1"]);
var defaultRegionInfoProvider = function(region, options) {
  var regionInfo = void 0;
  switch (region) {
    case "ap-northeast-1":
      regionInfo = {
        hostname: "cognito-identity.ap-northeast-1.amazonaws.com",
        partition: "aws"
      };
      break;
    case "ap-northeast-2":
      regionInfo = {
        hostname: "cognito-identity.ap-northeast-2.amazonaws.com",
        partition: "aws"
      };
      break;
    case "ap-south-1":
      regionInfo = {
        hostname: "cognito-identity.ap-south-1.amazonaws.com",
        partition: "aws"
      };
      break;
    case "ap-southeast-1":
      regionInfo = {
        hostname: "cognito-identity.ap-southeast-1.amazonaws.com",
        partition: "aws"
      };
      break;
    case "ap-southeast-2":
      regionInfo = {
        hostname: "cognito-identity.ap-southeast-2.amazonaws.com",
        partition: "aws"
      };
      break;
    case "ca-central-1":
      regionInfo = {
        hostname: "cognito-identity.ca-central-1.amazonaws.com",
        partition: "aws"
      };
      break;
    case "cn-north-1":
      regionInfo = {
        hostname: "cognito-identity.cn-north-1.amazonaws.com.cn",
        partition: "aws-cn"
      };
      break;
    case "eu-central-1":
      regionInfo = {
        hostname: "cognito-identity.eu-central-1.amazonaws.com",
        partition: "aws"
      };
      break;
    case "eu-north-1":
      regionInfo = {
        hostname: "cognito-identity.eu-north-1.amazonaws.com",
        partition: "aws"
      };
      break;
    case "eu-west-1":
      regionInfo = {
        hostname: "cognito-identity.eu-west-1.amazonaws.com",
        partition: "aws"
      };
      break;
    case "eu-west-2":
      regionInfo = {
        hostname: "cognito-identity.eu-west-2.amazonaws.com",
        partition: "aws"
      };
      break;
    case "eu-west-3":
      regionInfo = {
        hostname: "cognito-identity.eu-west-3.amazonaws.com",
        partition: "aws"
      };
      break;
    case "fips-us-east-1":
      regionInfo = {
        hostname: "cognito-identity-fips.us-east-1.amazonaws.com",
        partition: "aws",
        signingRegion: "us-east-1"
      };
      break;
    case "fips-us-east-2":
      regionInfo = {
        hostname: "cognito-identity-fips.us-east-2.amazonaws.com",
        partition: "aws",
        signingRegion: "us-east-2"
      };
      break;
    case "fips-us-gov-west-1":
      regionInfo = {
        hostname: "cognito-identity-fips.us-gov-west-1.amazonaws.com",
        partition: "aws-us-gov",
        signingRegion: "us-gov-west-1"
      };
      break;
    case "fips-us-west-2":
      regionInfo = {
        hostname: "cognito-identity-fips.us-west-2.amazonaws.com",
        partition: "aws",
        signingRegion: "us-west-2"
      };
      break;
    case "sa-east-1":
      regionInfo = {
        hostname: "cognito-identity.sa-east-1.amazonaws.com",
        partition: "aws"
      };
      break;
    case "us-east-1":
      regionInfo = {
        hostname: "cognito-identity.us-east-1.amazonaws.com",
        partition: "aws"
      };
      break;
    case "us-east-2":
      regionInfo = {
        hostname: "cognito-identity.us-east-2.amazonaws.com",
        partition: "aws"
      };
      break;
    case "us-gov-west-1":
      regionInfo = {
        hostname: "cognito-identity.us-gov-west-1.amazonaws.com",
        partition: "aws-us-gov"
      };
      break;
    case "us-west-1":
      regionInfo = {
        hostname: "cognito-identity.us-west-1.amazonaws.com",
        partition: "aws"
      };
      break;
    case "us-west-2":
      regionInfo = {
        hostname: "cognito-identity.us-west-2.amazonaws.com",
        partition: "aws"
      };
      break;
    default:
      if (AWS_REGIONS.has(region)) {
        regionInfo = {
          hostname: AWS_TEMPLATE.replace("{region}", region),
          partition: "aws"
        };
      }
      if (AWS_CN_REGIONS.has(region)) {
        regionInfo = {
          hostname: AWS_CN_TEMPLATE.replace("{region}", region),
          partition: "aws-cn"
        };
      }
      if (AWS_ISO_REGIONS.has(region)) {
        regionInfo = {
          hostname: AWS_ISO_TEMPLATE.replace("{region}", region),
          partition: "aws-iso"
        };
      }
      if (AWS_ISO_B_REGIONS.has(region)) {
        regionInfo = {
          hostname: AWS_ISO_B_TEMPLATE.replace("{region}", region),
          partition: "aws-iso-b"
        };
      }
      if (AWS_US_GOV_REGIONS.has(region)) {
        regionInfo = {
          hostname: AWS_US_GOV_TEMPLATE.replace("{region}", region),
          partition: "aws-us-gov"
        };
      }
      if (regionInfo === void 0) {
        regionInfo = {
          hostname: AWS_TEMPLATE.replace("{region}", region),
          partition: "aws"
        };
      }
  }
  return Promise.resolve(__assign$b({ signingService: "cognito-identity" }, regionInfo));
};
var ClientSharedValues = {
  apiVersion: "2014-06-30",
  disableHostPrefix: false,
  logger: {},
  regionInfoProvider: defaultRegionInfoProvider,
  serviceId: "Cognito Identity",
  urlParser: parseUrl
};
var ClientDefaultValues = __assign$b(__assign$b({}, ClientSharedValues), { runtime: "browser", base64Decoder: fromBase64, base64Encoder: toBase64, bodyLengthChecker: calculateBodyLength, credentialDefaultProvider: function(_2) {
  return function() {
    return Promise.reject(new Error("Credential is missing"));
  };
}, defaultUserAgentProvider: defaultUserAgent({
  serviceId: ClientSharedValues.serviceId,
  clientVersion: packageInfo.version
}), maxAttempts: DEFAULT_MAX_ATTEMPTS, region: invalidProvider("Region is missing"), requestHandler: new FetchHttpHandler(), sha256: build$2.Sha256, streamCollector, utf8Decoder: fromUtf8$1, utf8Encoder: toUtf8 });
var CognitoIdentityClient = function(_super) {
  __extends$3(CognitoIdentityClient2, _super);
  function CognitoIdentityClient2(configuration) {
    var _this = this;
    var _config_0 = __assign$b(__assign$b({}, ClientDefaultValues), configuration);
    var _config_1 = resolveRegionConfig(_config_0);
    var _config_2 = resolveEndpointsConfig(_config_1);
    var _config_3 = resolveAwsAuthConfig(_config_2);
    var _config_4 = resolveRetryConfig(_config_3);
    var _config_5 = resolveHostHeaderConfig(_config_4);
    var _config_6 = resolveUserAgentConfig(_config_5);
    _this = _super.call(this, _config_6) || this;
    _this.config = _config_6;
    _this.middlewareStack.use(getRetryPlugin(_this.config));
    _this.middlewareStack.use(getContentLengthPlugin(_this.config));
    _this.middlewareStack.use(getHostHeaderPlugin(_this.config));
    _this.middlewareStack.use(getLoggerPlugin(_this.config));
    _this.middlewareStack.use(getUserAgentPlugin(_this.config));
    return _this;
  }
  CognitoIdentityClient2.prototype.destroy = function() {
    _super.prototype.destroy.call(this);
  };
  return CognitoIdentityClient2;
}(Client$1);
var AmbiguousRoleResolutionType;
(function(AmbiguousRoleResolutionType2) {
  AmbiguousRoleResolutionType2["AUTHENTICATED_ROLE"] = "AuthenticatedRole";
  AmbiguousRoleResolutionType2["DENY"] = "Deny";
})(AmbiguousRoleResolutionType || (AmbiguousRoleResolutionType = {}));
var CognitoIdentityProvider;
(function(CognitoIdentityProvider2) {
  CognitoIdentityProvider2.filterSensitiveLog = function(obj) {
    return __assign$b({}, obj);
  };
})(CognitoIdentityProvider || (CognitoIdentityProvider = {}));
var CreateIdentityPoolInput;
(function(CreateIdentityPoolInput2) {
  CreateIdentityPoolInput2.filterSensitiveLog = function(obj) {
    return __assign$b({}, obj);
  };
})(CreateIdentityPoolInput || (CreateIdentityPoolInput = {}));
var IdentityPool;
(function(IdentityPool2) {
  IdentityPool2.filterSensitiveLog = function(obj) {
    return __assign$b({}, obj);
  };
})(IdentityPool || (IdentityPool = {}));
var InternalErrorException;
(function(InternalErrorException2) {
  InternalErrorException2.filterSensitiveLog = function(obj) {
    return __assign$b({}, obj);
  };
})(InternalErrorException || (InternalErrorException = {}));
var InvalidParameterException;
(function(InvalidParameterException2) {
  InvalidParameterException2.filterSensitiveLog = function(obj) {
    return __assign$b({}, obj);
  };
})(InvalidParameterException || (InvalidParameterException = {}));
var LimitExceededException;
(function(LimitExceededException2) {
  LimitExceededException2.filterSensitiveLog = function(obj) {
    return __assign$b({}, obj);
  };
})(LimitExceededException || (LimitExceededException = {}));
var NotAuthorizedException;
(function(NotAuthorizedException2) {
  NotAuthorizedException2.filterSensitiveLog = function(obj) {
    return __assign$b({}, obj);
  };
})(NotAuthorizedException || (NotAuthorizedException = {}));
var ResourceConflictException;
(function(ResourceConflictException2) {
  ResourceConflictException2.filterSensitiveLog = function(obj) {
    return __assign$b({}, obj);
  };
})(ResourceConflictException || (ResourceConflictException = {}));
var TooManyRequestsException;
(function(TooManyRequestsException2) {
  TooManyRequestsException2.filterSensitiveLog = function(obj) {
    return __assign$b({}, obj);
  };
})(TooManyRequestsException || (TooManyRequestsException = {}));
var DeleteIdentitiesInput;
(function(DeleteIdentitiesInput2) {
  DeleteIdentitiesInput2.filterSensitiveLog = function(obj) {
    return __assign$b({}, obj);
  };
})(DeleteIdentitiesInput || (DeleteIdentitiesInput = {}));
var ErrorCode;
(function(ErrorCode2) {
  ErrorCode2["ACCESS_DENIED"] = "AccessDenied";
  ErrorCode2["INTERNAL_SERVER_ERROR"] = "InternalServerError";
})(ErrorCode || (ErrorCode = {}));
var UnprocessedIdentityId;
(function(UnprocessedIdentityId2) {
  UnprocessedIdentityId2.filterSensitiveLog = function(obj) {
    return __assign$b({}, obj);
  };
})(UnprocessedIdentityId || (UnprocessedIdentityId = {}));
var DeleteIdentitiesResponse;
(function(DeleteIdentitiesResponse2) {
  DeleteIdentitiesResponse2.filterSensitiveLog = function(obj) {
    return __assign$b({}, obj);
  };
})(DeleteIdentitiesResponse || (DeleteIdentitiesResponse = {}));
var DeleteIdentityPoolInput;
(function(DeleteIdentityPoolInput2) {
  DeleteIdentityPoolInput2.filterSensitiveLog = function(obj) {
    return __assign$b({}, obj);
  };
})(DeleteIdentityPoolInput || (DeleteIdentityPoolInput = {}));
var ResourceNotFoundException;
(function(ResourceNotFoundException2) {
  ResourceNotFoundException2.filterSensitiveLog = function(obj) {
    return __assign$b({}, obj);
  };
})(ResourceNotFoundException || (ResourceNotFoundException = {}));
var DescribeIdentityInput;
(function(DescribeIdentityInput2) {
  DescribeIdentityInput2.filterSensitiveLog = function(obj) {
    return __assign$b({}, obj);
  };
})(DescribeIdentityInput || (DescribeIdentityInput = {}));
var IdentityDescription;
(function(IdentityDescription2) {
  IdentityDescription2.filterSensitiveLog = function(obj) {
    return __assign$b({}, obj);
  };
})(IdentityDescription || (IdentityDescription = {}));
var DescribeIdentityPoolInput;
(function(DescribeIdentityPoolInput2) {
  DescribeIdentityPoolInput2.filterSensitiveLog = function(obj) {
    return __assign$b({}, obj);
  };
})(DescribeIdentityPoolInput || (DescribeIdentityPoolInput = {}));
var ExternalServiceException;
(function(ExternalServiceException2) {
  ExternalServiceException2.filterSensitiveLog = function(obj) {
    return __assign$b({}, obj);
  };
})(ExternalServiceException || (ExternalServiceException = {}));
var GetCredentialsForIdentityInput;
(function(GetCredentialsForIdentityInput2) {
  GetCredentialsForIdentityInput2.filterSensitiveLog = function(obj) {
    return __assign$b({}, obj);
  };
})(GetCredentialsForIdentityInput || (GetCredentialsForIdentityInput = {}));
var Credentials$1;
(function(Credentials2) {
  Credentials2.filterSensitiveLog = function(obj) {
    return __assign$b({}, obj);
  };
})(Credentials$1 || (Credentials$1 = {}));
var GetCredentialsForIdentityResponse;
(function(GetCredentialsForIdentityResponse2) {
  GetCredentialsForIdentityResponse2.filterSensitiveLog = function(obj) {
    return __assign$b({}, obj);
  };
})(GetCredentialsForIdentityResponse || (GetCredentialsForIdentityResponse = {}));
var InvalidIdentityPoolConfigurationException;
(function(InvalidIdentityPoolConfigurationException2) {
  InvalidIdentityPoolConfigurationException2.filterSensitiveLog = function(obj) {
    return __assign$b({}, obj);
  };
})(InvalidIdentityPoolConfigurationException || (InvalidIdentityPoolConfigurationException = {}));
var GetIdInput;
(function(GetIdInput2) {
  GetIdInput2.filterSensitiveLog = function(obj) {
    return __assign$b({}, obj);
  };
})(GetIdInput || (GetIdInput = {}));
var GetIdResponse;
(function(GetIdResponse2) {
  GetIdResponse2.filterSensitiveLog = function(obj) {
    return __assign$b({}, obj);
  };
})(GetIdResponse || (GetIdResponse = {}));
var GetIdentityPoolRolesInput;
(function(GetIdentityPoolRolesInput2) {
  GetIdentityPoolRolesInput2.filterSensitiveLog = function(obj) {
    return __assign$b({}, obj);
  };
})(GetIdentityPoolRolesInput || (GetIdentityPoolRolesInput = {}));
var MappingRuleMatchType;
(function(MappingRuleMatchType2) {
  MappingRuleMatchType2["CONTAINS"] = "Contains";
  MappingRuleMatchType2["EQUALS"] = "Equals";
  MappingRuleMatchType2["NOT_EQUAL"] = "NotEqual";
  MappingRuleMatchType2["STARTS_WITH"] = "StartsWith";
})(MappingRuleMatchType || (MappingRuleMatchType = {}));
var MappingRule;
(function(MappingRule2) {
  MappingRule2.filterSensitiveLog = function(obj) {
    return __assign$b({}, obj);
  };
})(MappingRule || (MappingRule = {}));
var RulesConfigurationType;
(function(RulesConfigurationType2) {
  RulesConfigurationType2.filterSensitiveLog = function(obj) {
    return __assign$b({}, obj);
  };
})(RulesConfigurationType || (RulesConfigurationType = {}));
var RoleMappingType;
(function(RoleMappingType2) {
  RoleMappingType2["RULES"] = "Rules";
  RoleMappingType2["TOKEN"] = "Token";
})(RoleMappingType || (RoleMappingType = {}));
var RoleMapping;
(function(RoleMapping2) {
  RoleMapping2.filterSensitiveLog = function(obj) {
    return __assign$b({}, obj);
  };
})(RoleMapping || (RoleMapping = {}));
var GetIdentityPoolRolesResponse;
(function(GetIdentityPoolRolesResponse2) {
  GetIdentityPoolRolesResponse2.filterSensitiveLog = function(obj) {
    return __assign$b({}, obj);
  };
})(GetIdentityPoolRolesResponse || (GetIdentityPoolRolesResponse = {}));
var GetOpenIdTokenInput;
(function(GetOpenIdTokenInput2) {
  GetOpenIdTokenInput2.filterSensitiveLog = function(obj) {
    return __assign$b({}, obj);
  };
})(GetOpenIdTokenInput || (GetOpenIdTokenInput = {}));
var GetOpenIdTokenResponse;
(function(GetOpenIdTokenResponse2) {
  GetOpenIdTokenResponse2.filterSensitiveLog = function(obj) {
    return __assign$b({}, obj);
  };
})(GetOpenIdTokenResponse || (GetOpenIdTokenResponse = {}));
var DeveloperUserAlreadyRegisteredException;
(function(DeveloperUserAlreadyRegisteredException2) {
  DeveloperUserAlreadyRegisteredException2.filterSensitiveLog = function(obj) {
    return __assign$b({}, obj);
  };
})(DeveloperUserAlreadyRegisteredException || (DeveloperUserAlreadyRegisteredException = {}));
var GetOpenIdTokenForDeveloperIdentityInput;
(function(GetOpenIdTokenForDeveloperIdentityInput2) {
  GetOpenIdTokenForDeveloperIdentityInput2.filterSensitiveLog = function(obj) {
    return __assign$b({}, obj);
  };
})(GetOpenIdTokenForDeveloperIdentityInput || (GetOpenIdTokenForDeveloperIdentityInput = {}));
var GetOpenIdTokenForDeveloperIdentityResponse;
(function(GetOpenIdTokenForDeveloperIdentityResponse2) {
  GetOpenIdTokenForDeveloperIdentityResponse2.filterSensitiveLog = function(obj) {
    return __assign$b({}, obj);
  };
})(GetOpenIdTokenForDeveloperIdentityResponse || (GetOpenIdTokenForDeveloperIdentityResponse = {}));
var ListIdentitiesInput;
(function(ListIdentitiesInput2) {
  ListIdentitiesInput2.filterSensitiveLog = function(obj) {
    return __assign$b({}, obj);
  };
})(ListIdentitiesInput || (ListIdentitiesInput = {}));
var ListIdentitiesResponse;
(function(ListIdentitiesResponse2) {
  ListIdentitiesResponse2.filterSensitiveLog = function(obj) {
    return __assign$b({}, obj);
  };
})(ListIdentitiesResponse || (ListIdentitiesResponse = {}));
var ListIdentityPoolsInput;
(function(ListIdentityPoolsInput2) {
  ListIdentityPoolsInput2.filterSensitiveLog = function(obj) {
    return __assign$b({}, obj);
  };
})(ListIdentityPoolsInput || (ListIdentityPoolsInput = {}));
var IdentityPoolShortDescription;
(function(IdentityPoolShortDescription2) {
  IdentityPoolShortDescription2.filterSensitiveLog = function(obj) {
    return __assign$b({}, obj);
  };
})(IdentityPoolShortDescription || (IdentityPoolShortDescription = {}));
var ListIdentityPoolsResponse;
(function(ListIdentityPoolsResponse2) {
  ListIdentityPoolsResponse2.filterSensitiveLog = function(obj) {
    return __assign$b({}, obj);
  };
})(ListIdentityPoolsResponse || (ListIdentityPoolsResponse = {}));
var ListTagsForResourceInput;
(function(ListTagsForResourceInput2) {
  ListTagsForResourceInput2.filterSensitiveLog = function(obj) {
    return __assign$b({}, obj);
  };
})(ListTagsForResourceInput || (ListTagsForResourceInput = {}));
var ListTagsForResourceResponse;
(function(ListTagsForResourceResponse2) {
  ListTagsForResourceResponse2.filterSensitiveLog = function(obj) {
    return __assign$b({}, obj);
  };
})(ListTagsForResourceResponse || (ListTagsForResourceResponse = {}));
var LookupDeveloperIdentityInput;
(function(LookupDeveloperIdentityInput2) {
  LookupDeveloperIdentityInput2.filterSensitiveLog = function(obj) {
    return __assign$b({}, obj);
  };
})(LookupDeveloperIdentityInput || (LookupDeveloperIdentityInput = {}));
var LookupDeveloperIdentityResponse;
(function(LookupDeveloperIdentityResponse2) {
  LookupDeveloperIdentityResponse2.filterSensitiveLog = function(obj) {
    return __assign$b({}, obj);
  };
})(LookupDeveloperIdentityResponse || (LookupDeveloperIdentityResponse = {}));
var MergeDeveloperIdentitiesInput;
(function(MergeDeveloperIdentitiesInput2) {
  MergeDeveloperIdentitiesInput2.filterSensitiveLog = function(obj) {
    return __assign$b({}, obj);
  };
})(MergeDeveloperIdentitiesInput || (MergeDeveloperIdentitiesInput = {}));
var MergeDeveloperIdentitiesResponse;
(function(MergeDeveloperIdentitiesResponse2) {
  MergeDeveloperIdentitiesResponse2.filterSensitiveLog = function(obj) {
    return __assign$b({}, obj);
  };
})(MergeDeveloperIdentitiesResponse || (MergeDeveloperIdentitiesResponse = {}));
var ConcurrentModificationException;
(function(ConcurrentModificationException2) {
  ConcurrentModificationException2.filterSensitiveLog = function(obj) {
    return __assign$b({}, obj);
  };
})(ConcurrentModificationException || (ConcurrentModificationException = {}));
var SetIdentityPoolRolesInput;
(function(SetIdentityPoolRolesInput2) {
  SetIdentityPoolRolesInput2.filterSensitiveLog = function(obj) {
    return __assign$b({}, obj);
  };
})(SetIdentityPoolRolesInput || (SetIdentityPoolRolesInput = {}));
var TagResourceInput;
(function(TagResourceInput2) {
  TagResourceInput2.filterSensitiveLog = function(obj) {
    return __assign$b({}, obj);
  };
})(TagResourceInput || (TagResourceInput = {}));
var TagResourceResponse;
(function(TagResourceResponse2) {
  TagResourceResponse2.filterSensitiveLog = function(obj) {
    return __assign$b({}, obj);
  };
})(TagResourceResponse || (TagResourceResponse = {}));
var UnlinkDeveloperIdentityInput;
(function(UnlinkDeveloperIdentityInput2) {
  UnlinkDeveloperIdentityInput2.filterSensitiveLog = function(obj) {
    return __assign$b({}, obj);
  };
})(UnlinkDeveloperIdentityInput || (UnlinkDeveloperIdentityInput = {}));
var UnlinkIdentityInput;
(function(UnlinkIdentityInput2) {
  UnlinkIdentityInput2.filterSensitiveLog = function(obj) {
    return __assign$b({}, obj);
  };
})(UnlinkIdentityInput || (UnlinkIdentityInput = {}));
var UntagResourceInput;
(function(UntagResourceInput2) {
  UntagResourceInput2.filterSensitiveLog = function(obj) {
    return __assign$b({}, obj);
  };
})(UntagResourceInput || (UntagResourceInput = {}));
var UntagResourceResponse;
(function(UntagResourceResponse2) {
  UntagResourceResponse2.filterSensitiveLog = function(obj) {
    return __assign$b({}, obj);
  };
})(UntagResourceResponse || (UntagResourceResponse = {}));
var serializeAws_json1_1GetCredentialsForIdentityCommand = function(input, context) {
  return __awaiter$d(void 0, void 0, void 0, function() {
    var headers, body;
    return __generator$d(this, function(_a2) {
      headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSCognitoIdentityService.GetCredentialsForIdentity"
      };
      body = JSON.stringify(serializeAws_json1_1GetCredentialsForIdentityInput(input));
      return [2, buildHttpRpcRequest(context, headers, "/", void 0, body)];
    });
  });
};
var serializeAws_json1_1GetIdCommand = function(input, context) {
  return __awaiter$d(void 0, void 0, void 0, function() {
    var headers, body;
    return __generator$d(this, function(_a2) {
      headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSCognitoIdentityService.GetId"
      };
      body = JSON.stringify(serializeAws_json1_1GetIdInput(input));
      return [2, buildHttpRpcRequest(context, headers, "/", void 0, body)];
    });
  });
};
var deserializeAws_json1_1GetCredentialsForIdentityCommand = function(output, context) {
  return __awaiter$d(void 0, void 0, void 0, function() {
    var data, contents, response;
    return __generator$d(this, function(_a2) {
      switch (_a2.label) {
        case 0:
          if (output.statusCode >= 300) {
            return [2, deserializeAws_json1_1GetCredentialsForIdentityCommandError(output, context)];
          }
          return [4, parseBody(output.body, context)];
        case 1:
          data = _a2.sent();
          contents = {};
          contents = deserializeAws_json1_1GetCredentialsForIdentityResponse(data);
          response = __assign$b({ $metadata: deserializeMetadata(output) }, contents);
          return [2, Promise.resolve(response)];
      }
    });
  });
};
var deserializeAws_json1_1GetCredentialsForIdentityCommandError = function(output, context) {
  return __awaiter$d(void 0, void 0, void 0, function() {
    var parsedOutput, _a2, response, errorCode, _b, _c, _d, _e2, _f, _g, _h, _j, _k, parsedBody, message;
    var _l2;
    return __generator$d(this, function(_m) {
      switch (_m.label) {
        case 0:
          _a2 = [__assign$b({}, output)];
          _l2 = {};
          return [4, parseBody(output.body, context)];
        case 1:
          parsedOutput = __assign$b.apply(void 0, _a2.concat([(_l2.body = _m.sent(), _l2)]));
          errorCode = "UnknownError";
          errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
          _b = errorCode;
          switch (_b) {
            case "ExternalServiceException":
              return [3, 2];
            case "com.amazonaws.cognitoidentity#ExternalServiceException":
              return [3, 2];
            case "InternalErrorException":
              return [3, 4];
            case "com.amazonaws.cognitoidentity#InternalErrorException":
              return [3, 4];
            case "InvalidIdentityPoolConfigurationException":
              return [3, 6];
            case "com.amazonaws.cognitoidentity#InvalidIdentityPoolConfigurationException":
              return [3, 6];
            case "InvalidParameterException":
              return [3, 8];
            case "com.amazonaws.cognitoidentity#InvalidParameterException":
              return [3, 8];
            case "NotAuthorizedException":
              return [3, 10];
            case "com.amazonaws.cognitoidentity#NotAuthorizedException":
              return [3, 10];
            case "ResourceConflictException":
              return [3, 12];
            case "com.amazonaws.cognitoidentity#ResourceConflictException":
              return [3, 12];
            case "ResourceNotFoundException":
              return [3, 14];
            case "com.amazonaws.cognitoidentity#ResourceNotFoundException":
              return [3, 14];
            case "TooManyRequestsException":
              return [3, 16];
            case "com.amazonaws.cognitoidentity#TooManyRequestsException":
              return [3, 16];
          }
          return [3, 18];
        case 2:
          _c = [{}];
          return [4, deserializeAws_json1_1ExternalServiceExceptionResponse(parsedOutput)];
        case 3:
          response = __assign$b.apply(void 0, [__assign$b.apply(void 0, _c.concat([_m.sent()])), { name: errorCode, $metadata: deserializeMetadata(output) }]);
          return [3, 19];
        case 4:
          _d = [{}];
          return [4, deserializeAws_json1_1InternalErrorExceptionResponse(parsedOutput)];
        case 5:
          response = __assign$b.apply(void 0, [__assign$b.apply(void 0, _d.concat([_m.sent()])), { name: errorCode, $metadata: deserializeMetadata(output) }]);
          return [3, 19];
        case 6:
          _e2 = [{}];
          return [4, deserializeAws_json1_1InvalidIdentityPoolConfigurationExceptionResponse(parsedOutput)];
        case 7:
          response = __assign$b.apply(void 0, [__assign$b.apply(void 0, _e2.concat([_m.sent()])), { name: errorCode, $metadata: deserializeMetadata(output) }]);
          return [3, 19];
        case 8:
          _f = [{}];
          return [4, deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput)];
        case 9:
          response = __assign$b.apply(void 0, [__assign$b.apply(void 0, _f.concat([_m.sent()])), { name: errorCode, $metadata: deserializeMetadata(output) }]);
          return [3, 19];
        case 10:
          _g = [{}];
          return [4, deserializeAws_json1_1NotAuthorizedExceptionResponse(parsedOutput)];
        case 11:
          response = __assign$b.apply(void 0, [__assign$b.apply(void 0, _g.concat([_m.sent()])), { name: errorCode, $metadata: deserializeMetadata(output) }]);
          return [3, 19];
        case 12:
          _h = [{}];
          return [4, deserializeAws_json1_1ResourceConflictExceptionResponse(parsedOutput)];
        case 13:
          response = __assign$b.apply(void 0, [__assign$b.apply(void 0, _h.concat([_m.sent()])), { name: errorCode, $metadata: deserializeMetadata(output) }]);
          return [3, 19];
        case 14:
          _j = [{}];
          return [4, deserializeAws_json1_1ResourceNotFoundExceptionResponse(parsedOutput)];
        case 15:
          response = __assign$b.apply(void 0, [__assign$b.apply(void 0, _j.concat([_m.sent()])), { name: errorCode, $metadata: deserializeMetadata(output) }]);
          return [3, 19];
        case 16:
          _k = [{}];
          return [4, deserializeAws_json1_1TooManyRequestsExceptionResponse(parsedOutput)];
        case 17:
          response = __assign$b.apply(void 0, [__assign$b.apply(void 0, _k.concat([_m.sent()])), { name: errorCode, $metadata: deserializeMetadata(output) }]);
          return [3, 19];
        case 18:
          parsedBody = parsedOutput.body;
          errorCode = parsedBody.code || parsedBody.Code || errorCode;
          response = __assign$b(__assign$b({}, parsedBody), { name: "" + errorCode, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
          _m.label = 19;
        case 19:
          message = response.message || response.Message || errorCode;
          response.message = message;
          delete response.Message;
          return [2, Promise.reject(Object.assign(new Error(message), response))];
      }
    });
  });
};
var deserializeAws_json1_1GetIdCommand = function(output, context) {
  return __awaiter$d(void 0, void 0, void 0, function() {
    var data, contents, response;
    return __generator$d(this, function(_a2) {
      switch (_a2.label) {
        case 0:
          if (output.statusCode >= 300) {
            return [2, deserializeAws_json1_1GetIdCommandError(output, context)];
          }
          return [4, parseBody(output.body, context)];
        case 1:
          data = _a2.sent();
          contents = {};
          contents = deserializeAws_json1_1GetIdResponse(data);
          response = __assign$b({ $metadata: deserializeMetadata(output) }, contents);
          return [2, Promise.resolve(response)];
      }
    });
  });
};
var deserializeAws_json1_1GetIdCommandError = function(output, context) {
  return __awaiter$d(void 0, void 0, void 0, function() {
    var parsedOutput, _a2, response, errorCode, _b, _c, _d, _e2, _f, _g, _h, _j, _k, parsedBody, message;
    var _l2;
    return __generator$d(this, function(_m) {
      switch (_m.label) {
        case 0:
          _a2 = [__assign$b({}, output)];
          _l2 = {};
          return [4, parseBody(output.body, context)];
        case 1:
          parsedOutput = __assign$b.apply(void 0, _a2.concat([(_l2.body = _m.sent(), _l2)]));
          errorCode = "UnknownError";
          errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
          _b = errorCode;
          switch (_b) {
            case "ExternalServiceException":
              return [3, 2];
            case "com.amazonaws.cognitoidentity#ExternalServiceException":
              return [3, 2];
            case "InternalErrorException":
              return [3, 4];
            case "com.amazonaws.cognitoidentity#InternalErrorException":
              return [3, 4];
            case "InvalidParameterException":
              return [3, 6];
            case "com.amazonaws.cognitoidentity#InvalidParameterException":
              return [3, 6];
            case "LimitExceededException":
              return [3, 8];
            case "com.amazonaws.cognitoidentity#LimitExceededException":
              return [3, 8];
            case "NotAuthorizedException":
              return [3, 10];
            case "com.amazonaws.cognitoidentity#NotAuthorizedException":
              return [3, 10];
            case "ResourceConflictException":
              return [3, 12];
            case "com.amazonaws.cognitoidentity#ResourceConflictException":
              return [3, 12];
            case "ResourceNotFoundException":
              return [3, 14];
            case "com.amazonaws.cognitoidentity#ResourceNotFoundException":
              return [3, 14];
            case "TooManyRequestsException":
              return [3, 16];
            case "com.amazonaws.cognitoidentity#TooManyRequestsException":
              return [3, 16];
          }
          return [3, 18];
        case 2:
          _c = [{}];
          return [4, deserializeAws_json1_1ExternalServiceExceptionResponse(parsedOutput)];
        case 3:
          response = __assign$b.apply(void 0, [__assign$b.apply(void 0, _c.concat([_m.sent()])), { name: errorCode, $metadata: deserializeMetadata(output) }]);
          return [3, 19];
        case 4:
          _d = [{}];
          return [4, deserializeAws_json1_1InternalErrorExceptionResponse(parsedOutput)];
        case 5:
          response = __assign$b.apply(void 0, [__assign$b.apply(void 0, _d.concat([_m.sent()])), { name: errorCode, $metadata: deserializeMetadata(output) }]);
          return [3, 19];
        case 6:
          _e2 = [{}];
          return [4, deserializeAws_json1_1InvalidParameterExceptionResponse(parsedOutput)];
        case 7:
          response = __assign$b.apply(void 0, [__assign$b.apply(void 0, _e2.concat([_m.sent()])), { name: errorCode, $metadata: deserializeMetadata(output) }]);
          return [3, 19];
        case 8:
          _f = [{}];
          return [4, deserializeAws_json1_1LimitExceededExceptionResponse(parsedOutput)];
        case 9:
          response = __assign$b.apply(void 0, [__assign$b.apply(void 0, _f.concat([_m.sent()])), { name: errorCode, $metadata: deserializeMetadata(output) }]);
          return [3, 19];
        case 10:
          _g = [{}];
          return [4, deserializeAws_json1_1NotAuthorizedExceptionResponse(parsedOutput)];
        case 11:
          response = __assign$b.apply(void 0, [__assign$b.apply(void 0, _g.concat([_m.sent()])), { name: errorCode, $metadata: deserializeMetadata(output) }]);
          return [3, 19];
        case 12:
          _h = [{}];
          return [4, deserializeAws_json1_1ResourceConflictExceptionResponse(parsedOutput)];
        case 13:
          response = __assign$b.apply(void 0, [__assign$b.apply(void 0, _h.concat([_m.sent()])), { name: errorCode, $metadata: deserializeMetadata(output) }]);
          return [3, 19];
        case 14:
          _j = [{}];
          return [4, deserializeAws_json1_1ResourceNotFoundExceptionResponse(parsedOutput)];
        case 15:
          response = __assign$b.apply(void 0, [__assign$b.apply(void 0, _j.concat([_m.sent()])), { name: errorCode, $metadata: deserializeMetadata(output) }]);
          return [3, 19];
        case 16:
          _k = [{}];
          return [4, deserializeAws_json1_1TooManyRequestsExceptionResponse(parsedOutput)];
        case 17:
          response = __assign$b.apply(void 0, [__assign$b.apply(void 0, _k.concat([_m.sent()])), { name: errorCode, $metadata: deserializeMetadata(output) }]);
          return [3, 19];
        case 18:
          parsedBody = parsedOutput.body;
          errorCode = parsedBody.code || parsedBody.Code || errorCode;
          response = __assign$b(__assign$b({}, parsedBody), { name: "" + errorCode, message: parsedBody.message || parsedBody.Message || errorCode, $fault: "client", $metadata: deserializeMetadata(output) });
          _m.label = 19;
        case 19:
          message = response.message || response.Message || errorCode;
          response.message = message;
          delete response.Message;
          return [2, Promise.reject(Object.assign(new Error(message), response))];
      }
    });
  });
};
var deserializeAws_json1_1ExternalServiceExceptionResponse = function(parsedOutput, context) {
  return __awaiter$d(void 0, void 0, void 0, function() {
    var body, deserialized, contents;
    return __generator$d(this, function(_a2) {
      body = parsedOutput.body;
      deserialized = deserializeAws_json1_1ExternalServiceException(body);
      contents = __assign$b({ name: "ExternalServiceException", $fault: "client", $metadata: deserializeMetadata(parsedOutput) }, deserialized);
      return [2, contents];
    });
  });
};
var deserializeAws_json1_1InternalErrorExceptionResponse = function(parsedOutput, context) {
  return __awaiter$d(void 0, void 0, void 0, function() {
    var body, deserialized, contents;
    return __generator$d(this, function(_a2) {
      body = parsedOutput.body;
      deserialized = deserializeAws_json1_1InternalErrorException(body);
      contents = __assign$b({ name: "InternalErrorException", $fault: "server", $metadata: deserializeMetadata(parsedOutput) }, deserialized);
      return [2, contents];
    });
  });
};
var deserializeAws_json1_1InvalidIdentityPoolConfigurationExceptionResponse = function(parsedOutput, context) {
  return __awaiter$d(void 0, void 0, void 0, function() {
    var body, deserialized, contents;
    return __generator$d(this, function(_a2) {
      body = parsedOutput.body;
      deserialized = deserializeAws_json1_1InvalidIdentityPoolConfigurationException(body);
      contents = __assign$b({ name: "InvalidIdentityPoolConfigurationException", $fault: "client", $metadata: deserializeMetadata(parsedOutput) }, deserialized);
      return [2, contents];
    });
  });
};
var deserializeAws_json1_1InvalidParameterExceptionResponse = function(parsedOutput, context) {
  return __awaiter$d(void 0, void 0, void 0, function() {
    var body, deserialized, contents;
    return __generator$d(this, function(_a2) {
      body = parsedOutput.body;
      deserialized = deserializeAws_json1_1InvalidParameterException(body);
      contents = __assign$b({ name: "InvalidParameterException", $fault: "client", $metadata: deserializeMetadata(parsedOutput) }, deserialized);
      return [2, contents];
    });
  });
};
var deserializeAws_json1_1LimitExceededExceptionResponse = function(parsedOutput, context) {
  return __awaiter$d(void 0, void 0, void 0, function() {
    var body, deserialized, contents;
    return __generator$d(this, function(_a2) {
      body = parsedOutput.body;
      deserialized = deserializeAws_json1_1LimitExceededException(body);
      contents = __assign$b({ name: "LimitExceededException", $fault: "client", $metadata: deserializeMetadata(parsedOutput) }, deserialized);
      return [2, contents];
    });
  });
};
var deserializeAws_json1_1NotAuthorizedExceptionResponse = function(parsedOutput, context) {
  return __awaiter$d(void 0, void 0, void 0, function() {
    var body, deserialized, contents;
    return __generator$d(this, function(_a2) {
      body = parsedOutput.body;
      deserialized = deserializeAws_json1_1NotAuthorizedException(body);
      contents = __assign$b({ name: "NotAuthorizedException", $fault: "client", $metadata: deserializeMetadata(parsedOutput) }, deserialized);
      return [2, contents];
    });
  });
};
var deserializeAws_json1_1ResourceConflictExceptionResponse = function(parsedOutput, context) {
  return __awaiter$d(void 0, void 0, void 0, function() {
    var body, deserialized, contents;
    return __generator$d(this, function(_a2) {
      body = parsedOutput.body;
      deserialized = deserializeAws_json1_1ResourceConflictException(body);
      contents = __assign$b({ name: "ResourceConflictException", $fault: "client", $metadata: deserializeMetadata(parsedOutput) }, deserialized);
      return [2, contents];
    });
  });
};
var deserializeAws_json1_1ResourceNotFoundExceptionResponse = function(parsedOutput, context) {
  return __awaiter$d(void 0, void 0, void 0, function() {
    var body, deserialized, contents;
    return __generator$d(this, function(_a2) {
      body = parsedOutput.body;
      deserialized = deserializeAws_json1_1ResourceNotFoundException(body);
      contents = __assign$b({ name: "ResourceNotFoundException", $fault: "client", $metadata: deserializeMetadata(parsedOutput) }, deserialized);
      return [2, contents];
    });
  });
};
var deserializeAws_json1_1TooManyRequestsExceptionResponse = function(parsedOutput, context) {
  return __awaiter$d(void 0, void 0, void 0, function() {
    var body, deserialized, contents;
    return __generator$d(this, function(_a2) {
      body = parsedOutput.body;
      deserialized = deserializeAws_json1_1TooManyRequestsException(body);
      contents = __assign$b({ name: "TooManyRequestsException", $fault: "client", $metadata: deserializeMetadata(parsedOutput) }, deserialized);
      return [2, contents];
    });
  });
};
var serializeAws_json1_1GetCredentialsForIdentityInput = function(input, context) {
  return __assign$b(__assign$b(__assign$b({}, input.CustomRoleArn !== void 0 && input.CustomRoleArn !== null && { CustomRoleArn: input.CustomRoleArn }), input.IdentityId !== void 0 && input.IdentityId !== null && { IdentityId: input.IdentityId }), input.Logins !== void 0 && input.Logins !== null && { Logins: serializeAws_json1_1LoginsMap(input.Logins) });
};
var serializeAws_json1_1GetIdInput = function(input, context) {
  return __assign$b(__assign$b(__assign$b({}, input.AccountId !== void 0 && input.AccountId !== null && { AccountId: input.AccountId }), input.IdentityPoolId !== void 0 && input.IdentityPoolId !== null && { IdentityPoolId: input.IdentityPoolId }), input.Logins !== void 0 && input.Logins !== null && { Logins: serializeAws_json1_1LoginsMap(input.Logins) });
};
var serializeAws_json1_1LoginsMap = function(input, context) {
  return Object.entries(input).reduce(function(acc, _a2) {
    var _b;
    var _c = __read$a(_a2, 2), key = _c[0], value = _c[1];
    if (value === null) {
      return acc;
    }
    return __assign$b(__assign$b({}, acc), (_b = {}, _b[key] = value, _b));
  }, {});
};
var deserializeAws_json1_1Credentials = function(output, context) {
  return {
    AccessKeyId: output.AccessKeyId !== void 0 && output.AccessKeyId !== null ? output.AccessKeyId : void 0,
    Expiration: output.Expiration !== void 0 && output.Expiration !== null ? new Date(Math.round(output.Expiration * 1e3)) : void 0,
    SecretKey: output.SecretKey !== void 0 && output.SecretKey !== null ? output.SecretKey : void 0,
    SessionToken: output.SessionToken !== void 0 && output.SessionToken !== null ? output.SessionToken : void 0
  };
};
var deserializeAws_json1_1ExternalServiceException = function(output, context) {
  return {
    message: output.message !== void 0 && output.message !== null ? output.message : void 0
  };
};
var deserializeAws_json1_1GetCredentialsForIdentityResponse = function(output, context) {
  return {
    Credentials: output.Credentials !== void 0 && output.Credentials !== null ? deserializeAws_json1_1Credentials(output.Credentials) : void 0,
    IdentityId: output.IdentityId !== void 0 && output.IdentityId !== null ? output.IdentityId : void 0
  };
};
var deserializeAws_json1_1GetIdResponse = function(output, context) {
  return {
    IdentityId: output.IdentityId !== void 0 && output.IdentityId !== null ? output.IdentityId : void 0
  };
};
var deserializeAws_json1_1InternalErrorException = function(output, context) {
  return {
    message: output.message !== void 0 && output.message !== null ? output.message : void 0
  };
};
var deserializeAws_json1_1InvalidIdentityPoolConfigurationException = function(output, context) {
  return {
    message: output.message !== void 0 && output.message !== null ? output.message : void 0
  };
};
var deserializeAws_json1_1InvalidParameterException = function(output, context) {
  return {
    message: output.message !== void 0 && output.message !== null ? output.message : void 0
  };
};
var deserializeAws_json1_1LimitExceededException = function(output, context) {
  return {
    message: output.message !== void 0 && output.message !== null ? output.message : void 0
  };
};
var deserializeAws_json1_1NotAuthorizedException = function(output, context) {
  return {
    message: output.message !== void 0 && output.message !== null ? output.message : void 0
  };
};
var deserializeAws_json1_1ResourceConflictException = function(output, context) {
  return {
    message: output.message !== void 0 && output.message !== null ? output.message : void 0
  };
};
var deserializeAws_json1_1ResourceNotFoundException = function(output, context) {
  return {
    message: output.message !== void 0 && output.message !== null ? output.message : void 0
  };
};
var deserializeAws_json1_1TooManyRequestsException = function(output, context) {
  return {
    message: output.message !== void 0 && output.message !== null ? output.message : void 0
  };
};
var deserializeMetadata = function(output) {
  var _a2;
  return {
    httpStatusCode: output.statusCode,
    requestId: (_a2 = output.headers["x-amzn-requestid"]) !== null && _a2 !== void 0 ? _a2 : output.headers["x-amzn-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"]
  };
};
var collectBody = function(streamBody, context) {
  if (streamBody === void 0) {
    streamBody = new Uint8Array();
  }
  if (streamBody instanceof Uint8Array) {
    return Promise.resolve(streamBody);
  }
  return context.streamCollector(streamBody) || Promise.resolve(new Uint8Array());
};
var collectBodyString = function(streamBody, context) {
  return collectBody(streamBody, context).then(function(body) {
    return context.utf8Encoder(body);
  });
};
var buildHttpRpcRequest = function(context, headers, path, resolvedHostname, body) {
  return __awaiter$d(void 0, void 0, void 0, function() {
    var _a2, hostname, _b, protocol, port, contents;
    return __generator$d(this, function(_c) {
      switch (_c.label) {
        case 0:
          return [4, context.endpoint()];
        case 1:
          _a2 = _c.sent(), hostname = _a2.hostname, _b = _a2.protocol, protocol = _b === void 0 ? "https" : _b, port = _a2.port;
          contents = {
            protocol,
            hostname,
            port,
            method: "POST",
            path,
            headers
          };
          if (resolvedHostname !== void 0) {
            contents.hostname = resolvedHostname;
          }
          if (body !== void 0) {
            contents.body = body;
          }
          return [2, new HttpRequest(contents)];
      }
    });
  });
};
var parseBody = function(streamBody, context) {
  return collectBodyString(streamBody, context).then(function(encoded) {
    if (encoded.length) {
      return JSON.parse(encoded);
    }
    return {};
  });
};
var loadRestJsonErrorCode = function(output, data) {
  var findKey2 = function(object, key) {
    return Object.keys(object).find(function(k2) {
      return k2.toLowerCase() === key.toLowerCase();
    });
  };
  var sanitizeErrorCode = function(rawValue) {
    var cleanValue = rawValue;
    if (cleanValue.indexOf(":") >= 0) {
      cleanValue = cleanValue.split(":")[0];
    }
    if (cleanValue.indexOf("#") >= 0) {
      cleanValue = cleanValue.split("#")[1];
    }
    return cleanValue;
  };
  var headerKey = findKey2(output.headers, "x-amzn-errortype");
  if (headerKey !== void 0) {
    return sanitizeErrorCode(output.headers[headerKey]);
  }
  if (data.code !== void 0) {
    return sanitizeErrorCode(data.code);
  }
  if (data["__type"] !== void 0) {
    return sanitizeErrorCode(data["__type"]);
  }
  return "";
};
var GetCredentialsForIdentityCommand = function(_super) {
  __extends$3(GetCredentialsForIdentityCommand2, _super);
  function GetCredentialsForIdentityCommand2(input) {
    var _this = _super.call(this) || this;
    _this.input = input;
    return _this;
  }
  GetCredentialsForIdentityCommand2.prototype.resolveMiddleware = function(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    var stack = clientStack.concat(this.middlewareStack);
    var logger2 = configuration.logger;
    var clientName = "CognitoIdentityClient";
    var commandName = "GetCredentialsForIdentityCommand";
    var handlerExecutionContext = {
      logger: logger2,
      clientName,
      commandName,
      inputFilterSensitiveLog: GetCredentialsForIdentityInput.filterSensitiveLog,
      outputFilterSensitiveLog: GetCredentialsForIdentityResponse.filterSensitiveLog
    };
    var requestHandler = configuration.requestHandler;
    return stack.resolve(function(request) {
      return requestHandler.handle(request.request, options || {});
    }, handlerExecutionContext);
  };
  GetCredentialsForIdentityCommand2.prototype.serialize = function(input, context) {
    return serializeAws_json1_1GetCredentialsForIdentityCommand(input, context);
  };
  GetCredentialsForIdentityCommand2.prototype.deserialize = function(output, context) {
    return deserializeAws_json1_1GetCredentialsForIdentityCommand(output, context);
  };
  return GetCredentialsForIdentityCommand2;
}(Command);
var GetIdCommand = function(_super) {
  __extends$3(GetIdCommand2, _super);
  function GetIdCommand2(input) {
    var _this = _super.call(this) || this;
    _this.input = input;
    return _this;
  }
  GetIdCommand2.prototype.resolveMiddleware = function(clientStack, configuration, options) {
    this.middlewareStack.use(getSerdePlugin(configuration, this.serialize, this.deserialize));
    var stack = clientStack.concat(this.middlewareStack);
    var logger2 = configuration.logger;
    var clientName = "CognitoIdentityClient";
    var commandName = "GetIdCommand";
    var handlerExecutionContext = {
      logger: logger2,
      clientName,
      commandName,
      inputFilterSensitiveLog: GetIdInput.filterSensitiveLog,
      outputFilterSensitiveLog: GetIdResponse.filterSensitiveLog
    };
    var requestHandler = configuration.requestHandler;
    return stack.resolve(function(request) {
      return requestHandler.handle(request.request, options || {});
    }, handlerExecutionContext);
  };
  GetIdCommand2.prototype.serialize = function(input, context) {
    return serializeAws_json1_1GetIdCommand(input, context);
  };
  GetIdCommand2.prototype.deserialize = function(output, context) {
    return deserializeAws_json1_1GetIdCommand(output, context);
  };
  return GetIdCommand2;
}(Command);
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$1 = function(d3, b3) {
  extendStatics$1 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b4) {
    d4.__proto__ = b4;
  } || function(d4, b4) {
    for (var p2 in b4)
      if (b4.hasOwnProperty(p2))
        d4[p2] = b4[p2];
  };
  return extendStatics$1(d3, b3);
};
function __extends$1(d3, b3) {
  extendStatics$1(d3, b3);
  function __() {
    this.constructor = d3;
  }
  d3.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __());
}
var ProviderError = function(_super) {
  __extends$1(ProviderError2, _super);
  function ProviderError2(message, tryNextLink) {
    if (tryNextLink === void 0) {
      tryNextLink = true;
    }
    var _this = _super.call(this, message) || this;
    _this.tryNextLink = tryNextLink;
    return _this;
  }
  return ProviderError2;
}(Error);
function resolveLogins(logins) {
  return Promise.all(Object.keys(logins).reduce(function(arr, name2) {
    var tokenOrProvider = logins[name2];
    if (typeof tokenOrProvider === "string") {
      arr.push([name2, tokenOrProvider]);
    } else {
      arr.push(tokenOrProvider().then(function(token) {
        return [name2, token];
      }));
    }
    return arr;
  }, [])).then(function(resolvedPairs) {
    return resolvedPairs.reduce(function(logins2, _a2) {
      var _b = __read$1(_a2, 2), key = _b[0], value = _b[1];
      logins2[key] = value;
      return logins2;
    }, {});
  });
}
function fromCognitoIdentity(parameters) {
  var _this = this;
  return function() {
    return __awaiter$1(_this, void 0, void 0, function() {
      var _a2, _b, _c, AccessKeyId, Expiration, _d, SecretKey, SessionToken, _e2, _f, _g, _h;
      var _j;
      return __generator$1(this, function(_k) {
        switch (_k.label) {
          case 0:
            _f = (_e2 = parameters.client).send;
            _g = GetCredentialsForIdentityCommand.bind;
            _j = {
              CustomRoleArn: parameters.customRoleArn,
              IdentityId: parameters.identityId
            };
            if (!parameters.logins)
              return [3, 2];
            return [4, resolveLogins(parameters.logins)];
          case 1:
            _h = _k.sent();
            return [3, 3];
          case 2:
            _h = void 0;
            _k.label = 3;
          case 3:
            return [4, _f.apply(_e2, [new (_g.apply(GetCredentialsForIdentityCommand, [void 0, (_j.Logins = _h, _j)]))()])];
          case 4:
            _a2 = _k.sent().Credentials, _b = _a2 === void 0 ? throwOnMissingCredentials() : _a2, _c = _b.AccessKeyId, AccessKeyId = _c === void 0 ? throwOnMissingAccessKeyId() : _c, Expiration = _b.Expiration, _d = _b.SecretKey, SecretKey = _d === void 0 ? throwOnMissingSecretKey() : _d, SessionToken = _b.SessionToken;
            return [2, {
              identityId: parameters.identityId,
              accessKeyId: AccessKeyId,
              secretAccessKey: SecretKey,
              sessionToken: SessionToken,
              expiration: Expiration
            }];
        }
      });
    });
  };
}
function throwOnMissingAccessKeyId() {
  throw new ProviderError("Response from Amazon Cognito contained no access key ID");
}
function throwOnMissingCredentials() {
  throw new ProviderError("Response from Amazon Cognito contained no credentials");
}
function throwOnMissingSecretKey() {
  throw new ProviderError("Response from Amazon Cognito contained no secret key");
}
var STORE_NAME = "IdentityIds";
var IndexedDbStorage = function() {
  function IndexedDbStorage2(dbName) {
    if (dbName === void 0) {
      dbName = "aws:cognito-identity-ids";
    }
    this.dbName = dbName;
  }
  IndexedDbStorage2.prototype.getItem = function(key) {
    return this.withObjectStore("readonly", function(store) {
      var req = store.get(key);
      return new Promise(function(resolve2) {
        req.onerror = function() {
          return resolve2(null);
        };
        req.onsuccess = function() {
          return resolve2(req.result ? req.result.value : null);
        };
      });
    }).catch(function() {
      return null;
    });
  };
  IndexedDbStorage2.prototype.removeItem = function(key) {
    return this.withObjectStore("readwrite", function(store) {
      var req = store.delete(key);
      return new Promise(function(resolve2, reject) {
        req.onerror = function() {
          return reject(req.error);
        };
        req.onsuccess = function() {
          return resolve2();
        };
      });
    });
  };
  IndexedDbStorage2.prototype.setItem = function(id, value) {
    return this.withObjectStore("readwrite", function(store) {
      var req = store.put({ id, value });
      return new Promise(function(resolve2, reject) {
        req.onerror = function() {
          return reject(req.error);
        };
        req.onsuccess = function() {
          return resolve2();
        };
      });
    });
  };
  IndexedDbStorage2.prototype.getDb = function() {
    var openDbRequest = self.indexedDB.open(this.dbName, 1);
    return new Promise(function(resolve2, reject) {
      openDbRequest.onsuccess = function() {
        resolve2(openDbRequest.result);
      };
      openDbRequest.onerror = function() {
        reject(openDbRequest.error);
      };
      openDbRequest.onblocked = function() {
        reject(new Error("Unable to access DB"));
      };
      openDbRequest.onupgradeneeded = function() {
        var db = openDbRequest.result;
        db.onerror = function() {
          reject(new Error("Failed to create object store"));
        };
        db.createObjectStore(STORE_NAME, { keyPath: "id" });
      };
    });
  };
  IndexedDbStorage2.prototype.withObjectStore = function(mode, action) {
    return this.getDb().then(function(db) {
      var tx = db.transaction(STORE_NAME, mode);
      tx.oncomplete = function() {
        return db.close();
      };
      return new Promise(function(resolve2, reject) {
        tx.onerror = function() {
          return reject(tx.error);
        };
        resolve2(action(tx.objectStore(STORE_NAME)));
      }).catch(function(err) {
        db.close();
        throw err;
      });
    });
  };
  return IndexedDbStorage2;
}();
var InMemoryStorage = function() {
  function InMemoryStorage2(store) {
    if (store === void 0) {
      store = {};
    }
    this.store = store;
  }
  InMemoryStorage2.prototype.getItem = function(key) {
    if (key in this.store) {
      return this.store[key];
    }
    return null;
  };
  InMemoryStorage2.prototype.removeItem = function(key) {
    delete this.store[key];
  };
  InMemoryStorage2.prototype.setItem = function(key, value) {
    this.store[key] = value;
  };
  return InMemoryStorage2;
}();
var inMemoryStorage = new InMemoryStorage();
function localStorage() {
  if (typeof self === "object" && self.indexedDB) {
    return new IndexedDbStorage();
  }
  if (typeof window === "object" && window.localStorage) {
    return window.localStorage;
  }
  return inMemoryStorage;
}
function fromCognitoIdentityPool(_a2) {
  var _this = this;
  var accountId = _a2.accountId, _b = _a2.cache, cache = _b === void 0 ? localStorage() : _b, client = _a2.client, customRoleArn = _a2.customRoleArn, identityPoolId = _a2.identityPoolId, logins = _a2.logins, _c = _a2.userIdentifier, userIdentifier = _c === void 0 ? !logins || Object.keys(logins).length === 0 ? "ANONYMOUS" : void 0 : _c;
  var cacheKey = userIdentifier ? "aws:cognito-identity-credentials:" + identityPoolId + ":" + userIdentifier : void 0;
  var provider = function() {
    return __awaiter$1(_this, void 0, void 0, function() {
      var identityId, _a3, _b2, IdentityId, _c2, _d, _e2, _f;
      var _g;
      return __generator$1(this, function(_h) {
        switch (_h.label) {
          case 0:
            _a3 = cacheKey;
            if (!_a3)
              return [3, 2];
            return [4, cache.getItem(cacheKey)];
          case 1:
            _a3 = _h.sent();
            _h.label = 2;
          case 2:
            identityId = _a3;
            if (!!identityId)
              return [3, 7];
            _d = (_c2 = client).send;
            _e2 = GetIdCommand.bind;
            _g = {
              AccountId: accountId,
              IdentityPoolId: identityPoolId
            };
            if (!logins)
              return [3, 4];
            return [4, resolveLogins(logins)];
          case 3:
            _f = _h.sent();
            return [3, 5];
          case 4:
            _f = void 0;
            _h.label = 5;
          case 5:
            return [4, _d.apply(_c2, [new (_e2.apply(GetIdCommand, [void 0, (_g.Logins = _f, _g)]))()])];
          case 6:
            _b2 = _h.sent().IdentityId, IdentityId = _b2 === void 0 ? throwOnMissingId() : _b2;
            identityId = IdentityId;
            if (cacheKey) {
              Promise.resolve(cache.setItem(cacheKey, identityId)).catch(function() {
              });
            }
            _h.label = 7;
          case 7:
            provider = fromCognitoIdentity({
              client,
              customRoleArn,
              logins,
              identityId
            });
            return [2, provider()];
        }
      });
    });
  };
  return function() {
    return provider().catch(function(err) {
      return __awaiter$1(_this, void 0, void 0, function() {
        return __generator$1(this, function(_a3) {
          if (cacheKey) {
            Promise.resolve(cache.removeItem(cacheKey)).catch(function() {
            });
          }
          throw err;
        });
      });
    });
  };
}
function throwOnMissingId() {
  throw new ProviderError("Response from Amazon Cognito contained no identity ID");
}
function createCognitoIdentityClient(config) {
  var client = new CognitoIdentityClient({
    region: config.region,
    customUserAgent: getAmplifyUserAgent()
  });
  client.middlewareStack.add(function(next, _2) {
    return function(args) {
      return next(middlewareArgs(args));
    };
  }, {
    step: "build",
    name: "cacheControlMiddleWare"
  });
  return client;
}
function middlewareArgs(args) {
  return __assign$c(__assign$c({}, args), { request: __assign$c(__assign$c({}, args.request), { headers: __assign$c(__assign$c({}, args.request.headers), { "cache-control": "no-store" }) }) });
}
var logger$4 = new ConsoleLogger("Credentials");
var CREDENTIALS_TTL = 50 * 60 * 1e3;
var COGNITO_IDENTITY_KEY_PREFIX = "CognitoIdentityId-";
var AMPLIFY_SYMBOL$2 = typeof Symbol !== "undefined" && typeof Symbol.for === "function" ? Symbol.for("amplify_default") : "@@amplify_default";
var dispatchCredentialsEvent = function(event, data, message) {
  Hub.dispatch("core", { event, data, message }, "Credentials", AMPLIFY_SYMBOL$2);
};
var CredentialsClass = function() {
  function CredentialsClass2(config) {
    this._gettingCredPromise = null;
    this._refreshHandlers = {};
    this.Auth = void 0;
    this.configure(config);
    this._refreshHandlers["google"] = GoogleOAuth.refreshGoogleToken;
    this._refreshHandlers["facebook"] = FacebookOAuth.refreshFacebookToken;
  }
  CredentialsClass2.prototype.getModuleName = function() {
    return "Credentials";
  };
  CredentialsClass2.prototype.getCredSource = function() {
    return this._credentials_source;
  };
  CredentialsClass2.prototype.configure = function(config) {
    if (!config)
      return this._config || {};
    this._config = Object.assign({}, this._config, config);
    var refreshHandlers = this._config.refreshHandlers;
    if (refreshHandlers) {
      this._refreshHandlers = __assign$c(__assign$c({}, this._refreshHandlers), refreshHandlers);
    }
    this._storage = this._config.storage;
    if (!this._storage) {
      this._storage = new StorageHelper$1().getStorage();
    }
    this._storageSync = Promise.resolve();
    if (typeof this._storage["sync"] === "function") {
      this._storageSync = this._storage["sync"]();
    }
    dispatchCredentialsEvent("credentials_configured", null, "Credentials has been configured successfully");
    return this._config;
  };
  CredentialsClass2.prototype.get = function() {
    logger$4.debug("getting credentials");
    return this._pickupCredentials();
  };
  CredentialsClass2.prototype._getCognitoIdentityIdStorageKey = function(identityPoolId) {
    return "" + COGNITO_IDENTITY_KEY_PREFIX + identityPoolId;
  };
  CredentialsClass2.prototype._pickupCredentials = function() {
    logger$4.debug("picking up credentials");
    if (!this._gettingCredPromise || !this._gettingCredPromise.isPending()) {
      logger$4.debug("getting new cred promise");
      this._gettingCredPromise = makeQuerablePromise(this._keepAlive());
    } else {
      logger$4.debug("getting old cred promise");
    }
    return this._gettingCredPromise;
  };
  CredentialsClass2.prototype._keepAlive = function() {
    return __awaiter$e(this, void 0, void 0, function() {
      var cred, _a2, Auth2, user_1, session, refreshToken_1, refreshRequest, err_1;
      return __generator$e(this, function(_b) {
        switch (_b.label) {
          case 0:
            logger$4.debug("checking if credentials exists and not expired");
            cred = this._credentials;
            if (cred && !this._isExpired(cred) && !this._isPastTTL()) {
              logger$4.debug("credentials not changed and not expired, directly return");
              return [2, Promise.resolve(cred)];
            }
            logger$4.debug("need to get a new credential or refresh the existing one");
            _a2 = this.Auth, Auth2 = _a2 === void 0 ? Amplify.Auth : _a2;
            if (!Auth2 || typeof Auth2.currentUserCredentials !== "function") {
              return [2, this._setCredentialsForGuest()];
            }
            if (!(!this._isExpired(cred) && this._isPastTTL()))
              return [3, 6];
            logger$4.debug("ttl has passed but token is not yet expired");
            _b.label = 1;
          case 1:
            _b.trys.push([1, 5, , 6]);
            return [4, Auth2.currentUserPoolUser()];
          case 2:
            user_1 = _b.sent();
            return [4, Auth2.currentSession()];
          case 3:
            session = _b.sent();
            refreshToken_1 = session.refreshToken;
            refreshRequest = new Promise(function(res, rej) {
              user_1.refreshSession(refreshToken_1, function(err, data) {
                return err ? rej(err) : res(data);
              });
            });
            return [4, refreshRequest];
          case 4:
            _b.sent();
            return [3, 6];
          case 5:
            err_1 = _b.sent();
            logger$4.debug("Error attempting to refreshing the session", err_1);
            return [3, 6];
          case 6:
            return [2, Auth2.currentUserCredentials()];
        }
      });
    });
  };
  CredentialsClass2.prototype.refreshFederatedToken = function(federatedInfo) {
    logger$4.debug("Getting federated credentials");
    var provider = federatedInfo.provider, user = federatedInfo.user, token = federatedInfo.token, identity_id = federatedInfo.identity_id;
    var expires_at = federatedInfo.expires_at;
    expires_at = new Date(expires_at).getFullYear() === 1970 ? expires_at * 1e3 : expires_at;
    var that = this;
    logger$4.debug("checking if federated jwt token expired");
    if (expires_at > new Date().getTime()) {
      logger$4.debug("token not expired");
      return this._setCredentialsFromFederation({
        provider,
        token,
        user,
        identity_id,
        expires_at
      });
    } else {
      if (that._refreshHandlers[provider] && typeof that._refreshHandlers[provider] === "function") {
        logger$4.debug("getting refreshed jwt token from federation provider");
        return this._providerRefreshWithRetry({
          refreshHandler: that._refreshHandlers[provider],
          provider,
          user
        });
      } else {
        logger$4.debug("no refresh handler for provider:", provider);
        this.clear();
        return Promise.reject("no refresh handler for provider");
      }
    }
  };
  CredentialsClass2.prototype._providerRefreshWithRetry = function(_a2) {
    var _this = this;
    var refreshHandler = _a2.refreshHandler, provider = _a2.provider, user = _a2.user;
    var MAX_DELAY_MS2 = 10 * 1e3;
    return jitteredExponentialRetry$1(refreshHandler, [], MAX_DELAY_MS2).then(function(data) {
      logger$4.debug("refresh federated token sucessfully", data);
      return _this._setCredentialsFromFederation({
        provider,
        token: data.token,
        user,
        identity_id: data.identity_id,
        expires_at: data.expires_at
      });
    }).catch(function(e3) {
      var isNetworkError = typeof e3 === "string" && e3.toLowerCase().lastIndexOf("network error", e3.length) === 0;
      if (!isNetworkError) {
        _this.clear();
      }
      logger$4.debug("refresh federated token failed", e3);
      return Promise.reject("refreshing federation token failed: " + e3);
    });
  };
  CredentialsClass2.prototype._isExpired = function(credentials) {
    if (!credentials) {
      logger$4.debug("no credentials for expiration check");
      return true;
    }
    logger$4.debug("are these credentials expired?", credentials);
    var ts = Date.now();
    var expiration = credentials.expiration;
    return expiration.getTime() <= ts;
  };
  CredentialsClass2.prototype._isPastTTL = function() {
    return this._nextCredentialsRefresh <= Date.now();
  };
  CredentialsClass2.prototype._setCredentialsForGuest = function() {
    var _a2;
    return __awaiter$e(this, void 0, void 0, function() {
      var _b, identityPoolId, region, mandatorySignIn, identityPoolRegion, identityId, _c, cognitoClient, credentials, cognitoIdentityParams, credentialsProvider;
      var _this = this;
      return __generator$e(this, function(_d) {
        switch (_d.label) {
          case 0:
            logger$4.debug("setting credentials for guest");
            if (!((_a2 = this._config) === null || _a2 === void 0 ? void 0 : _a2.identityPoolId)) {
              this._config = Object.assign({}, this._config, parseAWSExports(this._config || {}).Auth);
            }
            _b = this._config, identityPoolId = _b.identityPoolId, region = _b.region, mandatorySignIn = _b.mandatorySignIn, identityPoolRegion = _b.identityPoolRegion;
            if (mandatorySignIn) {
              return [2, Promise.reject("cannot get guest credentials when mandatory signin enabled")];
            }
            if (!identityPoolId) {
              logger$4.debug("No Cognito Identity pool provided for unauthenticated access");
              return [2, Promise.reject("No Cognito Identity pool provided for unauthenticated access")];
            }
            if (!identityPoolRegion && !region) {
              logger$4.debug("region is not configured for getting the credentials");
              return [2, Promise.reject("region is not configured for getting the credentials")];
            }
            _c = this;
            return [4, this._getGuestIdentityId()];
          case 1:
            identityId = _c._identityId = _d.sent();
            cognitoClient = createCognitoIdentityClient({
              region: identityPoolRegion || region
            });
            credentials = void 0;
            if (identityId) {
              cognitoIdentityParams = {
                identityId,
                client: cognitoClient
              };
              credentials = fromCognitoIdentity(cognitoIdentityParams)();
            } else {
              credentialsProvider = function() {
                return __awaiter$e(_this, void 0, void 0, function() {
                  var IdentityId, cognitoIdentityParams2, credentialsFromCognitoIdentity;
                  return __generator$e(this, function(_a3) {
                    switch (_a3.label) {
                      case 0:
                        return [4, cognitoClient.send(new GetIdCommand({
                          IdentityPoolId: identityPoolId
                        }))];
                      case 1:
                        IdentityId = _a3.sent().IdentityId;
                        this._identityId = IdentityId;
                        cognitoIdentityParams2 = {
                          client: cognitoClient,
                          identityId: IdentityId
                        };
                        credentialsFromCognitoIdentity = fromCognitoIdentity(cognitoIdentityParams2);
                        return [2, credentialsFromCognitoIdentity()];
                    }
                  });
                });
              };
              credentials = credentialsProvider().catch(function(err) {
                return __awaiter$e(_this, void 0, void 0, function() {
                  return __generator$e(this, function(_a3) {
                    throw err;
                  });
                });
              });
            }
            return [2, this._loadCredentials(credentials, "guest", false, null).then(function(res) {
              return res;
            }).catch(function(e3) {
              return __awaiter$e(_this, void 0, void 0, function() {
                var credentialsProvider2;
                var _this2 = this;
                return __generator$e(this, function(_a3) {
                  switch (_a3.label) {
                    case 0:
                      if (!(e3.name === "ResourceNotFoundException" && e3.message === "Identity '" + identityId + "' not found."))
                        return [3, 2];
                      logger$4.debug("Failed to load guest credentials");
                      return [4, this._removeGuestIdentityId()];
                    case 1:
                      _a3.sent();
                      credentialsProvider2 = function() {
                        return __awaiter$e(_this2, void 0, void 0, function() {
                          var IdentityId, cognitoIdentityParams2, credentialsFromCognitoIdentity;
                          return __generator$e(this, function(_a4) {
                            switch (_a4.label) {
                              case 0:
                                return [4, cognitoClient.send(new GetIdCommand({
                                  IdentityPoolId: identityPoolId
                                }))];
                              case 1:
                                IdentityId = _a4.sent().IdentityId;
                                this._identityId = IdentityId;
                                cognitoIdentityParams2 = {
                                  client: cognitoClient,
                                  identityId: IdentityId
                                };
                                credentialsFromCognitoIdentity = fromCognitoIdentity(cognitoIdentityParams2);
                                return [2, credentialsFromCognitoIdentity()];
                            }
                          });
                        });
                      };
                      credentials = credentialsProvider2().catch(function(err) {
                        return __awaiter$e(_this2, void 0, void 0, function() {
                          return __generator$e(this, function(_a4) {
                            throw err;
                          });
                        });
                      });
                      return [2, this._loadCredentials(credentials, "guest", false, null)];
                    case 2:
                      return [2, e3];
                  }
                });
              });
            })];
        }
      });
    });
  };
  CredentialsClass2.prototype._setCredentialsFromFederation = function(params) {
    var provider = params.provider, token = params.token, identity_id = params.identity_id;
    var domains = {
      google: "accounts.google.com",
      facebook: "graph.facebook.com",
      amazon: "www.amazon.com",
      developer: "cognito-identity.amazonaws.com"
    };
    var domain = domains[provider] || provider;
    if (!domain) {
      return Promise.reject("You must specify a federated provider");
    }
    var logins = {};
    logins[domain] = token;
    var _a2 = this._config, identityPoolId = _a2.identityPoolId, region = _a2.region, identityPoolRegion = _a2.identityPoolRegion;
    if (!identityPoolId) {
      logger$4.debug("No Cognito Federated Identity pool provided");
      return Promise.reject("No Cognito Federated Identity pool provided");
    }
    if (!identityPoolRegion && !region) {
      logger$4.debug("region is not configured for getting the credentials");
      return Promise.reject("region is not configured for getting the credentials");
    }
    var cognitoClient = createCognitoIdentityClient({
      region: identityPoolRegion || region
    });
    var credentials = void 0;
    if (identity_id) {
      var cognitoIdentityParams = {
        identityId: identity_id,
        logins,
        client: cognitoClient
      };
      credentials = fromCognitoIdentity(cognitoIdentityParams)();
    } else {
      var cognitoIdentityParams = {
        logins,
        identityPoolId,
        client: cognitoClient
      };
      credentials = fromCognitoIdentityPool(cognitoIdentityParams)();
    }
    return this._loadCredentials(credentials, "federated", true, params);
  };
  CredentialsClass2.prototype._setCredentialsFromSession = function(session) {
    var _this = this;
    logger$4.debug("set credentials from session");
    var idToken = session.getIdToken().getJwtToken();
    var _a2 = this._config, region = _a2.region, userPoolId = _a2.userPoolId, identityPoolId = _a2.identityPoolId, identityPoolRegion = _a2.identityPoolRegion;
    if (!identityPoolId) {
      logger$4.debug("No Cognito Federated Identity pool provided");
      return Promise.reject("No Cognito Federated Identity pool provided");
    }
    if (!identityPoolRegion && !region) {
      logger$4.debug("region is not configured for getting the credentials");
      return Promise.reject("region is not configured for getting the credentials");
    }
    var key = "cognito-idp." + region + ".amazonaws.com/" + userPoolId;
    var logins = {};
    logins[key] = idToken;
    var cognitoClient = createCognitoIdentityClient({
      region: identityPoolRegion || region
    });
    var credentialsProvider = function() {
      return __awaiter$e(_this, void 0, void 0, function() {
        var guestIdentityId, generatedOrRetrievedIdentityId, IdentityId, _a3, _b, AccessKeyId, Expiration, SecretKey, SessionToken, primaryIdentityId;
        return __generator$e(this, function(_c) {
          switch (_c.label) {
            case 0:
              return [4, this._getGuestIdentityId()];
            case 1:
              guestIdentityId = _c.sent();
              if (!!guestIdentityId)
                return [3, 3];
              return [4, cognitoClient.send(new GetIdCommand({
                IdentityPoolId: identityPoolId,
                Logins: logins
              }))];
            case 2:
              IdentityId = _c.sent().IdentityId;
              generatedOrRetrievedIdentityId = IdentityId;
              _c.label = 3;
            case 3:
              return [4, cognitoClient.send(new GetCredentialsForIdentityCommand({
                IdentityId: guestIdentityId || generatedOrRetrievedIdentityId,
                Logins: logins
              }))];
            case 4:
              _a3 = _c.sent(), _b = _a3.Credentials, AccessKeyId = _b.AccessKeyId, Expiration = _b.Expiration, SecretKey = _b.SecretKey, SessionToken = _b.SessionToken, primaryIdentityId = _a3.IdentityId;
              this._identityId = primaryIdentityId;
              if (!guestIdentityId)
                return [3, 6];
              logger$4.debug("The guest identity " + guestIdentityId + " has been successfully linked to the logins");
              if (guestIdentityId === primaryIdentityId) {
                logger$4.debug("The guest identity " + guestIdentityId + " has become the primary identity");
              }
              return [4, this._removeGuestIdentityId()];
            case 5:
              _c.sent();
              _c.label = 6;
            case 6:
              return [2, {
                accessKeyId: AccessKeyId,
                secretAccessKey: SecretKey,
                sessionToken: SessionToken,
                expiration: Expiration,
                identityId: primaryIdentityId
              }];
          }
        });
      });
    };
    var credentials = credentialsProvider().catch(function(err) {
      return __awaiter$e(_this, void 0, void 0, function() {
        return __generator$e(this, function(_a3) {
          throw err;
        });
      });
    });
    return this._loadCredentials(credentials, "userPool", true, null);
  };
  CredentialsClass2.prototype._loadCredentials = function(credentials, source, authenticated, info) {
    var _this = this;
    var that = this;
    return new Promise(function(res, rej) {
      credentials.then(function(credentials2) {
        return __awaiter$e(_this, void 0, void 0, function() {
          var user, provider, token, expires_at, identity_id;
          return __generator$e(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                logger$4.debug("Load credentials successfully", credentials2);
                if (this._identityId && !credentials2.identityId) {
                  credentials2["identityId"] = this._identityId;
                }
                that._credentials = credentials2;
                that._credentials.authenticated = authenticated;
                that._credentials_source = source;
                that._nextCredentialsRefresh = new Date().getTime() + CREDENTIALS_TTL;
                if (source === "federated") {
                  user = Object.assign({ id: this._credentials.identityId }, info.user);
                  provider = info.provider, token = info.token, expires_at = info.expires_at, identity_id = info.identity_id;
                  try {
                    this._storage.setItem("aws-amplify-federatedInfo", JSON.stringify({
                      provider,
                      token,
                      user,
                      expires_at,
                      identity_id
                    }));
                  } catch (e3) {
                    logger$4.debug("Failed to put federated info into auth storage", e3);
                  }
                }
                if (!(source === "guest"))
                  return [3, 2];
                return [4, this._setGuestIdentityId(credentials2.identityId)];
              case 1:
                _a2.sent();
                _a2.label = 2;
              case 2:
                res(that._credentials);
                return [2];
            }
          });
        });
      }).catch(function(err) {
        if (err) {
          logger$4.debug("Failed to load credentials", credentials);
          logger$4.debug("Error loading credentials", err);
          rej(err);
          return;
        }
      });
    });
  };
  CredentialsClass2.prototype.set = function(params, source) {
    if (source === "session") {
      return this._setCredentialsFromSession(params);
    } else if (source === "federation") {
      return this._setCredentialsFromFederation(params);
    } else if (source === "guest") {
      return this._setCredentialsForGuest();
    } else {
      logger$4.debug("no source specified for setting credentials");
      return Promise.reject("invalid source");
    }
  };
  CredentialsClass2.prototype.clear = function() {
    return __awaiter$e(this, void 0, void 0, function() {
      return __generator$e(this, function(_a2) {
        this._credentials = null;
        this._credentials_source = null;
        logger$4.debug("removing aws-amplify-federatedInfo from storage");
        this._storage.removeItem("aws-amplify-federatedInfo");
        return [2];
      });
    });
  };
  CredentialsClass2.prototype._getGuestIdentityId = function() {
    return __awaiter$e(this, void 0, void 0, function() {
      var identityPoolId, e_1;
      return __generator$e(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            identityPoolId = this._config.identityPoolId;
            _a2.label = 1;
          case 1:
            _a2.trys.push([1, 3, , 4]);
            return [4, this._storageSync];
          case 2:
            _a2.sent();
            return [2, this._storage.getItem(this._getCognitoIdentityIdStorageKey(identityPoolId))];
          case 3:
            e_1 = _a2.sent();
            logger$4.debug("Failed to get the cached guest identityId", e_1);
            return [3, 4];
          case 4:
            return [2];
        }
      });
    });
  };
  CredentialsClass2.prototype._setGuestIdentityId = function(identityId) {
    return __awaiter$e(this, void 0, void 0, function() {
      var identityPoolId, e_2;
      return __generator$e(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            identityPoolId = this._config.identityPoolId;
            _a2.label = 1;
          case 1:
            _a2.trys.push([1, 3, , 4]);
            return [4, this._storageSync];
          case 2:
            _a2.sent();
            this._storage.setItem(this._getCognitoIdentityIdStorageKey(identityPoolId), identityId);
            return [3, 4];
          case 3:
            e_2 = _a2.sent();
            logger$4.debug("Failed to cache guest identityId", e_2);
            return [3, 4];
          case 4:
            return [2];
        }
      });
    });
  };
  CredentialsClass2.prototype._removeGuestIdentityId = function() {
    return __awaiter$e(this, void 0, void 0, function() {
      var identityPoolId;
      return __generator$e(this, function(_a2) {
        identityPoolId = this._config.identityPoolId;
        logger$4.debug("removing " + this._getCognitoIdentityIdStorageKey(identityPoolId) + " from storage");
        this._storage.removeItem(this._getCognitoIdentityIdStorageKey(identityPoolId));
        return [2];
      });
    });
  };
  CredentialsClass2.prototype.shear = function(credentials) {
    return {
      accessKeyId: credentials.accessKeyId,
      sessionToken: credentials.sessionToken,
      secretAccessKey: credentials.secretAccessKey,
      identityId: credentials.identityId,
      authenticated: credentials.authenticated
    };
  };
  return CredentialsClass2;
}();
var Credentials = new CredentialsClass(null);
Amplify.register(Credentials);
/*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var parse_1 = parse$1;
var serialize_1 = serialize;
var decode = decodeURIComponent;
var encode$2 = encodeURIComponent;
var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
function parse$1(str, options) {
  if (typeof str !== "string") {
    throw new TypeError("argument str must be a string");
  }
  var obj = {};
  var opt = options || {};
  var pairs = str.split(";");
  var dec = opt.decode || decode;
  for (var i2 = 0; i2 < pairs.length; i2++) {
    var pair = pairs[i2];
    var index2 = pair.indexOf("=");
    if (index2 < 0) {
      continue;
    }
    var key = pair.substring(0, index2).trim();
    if (void 0 == obj[key]) {
      var val = pair.substring(index2 + 1, pair.length).trim();
      if (val[0] === '"') {
        val = val.slice(1, -1);
      }
      obj[key] = tryDecode(val, dec);
    }
  }
  return obj;
}
function serialize(name2, val, options) {
  var opt = options || {};
  var enc = opt.encode || encode$2;
  if (typeof enc !== "function") {
    throw new TypeError("option encode is invalid");
  }
  if (!fieldContentRegExp.test(name2)) {
    throw new TypeError("argument name is invalid");
  }
  var value = enc(val);
  if (value && !fieldContentRegExp.test(value)) {
    throw new TypeError("argument val is invalid");
  }
  var str = name2 + "=" + value;
  if (null != opt.maxAge) {
    var maxAge = opt.maxAge - 0;
    if (isNaN(maxAge) || !isFinite(maxAge)) {
      throw new TypeError("option maxAge is invalid");
    }
    str += "; Max-Age=" + Math.floor(maxAge);
  }
  if (opt.domain) {
    if (!fieldContentRegExp.test(opt.domain)) {
      throw new TypeError("option domain is invalid");
    }
    str += "; Domain=" + opt.domain;
  }
  if (opt.path) {
    if (!fieldContentRegExp.test(opt.path)) {
      throw new TypeError("option path is invalid");
    }
    str += "; Path=" + opt.path;
  }
  if (opt.expires) {
    if (typeof opt.expires.toUTCString !== "function") {
      throw new TypeError("option expires is invalid");
    }
    str += "; Expires=" + opt.expires.toUTCString();
  }
  if (opt.httpOnly) {
    str += "; HttpOnly";
  }
  if (opt.secure) {
    str += "; Secure";
  }
  if (opt.sameSite) {
    var sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
    switch (sameSite) {
      case true:
        str += "; SameSite=Strict";
        break;
      case "lax":
        str += "; SameSite=Lax";
        break;
      case "strict":
        str += "; SameSite=Strict";
        break;
      case "none":
        str += "; SameSite=None";
        break;
      default:
        throw new TypeError("option sameSite is invalid");
    }
  }
  return str;
}
function tryDecode(str, decode2) {
  try {
    return decode2(str);
  } catch (e3) {
    return str;
  }
}
function hasDocumentCookie() {
  return typeof document === "object" && typeof document.cookie === "string";
}
function parseCookies(cookies2, options) {
  if (typeof cookies2 === "string") {
    return parse_1(cookies2, options);
  } else if (typeof cookies2 === "object" && cookies2 !== null) {
    return cookies2;
  } else {
    return {};
  }
}
function isParsingCookie(value, doNotParse) {
  if (typeof doNotParse === "undefined") {
    doNotParse = !value || value[0] !== "{" && value[0] !== "[" && value[0] !== '"';
  }
  return !doNotParse;
}
function readCookie(value, options) {
  if (options === void 0) {
    options = {};
  }
  var cleanValue = cleanupCookieValue(value);
  if (isParsingCookie(cleanValue, options.doNotParse)) {
    try {
      return JSON.parse(cleanValue);
    } catch (e3) {
    }
  }
  return value;
}
function cleanupCookieValue(value) {
  if (value && value[0] === "j" && value[1] === ":") {
    return value.substr(2);
  }
  return value;
}
var __assign$1 = globalThis && globalThis.__assign || function() {
  __assign$1 = Object.assign || function(t3) {
    for (var s3, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s3 = arguments[i2];
      for (var p2 in s3)
        if (Object.prototype.hasOwnProperty.call(s3, p2))
          t3[p2] = s3[p2];
    }
    return t3;
  };
  return __assign$1.apply(this, arguments);
};
var Cookies = function() {
  function Cookies2(cookies2, options) {
    var _this = this;
    this.changeListeners = [];
    this.HAS_DOCUMENT_COOKIE = false;
    this.cookies = parseCookies(cookies2, options);
    new Promise(function() {
      _this.HAS_DOCUMENT_COOKIE = hasDocumentCookie();
    }).catch(function() {
    });
  }
  Cookies2.prototype._updateBrowserValues = function(parseOptions) {
    if (!this.HAS_DOCUMENT_COOKIE) {
      return;
    }
    this.cookies = parse_1(document.cookie, parseOptions);
  };
  Cookies2.prototype._emitChange = function(params) {
    for (var i2 = 0; i2 < this.changeListeners.length; ++i2) {
      this.changeListeners[i2](params);
    }
  };
  Cookies2.prototype.get = function(name2, options, parseOptions) {
    if (options === void 0) {
      options = {};
    }
    this._updateBrowserValues(parseOptions);
    return readCookie(this.cookies[name2], options);
  };
  Cookies2.prototype.getAll = function(options, parseOptions) {
    if (options === void 0) {
      options = {};
    }
    this._updateBrowserValues(parseOptions);
    var result = {};
    for (var name_1 in this.cookies) {
      result[name_1] = readCookie(this.cookies[name_1], options);
    }
    return result;
  };
  Cookies2.prototype.set = function(name2, value, options) {
    var _a2;
    if (typeof value === "object") {
      value = JSON.stringify(value);
    }
    this.cookies = __assign$1(__assign$1({}, this.cookies), (_a2 = {}, _a2[name2] = value, _a2));
    if (this.HAS_DOCUMENT_COOKIE) {
      document.cookie = serialize_1(name2, value, options);
    }
    this._emitChange({ name: name2, value, options });
  };
  Cookies2.prototype.remove = function(name2, options) {
    var finalOptions = options = __assign$1(__assign$1({}, options), { expires: new Date(1970, 1, 1, 0, 0, 1), maxAge: 0 });
    this.cookies = __assign$1({}, this.cookies);
    delete this.cookies[name2];
    if (this.HAS_DOCUMENT_COOKIE) {
      document.cookie = serialize_1(name2, "", finalOptions);
    }
    this._emitChange({ name: name2, value: void 0, options });
  };
  Cookies2.prototype.addChangeListener = function(callback) {
    this.changeListeners.push(callback);
  };
  Cookies2.prototype.removeChangeListener = function(callback) {
    var idx = this.changeListeners.indexOf(callback);
    if (idx >= 0) {
      this.changeListeners.splice(idx, 1);
    }
  };
  return Cookies2;
}();
const Cookies$1 = Cookies;
var isBrowser = browserOrNode().isBrowser;
var ONE_YEAR_IN_MS = 365 * 24 * 60 * 60 * 1e3;
var UniversalStorage = function() {
  function UniversalStorage2(context) {
    if (context === void 0) {
      context = {};
    }
    this.cookies = new Cookies$1();
    this.store = isBrowser ? window.localStorage : /* @__PURE__ */ Object.create(null);
    this.cookies = context.req ? new Cookies$1(context.req.headers.cookie) : new Cookies$1();
    Object.assign(this.store, this.cookies.getAll());
  }
  Object.defineProperty(UniversalStorage2.prototype, "length", {
    get: function() {
      return Object.entries(this.store).length;
    },
    enumerable: true,
    configurable: true
  });
  UniversalStorage2.prototype.clear = function() {
    var _this = this;
    Array.from(new Array(this.length)).map(function(_2, i2) {
      return _this.key(i2);
    }).forEach(function(key) {
      return _this.removeItem(key);
    });
  };
  UniversalStorage2.prototype.getItem = function(key) {
    return this.getLocalItem(key);
  };
  UniversalStorage2.prototype.getLocalItem = function(key) {
    return Object.prototype.hasOwnProperty.call(this.store, key) ? this.store[key] : null;
  };
  UniversalStorage2.prototype.getUniversalItem = function(key) {
    return this.cookies.get(key);
  };
  UniversalStorage2.prototype.key = function(index2) {
    return Object.keys(this.store)[index2];
  };
  UniversalStorage2.prototype.removeItem = function(key) {
    this.removeLocalItem(key);
    this.removeUniversalItem(key);
  };
  UniversalStorage2.prototype.removeLocalItem = function(key) {
    delete this.store[key];
  };
  UniversalStorage2.prototype.removeUniversalItem = function(key) {
    this.cookies.remove(key, {
      path: "/"
    });
  };
  UniversalStorage2.prototype.setItem = function(key, value) {
    this.setLocalItem(key, value);
    var tokenType = key.split(".").pop();
    var sessionTokenTypes = [
      "LastAuthUser",
      "accessToken",
      "refreshToken",
      "idToken"
    ];
    if (sessionTokenTypes.includes(tokenType !== null && tokenType !== void 0 ? tokenType : "")) {
      this.setUniversalItem(key, value, {
        expires: new Date(Date.now() + ONE_YEAR_IN_MS)
      });
    }
  };
  UniversalStorage2.prototype.setLocalItem = function(key, value) {
    this.store[key] = value;
  };
  UniversalStorage2.prototype.setUniversalItem = function(key, value, options) {
    if (options === void 0) {
      options = {};
    }
    this.cookies.set(key, value, __assign$c(__assign$c({}, options), {
      path: "/",
      sameSite: true,
      secure: isBrowser && window.location.hostname === "localhost" ? false : true
    }));
  };
  return UniversalStorage2;
}();
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics = function(d3, b3) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b4) {
    d4.__proto__ = b4;
  } || function(d4, b4) {
    for (var p2 in b4)
      if (b4.hasOwnProperty(p2))
        d4[p2] = b4[p2];
  };
  return extendStatics(d3, b3);
};
function __extends(d3, b3) {
  extendStatics(d3, b3);
  function __() {
    this.constructor = d3;
  }
  d3.prototype = b3 === null ? Object.create(b3) : (__.prototype = b3.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t3) {
    for (var s3, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s3 = arguments[i2];
      for (var p2 in s3)
        if (Object.prototype.hasOwnProperty.call(s3, p2))
          t3[p2] = s3[p2];
    }
    return t3;
  };
  return __assign.apply(this, arguments);
};
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve2) {
      resolve2(value);
    });
  }
  return new (P || (P = Promise))(function(resolve2, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e3) {
        reject(e3);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e3) {
        reject(e3);
      }
    }
    function step(result) {
      result.done ? resolve2(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t3[0] & 1)
      throw t3[1];
    return t3[1];
  }, trys: [], ops: [] }, f, y3, t3, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n2) {
    return function(v) {
      return step([n2, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_2)
      try {
        if (f = 1, y3 && (t3 = op[0] & 2 ? y3["return"] : op[0] ? y3["throw"] || ((t3 = y3["return"]) && t3.call(y3), 0) : y3.next) && !(t3 = t3.call(y3, op[1])).done)
          return t3;
        if (y3 = 0, t3)
          op = [op[0] & 2, t3.value];
        switch (op[0]) {
          case 0:
          case 1:
            t3 = op;
            break;
          case 4:
            _2.label++;
            return { value: op[1], done: false };
          case 5:
            _2.label++;
            y3 = op[1];
            op = [0];
            continue;
          case 7:
            op = _2.ops.pop();
            _2.trys.pop();
            continue;
          default:
            if (!(t3 = _2.trys, t3 = t3.length > 0 && t3[t3.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _2 = 0;
              continue;
            }
            if (op[0] === 3 && (!t3 || op[1] > t3[0] && op[1] < t3[3])) {
              _2.label = op[1];
              break;
            }
            if (op[0] === 6 && _2.label < t3[1]) {
              _2.label = t3[1];
              t3 = op;
              break;
            }
            if (t3 && _2.label < t3[2]) {
              _2.label = t3[2];
              _2.ops.push(op);
              break;
            }
            if (t3[2])
              _2.ops.pop();
            _2.trys.pop();
            continue;
        }
        op = body.call(thisArg, _2);
      } catch (e3) {
        op = [6, e3];
        y3 = 0;
      } finally {
        f = t3 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __read(o2, n2) {
  var m3 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m3)
    return o2;
  var i2 = m3.call(o2), r2, ar2 = [], e3;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done)
      ar2.push(r2.value);
  } catch (error) {
    e3 = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m3 = i2["return"]))
        m3.call(i2);
    } finally {
      if (e3)
        throw e3.error;
    }
  }
  return ar2;
}
var CognitoHostedUIIdentityProvider;
(function(CognitoHostedUIIdentityProvider2) {
  CognitoHostedUIIdentityProvider2["Cognito"] = "COGNITO";
  CognitoHostedUIIdentityProvider2["Google"] = "Google";
  CognitoHostedUIIdentityProvider2["Facebook"] = "Facebook";
  CognitoHostedUIIdentityProvider2["Amazon"] = "LoginWithAmazon";
  CognitoHostedUIIdentityProvider2["Apple"] = "SignInWithApple";
})(CognitoHostedUIIdentityProvider || (CognitoHostedUIIdentityProvider = {}));
function isFederatedSignInOptions(obj) {
  var keys = ["provider"];
  return obj && !!keys.find(function(k2) {
    return obj.hasOwnProperty(k2);
  });
}
function isFederatedSignInOptionsCustom(obj) {
  var keys = ["customProvider"];
  return obj && !!keys.find(function(k2) {
    return obj.hasOwnProperty(k2);
  });
}
function hasCustomState(obj) {
  var keys = ["customState"];
  return obj && !!keys.find(function(k2) {
    return obj.hasOwnProperty(k2);
  });
}
function isCognitoHostedOpts(oauth) {
  return oauth.redirectSignIn !== void 0;
}
var AuthErrorTypes;
(function(AuthErrorTypes2) {
  AuthErrorTypes2["NoConfig"] = "noConfig";
  AuthErrorTypes2["MissingAuthConfig"] = "missingAuthConfig";
  AuthErrorTypes2["EmptyUsername"] = "emptyUsername";
  AuthErrorTypes2["InvalidUsername"] = "invalidUsername";
  AuthErrorTypes2["EmptyPassword"] = "emptyPassword";
  AuthErrorTypes2["EmptyCode"] = "emptyCode";
  AuthErrorTypes2["SignUpError"] = "signUpError";
  AuthErrorTypes2["NoMFA"] = "noMFA";
  AuthErrorTypes2["InvalidMFA"] = "invalidMFA";
  AuthErrorTypes2["EmptyChallengeResponse"] = "emptyChallengeResponse";
  AuthErrorTypes2["NoUserSession"] = "noUserSession";
  AuthErrorTypes2["Default"] = "default";
  AuthErrorTypes2["DeviceConfig"] = "deviceConfig";
  AuthErrorTypes2["NetworkError"] = "networkError";
  AuthErrorTypes2["AutoSignInError"] = "autoSignInError";
})(AuthErrorTypes || (AuthErrorTypes = {}));
function isUsernamePasswordOpts(obj) {
  return !!obj.username;
}
var GRAPHQL_AUTH_MODE;
(function(GRAPHQL_AUTH_MODE2) {
  GRAPHQL_AUTH_MODE2["API_KEY"] = "API_KEY";
  GRAPHQL_AUTH_MODE2["AWS_IAM"] = "AWS_IAM";
  GRAPHQL_AUTH_MODE2["OPENID_CONNECT"] = "OPENID_CONNECT";
  GRAPHQL_AUTH_MODE2["AMAZON_COGNITO_USER_POOLS"] = "AMAZON_COGNITO_USER_POOLS";
  GRAPHQL_AUTH_MODE2["AWS_LAMBDA"] = "AWS_LAMBDA";
})(GRAPHQL_AUTH_MODE || (GRAPHQL_AUTH_MODE = {}));
/*!
 * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * SPDX-License-Identifier: Apache-2.0
 */
var AuthenticationDetails = /* @__PURE__ */ function() {
  function AuthenticationDetails2(data) {
    var _ref = data || {}, ValidationData = _ref.ValidationData, Username = _ref.Username, Password = _ref.Password, AuthParameters = _ref.AuthParameters, ClientMetadata = _ref.ClientMetadata;
    this.validationData = ValidationData || {};
    this.authParameters = AuthParameters || {};
    this.clientMetadata = ClientMetadata || {};
    this.username = Username;
    this.password = Password;
  }
  var _proto = AuthenticationDetails2.prototype;
  _proto.getUsername = function getUsername() {
    return this.username;
  };
  _proto.getPassword = function getPassword() {
    return this.password;
  };
  _proto.getValidationData = function getValidationData() {
    return this.validationData;
  };
  _proto.getAuthParameters = function getAuthParameters() {
    return this.authParameters;
  };
  _proto.getClientMetadata = function getClientMetadata() {
    return this.clientMetadata;
  };
  return AuthenticationDetails2;
}();
var buffer = {};
var base64Js = {};
base64Js.byteLength = byteLength;
base64Js.toByteArray = toByteArray;
base64Js.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i2 = 0, len = code.length; i2 < len; ++i2) {
  lookup[i2] = code[i2];
  revLookup[code.charCodeAt(i2)] = i2;
}
revLookup["-".charCodeAt(0)] = 62;
revLookup["_".charCodeAt(0)] = 63;
function getLens(b64) {
  var len = b64.length;
  if (len % 4 > 0) {
    throw new Error("Invalid string. Length must be a multiple of 4");
  }
  var validLen = b64.indexOf("=");
  if (validLen === -1)
    validLen = len;
  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
}
function byteLength(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}
function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
  var curByte = 0;
  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
  var i2;
  for (i2 = 0; i2 < len; i2 += 4) {
    tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
    arr[curByte++] = tmp >> 16 & 255;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
    arr[curByte++] = tmp & 255;
  }
  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 255;
    arr[curByte++] = tmp & 255;
  }
  return arr;
}
function tripletToBase64(num) {
  return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
}
function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];
  for (var i2 = start; i2 < end; i2 += 3) {
    tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
    output.push(tripletToBase64(tmp));
  }
  return output.join("");
}
function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3;
  var parts = [];
  var maxChunkLength = 16383;
  for (var i2 = 0, len2 = len - extraBytes; i2 < len2; i2 += maxChunkLength) {
    parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len2 ? len2 : i2 + maxChunkLength));
  }
  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    parts.push(
      lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
    );
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    parts.push(
      lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
    );
  }
  return parts.join("");
}
var ieee754 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ieee754.read = function(buffer2, offset, isLE, mLen, nBytes) {
  var e3, m3;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i2 = isLE ? nBytes - 1 : 0;
  var d3 = isLE ? -1 : 1;
  var s3 = buffer2[offset + i2];
  i2 += d3;
  e3 = s3 & (1 << -nBits) - 1;
  s3 >>= -nBits;
  nBits += eLen;
  for (; nBits > 0; e3 = e3 * 256 + buffer2[offset + i2], i2 += d3, nBits -= 8) {
  }
  m3 = e3 & (1 << -nBits) - 1;
  e3 >>= -nBits;
  nBits += mLen;
  for (; nBits > 0; m3 = m3 * 256 + buffer2[offset + i2], i2 += d3, nBits -= 8) {
  }
  if (e3 === 0) {
    e3 = 1 - eBias;
  } else if (e3 === eMax) {
    return m3 ? NaN : (s3 ? -1 : 1) * Infinity;
  } else {
    m3 = m3 + Math.pow(2, mLen);
    e3 = e3 - eBias;
  }
  return (s3 ? -1 : 1) * m3 * Math.pow(2, e3 - mLen);
};
ieee754.write = function(buffer2, value, offset, isLE, mLen, nBytes) {
  var e3, m3, c2;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i2 = isLE ? 0 : nBytes - 1;
  var d3 = isLE ? 1 : -1;
  var s3 = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);
  if (isNaN(value) || value === Infinity) {
    m3 = isNaN(value) ? 1 : 0;
    e3 = eMax;
  } else {
    e3 = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c2 = Math.pow(2, -e3)) < 1) {
      e3--;
      c2 *= 2;
    }
    if (e3 + eBias >= 1) {
      value += rt / c2;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c2 >= 2) {
      e3++;
      c2 /= 2;
    }
    if (e3 + eBias >= eMax) {
      m3 = 0;
      e3 = eMax;
    } else if (e3 + eBias >= 1) {
      m3 = (value * c2 - 1) * Math.pow(2, mLen);
      e3 = e3 + eBias;
    } else {
      m3 = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e3 = 0;
    }
  }
  for (; mLen >= 8; buffer2[offset + i2] = m3 & 255, i2 += d3, m3 /= 256, mLen -= 8) {
  }
  e3 = e3 << mLen | m3;
  eLen += mLen;
  for (; eLen > 0; buffer2[offset + i2] = e3 & 255, i2 += d3, e3 /= 256, eLen -= 8) {
  }
  buffer2[offset + i2 - d3] |= s3 * 128;
};
var toString$1 = {}.toString;
var isarray = Array.isArray || function(arr) {
  return toString$1.call(arr) == "[object Array]";
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */
(function(exports) {
  var base64 = base64Js;
  var ieee754$1 = ieee754;
  var isArray2 = isarray;
  exports.Buffer = Buffer2;
  exports.SlowBuffer = SlowBuffer;
  exports.INSPECT_MAX_BYTES = 50;
  Buffer2.TYPED_ARRAY_SUPPORT = commonjsGlobal.TYPED_ARRAY_SUPPORT !== void 0 ? commonjsGlobal.TYPED_ARRAY_SUPPORT : typedArraySupport();
  exports.kMaxLength = kMaxLength();
  function typedArraySupport() {
    try {
      var arr = new Uint8Array(1);
      arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function() {
        return 42;
      } };
      return arr.foo() === 42 && typeof arr.subarray === "function" && arr.subarray(1, 1).byteLength === 0;
    } catch (e3) {
      return false;
    }
  }
  function kMaxLength() {
    return Buffer2.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
  }
  function createBuffer(that, length) {
    if (kMaxLength() < length) {
      throw new RangeError("Invalid typed array length");
    }
    if (Buffer2.TYPED_ARRAY_SUPPORT) {
      that = new Uint8Array(length);
      that.__proto__ = Buffer2.prototype;
    } else {
      if (that === null) {
        that = new Buffer2(length);
      }
      that.length = length;
    }
    return that;
  }
  function Buffer2(arg, encodingOrOffset, length) {
    if (!Buffer2.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer2)) {
      return new Buffer2(arg, encodingOrOffset, length);
    }
    if (typeof arg === "number") {
      if (typeof encodingOrOffset === "string") {
        throw new Error(
          "If encoding is specified then the first argument must be a string"
        );
      }
      return allocUnsafe(this, arg);
    }
    return from(this, arg, encodingOrOffset, length);
  }
  Buffer2.poolSize = 8192;
  Buffer2._augment = function(arr) {
    arr.__proto__ = Buffer2.prototype;
    return arr;
  };
  function from(that, value, encodingOrOffset, length) {
    if (typeof value === "number") {
      throw new TypeError('"value" argument must not be a number');
    }
    if (typeof ArrayBuffer !== "undefined" && value instanceof ArrayBuffer) {
      return fromArrayBuffer(that, value, encodingOrOffset, length);
    }
    if (typeof value === "string") {
      return fromString(that, value, encodingOrOffset);
    }
    return fromObject(that, value);
  }
  Buffer2.from = function(value, encodingOrOffset, length) {
    return from(null, value, encodingOrOffset, length);
  };
  if (Buffer2.TYPED_ARRAY_SUPPORT) {
    Buffer2.prototype.__proto__ = Uint8Array.prototype;
    Buffer2.__proto__ = Uint8Array;
    if (typeof Symbol !== "undefined" && Symbol.species && Buffer2[Symbol.species] === Buffer2) {
      Object.defineProperty(Buffer2, Symbol.species, {
        value: null,
        configurable: true
      });
    }
  }
  function assertSize(size2) {
    if (typeof size2 !== "number") {
      throw new TypeError('"size" argument must be a number');
    } else if (size2 < 0) {
      throw new RangeError('"size" argument must not be negative');
    }
  }
  function alloc(that, size2, fill, encoding) {
    assertSize(size2);
    if (size2 <= 0) {
      return createBuffer(that, size2);
    }
    if (fill !== void 0) {
      return typeof encoding === "string" ? createBuffer(that, size2).fill(fill, encoding) : createBuffer(that, size2).fill(fill);
    }
    return createBuffer(that, size2);
  }
  Buffer2.alloc = function(size2, fill, encoding) {
    return alloc(null, size2, fill, encoding);
  };
  function allocUnsafe(that, size2) {
    assertSize(size2);
    that = createBuffer(that, size2 < 0 ? 0 : checked(size2) | 0);
    if (!Buffer2.TYPED_ARRAY_SUPPORT) {
      for (var i2 = 0; i2 < size2; ++i2) {
        that[i2] = 0;
      }
    }
    return that;
  }
  Buffer2.allocUnsafe = function(size2) {
    return allocUnsafe(null, size2);
  };
  Buffer2.allocUnsafeSlow = function(size2) {
    return allocUnsafe(null, size2);
  };
  function fromString(that, string, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
      encoding = "utf8";
    }
    if (!Buffer2.isEncoding(encoding)) {
      throw new TypeError('"encoding" must be a valid string encoding');
    }
    var length = byteLength2(string, encoding) | 0;
    that = createBuffer(that, length);
    var actual = that.write(string, encoding);
    if (actual !== length) {
      that = that.slice(0, actual);
    }
    return that;
  }
  function fromArrayLike(that, array) {
    var length = array.length < 0 ? 0 : checked(array.length) | 0;
    that = createBuffer(that, length);
    for (var i2 = 0; i2 < length; i2 += 1) {
      that[i2] = array[i2] & 255;
    }
    return that;
  }
  function fromArrayBuffer(that, array, byteOffset, length) {
    array.byteLength;
    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError("'offset' is out of bounds");
    }
    if (array.byteLength < byteOffset + (length || 0)) {
      throw new RangeError("'length' is out of bounds");
    }
    if (byteOffset === void 0 && length === void 0) {
      array = new Uint8Array(array);
    } else if (length === void 0) {
      array = new Uint8Array(array, byteOffset);
    } else {
      array = new Uint8Array(array, byteOffset, length);
    }
    if (Buffer2.TYPED_ARRAY_SUPPORT) {
      that = array;
      that.__proto__ = Buffer2.prototype;
    } else {
      that = fromArrayLike(that, array);
    }
    return that;
  }
  function fromObject(that, obj) {
    if (Buffer2.isBuffer(obj)) {
      var len = checked(obj.length) | 0;
      that = createBuffer(that, len);
      if (that.length === 0) {
        return that;
      }
      obj.copy(that, 0, 0, len);
      return that;
    }
    if (obj) {
      if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) {
        if (typeof obj.length !== "number" || isnan(obj.length)) {
          return createBuffer(that, 0);
        }
        return fromArrayLike(that, obj);
      }
      if (obj.type === "Buffer" && isArray2(obj.data)) {
        return fromArrayLike(that, obj.data);
      }
    }
    throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
  }
  function checked(length) {
    if (length >= kMaxLength()) {
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength().toString(16) + " bytes");
    }
    return length | 0;
  }
  function SlowBuffer(length) {
    if (+length != length) {
      length = 0;
    }
    return Buffer2.alloc(+length);
  }
  Buffer2.isBuffer = function isBuffer2(b3) {
    return !!(b3 != null && b3._isBuffer);
  };
  Buffer2.compare = function compare(a3, b3) {
    if (!Buffer2.isBuffer(a3) || !Buffer2.isBuffer(b3)) {
      throw new TypeError("Arguments must be Buffers");
    }
    if (a3 === b3)
      return 0;
    var x2 = a3.length;
    var y3 = b3.length;
    for (var i2 = 0, len = Math.min(x2, y3); i2 < len; ++i2) {
      if (a3[i2] !== b3[i2]) {
        x2 = a3[i2];
        y3 = b3[i2];
        break;
      }
    }
    if (x2 < y3)
      return -1;
    if (y3 < x2)
      return 1;
    return 0;
  };
  Buffer2.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  Buffer2.concat = function concat(list, length) {
    if (!isArray2(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    if (list.length === 0) {
      return Buffer2.alloc(0);
    }
    var i2;
    if (length === void 0) {
      length = 0;
      for (i2 = 0; i2 < list.length; ++i2) {
        length += list[i2].length;
      }
    }
    var buffer2 = Buffer2.allocUnsafe(length);
    var pos = 0;
    for (i2 = 0; i2 < list.length; ++i2) {
      var buf = list[i2];
      if (!Buffer2.isBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      buf.copy(buffer2, pos);
      pos += buf.length;
    }
    return buffer2;
  };
  function byteLength2(string, encoding) {
    if (Buffer2.isBuffer(string)) {
      return string.length;
    }
    if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
      return string.byteLength;
    }
    if (typeof string !== "string") {
      string = "" + string;
    }
    var len = string.length;
    if (len === 0)
      return 0;
    var loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "ascii":
        case "latin1":
        case "binary":
          return len;
        case "utf8":
        case "utf-8":
        case void 0:
          return utf8ToBytes(string).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return len * 2;
        case "hex":
          return len >>> 1;
        case "base64":
          return base64ToBytes(string).length;
        default:
          if (loweredCase)
            return utf8ToBytes(string).length;
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer2.byteLength = byteLength2;
  function slowToString(encoding, start, end) {
    var loweredCase = false;
    if (start === void 0 || start < 0) {
      start = 0;
    }
    if (start > this.length) {
      return "";
    }
    if (end === void 0 || end > this.length) {
      end = this.length;
    }
    if (end <= 0) {
      return "";
    }
    end >>>= 0;
    start >>>= 0;
    if (end <= start) {
      return "";
    }
    if (!encoding)
      encoding = "utf8";
    while (true) {
      switch (encoding) {
        case "hex":
          return hexSlice(this, start, end);
        case "utf8":
        case "utf-8":
          return utf8Slice(this, start, end);
        case "ascii":
          return asciiSlice(this, start, end);
        case "latin1":
        case "binary":
          return latin1Slice(this, start, end);
        case "base64":
          return base64Slice(this, start, end);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return utf16leSlice(this, start, end);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = (encoding + "").toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer2.prototype._isBuffer = true;
  function swap(b3, n2, m3) {
    var i2 = b3[n2];
    b3[n2] = b3[m3];
    b3[m3] = i2;
  }
  Buffer2.prototype.swap16 = function swap16() {
    var len = this.length;
    if (len % 2 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for (var i2 = 0; i2 < len; i2 += 2) {
      swap(this, i2, i2 + 1);
    }
    return this;
  };
  Buffer2.prototype.swap32 = function swap32() {
    var len = this.length;
    if (len % 4 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for (var i2 = 0; i2 < len; i2 += 4) {
      swap(this, i2, i2 + 3);
      swap(this, i2 + 1, i2 + 2);
    }
    return this;
  };
  Buffer2.prototype.swap64 = function swap64() {
    var len = this.length;
    if (len % 8 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for (var i2 = 0; i2 < len; i2 += 8) {
      swap(this, i2, i2 + 7);
      swap(this, i2 + 1, i2 + 6);
      swap(this, i2 + 2, i2 + 5);
      swap(this, i2 + 3, i2 + 4);
    }
    return this;
  };
  Buffer2.prototype.toString = function toString3() {
    var length = this.length | 0;
    if (length === 0)
      return "";
    if (arguments.length === 0)
      return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
  };
  Buffer2.prototype.equals = function equals(b3) {
    if (!Buffer2.isBuffer(b3))
      throw new TypeError("Argument must be a Buffer");
    if (this === b3)
      return true;
    return Buffer2.compare(this, b3) === 0;
  };
  Buffer2.prototype.inspect = function inspect() {
    var str = "";
    var max = exports.INSPECT_MAX_BYTES;
    if (this.length > 0) {
      str = this.toString("hex", 0, max).match(/.{2}/g).join(" ");
      if (this.length > max)
        str += " ... ";
    }
    return "<Buffer " + str + ">";
  };
  Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (!Buffer2.isBuffer(target)) {
      throw new TypeError("Argument must be a Buffer");
    }
    if (start === void 0) {
      start = 0;
    }
    if (end === void 0) {
      end = target ? target.length : 0;
    }
    if (thisStart === void 0) {
      thisStart = 0;
    }
    if (thisEnd === void 0) {
      thisEnd = this.length;
    }
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError("out of range index");
    }
    if (thisStart >= thisEnd && start >= end) {
      return 0;
    }
    if (thisStart >= thisEnd) {
      return -1;
    }
    if (start >= end) {
      return 1;
    }
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target)
      return 0;
    var x2 = thisEnd - thisStart;
    var y3 = end - start;
    var len = Math.min(x2, y3);
    var thisCopy = this.slice(thisStart, thisEnd);
    var targetCopy = target.slice(start, end);
    for (var i2 = 0; i2 < len; ++i2) {
      if (thisCopy[i2] !== targetCopy[i2]) {
        x2 = thisCopy[i2];
        y3 = targetCopy[i2];
        break;
      }
    }
    if (x2 < y3)
      return -1;
    if (y3 < x2)
      return 1;
    return 0;
  };
  function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
    if (buffer2.length === 0)
      return -1;
    if (typeof byteOffset === "string") {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 2147483647) {
      byteOffset = 2147483647;
    } else if (byteOffset < -2147483648) {
      byteOffset = -2147483648;
    }
    byteOffset = +byteOffset;
    if (isNaN(byteOffset)) {
      byteOffset = dir ? 0 : buffer2.length - 1;
    }
    if (byteOffset < 0)
      byteOffset = buffer2.length + byteOffset;
    if (byteOffset >= buffer2.length) {
      if (dir)
        return -1;
      else
        byteOffset = buffer2.length - 1;
    } else if (byteOffset < 0) {
      if (dir)
        byteOffset = 0;
      else
        return -1;
    }
    if (typeof val === "string") {
      val = Buffer2.from(val, encoding);
    }
    if (Buffer2.isBuffer(val)) {
      if (val.length === 0) {
        return -1;
      }
      return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
      val = val & 255;
      if (Buffer2.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === "function") {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
        }
      }
      return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
  }
  function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    var indexSize = 1;
    var arrLength = arr.length;
    var valLength = val.length;
    if (encoding !== void 0) {
      encoding = String(encoding).toLowerCase();
      if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
        if (arr.length < 2 || val.length < 2) {
          return -1;
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }
    function read(buf, i3) {
      if (indexSize === 1) {
        return buf[i3];
      } else {
        return buf.readUInt16BE(i3 * indexSize);
      }
    }
    var i2;
    if (dir) {
      var foundIndex = -1;
      for (i2 = byteOffset; i2 < arrLength; i2++) {
        if (read(arr, i2) === read(val, foundIndex === -1 ? 0 : i2 - foundIndex)) {
          if (foundIndex === -1)
            foundIndex = i2;
          if (i2 - foundIndex + 1 === valLength)
            return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1)
            i2 -= i2 - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength)
        byteOffset = arrLength - valLength;
      for (i2 = byteOffset; i2 >= 0; i2--) {
        var found = true;
        for (var j = 0; j < valLength; j++) {
          if (read(arr, i2 + j) !== read(val, j)) {
            found = false;
            break;
          }
        }
        if (found)
          return i2;
      }
    }
    return -1;
  }
  Buffer2.prototype.includes = function includes2(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
  };
  Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
  };
  Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
  };
  function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    var remaining = buf.length - offset;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }
    var strLen = string.length;
    if (strLen % 2 !== 0)
      throw new TypeError("Invalid hex string");
    if (length > strLen / 2) {
      length = strLen / 2;
    }
    for (var i2 = 0; i2 < length; ++i2) {
      var parsed = parseInt(string.substr(i2 * 2, 2), 16);
      if (isNaN(parsed))
        return i2;
      buf[offset + i2] = parsed;
    }
    return i2;
  }
  function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
  }
  function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
  }
  function latin1Write(buf, string, offset, length) {
    return asciiWrite(buf, string, offset, length);
  }
  function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
  }
  function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
  }
  Buffer2.prototype.write = function write(string, offset, length, encoding) {
    if (offset === void 0) {
      encoding = "utf8";
      length = this.length;
      offset = 0;
    } else if (length === void 0 && typeof offset === "string") {
      encoding = offset;
      length = this.length;
      offset = 0;
    } else if (isFinite(offset)) {
      offset = offset | 0;
      if (isFinite(length)) {
        length = length | 0;
        if (encoding === void 0)
          encoding = "utf8";
      } else {
        encoding = length;
        length = void 0;
      }
    } else {
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    }
    var remaining = this.length - offset;
    if (length === void 0 || length > remaining)
      length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
      throw new RangeError("Attempt to write outside buffer bounds");
    }
    if (!encoding)
      encoding = "utf8";
    var loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "hex":
          return hexWrite(this, string, offset, length);
        case "utf8":
        case "utf-8":
          return utf8Write(this, string, offset, length);
        case "ascii":
          return asciiWrite(this, string, offset, length);
        case "latin1":
        case "binary":
          return latin1Write(this, string, offset, length);
        case "base64":
          return base64Write(this, string, offset, length);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ucs2Write(this, string, offset, length);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer2.prototype.toJSON = function toJSON2() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) {
      return base64.fromByteArray(buf);
    } else {
      return base64.fromByteArray(buf.slice(start, end));
    }
  }
  function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    var res = [];
    var i2 = start;
    while (i2 < end) {
      var firstByte = buf[i2];
      var codePoint = null;
      var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (i2 + bytesPerSequence <= end) {
        var secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf[i2 + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf[i2 + 1];
            thirdByte = buf[i2 + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf[i2 + 1];
            thirdByte = buf[i2 + 2];
            fourthByte = buf[i2 + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      i2 += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
  }
  var MAX_ARGUMENTS_LENGTH = 4096;
  function decodeCodePointsArray(codePoints) {
    var len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints);
    }
    var res = "";
    var i2 = 0;
    while (i2 < len) {
      res += String.fromCharCode.apply(
        String,
        codePoints.slice(i2, i2 += MAX_ARGUMENTS_LENGTH)
      );
    }
    return res;
  }
  function asciiSlice(buf, start, end) {
    var ret = "";
    end = Math.min(buf.length, end);
    for (var i2 = start; i2 < end; ++i2) {
      ret += String.fromCharCode(buf[i2] & 127);
    }
    return ret;
  }
  function latin1Slice(buf, start, end) {
    var ret = "";
    end = Math.min(buf.length, end);
    for (var i2 = start; i2 < end; ++i2) {
      ret += String.fromCharCode(buf[i2]);
    }
    return ret;
  }
  function hexSlice(buf, start, end) {
    var len = buf.length;
    if (!start || start < 0)
      start = 0;
    if (!end || end < 0 || end > len)
      end = len;
    var out = "";
    for (var i2 = start; i2 < end; ++i2) {
      out += toHex2(buf[i2]);
    }
    return out;
  }
  function utf16leSlice(buf, start, end) {
    var bytes = buf.slice(start, end);
    var res = "";
    for (var i2 = 0; i2 < bytes.length; i2 += 2) {
      res += String.fromCharCode(bytes[i2] + bytes[i2 + 1] * 256);
    }
    return res;
  }
  Buffer2.prototype.slice = function slice(start, end) {
    var len = this.length;
    start = ~~start;
    end = end === void 0 ? len : ~~end;
    if (start < 0) {
      start += len;
      if (start < 0)
        start = 0;
    } else if (start > len) {
      start = len;
    }
    if (end < 0) {
      end += len;
      if (end < 0)
        end = 0;
    } else if (end > len) {
      end = len;
    }
    if (end < start)
      end = start;
    var newBuf;
    if (Buffer2.TYPED_ARRAY_SUPPORT) {
      newBuf = this.subarray(start, end);
      newBuf.__proto__ = Buffer2.prototype;
    } else {
      var sliceLen = end - start;
      newBuf = new Buffer2(sliceLen, void 0);
      for (var i2 = 0; i2 < sliceLen; ++i2) {
        newBuf[i2] = this[i2 + start];
      }
    }
    return newBuf;
  };
  function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0)
      throw new RangeError("offset is not uint");
    if (offset + ext > length)
      throw new RangeError("Trying to access beyond buffer length");
  }
  Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength3, noAssert) {
    offset = offset | 0;
    byteLength3 = byteLength3 | 0;
    if (!noAssert)
      checkOffset(offset, byteLength3, this.length);
    var val = this[offset];
    var mul = 1;
    var i2 = 0;
    while (++i2 < byteLength3 && (mul *= 256)) {
      val += this[offset + i2] * mul;
    }
    return val;
  };
  Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength3, noAssert) {
    offset = offset | 0;
    byteLength3 = byteLength3 | 0;
    if (!noAssert) {
      checkOffset(offset, byteLength3, this.length);
    }
    var val = this[offset + --byteLength3];
    var mul = 1;
    while (byteLength3 > 0 && (mul *= 256)) {
      val += this[offset + --byteLength3] * mul;
    }
    return val;
  };
  Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    return this[offset];
  };
  Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
  };
  Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
  };
  Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
  };
  Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
  };
  Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength3, noAssert) {
    offset = offset | 0;
    byteLength3 = byteLength3 | 0;
    if (!noAssert)
      checkOffset(offset, byteLength3, this.length);
    var val = this[offset];
    var mul = 1;
    var i2 = 0;
    while (++i2 < byteLength3 && (mul *= 256)) {
      val += this[offset + i2] * mul;
    }
    mul *= 128;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength3, noAssert) {
    offset = offset | 0;
    byteLength3 = byteLength3 | 0;
    if (!noAssert)
      checkOffset(offset, byteLength3, this.length);
    var i2 = byteLength3;
    var mul = 1;
    var val = this[offset + --i2];
    while (i2 > 0 && (mul *= 256)) {
      val += this[offset + --i2] * mul;
    }
    mul *= 128;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength3);
    return val;
  };
  Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    if (!(this[offset] & 128))
      return this[offset];
    return (255 - this[offset] + 1) * -1;
  };
  Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    var val = this[offset] | this[offset + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    var val = this[offset + 1] | this[offset] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
  };
  Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
  };
  Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee754$1.read(this, offset, true, 23, 4);
  };
  Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee754$1.read(this, offset, false, 23, 4);
  };
  Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee754$1.read(this, offset, true, 52, 8);
  };
  Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee754$1.read(this, offset, false, 52, 8);
  };
  function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer2.isBuffer(buf))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min)
      throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length)
      throw new RangeError("Index out of range");
  }
  Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset | 0;
    byteLength3 = byteLength3 | 0;
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset, byteLength3, maxBytes, 0);
    }
    var mul = 1;
    var i2 = 0;
    this[offset] = value & 255;
    while (++i2 < byteLength3 && (mul *= 256)) {
      this[offset + i2] = value / mul & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset | 0;
    byteLength3 = byteLength3 | 0;
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength3) - 1;
      checkInt(this, value, offset, byteLength3, maxBytes, 0);
    }
    var i2 = byteLength3 - 1;
    var mul = 1;
    this[offset + i2] = value & 255;
    while (--i2 >= 0 && (mul *= 256)) {
      this[offset + i2] = value / mul & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 255, 0);
    if (!Buffer2.TYPED_ARRAY_SUPPORT)
      value = Math.floor(value);
    this[offset] = value & 255;
    return offset + 1;
  };
  function objectWriteUInt16(buf, value, offset, littleEndian) {
    if (value < 0)
      value = 65535 + value + 1;
    for (var i2 = 0, j = Math.min(buf.length - offset, 2); i2 < j; ++i2) {
      buf[offset + i2] = (value & 255 << 8 * (littleEndian ? i2 : 1 - i2)) >>> (littleEndian ? i2 : 1 - i2) * 8;
    }
  }
  Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 65535, 0);
    if (Buffer2.TYPED_ARRAY_SUPPORT) {
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
    } else {
      objectWriteUInt16(this, value, offset, true);
    }
    return offset + 2;
  };
  Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 65535, 0);
    if (Buffer2.TYPED_ARRAY_SUPPORT) {
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
    } else {
      objectWriteUInt16(this, value, offset, false);
    }
    return offset + 2;
  };
  function objectWriteUInt32(buf, value, offset, littleEndian) {
    if (value < 0)
      value = 4294967295 + value + 1;
    for (var i2 = 0, j = Math.min(buf.length - offset, 4); i2 < j; ++i2) {
      buf[offset + i2] = value >>> (littleEndian ? i2 : 3 - i2) * 8 & 255;
    }
  }
  Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 4294967295, 0);
    if (Buffer2.TYPED_ARRAY_SUPPORT) {
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
    } else {
      objectWriteUInt32(this, value, offset, true);
    }
    return offset + 4;
  };
  Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 4294967295, 0);
    if (Buffer2.TYPED_ARRAY_SUPPORT) {
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
    } else {
      objectWriteUInt32(this, value, offset, false);
    }
    return offset + 4;
  };
  Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset, byteLength3, limit - 1, -limit);
    }
    var i2 = 0;
    var mul = 1;
    var sub2 = 0;
    this[offset] = value & 255;
    while (++i2 < byteLength3 && (mul *= 256)) {
      if (value < 0 && sub2 === 0 && this[offset + i2 - 1] !== 0) {
        sub2 = 1;
      }
      this[offset + i2] = (value / mul >> 0) - sub2 & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength3, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength3 - 1);
      checkInt(this, value, offset, byteLength3, limit - 1, -limit);
    }
    var i2 = byteLength3 - 1;
    var mul = 1;
    var sub2 = 0;
    this[offset + i2] = value & 255;
    while (--i2 >= 0 && (mul *= 256)) {
      if (value < 0 && sub2 === 0 && this[offset + i2 + 1] !== 0) {
        sub2 = 1;
      }
      this[offset + i2] = (value / mul >> 0) - sub2 & 255;
    }
    return offset + byteLength3;
  };
  Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 127, -128);
    if (!Buffer2.TYPED_ARRAY_SUPPORT)
      value = Math.floor(value);
    if (value < 0)
      value = 255 + value + 1;
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 32767, -32768);
    if (Buffer2.TYPED_ARRAY_SUPPORT) {
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
    } else {
      objectWriteUInt16(this, value, offset, true);
    }
    return offset + 2;
  };
  Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 32767, -32768);
    if (Buffer2.TYPED_ARRAY_SUPPORT) {
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
    } else {
      objectWriteUInt16(this, value, offset, false);
    }
    return offset + 2;
  };
  Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 2147483647, -2147483648);
    if (Buffer2.TYPED_ARRAY_SUPPORT) {
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
    } else {
      objectWriteUInt32(this, value, offset, true);
    }
    return offset + 4;
  };
  Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 2147483647, -2147483648);
    if (value < 0)
      value = 4294967295 + value + 1;
    if (Buffer2.TYPED_ARRAY_SUPPORT) {
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
    } else {
      objectWriteUInt32(this, value, offset, false);
    }
    return offset + 4;
  };
  function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length)
      throw new RangeError("Index out of range");
    if (offset < 0)
      throw new RangeError("Index out of range");
  }
  function writeFloat(buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4);
    }
    ieee754$1.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }
  Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
  };
  Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
  };
  function writeDouble(buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8);
    }
    ieee754$1.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }
  Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
  };
  Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
  };
  Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
    if (!start)
      start = 0;
    if (!end && end !== 0)
      end = this.length;
    if (targetStart >= target.length)
      targetStart = target.length;
    if (!targetStart)
      targetStart = 0;
    if (end > 0 && end < start)
      end = start;
    if (end === start)
      return 0;
    if (target.length === 0 || this.length === 0)
      return 0;
    if (targetStart < 0) {
      throw new RangeError("targetStart out of bounds");
    }
    if (start < 0 || start >= this.length)
      throw new RangeError("sourceStart out of bounds");
    if (end < 0)
      throw new RangeError("sourceEnd out of bounds");
    if (end > this.length)
      end = this.length;
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }
    var len = end - start;
    var i2;
    if (this === target && start < targetStart && targetStart < end) {
      for (i2 = len - 1; i2 >= 0; --i2) {
        target[i2 + targetStart] = this[i2 + start];
      }
    } else if (len < 1e3 || !Buffer2.TYPED_ARRAY_SUPPORT) {
      for (i2 = 0; i2 < len; ++i2) {
        target[i2 + targetStart] = this[i2 + start];
      }
    } else {
      Uint8Array.prototype.set.call(
        target,
        this.subarray(start, start + len),
        targetStart
      );
    }
    return len;
  };
  Buffer2.prototype.fill = function fill(val, start, end, encoding) {
    if (typeof val === "string") {
      if (typeof start === "string") {
        encoding = start;
        start = 0;
        end = this.length;
      } else if (typeof end === "string") {
        encoding = end;
        end = this.length;
      }
      if (val.length === 1) {
        var code2 = val.charCodeAt(0);
        if (code2 < 256) {
          val = code2;
        }
      }
      if (encoding !== void 0 && typeof encoding !== "string") {
        throw new TypeError("encoding must be a string");
      }
      if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
    } else if (typeof val === "number") {
      val = val & 255;
    }
    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError("Out of range index");
    }
    if (end <= start) {
      return this;
    }
    start = start >>> 0;
    end = end === void 0 ? this.length : end >>> 0;
    if (!val)
      val = 0;
    var i2;
    if (typeof val === "number") {
      for (i2 = start; i2 < end; ++i2) {
        this[i2] = val;
      }
    } else {
      var bytes = Buffer2.isBuffer(val) ? val : utf8ToBytes(new Buffer2(val, encoding).toString());
      var len = bytes.length;
      for (i2 = 0; i2 < end - start; ++i2) {
        this[i2 + start] = bytes[i2 % len];
      }
    }
    return this;
  };
  var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;
  function base64clean(str) {
    str = stringtrim(str).replace(INVALID_BASE64_RE, "");
    if (str.length < 2)
      return "";
    while (str.length % 4 !== 0) {
      str = str + "=";
    }
    return str;
  }
  function stringtrim(str) {
    if (str.trim)
      return str.trim();
    return str.replace(/^\s+|\s+$/g, "");
  }
  function toHex2(n2) {
    if (n2 < 16)
      return "0" + n2.toString(16);
    return n2.toString(16);
  }
  function utf8ToBytes(string, units) {
    units = units || Infinity;
    var codePoint;
    var length = string.length;
    var leadSurrogate = null;
    var bytes = [];
    for (var i2 = 0; i2 < length; ++i2) {
      codePoint = string.charCodeAt(i2);
      if (codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            continue;
          } else if (i2 + 1 === length) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 56320) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1)
          bytes.push(239, 191, 189);
      }
      leadSurrogate = null;
      if (codePoint < 128) {
        if ((units -= 1) < 0)
          break;
        bytes.push(codePoint);
      } else if (codePoint < 2048) {
        if ((units -= 2) < 0)
          break;
        bytes.push(
          codePoint >> 6 | 192,
          codePoint & 63 | 128
        );
      } else if (codePoint < 65536) {
        if ((units -= 3) < 0)
          break;
        bytes.push(
          codePoint >> 12 | 224,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else if (codePoint < 1114112) {
        if ((units -= 4) < 0)
          break;
        bytes.push(
          codePoint >> 18 | 240,
          codePoint >> 12 & 63 | 128,
          codePoint >> 6 & 63 | 128,
          codePoint & 63 | 128
        );
      } else {
        throw new Error("Invalid code point");
      }
    }
    return bytes;
  }
  function asciiToBytes(str) {
    var byteArray = [];
    for (var i2 = 0; i2 < str.length; ++i2) {
      byteArray.push(str.charCodeAt(i2) & 255);
    }
    return byteArray;
  }
  function utf16leToBytes(str, units) {
    var c2, hi, lo;
    var byteArray = [];
    for (var i2 = 0; i2 < str.length; ++i2) {
      if ((units -= 2) < 0)
        break;
      c2 = str.charCodeAt(i2);
      hi = c2 >> 8;
      lo = c2 % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }
    return byteArray;
  }
  function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
  }
  function blitBuffer(src, dst, offset, length) {
    for (var i2 = 0; i2 < length; ++i2) {
      if (i2 + offset >= dst.length || i2 >= src.length)
        break;
      dst[i2 + offset] = src[i2];
    }
    return i2;
  }
  function isnan(val) {
    return val !== val;
  }
})(buffer);
var crypto$1;
if (typeof window !== "undefined" && window.crypto) {
  crypto$1 = window.crypto;
}
if (!crypto$1 && typeof window !== "undefined" && window.msCrypto) {
  crypto$1 = window.msCrypto;
}
if (!crypto$1 && typeof global !== "undefined" && global.crypto) {
  crypto$1 = global.crypto;
}
if (!crypto$1 && typeof require === "function") {
  try {
    crypto$1 = require("crypto");
  } catch (err) {
  }
}
function cryptoSecureRandomInt() {
  if (crypto$1) {
    if (typeof crypto$1.getRandomValues === "function") {
      try {
        return crypto$1.getRandomValues(new Uint32Array(1))[0];
      } catch (err) {
      }
    }
    if (typeof crypto$1.randomBytes === "function") {
      try {
        return crypto$1.randomBytes(4).readInt32LE();
      } catch (err) {
      }
    }
  }
  throw new Error("Native crypto module could not be used to get secure random number.");
}
function hexStringify(wordArray) {
  var words = wordArray.words;
  var sigBytes = wordArray.sigBytes;
  var hexChars = [];
  for (var i2 = 0; i2 < sigBytes; i2++) {
    var bite = words[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255;
    hexChars.push((bite >>> 4).toString(16));
    hexChars.push((bite & 15).toString(16));
  }
  return hexChars.join("");
}
var WordArray = /* @__PURE__ */ function() {
  function WordArray2(words, sigBytes) {
    words = this.words = words || [];
    if (sigBytes != void 0) {
      this.sigBytes = sigBytes;
    } else {
      this.sigBytes = words.length * 4;
    }
  }
  var _proto = WordArray2.prototype;
  _proto.random = function random(nBytes) {
    var words = [];
    for (var i2 = 0; i2 < nBytes; i2 += 4) {
      words.push(cryptoSecureRandomInt());
    }
    return new WordArray2(words, nBytes);
  };
  _proto.toString = function toString3() {
    return hexStringify(this);
  };
  return WordArray2;
}();
function BigInteger(a3, b3) {
  if (a3 != null)
    this.fromString(a3, b3);
}
function nbi() {
  return new BigInteger(null);
}
var dbits;
var canary = 244837814094590;
var j_lm = (canary & 16777215) == 15715070;
function am1(i2, x2, w2, j, c2, n2) {
  while (--n2 >= 0) {
    var v = x2 * this[i2++] + w2[j] + c2;
    c2 = Math.floor(v / 67108864);
    w2[j++] = v & 67108863;
  }
  return c2;
}
function am2(i2, x2, w2, j, c2, n2) {
  var xl2 = x2 & 32767, xh = x2 >> 15;
  while (--n2 >= 0) {
    var l = this[i2] & 32767;
    var h4 = this[i2++] >> 15;
    var m3 = xh * l + h4 * xl2;
    l = xl2 * l + ((m3 & 32767) << 15) + w2[j] + (c2 & 1073741823);
    c2 = (l >>> 30) + (m3 >>> 15) + xh * h4 + (c2 >>> 30);
    w2[j++] = l & 1073741823;
  }
  return c2;
}
function am3(i2, x2, w2, j, c2, n2) {
  var xl2 = x2 & 16383, xh = x2 >> 14;
  while (--n2 >= 0) {
    var l = this[i2] & 16383;
    var h4 = this[i2++] >> 14;
    var m3 = xh * l + h4 * xl2;
    l = xl2 * l + ((m3 & 16383) << 14) + w2[j] + c2;
    c2 = (l >> 28) + (m3 >> 14) + xh * h4;
    w2[j++] = l & 268435455;
  }
  return c2;
}
var inBrowser = typeof navigator !== "undefined";
if (inBrowser && j_lm && navigator.appName == "Microsoft Internet Explorer") {
  BigInteger.prototype.am = am2;
  dbits = 30;
} else if (inBrowser && j_lm && navigator.appName != "Netscape") {
  BigInteger.prototype.am = am1;
  dbits = 26;
} else {
  BigInteger.prototype.am = am3;
  dbits = 28;
}
BigInteger.prototype.DB = dbits;
BigInteger.prototype.DM = (1 << dbits) - 1;
BigInteger.prototype.DV = 1 << dbits;
var BI_FP = 52;
BigInteger.prototype.FV = Math.pow(2, BI_FP);
BigInteger.prototype.F1 = BI_FP - dbits;
BigInteger.prototype.F2 = 2 * dbits - BI_FP;
var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
var BI_RC = new Array();
var rr$1, vv;
rr$1 = "0".charCodeAt(0);
for (vv = 0; vv <= 9; ++vv)
  BI_RC[rr$1++] = vv;
rr$1 = "a".charCodeAt(0);
for (vv = 10; vv < 36; ++vv)
  BI_RC[rr$1++] = vv;
rr$1 = "A".charCodeAt(0);
for (vv = 10; vv < 36; ++vv)
  BI_RC[rr$1++] = vv;
function int2char(n2) {
  return BI_RM.charAt(n2);
}
function intAt(s3, i2) {
  var c2 = BI_RC[s3.charCodeAt(i2)];
  return c2 == null ? -1 : c2;
}
function bnpCopyTo(r2) {
  for (var i2 = this.t - 1; i2 >= 0; --i2)
    r2[i2] = this[i2];
  r2.t = this.t;
  r2.s = this.s;
}
function bnpFromInt(x2) {
  this.t = 1;
  this.s = x2 < 0 ? -1 : 0;
  if (x2 > 0)
    this[0] = x2;
  else if (x2 < -1)
    this[0] = x2 + this.DV;
  else
    this.t = 0;
}
function nbv(i2) {
  var r2 = nbi();
  r2.fromInt(i2);
  return r2;
}
function bnpFromString(s3, b3) {
  var k2;
  if (b3 == 16)
    k2 = 4;
  else if (b3 == 8)
    k2 = 3;
  else if (b3 == 2)
    k2 = 1;
  else if (b3 == 32)
    k2 = 5;
  else if (b3 == 4)
    k2 = 2;
  else
    throw new Error("Only radix 2, 4, 8, 16, 32 are supported");
  this.t = 0;
  this.s = 0;
  var i2 = s3.length, mi = false, sh = 0;
  while (--i2 >= 0) {
    var x2 = intAt(s3, i2);
    if (x2 < 0) {
      if (s3.charAt(i2) == "-")
        mi = true;
      continue;
    }
    mi = false;
    if (sh == 0)
      this[this.t++] = x2;
    else if (sh + k2 > this.DB) {
      this[this.t - 1] |= (x2 & (1 << this.DB - sh) - 1) << sh;
      this[this.t++] = x2 >> this.DB - sh;
    } else
      this[this.t - 1] |= x2 << sh;
    sh += k2;
    if (sh >= this.DB)
      sh -= this.DB;
  }
  this.clamp();
  if (mi)
    BigInteger.ZERO.subTo(this, this);
}
function bnpClamp() {
  var c2 = this.s & this.DM;
  while (this.t > 0 && this[this.t - 1] == c2)
    --this.t;
}
function bnToString(b3) {
  if (this.s < 0)
    return "-" + this.negate().toString(b3);
  var k2;
  if (b3 == 16)
    k2 = 4;
  else if (b3 == 8)
    k2 = 3;
  else if (b3 == 2)
    k2 = 1;
  else if (b3 == 32)
    k2 = 5;
  else if (b3 == 4)
    k2 = 2;
  else
    throw new Error("Only radix 2, 4, 8, 16, 32 are supported");
  var km = (1 << k2) - 1, d3, m3 = false, r2 = "", i2 = this.t;
  var p2 = this.DB - i2 * this.DB % k2;
  if (i2-- > 0) {
    if (p2 < this.DB && (d3 = this[i2] >> p2) > 0) {
      m3 = true;
      r2 = int2char(d3);
    }
    while (i2 >= 0) {
      if (p2 < k2) {
        d3 = (this[i2] & (1 << p2) - 1) << k2 - p2;
        d3 |= this[--i2] >> (p2 += this.DB - k2);
      } else {
        d3 = this[i2] >> (p2 -= k2) & km;
        if (p2 <= 0) {
          p2 += this.DB;
          --i2;
        }
      }
      if (d3 > 0)
        m3 = true;
      if (m3)
        r2 += int2char(d3);
    }
  }
  return m3 ? r2 : "0";
}
function bnNegate() {
  var r2 = nbi();
  BigInteger.ZERO.subTo(this, r2);
  return r2;
}
function bnAbs() {
  return this.s < 0 ? this.negate() : this;
}
function bnCompareTo(a3) {
  var r2 = this.s - a3.s;
  if (r2 != 0)
    return r2;
  var i2 = this.t;
  r2 = i2 - a3.t;
  if (r2 != 0)
    return this.s < 0 ? -r2 : r2;
  while (--i2 >= 0)
    if ((r2 = this[i2] - a3[i2]) != 0)
      return r2;
  return 0;
}
function nbits(x2) {
  var r2 = 1, t3;
  if ((t3 = x2 >>> 16) != 0) {
    x2 = t3;
    r2 += 16;
  }
  if ((t3 = x2 >> 8) != 0) {
    x2 = t3;
    r2 += 8;
  }
  if ((t3 = x2 >> 4) != 0) {
    x2 = t3;
    r2 += 4;
  }
  if ((t3 = x2 >> 2) != 0) {
    x2 = t3;
    r2 += 2;
  }
  if ((t3 = x2 >> 1) != 0) {
    x2 = t3;
    r2 += 1;
  }
  return r2;
}
function bnBitLength() {
  if (this.t <= 0)
    return 0;
  return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ this.s & this.DM);
}
function bnpDLShiftTo(n2, r2) {
  var i2;
  for (i2 = this.t - 1; i2 >= 0; --i2)
    r2[i2 + n2] = this[i2];
  for (i2 = n2 - 1; i2 >= 0; --i2)
    r2[i2] = 0;
  r2.t = this.t + n2;
  r2.s = this.s;
}
function bnpDRShiftTo(n2, r2) {
  for (var i2 = n2; i2 < this.t; ++i2)
    r2[i2 - n2] = this[i2];
  r2.t = Math.max(this.t - n2, 0);
  r2.s = this.s;
}
function bnpLShiftTo(n2, r2) {
  var bs = n2 % this.DB;
  var cbs = this.DB - bs;
  var bm = (1 << cbs) - 1;
  var ds = Math.floor(n2 / this.DB), c2 = this.s << bs & this.DM, i2;
  for (i2 = this.t - 1; i2 >= 0; --i2) {
    r2[i2 + ds + 1] = this[i2] >> cbs | c2;
    c2 = (this[i2] & bm) << bs;
  }
  for (i2 = ds - 1; i2 >= 0; --i2)
    r2[i2] = 0;
  r2[ds] = c2;
  r2.t = this.t + ds + 1;
  r2.s = this.s;
  r2.clamp();
}
function bnpRShiftTo(n2, r2) {
  r2.s = this.s;
  var ds = Math.floor(n2 / this.DB);
  if (ds >= this.t) {
    r2.t = 0;
    return;
  }
  var bs = n2 % this.DB;
  var cbs = this.DB - bs;
  var bm = (1 << bs) - 1;
  r2[0] = this[ds] >> bs;
  for (var i2 = ds + 1; i2 < this.t; ++i2) {
    r2[i2 - ds - 1] |= (this[i2] & bm) << cbs;
    r2[i2 - ds] = this[i2] >> bs;
  }
  if (bs > 0)
    r2[this.t - ds - 1] |= (this.s & bm) << cbs;
  r2.t = this.t - ds;
  r2.clamp();
}
function bnpSubTo(a3, r2) {
  var i2 = 0, c2 = 0, m3 = Math.min(a3.t, this.t);
  while (i2 < m3) {
    c2 += this[i2] - a3[i2];
    r2[i2++] = c2 & this.DM;
    c2 >>= this.DB;
  }
  if (a3.t < this.t) {
    c2 -= a3.s;
    while (i2 < this.t) {
      c2 += this[i2];
      r2[i2++] = c2 & this.DM;
      c2 >>= this.DB;
    }
    c2 += this.s;
  } else {
    c2 += this.s;
    while (i2 < a3.t) {
      c2 -= a3[i2];
      r2[i2++] = c2 & this.DM;
      c2 >>= this.DB;
    }
    c2 -= a3.s;
  }
  r2.s = c2 < 0 ? -1 : 0;
  if (c2 < -1)
    r2[i2++] = this.DV + c2;
  else if (c2 > 0)
    r2[i2++] = c2;
  r2.t = i2;
  r2.clamp();
}
function bnpMultiplyTo(a3, r2) {
  var x2 = this.abs(), y3 = a3.abs();
  var i2 = x2.t;
  r2.t = i2 + y3.t;
  while (--i2 >= 0)
    r2[i2] = 0;
  for (i2 = 0; i2 < y3.t; ++i2)
    r2[i2 + x2.t] = x2.am(0, y3[i2], r2, i2, 0, x2.t);
  r2.s = 0;
  r2.clamp();
  if (this.s != a3.s)
    BigInteger.ZERO.subTo(r2, r2);
}
function bnpSquareTo(r2) {
  var x2 = this.abs();
  var i2 = r2.t = 2 * x2.t;
  while (--i2 >= 0)
    r2[i2] = 0;
  for (i2 = 0; i2 < x2.t - 1; ++i2) {
    var c2 = x2.am(i2, x2[i2], r2, 2 * i2, 0, 1);
    if ((r2[i2 + x2.t] += x2.am(i2 + 1, 2 * x2[i2], r2, 2 * i2 + 1, c2, x2.t - i2 - 1)) >= x2.DV) {
      r2[i2 + x2.t] -= x2.DV;
      r2[i2 + x2.t + 1] = 1;
    }
  }
  if (r2.t > 0)
    r2[r2.t - 1] += x2.am(i2, x2[i2], r2, 2 * i2, 0, 1);
  r2.s = 0;
  r2.clamp();
}
function bnpDivRemTo(m3, q2, r2) {
  var pm = m3.abs();
  if (pm.t <= 0)
    return;
  var pt = this.abs();
  if (pt.t < pm.t) {
    if (q2 != null)
      q2.fromInt(0);
    if (r2 != null)
      this.copyTo(r2);
    return;
  }
  if (r2 == null)
    r2 = nbi();
  var y3 = nbi(), ts = this.s, ms = m3.s;
  var nsh = this.DB - nbits(pm[pm.t - 1]);
  if (nsh > 0) {
    pm.lShiftTo(nsh, y3);
    pt.lShiftTo(nsh, r2);
  } else {
    pm.copyTo(y3);
    pt.copyTo(r2);
  }
  var ys = y3.t;
  var y0 = y3[ys - 1];
  if (y0 == 0)
    return;
  var yt = y0 * (1 << this.F1) + (ys > 1 ? y3[ys - 2] >> this.F2 : 0);
  var d1 = this.FV / yt, d22 = (1 << this.F1) / yt, e3 = 1 << this.F2;
  var i2 = r2.t, j = i2 - ys, t3 = q2 == null ? nbi() : q2;
  y3.dlShiftTo(j, t3);
  if (r2.compareTo(t3) >= 0) {
    r2[r2.t++] = 1;
    r2.subTo(t3, r2);
  }
  BigInteger.ONE.dlShiftTo(ys, t3);
  t3.subTo(y3, y3);
  while (y3.t < ys)
    y3[y3.t++] = 0;
  while (--j >= 0) {
    var qd = r2[--i2] == y0 ? this.DM : Math.floor(r2[i2] * d1 + (r2[i2 - 1] + e3) * d22);
    if ((r2[i2] += y3.am(0, qd, r2, j, 0, ys)) < qd) {
      y3.dlShiftTo(j, t3);
      r2.subTo(t3, r2);
      while (r2[i2] < --qd)
        r2.subTo(t3, r2);
    }
  }
  if (q2 != null) {
    r2.drShiftTo(ys, q2);
    if (ts != ms)
      BigInteger.ZERO.subTo(q2, q2);
  }
  r2.t = ys;
  r2.clamp();
  if (nsh > 0)
    r2.rShiftTo(nsh, r2);
  if (ts < 0)
    BigInteger.ZERO.subTo(r2, r2);
}
function bnMod(a3) {
  var r2 = nbi();
  this.abs().divRemTo(a3, null, r2);
  if (this.s < 0 && r2.compareTo(BigInteger.ZERO) > 0)
    a3.subTo(r2, r2);
  return r2;
}
function bnpInvDigit() {
  if (this.t < 1)
    return 0;
  var x2 = this[0];
  if ((x2 & 1) == 0)
    return 0;
  var y3 = x2 & 3;
  y3 = y3 * (2 - (x2 & 15) * y3) & 15;
  y3 = y3 * (2 - (x2 & 255) * y3) & 255;
  y3 = y3 * (2 - ((x2 & 65535) * y3 & 65535)) & 65535;
  y3 = y3 * (2 - x2 * y3 % this.DV) % this.DV;
  return y3 > 0 ? this.DV - y3 : -y3;
}
function bnEquals(a3) {
  return this.compareTo(a3) == 0;
}
function bnpAddTo(a3, r2) {
  var i2 = 0, c2 = 0, m3 = Math.min(a3.t, this.t);
  while (i2 < m3) {
    c2 += this[i2] + a3[i2];
    r2[i2++] = c2 & this.DM;
    c2 >>= this.DB;
  }
  if (a3.t < this.t) {
    c2 += a3.s;
    while (i2 < this.t) {
      c2 += this[i2];
      r2[i2++] = c2 & this.DM;
      c2 >>= this.DB;
    }
    c2 += this.s;
  } else {
    c2 += this.s;
    while (i2 < a3.t) {
      c2 += a3[i2];
      r2[i2++] = c2 & this.DM;
      c2 >>= this.DB;
    }
    c2 += a3.s;
  }
  r2.s = c2 < 0 ? -1 : 0;
  if (c2 > 0)
    r2[i2++] = c2;
  else if (c2 < -1)
    r2[i2++] = this.DV + c2;
  r2.t = i2;
  r2.clamp();
}
function bnAdd(a3) {
  var r2 = nbi();
  this.addTo(a3, r2);
  return r2;
}
function bnSubtract(a3) {
  var r2 = nbi();
  this.subTo(a3, r2);
  return r2;
}
function bnMultiply(a3) {
  var r2 = nbi();
  this.multiplyTo(a3, r2);
  return r2;
}
function bnDivide(a3) {
  var r2 = nbi();
  this.divRemTo(a3, r2, null);
  return r2;
}
function Montgomery(m3) {
  this.m = m3;
  this.mp = m3.invDigit();
  this.mpl = this.mp & 32767;
  this.mph = this.mp >> 15;
  this.um = (1 << m3.DB - 15) - 1;
  this.mt2 = 2 * m3.t;
}
function montConvert(x2) {
  var r2 = nbi();
  x2.abs().dlShiftTo(this.m.t, r2);
  r2.divRemTo(this.m, null, r2);
  if (x2.s < 0 && r2.compareTo(BigInteger.ZERO) > 0)
    this.m.subTo(r2, r2);
  return r2;
}
function montRevert(x2) {
  var r2 = nbi();
  x2.copyTo(r2);
  this.reduce(r2);
  return r2;
}
function montReduce(x2) {
  while (x2.t <= this.mt2)
    x2[x2.t++] = 0;
  for (var i2 = 0; i2 < this.m.t; ++i2) {
    var j = x2[i2] & 32767;
    var u0 = j * this.mpl + ((j * this.mph + (x2[i2] >> 15) * this.mpl & this.um) << 15) & x2.DM;
    j = i2 + this.m.t;
    x2[j] += this.m.am(0, u0, x2, i2, 0, this.m.t);
    while (x2[j] >= x2.DV) {
      x2[j] -= x2.DV;
      x2[++j]++;
    }
  }
  x2.clamp();
  x2.drShiftTo(this.m.t, x2);
  if (x2.compareTo(this.m) >= 0)
    x2.subTo(this.m, x2);
}
function montSqrTo(x2, r2) {
  x2.squareTo(r2);
  this.reduce(r2);
}
function montMulTo(x2, y3, r2) {
  x2.multiplyTo(y3, r2);
  this.reduce(r2);
}
Montgomery.prototype.convert = montConvert;
Montgomery.prototype.revert = montRevert;
Montgomery.prototype.reduce = montReduce;
Montgomery.prototype.mulTo = montMulTo;
Montgomery.prototype.sqrTo = montSqrTo;
function bnModPow(e3, m3, callback) {
  var i2 = e3.bitLength(), k2, r2 = nbv(1), z2 = new Montgomery(m3);
  if (i2 <= 0)
    return r2;
  else if (i2 < 18)
    k2 = 1;
  else if (i2 < 48)
    k2 = 3;
  else if (i2 < 144)
    k2 = 4;
  else if (i2 < 768)
    k2 = 5;
  else
    k2 = 6;
  var g = new Array(), n2 = 3, k1 = k2 - 1, km = (1 << k2) - 1;
  g[1] = z2.convert(this);
  if (k2 > 1) {
    var g2 = nbi();
    z2.sqrTo(g[1], g2);
    while (n2 <= km) {
      g[n2] = nbi();
      z2.mulTo(g2, g[n2 - 2], g[n2]);
      n2 += 2;
    }
  }
  var j = e3.t - 1, w2, is1 = true, r22 = nbi(), t3;
  i2 = nbits(e3[j]) - 1;
  while (j >= 0) {
    if (i2 >= k1)
      w2 = e3[j] >> i2 - k1 & km;
    else {
      w2 = (e3[j] & (1 << i2 + 1) - 1) << k1 - i2;
      if (j > 0)
        w2 |= e3[j - 1] >> this.DB + i2 - k1;
    }
    n2 = k2;
    while ((w2 & 1) == 0) {
      w2 >>= 1;
      --n2;
    }
    if ((i2 -= n2) < 0) {
      i2 += this.DB;
      --j;
    }
    if (is1) {
      g[w2].copyTo(r2);
      is1 = false;
    } else {
      while (n2 > 1) {
        z2.sqrTo(r2, r22);
        z2.sqrTo(r22, r2);
        n2 -= 2;
      }
      if (n2 > 0)
        z2.sqrTo(r2, r22);
      else {
        t3 = r2;
        r2 = r22;
        r22 = t3;
      }
      z2.mulTo(r22, g[w2], r2);
    }
    while (j >= 0 && (e3[j] & 1 << i2) == 0) {
      z2.sqrTo(r2, r22);
      t3 = r2;
      r2 = r22;
      r22 = t3;
      if (--i2 < 0) {
        i2 = this.DB - 1;
        --j;
      }
    }
  }
  var result = z2.revert(r2);
  callback(null, result);
  return result;
}
BigInteger.prototype.copyTo = bnpCopyTo;
BigInteger.prototype.fromInt = bnpFromInt;
BigInteger.prototype.fromString = bnpFromString;
BigInteger.prototype.clamp = bnpClamp;
BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
BigInteger.prototype.drShiftTo = bnpDRShiftTo;
BigInteger.prototype.lShiftTo = bnpLShiftTo;
BigInteger.prototype.rShiftTo = bnpRShiftTo;
BigInteger.prototype.subTo = bnpSubTo;
BigInteger.prototype.multiplyTo = bnpMultiplyTo;
BigInteger.prototype.squareTo = bnpSquareTo;
BigInteger.prototype.divRemTo = bnpDivRemTo;
BigInteger.prototype.invDigit = bnpInvDigit;
BigInteger.prototype.addTo = bnpAddTo;
BigInteger.prototype.toString = bnToString;
BigInteger.prototype.negate = bnNegate;
BigInteger.prototype.abs = bnAbs;
BigInteger.prototype.compareTo = bnCompareTo;
BigInteger.prototype.bitLength = bnBitLength;
BigInteger.prototype.mod = bnMod;
BigInteger.prototype.equals = bnEquals;
BigInteger.prototype.add = bnAdd;
BigInteger.prototype.subtract = bnSubtract;
BigInteger.prototype.multiply = bnMultiply;
BigInteger.prototype.divide = bnDivide;
BigInteger.prototype.modPow = bnModPow;
BigInteger.ZERO = nbv(0);
BigInteger.ONE = nbv(1);
/*!
 * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * SPDX-License-Identifier: Apache-2.0
 */
function randomBytes(nBytes) {
  return buffer.Buffer.from(new WordArray().random(nBytes).toString(), "hex");
}
var HEX_MSB_REGEX = /^[89a-f]/i;
var initN = "FFFFFFFFFFFFFFFFC90FDAA22168C234C4C6628B80DC1CD129024E088A67CC74020BBEA63B139B22514A08798E3404DDEF9519B3CD3A431B302B0A6DF25F14374FE1356D6D51C245E485B576625E7EC6F44C42E9A637ED6B0BFF5CB6F406B7EDEE386BFB5A899FA5AE9F24117C4B1FE649286651ECE45B3DC2007CB8A163BF0598DA48361C55D39A69163FA8FD24CF5F83655D23DCA3AD961C62F356208552BB9ED529077096966D670C354E4ABC9804F1746C08CA18217C32905E462E36CE3BE39E772C180E86039B2783A2EC07A28FB5C55DF06F4C52C9DE2BCBF6955817183995497CEA956AE515D2261898FA051015728E5A8AAAC42DAD33170D04507A33A85521ABDF1CBA64ECFB850458DBEF0A8AEA71575D060C7DB3970F85A6E1E4C7ABF5AE8CDB0933D71E8C94E04A25619DCEE3D2261AD2EE6BF12FFA06D98A0864D87602733EC86A64521F2B18177B200CBBE117577A615D6C770988C0BAD946E208E24FA074E5AB3143DB5BFCE0FD108E4B82D120A93AD2CAFFFFFFFFFFFFFFFF";
var newPasswordRequiredChallengeUserAttributePrefix = "userAttributes.";
var AuthenticationHelper = /* @__PURE__ */ function() {
  function AuthenticationHelper2(PoolName) {
    this.N = new BigInteger(initN, 16);
    this.g = new BigInteger("2", 16);
    this.k = new BigInteger(this.hexHash("" + this.padHex(this.N) + this.padHex(this.g)), 16);
    this.smallAValue = this.generateRandomSmallA();
    this.getLargeAValue(function() {
    });
    this.infoBits = buffer.Buffer.from("Caldera Derived Key", "utf8");
    this.poolName = PoolName;
  }
  var _proto = AuthenticationHelper2.prototype;
  _proto.getSmallAValue = function getSmallAValue() {
    return this.smallAValue;
  };
  _proto.getLargeAValue = function getLargeAValue(callback) {
    var _this = this;
    if (this.largeAValue) {
      callback(null, this.largeAValue);
    } else {
      this.calculateA(this.smallAValue, function(err, largeAValue) {
        if (err) {
          callback(err, null);
        }
        _this.largeAValue = largeAValue;
        callback(null, _this.largeAValue);
      });
    }
  };
  _proto.generateRandomSmallA = function generateRandomSmallA() {
    var hexRandom = randomBytes(128).toString("hex");
    var randomBigInt = new BigInteger(hexRandom, 16);
    return randomBigInt;
  };
  _proto.generateRandomString = function generateRandomString() {
    return randomBytes(40).toString("base64");
  };
  _proto.getRandomPassword = function getRandomPassword() {
    return this.randomPassword;
  };
  _proto.getSaltDevices = function getSaltDevices() {
    return this.SaltToHashDevices;
  };
  _proto.getVerifierDevices = function getVerifierDevices() {
    return this.verifierDevices;
  };
  _proto.generateHashDevice = function generateHashDevice(deviceGroupKey, username, callback) {
    var _this2 = this;
    this.randomPassword = this.generateRandomString();
    var combinedString = "" + deviceGroupKey + username + ":" + this.randomPassword;
    var hashedString = this.hash(combinedString);
    var hexRandom = randomBytes(16).toString("hex");
    this.SaltToHashDevices = this.padHex(new BigInteger(hexRandom, 16));
    this.g.modPow(new BigInteger(this.hexHash(this.SaltToHashDevices + hashedString), 16), this.N, function(err, verifierDevicesNotPadded) {
      if (err) {
        callback(err, null);
      }
      _this2.verifierDevices = _this2.padHex(verifierDevicesNotPadded);
      callback(null, null);
    });
  };
  _proto.calculateA = function calculateA(a3, callback) {
    var _this3 = this;
    this.g.modPow(a3, this.N, function(err, A) {
      if (err) {
        callback(err, null);
      }
      if (A.mod(_this3.N).equals(BigInteger.ZERO)) {
        callback(new Error("Illegal paramater. A mod N cannot be 0."), null);
      }
      callback(null, A);
    });
  };
  _proto.calculateU = function calculateU(A, B2) {
    this.UHexHash = this.hexHash(this.padHex(A) + this.padHex(B2));
    var finalU = new BigInteger(this.UHexHash, 16);
    return finalU;
  };
  _proto.hash = function hash2(buf) {
    var awsCryptoHash = new build$4.Sha256();
    awsCryptoHash.update(buf);
    var resultFromAWSCrypto = awsCryptoHash.digestSync();
    var hashHex = buffer.Buffer.from(resultFromAWSCrypto).toString("hex");
    return new Array(64 - hashHex.length).join("0") + hashHex;
  };
  _proto.hexHash = function hexHash(hexStr) {
    return this.hash(buffer.Buffer.from(hexStr, "hex"));
  };
  _proto.computehkdf = function computehkdf(ikm, salt) {
    var infoBitsBuffer = buffer.Buffer.concat([this.infoBits, buffer.Buffer.from(String.fromCharCode(1), "utf8")]);
    var awsCryptoHash = new build$4.Sha256(salt);
    awsCryptoHash.update(ikm);
    var resultFromAWSCryptoPrk = awsCryptoHash.digestSync();
    var awsCryptoHashHmac = new build$4.Sha256(resultFromAWSCryptoPrk);
    awsCryptoHashHmac.update(infoBitsBuffer);
    var resultFromAWSCryptoHmac = awsCryptoHashHmac.digestSync();
    var hashHexFromAWSCrypto = resultFromAWSCryptoHmac;
    var currentHex = hashHexFromAWSCrypto.slice(0, 16);
    return currentHex;
  };
  _proto.getPasswordAuthenticationKey = function getPasswordAuthenticationKey(username, password, serverBValue, salt, callback) {
    var _this4 = this;
    if (serverBValue.mod(this.N).equals(BigInteger.ZERO)) {
      throw new Error("B cannot be zero.");
    }
    this.UValue = this.calculateU(this.largeAValue, serverBValue);
    if (this.UValue.equals(BigInteger.ZERO)) {
      throw new Error("U cannot be zero.");
    }
    var usernamePassword = "" + this.poolName + username + ":" + password;
    var usernamePasswordHash = this.hash(usernamePassword);
    var xValue = new BigInteger(this.hexHash(this.padHex(salt) + usernamePasswordHash), 16);
    this.calculateS(xValue, serverBValue, function(err, sValue) {
      if (err) {
        callback(err, null);
      }
      var hkdf = _this4.computehkdf(buffer.Buffer.from(_this4.padHex(sValue), "hex"), buffer.Buffer.from(_this4.padHex(_this4.UValue), "hex"));
      callback(null, hkdf);
    });
  };
  _proto.calculateS = function calculateS(xValue, serverBValue, callback) {
    var _this5 = this;
    this.g.modPow(xValue, this.N, function(err, gModPowXN) {
      if (err) {
        callback(err, null);
      }
      var intValue2 = serverBValue.subtract(_this5.k.multiply(gModPowXN));
      intValue2.modPow(_this5.smallAValue.add(_this5.UValue.multiply(xValue)), _this5.N, function(err2, result) {
        if (err2) {
          callback(err2, null);
        }
        callback(null, result.mod(_this5.N));
      });
    });
  };
  _proto.getNewPasswordRequiredChallengeUserAttributePrefix = function getNewPasswordRequiredChallengeUserAttributePrefix() {
    return newPasswordRequiredChallengeUserAttributePrefix;
  };
  _proto.padHex = function padHex(bigInt) {
    if (!(bigInt instanceof BigInteger)) {
      throw new Error("Not a BigInteger");
    }
    var isNegative = bigInt.compareTo(BigInteger.ZERO) < 0;
    var hexStr = bigInt.abs().toString(16);
    hexStr = hexStr.length % 2 !== 0 ? "0" + hexStr : hexStr;
    hexStr = HEX_MSB_REGEX.test(hexStr) ? "00" + hexStr : hexStr;
    if (isNegative) {
      var invertedNibbles = hexStr.split("").map(function(x2) {
        var invertedNibble = ~parseInt(x2, 16) & 15;
        return "0123456789ABCDEF".charAt(invertedNibble);
      }).join("");
      var flippedBitsBI = new BigInteger(invertedNibbles, 16).add(BigInteger.ONE);
      hexStr = flippedBitsBI.toString(16);
      if (hexStr.toUpperCase().startsWith("FF8")) {
        hexStr = hexStr.substring(2);
      }
    }
    return hexStr;
  };
  return AuthenticationHelper2;
}();
/*!
 * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * SPDX-License-Identifier: Apache-2.0
 */
var CognitoJwtToken = /* @__PURE__ */ function() {
  function CognitoJwtToken2(token) {
    this.jwtToken = token || "";
    this.payload = this.decodePayload();
  }
  var _proto = CognitoJwtToken2.prototype;
  _proto.getJwtToken = function getJwtToken() {
    return this.jwtToken;
  };
  _proto.getExpiration = function getExpiration() {
    return this.payload.exp;
  };
  _proto.getIssuedAt = function getIssuedAt() {
    return this.payload.iat;
  };
  _proto.decodePayload = function decodePayload() {
    var payload = this.jwtToken.split(".")[1];
    try {
      return JSON.parse(buffer.Buffer.from(payload, "base64").toString("utf8"));
    } catch (err) {
      return {};
    }
  };
  return CognitoJwtToken2;
}();
function _inheritsLoose$2(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf$y(subClass, superClass);
}
function _setPrototypeOf$y(o2, p2) {
  _setPrototypeOf$y = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf$y(o2, p2);
}
var CognitoAccessToken = /* @__PURE__ */ function(_CognitoJwtToken) {
  _inheritsLoose$2(CognitoAccessToken2, _CognitoJwtToken);
  function CognitoAccessToken2(_temp) {
    var _ref = _temp === void 0 ? {} : _temp, AccessToken = _ref.AccessToken;
    return _CognitoJwtToken.call(this, AccessToken || "") || this;
  }
  return CognitoAccessToken2;
}(CognitoJwtToken);
function _inheritsLoose$1(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf$x(subClass, superClass);
}
function _setPrototypeOf$x(o2, p2) {
  _setPrototypeOf$x = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf$x(o2, p2);
}
var CognitoIdToken = /* @__PURE__ */ function(_CognitoJwtToken) {
  _inheritsLoose$1(CognitoIdToken2, _CognitoJwtToken);
  function CognitoIdToken2(_temp) {
    var _ref = _temp === void 0 ? {} : _temp, IdToken = _ref.IdToken;
    return _CognitoJwtToken.call(this, IdToken || "") || this;
  }
  return CognitoIdToken2;
}(CognitoJwtToken);
/*!
 * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * SPDX-License-Identifier: Apache-2.0
 */
var CognitoRefreshToken = /* @__PURE__ */ function() {
  function CognitoRefreshToken2(_temp) {
    var _ref = _temp === void 0 ? {} : _temp, RefreshToken = _ref.RefreshToken;
    this.token = RefreshToken || "";
  }
  var _proto = CognitoRefreshToken2.prototype;
  _proto.getToken = function getToken() {
    return this.token;
  };
  return CognitoRefreshToken2;
}();
var version$1 = "5.0.4";
/*!
 * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * SPDX-License-Identifier: Apache-2.0
 */
var BASE_USER_AGENT = "aws-amplify/" + version$1;
var Platform = {
  userAgent: BASE_USER_AGENT + " js",
  product: "",
  navigator: null,
  isReactNative: false
};
if (typeof navigator !== "undefined" && navigator.product) {
  Platform.product = navigator.product || "";
  Platform.navigator = navigator || null;
  switch (navigator.product) {
    case "ReactNative":
      Platform.userAgent = BASE_USER_AGENT + " react-native";
      Platform.isReactNative = true;
      break;
    default:
      Platform.userAgent = BASE_USER_AGENT + " js";
      Platform.isReactNative = false;
      break;
  }
}
var getUserAgent = function getUserAgent2() {
  return Platform.userAgent;
};
/*!
 * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * SPDX-License-Identifier: Apache-2.0
 */
var CognitoUserSession = /* @__PURE__ */ function() {
  function CognitoUserSession2(_temp) {
    var _ref = _temp === void 0 ? {} : _temp, IdToken = _ref.IdToken, RefreshToken = _ref.RefreshToken, AccessToken = _ref.AccessToken, ClockDrift = _ref.ClockDrift;
    if (AccessToken == null || IdToken == null) {
      throw new Error("Id token and Access Token must be present.");
    }
    this.idToken = IdToken;
    this.refreshToken = RefreshToken;
    this.accessToken = AccessToken;
    this.clockDrift = ClockDrift === void 0 ? this.calculateClockDrift() : ClockDrift;
  }
  var _proto = CognitoUserSession2.prototype;
  _proto.getIdToken = function getIdToken() {
    return this.idToken;
  };
  _proto.getRefreshToken = function getRefreshToken() {
    return this.refreshToken;
  };
  _proto.getAccessToken = function getAccessToken() {
    return this.accessToken;
  };
  _proto.getClockDrift = function getClockDrift() {
    return this.clockDrift;
  };
  _proto.calculateClockDrift = function calculateClockDrift() {
    var now = Math.floor(new Date() / 1e3);
    var iat = Math.min(this.accessToken.getIssuedAt(), this.idToken.getIssuedAt());
    return now - iat;
  };
  _proto.isValid = function isValid2() {
    var now = Math.floor(new Date() / 1e3);
    var adjusted = now - this.clockDrift;
    return adjusted < this.accessToken.getExpiration() && adjusted < this.idToken.getExpiration();
  };
  return CognitoUserSession2;
}();
/*!
 * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * SPDX-License-Identifier: Apache-2.0
 */
var monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
var weekNames = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
var DateHelper = /* @__PURE__ */ function() {
  function DateHelper2() {
  }
  var _proto = DateHelper2.prototype;
  _proto.getNowString = function getNowString() {
    var now = new Date();
    var weekDay = weekNames[now.getUTCDay()];
    var month = monthNames[now.getUTCMonth()];
    var day = now.getUTCDate();
    var hours = now.getUTCHours();
    if (hours < 10) {
      hours = "0" + hours;
    }
    var minutes = now.getUTCMinutes();
    if (minutes < 10) {
      minutes = "0" + minutes;
    }
    var seconds = now.getUTCSeconds();
    if (seconds < 10) {
      seconds = "0" + seconds;
    }
    var year = now.getUTCFullYear();
    var dateNow = weekDay + " " + month + " " + day + " " + hours + ":" + minutes + ":" + seconds + " UTC " + year;
    return dateNow;
  };
  return DateHelper2;
}();
/*!
 * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * SPDX-License-Identifier: Apache-2.0
 */
var CognitoUserAttribute = /* @__PURE__ */ function() {
  function CognitoUserAttribute2(_temp) {
    var _ref = _temp === void 0 ? {} : _temp, Name = _ref.Name, Value = _ref.Value;
    this.Name = Name || "";
    this.Value = Value || "";
  }
  var _proto = CognitoUserAttribute2.prototype;
  _proto.getValue = function getValue() {
    return this.Value;
  };
  _proto.setValue = function setValue(value) {
    this.Value = value;
    return this;
  };
  _proto.getName = function getName() {
    return this.Name;
  };
  _proto.setName = function setName(name2) {
    this.Name = name2;
    return this;
  };
  _proto.toString = function toString3() {
    return JSON.stringify(this);
  };
  _proto.toJSON = function toJSON2() {
    return {
      Name: this.Name,
      Value: this.Value
    };
  };
  return CognitoUserAttribute2;
}();
/*!
 * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * SPDX-License-Identifier: Apache-2.0
 */
var dataMemory = {};
var MemoryStorage = /* @__PURE__ */ function() {
  function MemoryStorage2() {
  }
  MemoryStorage2.setItem = function setItem(key, value) {
    dataMemory[key] = value;
    return dataMemory[key];
  };
  MemoryStorage2.getItem = function getItem(key) {
    return Object.prototype.hasOwnProperty.call(dataMemory, key) ? dataMemory[key] : void 0;
  };
  MemoryStorage2.removeItem = function removeItem(key) {
    return delete dataMemory[key];
  };
  MemoryStorage2.clear = function clear2() {
    dataMemory = {};
    return dataMemory;
  };
  return MemoryStorage2;
}();
var StorageHelper = /* @__PURE__ */ function() {
  function StorageHelper2() {
    try {
      this.storageWindow = window.localStorage;
      this.storageWindow.setItem("aws.cognito.test-ls", 1);
      this.storageWindow.removeItem("aws.cognito.test-ls");
    } catch (exception) {
      this.storageWindow = MemoryStorage;
    }
  }
  var _proto = StorageHelper2.prototype;
  _proto.getStorage = function getStorage() {
    return this.storageWindow;
  };
  return StorageHelper2;
}();
/*!
 * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * SPDX-License-Identifier: Apache-2.0
 */
var isNavigatorAvailable = typeof navigator !== "undefined";
var userAgent = isNavigatorAvailable ? Platform.isReactNative ? "react-native" : navigator.userAgent : "nodejs";
var CognitoUser = /* @__PURE__ */ function() {
  function CognitoUser2(data) {
    if (data == null || data.Username == null || data.Pool == null) {
      throw new Error("Username and Pool information are required.");
    }
    this.username = data.Username || "";
    this.pool = data.Pool;
    this.Session = null;
    this.client = data.Pool.client;
    this.signInUserSession = null;
    this.authenticationFlowType = "USER_SRP_AUTH";
    this.storage = data.Storage || new StorageHelper().getStorage();
    this.keyPrefix = "CognitoIdentityServiceProvider." + this.pool.getClientId();
    this.userDataKey = this.keyPrefix + "." + this.username + ".userData";
  }
  var _proto = CognitoUser2.prototype;
  _proto.setSignInUserSession = function setSignInUserSession(signInUserSession) {
    this.clearCachedUserData();
    this.signInUserSession = signInUserSession;
    this.cacheTokens();
  };
  _proto.getSignInUserSession = function getSignInUserSession() {
    return this.signInUserSession;
  };
  _proto.getUsername = function getUsername() {
    return this.username;
  };
  _proto.getAuthenticationFlowType = function getAuthenticationFlowType() {
    return this.authenticationFlowType;
  };
  _proto.setAuthenticationFlowType = function setAuthenticationFlowType(authenticationFlowType) {
    this.authenticationFlowType = authenticationFlowType;
  };
  _proto.initiateAuth = function initiateAuth(authDetails, callback) {
    var _this = this;
    var authParameters = authDetails.getAuthParameters();
    authParameters.USERNAME = this.username;
    var clientMetaData = Object.keys(authDetails.getValidationData()).length !== 0 ? authDetails.getValidationData() : authDetails.getClientMetadata();
    var jsonReq = {
      AuthFlow: "CUSTOM_AUTH",
      ClientId: this.pool.getClientId(),
      AuthParameters: authParameters,
      ClientMetadata: clientMetaData
    };
    if (this.getUserContextData()) {
      jsonReq.UserContextData = this.getUserContextData();
    }
    this.client.request("InitiateAuth", jsonReq, function(err, data) {
      if (err) {
        return callback.onFailure(err);
      }
      var challengeName = data.ChallengeName;
      var challengeParameters = data.ChallengeParameters;
      if (challengeName === "CUSTOM_CHALLENGE") {
        _this.Session = data.Session;
        return callback.customChallenge(challengeParameters);
      }
      _this.signInUserSession = _this.getCognitoUserSession(data.AuthenticationResult);
      _this.cacheTokens();
      return callback.onSuccess(_this.signInUserSession);
    });
  };
  _proto.authenticateUser = function authenticateUser(authDetails, callback) {
    if (this.authenticationFlowType === "USER_PASSWORD_AUTH") {
      return this.authenticateUserPlainUsernamePassword(authDetails, callback);
    } else if (this.authenticationFlowType === "USER_SRP_AUTH" || this.authenticationFlowType === "CUSTOM_AUTH") {
      return this.authenticateUserDefaultAuth(authDetails, callback);
    }
    return callback.onFailure(new Error("Authentication flow type is invalid."));
  };
  _proto.authenticateUserDefaultAuth = function authenticateUserDefaultAuth(authDetails, callback) {
    var _this2 = this;
    var authenticationHelper = new AuthenticationHelper(this.pool.getUserPoolName());
    var dateHelper = new DateHelper();
    var serverBValue;
    var salt;
    var authParameters = {};
    if (this.deviceKey != null) {
      authParameters.DEVICE_KEY = this.deviceKey;
    }
    authParameters.USERNAME = this.username;
    authenticationHelper.getLargeAValue(function(errOnAValue, aValue) {
      if (errOnAValue) {
        callback.onFailure(errOnAValue);
      }
      authParameters.SRP_A = aValue.toString(16);
      if (_this2.authenticationFlowType === "CUSTOM_AUTH") {
        authParameters.CHALLENGE_NAME = "SRP_A";
      }
      var clientMetaData = Object.keys(authDetails.getValidationData()).length !== 0 ? authDetails.getValidationData() : authDetails.getClientMetadata();
      var jsonReq = {
        AuthFlow: _this2.authenticationFlowType,
        ClientId: _this2.pool.getClientId(),
        AuthParameters: authParameters,
        ClientMetadata: clientMetaData
      };
      if (_this2.getUserContextData(_this2.username)) {
        jsonReq.UserContextData = _this2.getUserContextData(_this2.username);
      }
      _this2.client.request("InitiateAuth", jsonReq, function(err, data) {
        if (err) {
          return callback.onFailure(err);
        }
        var challengeParameters = data.ChallengeParameters;
        _this2.username = challengeParameters.USER_ID_FOR_SRP;
        _this2.userDataKey = _this2.keyPrefix + "." + _this2.username + ".userData";
        serverBValue = new BigInteger(challengeParameters.SRP_B, 16);
        salt = new BigInteger(challengeParameters.SALT, 16);
        _this2.getCachedDeviceKeyAndPassword();
        authenticationHelper.getPasswordAuthenticationKey(_this2.username, authDetails.getPassword(), serverBValue, salt, function(errOnHkdf, hkdf) {
          if (errOnHkdf) {
            callback.onFailure(errOnHkdf);
          }
          var dateNow = dateHelper.getNowString();
          var concatBuffer = buffer.Buffer.concat([buffer.Buffer.from(_this2.pool.getUserPoolName(), "utf8"), buffer.Buffer.from(_this2.username, "utf8"), buffer.Buffer.from(challengeParameters.SECRET_BLOCK, "base64"), buffer.Buffer.from(dateNow, "utf8")]);
          var awsCryptoHash = new build$4.Sha256(hkdf);
          awsCryptoHash.update(concatBuffer);
          var resultFromAWSCrypto = awsCryptoHash.digestSync();
          var signatureString = buffer.Buffer.from(resultFromAWSCrypto).toString("base64");
          var challengeResponses = {};
          challengeResponses.USERNAME = _this2.username;
          challengeResponses.PASSWORD_CLAIM_SECRET_BLOCK = challengeParameters.SECRET_BLOCK;
          challengeResponses.TIMESTAMP = dateNow;
          challengeResponses.PASSWORD_CLAIM_SIGNATURE = signatureString;
          if (_this2.deviceKey != null) {
            challengeResponses.DEVICE_KEY = _this2.deviceKey;
          }
          var respondToAuthChallenge = function respondToAuthChallenge2(challenge, challengeCallback) {
            return _this2.client.request("RespondToAuthChallenge", challenge, function(errChallenge, dataChallenge) {
              if (errChallenge && errChallenge.code === "ResourceNotFoundException" && errChallenge.message.toLowerCase().indexOf("device") !== -1) {
                challengeResponses.DEVICE_KEY = null;
                _this2.deviceKey = null;
                _this2.randomPassword = null;
                _this2.deviceGroupKey = null;
                _this2.clearCachedDeviceKeyAndPassword();
                return respondToAuthChallenge2(challenge, challengeCallback);
              }
              return challengeCallback(errChallenge, dataChallenge);
            });
          };
          var jsonReqResp = {
            ChallengeName: "PASSWORD_VERIFIER",
            ClientId: _this2.pool.getClientId(),
            ChallengeResponses: challengeResponses,
            Session: data.Session,
            ClientMetadata: clientMetaData
          };
          if (_this2.getUserContextData()) {
            jsonReqResp.UserContextData = _this2.getUserContextData();
          }
          respondToAuthChallenge(jsonReqResp, function(errAuthenticate, dataAuthenticate) {
            if (errAuthenticate) {
              return callback.onFailure(errAuthenticate);
            }
            return _this2.authenticateUserInternal(dataAuthenticate, authenticationHelper, callback);
          });
          return void 0;
        });
        return void 0;
      });
    });
  };
  _proto.authenticateUserPlainUsernamePassword = function authenticateUserPlainUsernamePassword(authDetails, callback) {
    var _this3 = this;
    var authParameters = {};
    authParameters.USERNAME = this.username;
    authParameters.PASSWORD = authDetails.getPassword();
    if (!authParameters.PASSWORD) {
      callback.onFailure(new Error("PASSWORD parameter is required"));
      return;
    }
    var authenticationHelper = new AuthenticationHelper(this.pool.getUserPoolName());
    this.getCachedDeviceKeyAndPassword();
    if (this.deviceKey != null) {
      authParameters.DEVICE_KEY = this.deviceKey;
    }
    var clientMetaData = Object.keys(authDetails.getValidationData()).length !== 0 ? authDetails.getValidationData() : authDetails.getClientMetadata();
    var jsonReq = {
      AuthFlow: "USER_PASSWORD_AUTH",
      ClientId: this.pool.getClientId(),
      AuthParameters: authParameters,
      ClientMetadata: clientMetaData
    };
    if (this.getUserContextData(this.username)) {
      jsonReq.UserContextData = this.getUserContextData(this.username);
    }
    this.client.request("InitiateAuth", jsonReq, function(err, authResult) {
      if (err) {
        return callback.onFailure(err);
      }
      return _this3.authenticateUserInternal(authResult, authenticationHelper, callback);
    });
  };
  _proto.authenticateUserInternal = function authenticateUserInternal(dataAuthenticate, authenticationHelper, callback) {
    var _this4 = this;
    var challengeName = dataAuthenticate.ChallengeName;
    var challengeParameters = dataAuthenticate.ChallengeParameters;
    if (challengeName === "SMS_MFA") {
      this.Session = dataAuthenticate.Session;
      return callback.mfaRequired(challengeName, challengeParameters);
    }
    if (challengeName === "SELECT_MFA_TYPE") {
      this.Session = dataAuthenticate.Session;
      return callback.selectMFAType(challengeName, challengeParameters);
    }
    if (challengeName === "MFA_SETUP") {
      this.Session = dataAuthenticate.Session;
      return callback.mfaSetup(challengeName, challengeParameters);
    }
    if (challengeName === "SOFTWARE_TOKEN_MFA") {
      this.Session = dataAuthenticate.Session;
      return callback.totpRequired(challengeName, challengeParameters);
    }
    if (challengeName === "CUSTOM_CHALLENGE") {
      this.Session = dataAuthenticate.Session;
      return callback.customChallenge(challengeParameters);
    }
    if (challengeName === "NEW_PASSWORD_REQUIRED") {
      this.Session = dataAuthenticate.Session;
      var userAttributes = null;
      var rawRequiredAttributes = null;
      var requiredAttributes = [];
      var userAttributesPrefix = authenticationHelper.getNewPasswordRequiredChallengeUserAttributePrefix();
      if (challengeParameters) {
        userAttributes = JSON.parse(dataAuthenticate.ChallengeParameters.userAttributes);
        rawRequiredAttributes = JSON.parse(dataAuthenticate.ChallengeParameters.requiredAttributes);
      }
      if (rawRequiredAttributes) {
        for (var i2 = 0; i2 < rawRequiredAttributes.length; i2++) {
          requiredAttributes[i2] = rawRequiredAttributes[i2].substr(userAttributesPrefix.length);
        }
      }
      return callback.newPasswordRequired(userAttributes, requiredAttributes);
    }
    if (challengeName === "DEVICE_SRP_AUTH") {
      this.Session = dataAuthenticate.Session;
      this.getDeviceResponse(callback);
      return void 0;
    }
    this.signInUserSession = this.getCognitoUserSession(dataAuthenticate.AuthenticationResult);
    this.challengeName = challengeName;
    this.cacheTokens();
    var newDeviceMetadata = dataAuthenticate.AuthenticationResult.NewDeviceMetadata;
    if (newDeviceMetadata == null) {
      return callback.onSuccess(this.signInUserSession);
    }
    authenticationHelper.generateHashDevice(dataAuthenticate.AuthenticationResult.NewDeviceMetadata.DeviceGroupKey, dataAuthenticate.AuthenticationResult.NewDeviceMetadata.DeviceKey, function(errGenHash) {
      if (errGenHash) {
        return callback.onFailure(errGenHash);
      }
      var deviceSecretVerifierConfig = {
        Salt: buffer.Buffer.from(authenticationHelper.getSaltDevices(), "hex").toString("base64"),
        PasswordVerifier: buffer.Buffer.from(authenticationHelper.getVerifierDevices(), "hex").toString("base64")
      };
      _this4.verifierDevices = deviceSecretVerifierConfig.PasswordVerifier;
      _this4.deviceGroupKey = newDeviceMetadata.DeviceGroupKey;
      _this4.randomPassword = authenticationHelper.getRandomPassword();
      _this4.client.request("ConfirmDevice", {
        DeviceKey: newDeviceMetadata.DeviceKey,
        AccessToken: _this4.signInUserSession.getAccessToken().getJwtToken(),
        DeviceSecretVerifierConfig: deviceSecretVerifierConfig,
        DeviceName: userAgent
      }, function(errConfirm, dataConfirm) {
        if (errConfirm) {
          return callback.onFailure(errConfirm);
        }
        _this4.deviceKey = dataAuthenticate.AuthenticationResult.NewDeviceMetadata.DeviceKey;
        _this4.cacheDeviceKeyAndPassword();
        if (dataConfirm.UserConfirmationNecessary === true) {
          return callback.onSuccess(_this4.signInUserSession, dataConfirm.UserConfirmationNecessary);
        }
        return callback.onSuccess(_this4.signInUserSession);
      });
      return void 0;
    });
    return void 0;
  };
  _proto.completeNewPasswordChallenge = function completeNewPasswordChallenge(newPassword, requiredAttributeData, callback, clientMetadata) {
    var _this5 = this;
    if (!newPassword) {
      return callback.onFailure(new Error("New password is required."));
    }
    var authenticationHelper = new AuthenticationHelper(this.pool.getUserPoolName());
    var userAttributesPrefix = authenticationHelper.getNewPasswordRequiredChallengeUserAttributePrefix();
    var finalUserAttributes = {};
    if (requiredAttributeData) {
      Object.keys(requiredAttributeData).forEach(function(key) {
        finalUserAttributes[userAttributesPrefix + key] = requiredAttributeData[key];
      });
    }
    finalUserAttributes.NEW_PASSWORD = newPassword;
    finalUserAttributes.USERNAME = this.username;
    var jsonReq = {
      ChallengeName: "NEW_PASSWORD_REQUIRED",
      ClientId: this.pool.getClientId(),
      ChallengeResponses: finalUserAttributes,
      Session: this.Session,
      ClientMetadata: clientMetadata
    };
    if (this.getUserContextData()) {
      jsonReq.UserContextData = this.getUserContextData();
    }
    this.client.request("RespondToAuthChallenge", jsonReq, function(errAuthenticate, dataAuthenticate) {
      if (errAuthenticate) {
        return callback.onFailure(errAuthenticate);
      }
      return _this5.authenticateUserInternal(dataAuthenticate, authenticationHelper, callback);
    });
    return void 0;
  };
  _proto.getDeviceResponse = function getDeviceResponse(callback, clientMetadata) {
    var _this6 = this;
    var authenticationHelper = new AuthenticationHelper(this.deviceGroupKey);
    var dateHelper = new DateHelper();
    var authParameters = {};
    authParameters.USERNAME = this.username;
    authParameters.DEVICE_KEY = this.deviceKey;
    authenticationHelper.getLargeAValue(function(errAValue, aValue) {
      if (errAValue) {
        callback.onFailure(errAValue);
      }
      authParameters.SRP_A = aValue.toString(16);
      var jsonReq = {
        ChallengeName: "DEVICE_SRP_AUTH",
        ClientId: _this6.pool.getClientId(),
        ChallengeResponses: authParameters,
        ClientMetadata: clientMetadata,
        Session: _this6.Session
      };
      if (_this6.getUserContextData()) {
        jsonReq.UserContextData = _this6.getUserContextData();
      }
      _this6.client.request("RespondToAuthChallenge", jsonReq, function(err, data) {
        if (err) {
          return callback.onFailure(err);
        }
        var challengeParameters = data.ChallengeParameters;
        var serverBValue = new BigInteger(challengeParameters.SRP_B, 16);
        var salt = new BigInteger(challengeParameters.SALT, 16);
        authenticationHelper.getPasswordAuthenticationKey(_this6.deviceKey, _this6.randomPassword, serverBValue, salt, function(errHkdf, hkdf) {
          if (errHkdf) {
            return callback.onFailure(errHkdf);
          }
          var dateNow = dateHelper.getNowString();
          var concatBuffer = buffer.Buffer.concat([buffer.Buffer.from(_this6.deviceGroupKey, "utf8"), buffer.Buffer.from(_this6.deviceKey, "utf8"), buffer.Buffer.from(challengeParameters.SECRET_BLOCK, "base64"), buffer.Buffer.from(dateNow, "utf8")]);
          var awsCryptoHash = new build$4.Sha256(hkdf);
          awsCryptoHash.update(concatBuffer);
          var resultFromAWSCrypto = awsCryptoHash.digestSync();
          var signatureString = buffer.Buffer.from(resultFromAWSCrypto).toString("base64");
          var challengeResponses = {};
          challengeResponses.USERNAME = _this6.username;
          challengeResponses.PASSWORD_CLAIM_SECRET_BLOCK = challengeParameters.SECRET_BLOCK;
          challengeResponses.TIMESTAMP = dateNow;
          challengeResponses.PASSWORD_CLAIM_SIGNATURE = signatureString;
          challengeResponses.DEVICE_KEY = _this6.deviceKey;
          var jsonReqResp = {
            ChallengeName: "DEVICE_PASSWORD_VERIFIER",
            ClientId: _this6.pool.getClientId(),
            ChallengeResponses: challengeResponses,
            Session: data.Session
          };
          if (_this6.getUserContextData()) {
            jsonReqResp.UserContextData = _this6.getUserContextData();
          }
          _this6.client.request("RespondToAuthChallenge", jsonReqResp, function(errAuthenticate, dataAuthenticate) {
            if (errAuthenticate) {
              return callback.onFailure(errAuthenticate);
            }
            _this6.signInUserSession = _this6.getCognitoUserSession(dataAuthenticate.AuthenticationResult);
            _this6.cacheTokens();
            return callback.onSuccess(_this6.signInUserSession);
          });
          return void 0;
        });
        return void 0;
      });
    });
  };
  _proto.confirmRegistration = function confirmRegistration(confirmationCode, forceAliasCreation, callback, clientMetadata) {
    var jsonReq = {
      ClientId: this.pool.getClientId(),
      ConfirmationCode: confirmationCode,
      Username: this.username,
      ForceAliasCreation: forceAliasCreation,
      ClientMetadata: clientMetadata
    };
    if (this.getUserContextData()) {
      jsonReq.UserContextData = this.getUserContextData();
    }
    this.client.request("ConfirmSignUp", jsonReq, function(err) {
      if (err) {
        return callback(err, null);
      }
      return callback(null, "SUCCESS");
    });
  };
  _proto.sendCustomChallengeAnswer = function sendCustomChallengeAnswer(answerChallenge, callback, clientMetadata) {
    var _this7 = this;
    var challengeResponses = {};
    challengeResponses.USERNAME = this.username;
    challengeResponses.ANSWER = answerChallenge;
    var authenticationHelper = new AuthenticationHelper(this.pool.getUserPoolName());
    this.getCachedDeviceKeyAndPassword();
    if (this.deviceKey != null) {
      challengeResponses.DEVICE_KEY = this.deviceKey;
    }
    var jsonReq = {
      ChallengeName: "CUSTOM_CHALLENGE",
      ChallengeResponses: challengeResponses,
      ClientId: this.pool.getClientId(),
      Session: this.Session,
      ClientMetadata: clientMetadata
    };
    if (this.getUserContextData()) {
      jsonReq.UserContextData = this.getUserContextData();
    }
    this.client.request("RespondToAuthChallenge", jsonReq, function(err, data) {
      if (err) {
        return callback.onFailure(err);
      }
      return _this7.authenticateUserInternal(data, authenticationHelper, callback);
    });
  };
  _proto.sendMFACode = function sendMFACode(confirmationCode, callback, mfaType, clientMetadata) {
    var _this8 = this;
    var challengeResponses = {};
    challengeResponses.USERNAME = this.username;
    challengeResponses.SMS_MFA_CODE = confirmationCode;
    var mfaTypeSelection = mfaType || "SMS_MFA";
    if (mfaTypeSelection === "SOFTWARE_TOKEN_MFA") {
      challengeResponses.SOFTWARE_TOKEN_MFA_CODE = confirmationCode;
    }
    if (this.deviceKey != null) {
      challengeResponses.DEVICE_KEY = this.deviceKey;
    }
    var jsonReq = {
      ChallengeName: mfaTypeSelection,
      ChallengeResponses: challengeResponses,
      ClientId: this.pool.getClientId(),
      Session: this.Session,
      ClientMetadata: clientMetadata
    };
    if (this.getUserContextData()) {
      jsonReq.UserContextData = this.getUserContextData();
    }
    this.client.request("RespondToAuthChallenge", jsonReq, function(err, dataAuthenticate) {
      if (err) {
        return callback.onFailure(err);
      }
      var challengeName = dataAuthenticate.ChallengeName;
      if (challengeName === "DEVICE_SRP_AUTH") {
        _this8.getDeviceResponse(callback);
        return void 0;
      }
      _this8.signInUserSession = _this8.getCognitoUserSession(dataAuthenticate.AuthenticationResult);
      _this8.cacheTokens();
      if (dataAuthenticate.AuthenticationResult.NewDeviceMetadata == null) {
        return callback.onSuccess(_this8.signInUserSession);
      }
      var authenticationHelper = new AuthenticationHelper(_this8.pool.getUserPoolName());
      authenticationHelper.generateHashDevice(dataAuthenticate.AuthenticationResult.NewDeviceMetadata.DeviceGroupKey, dataAuthenticate.AuthenticationResult.NewDeviceMetadata.DeviceKey, function(errGenHash) {
        if (errGenHash) {
          return callback.onFailure(errGenHash);
        }
        var deviceSecretVerifierConfig = {
          Salt: buffer.Buffer.from(authenticationHelper.getSaltDevices(), "hex").toString("base64"),
          PasswordVerifier: buffer.Buffer.from(authenticationHelper.getVerifierDevices(), "hex").toString("base64")
        };
        _this8.verifierDevices = deviceSecretVerifierConfig.PasswordVerifier;
        _this8.deviceGroupKey = dataAuthenticate.AuthenticationResult.NewDeviceMetadata.DeviceGroupKey;
        _this8.randomPassword = authenticationHelper.getRandomPassword();
        _this8.client.request("ConfirmDevice", {
          DeviceKey: dataAuthenticate.AuthenticationResult.NewDeviceMetadata.DeviceKey,
          AccessToken: _this8.signInUserSession.getAccessToken().getJwtToken(),
          DeviceSecretVerifierConfig: deviceSecretVerifierConfig,
          DeviceName: userAgent
        }, function(errConfirm, dataConfirm) {
          if (errConfirm) {
            return callback.onFailure(errConfirm);
          }
          _this8.deviceKey = dataAuthenticate.AuthenticationResult.NewDeviceMetadata.DeviceKey;
          _this8.cacheDeviceKeyAndPassword();
          if (dataConfirm.UserConfirmationNecessary === true) {
            return callback.onSuccess(_this8.signInUserSession, dataConfirm.UserConfirmationNecessary);
          }
          return callback.onSuccess(_this8.signInUserSession);
        });
        return void 0;
      });
      return void 0;
    });
  };
  _proto.changePassword = function changePassword(oldUserPassword, newUserPassword, callback, clientMetadata) {
    if (!(this.signInUserSession != null && this.signInUserSession.isValid())) {
      return callback(new Error("User is not authenticated"), null);
    }
    this.client.request("ChangePassword", {
      PreviousPassword: oldUserPassword,
      ProposedPassword: newUserPassword,
      AccessToken: this.signInUserSession.getAccessToken().getJwtToken(),
      ClientMetadata: clientMetadata
    }, function(err) {
      if (err) {
        return callback(err, null);
      }
      return callback(null, "SUCCESS");
    });
    return void 0;
  };
  _proto.enableMFA = function enableMFA(callback) {
    if (this.signInUserSession == null || !this.signInUserSession.isValid()) {
      return callback(new Error("User is not authenticated"), null);
    }
    var mfaOptions = [];
    var mfaEnabled = {
      DeliveryMedium: "SMS",
      AttributeName: "phone_number"
    };
    mfaOptions.push(mfaEnabled);
    this.client.request("SetUserSettings", {
      MFAOptions: mfaOptions,
      AccessToken: this.signInUserSession.getAccessToken().getJwtToken()
    }, function(err) {
      if (err) {
        return callback(err, null);
      }
      return callback(null, "SUCCESS");
    });
    return void 0;
  };
  _proto.setUserMfaPreference = function setUserMfaPreference(smsMfaSettings, softwareTokenMfaSettings, callback) {
    if (this.signInUserSession == null || !this.signInUserSession.isValid()) {
      return callback(new Error("User is not authenticated"), null);
    }
    this.client.request("SetUserMFAPreference", {
      SMSMfaSettings: smsMfaSettings,
      SoftwareTokenMfaSettings: softwareTokenMfaSettings,
      AccessToken: this.signInUserSession.getAccessToken().getJwtToken()
    }, function(err) {
      if (err) {
        return callback(err, null);
      }
      return callback(null, "SUCCESS");
    });
    return void 0;
  };
  _proto.disableMFA = function disableMFA(callback) {
    if (this.signInUserSession == null || !this.signInUserSession.isValid()) {
      return callback(new Error("User is not authenticated"), null);
    }
    var mfaOptions = [];
    this.client.request("SetUserSettings", {
      MFAOptions: mfaOptions,
      AccessToken: this.signInUserSession.getAccessToken().getJwtToken()
    }, function(err) {
      if (err) {
        return callback(err, null);
      }
      return callback(null, "SUCCESS");
    });
    return void 0;
  };
  _proto.deleteUser = function deleteUser(callback, clientMetadata) {
    var _this9 = this;
    if (this.signInUserSession == null || !this.signInUserSession.isValid()) {
      return callback(new Error("User is not authenticated"), null);
    }
    this.client.request("DeleteUser", {
      AccessToken: this.signInUserSession.getAccessToken().getJwtToken(),
      ClientMetadata: clientMetadata
    }, function(err) {
      if (err) {
        return callback(err, null);
      }
      _this9.clearCachedUser();
      return callback(null, "SUCCESS");
    });
    return void 0;
  };
  _proto.updateAttributes = function updateAttributes(attributes, callback, clientMetadata) {
    var _this10 = this;
    if (this.signInUserSession == null || !this.signInUserSession.isValid()) {
      return callback(new Error("User is not authenticated"), null);
    }
    this.client.request("UpdateUserAttributes", {
      AccessToken: this.signInUserSession.getAccessToken().getJwtToken(),
      UserAttributes: attributes,
      ClientMetadata: clientMetadata
    }, function(err, result) {
      if (err) {
        return callback(err, null);
      }
      return _this10.getUserData(function() {
        return callback(null, "SUCCESS", result);
      }, {
        bypassCache: true
      });
    });
    return void 0;
  };
  _proto.getUserAttributes = function getUserAttributes(callback) {
    if (!(this.signInUserSession != null && this.signInUserSession.isValid())) {
      return callback(new Error("User is not authenticated"), null);
    }
    this.client.request("GetUser", {
      AccessToken: this.signInUserSession.getAccessToken().getJwtToken()
    }, function(err, userData) {
      if (err) {
        return callback(err, null);
      }
      var attributeList = [];
      for (var i2 = 0; i2 < userData.UserAttributes.length; i2++) {
        var attribute = {
          Name: userData.UserAttributes[i2].Name,
          Value: userData.UserAttributes[i2].Value
        };
        var userAttribute = new CognitoUserAttribute(attribute);
        attributeList.push(userAttribute);
      }
      return callback(null, attributeList);
    });
    return void 0;
  };
  _proto.getMFAOptions = function getMFAOptions(callback) {
    if (!(this.signInUserSession != null && this.signInUserSession.isValid())) {
      return callback(new Error("User is not authenticated"), null);
    }
    this.client.request("GetUser", {
      AccessToken: this.signInUserSession.getAccessToken().getJwtToken()
    }, function(err, userData) {
      if (err) {
        return callback(err, null);
      }
      return callback(null, userData.MFAOptions);
    });
    return void 0;
  };
  _proto.createGetUserRequest = function createGetUserRequest() {
    return this.client.promisifyRequest("GetUser", {
      AccessToken: this.signInUserSession.getAccessToken().getJwtToken()
    });
  };
  _proto.refreshSessionIfPossible = function refreshSessionIfPossible(options) {
    var _this11 = this;
    if (options === void 0) {
      options = {};
    }
    return new Promise(function(resolve2) {
      var refresh = _this11.signInUserSession.getRefreshToken();
      if (refresh && refresh.getToken()) {
        _this11.refreshSession(refresh, resolve2, options.clientMetadata);
      } else {
        resolve2();
      }
    });
  };
  _proto.getUserData = function getUserData(callback, params) {
    var _this12 = this;
    if (!(this.signInUserSession != null && this.signInUserSession.isValid())) {
      this.clearCachedUserData();
      return callback(new Error("User is not authenticated"), null);
    }
    var userData = this.getUserDataFromCache();
    if (!userData) {
      this.fetchUserData().then(function(data) {
        callback(null, data);
      })["catch"](callback);
      return;
    }
    if (this.isFetchUserDataAndTokenRequired(params)) {
      this.fetchUserData().then(function(data) {
        return _this12.refreshSessionIfPossible(params).then(function() {
          return data;
        });
      }).then(function(data) {
        return callback(null, data);
      })["catch"](callback);
      return;
    }
    try {
      callback(null, JSON.parse(userData));
      return;
    } catch (err) {
      this.clearCachedUserData();
      callback(err, null);
      return;
    }
  };
  _proto.getUserDataFromCache = function getUserDataFromCache() {
    var userData = this.storage.getItem(this.userDataKey);
    return userData;
  };
  _proto.isFetchUserDataAndTokenRequired = function isFetchUserDataAndTokenRequired(params) {
    var _ref = params || {}, _ref$bypassCache = _ref.bypassCache, bypassCache = _ref$bypassCache === void 0 ? false : _ref$bypassCache;
    return bypassCache;
  };
  _proto.fetchUserData = function fetchUserData() {
    var _this13 = this;
    return this.createGetUserRequest().then(function(data) {
      _this13.cacheUserData(data);
      return data;
    });
  };
  _proto.deleteAttributes = function deleteAttributes(attributeList, callback) {
    var _this14 = this;
    if (!(this.signInUserSession != null && this.signInUserSession.isValid())) {
      return callback(new Error("User is not authenticated"), null);
    }
    this.client.request("DeleteUserAttributes", {
      UserAttributeNames: attributeList,
      AccessToken: this.signInUserSession.getAccessToken().getJwtToken()
    }, function(err) {
      if (err) {
        return callback(err, null);
      }
      return _this14.getUserData(function() {
        return callback(null, "SUCCESS");
      }, {
        bypassCache: true
      });
    });
    return void 0;
  };
  _proto.resendConfirmationCode = function resendConfirmationCode(callback, clientMetadata) {
    var jsonReq = {
      ClientId: this.pool.getClientId(),
      Username: this.username,
      ClientMetadata: clientMetadata
    };
    this.client.request("ResendConfirmationCode", jsonReq, function(err, result) {
      if (err) {
        return callback(err, null);
      }
      return callback(null, result);
    });
  };
  _proto.getSession = function getSession(callback, options) {
    if (options === void 0) {
      options = {};
    }
    if (this.username == null) {
      return callback(new Error("Username is null. Cannot retrieve a new session"), null);
    }
    if (this.signInUserSession != null && this.signInUserSession.isValid()) {
      return callback(null, this.signInUserSession);
    }
    var keyPrefix = "CognitoIdentityServiceProvider." + this.pool.getClientId() + "." + this.username;
    var idTokenKey = keyPrefix + ".idToken";
    var accessTokenKey = keyPrefix + ".accessToken";
    var refreshTokenKey = keyPrefix + ".refreshToken";
    var clockDriftKey = keyPrefix + ".clockDrift";
    if (this.storage.getItem(idTokenKey)) {
      var idToken = new CognitoIdToken({
        IdToken: this.storage.getItem(idTokenKey)
      });
      var accessToken = new CognitoAccessToken({
        AccessToken: this.storage.getItem(accessTokenKey)
      });
      var refreshToken = new CognitoRefreshToken({
        RefreshToken: this.storage.getItem(refreshTokenKey)
      });
      var clockDrift = parseInt(this.storage.getItem(clockDriftKey), 0) || 0;
      var sessionData = {
        IdToken: idToken,
        AccessToken: accessToken,
        RefreshToken: refreshToken,
        ClockDrift: clockDrift
      };
      var cachedSession = new CognitoUserSession(sessionData);
      if (cachedSession.isValid()) {
        this.signInUserSession = cachedSession;
        return callback(null, this.signInUserSession);
      }
      if (!refreshToken.getToken()) {
        return callback(new Error("Cannot retrieve a new session. Please authenticate."), null);
      }
      this.refreshSession(refreshToken, callback, options.clientMetadata);
    } else {
      callback(new Error("Local storage is missing an ID Token, Please authenticate"), null);
    }
    return void 0;
  };
  _proto.refreshSession = function refreshSession(refreshToken, callback, clientMetadata) {
    var _this15 = this;
    var wrappedCallback = this.pool.wrapRefreshSessionCallback ? this.pool.wrapRefreshSessionCallback(callback) : callback;
    var authParameters = {};
    authParameters.REFRESH_TOKEN = refreshToken.getToken();
    var keyPrefix = "CognitoIdentityServiceProvider." + this.pool.getClientId();
    var lastUserKey = keyPrefix + ".LastAuthUser";
    if (this.storage.getItem(lastUserKey)) {
      this.username = this.storage.getItem(lastUserKey);
      var deviceKeyKey = keyPrefix + "." + this.username + ".deviceKey";
      this.deviceKey = this.storage.getItem(deviceKeyKey);
      authParameters.DEVICE_KEY = this.deviceKey;
    }
    var jsonReq = {
      ClientId: this.pool.getClientId(),
      AuthFlow: "REFRESH_TOKEN_AUTH",
      AuthParameters: authParameters,
      ClientMetadata: clientMetadata
    };
    if (this.getUserContextData()) {
      jsonReq.UserContextData = this.getUserContextData();
    }
    this.client.request("InitiateAuth", jsonReq, function(err, authResult) {
      if (err) {
        if (err.code === "NotAuthorizedException") {
          _this15.clearCachedUser();
        }
        return wrappedCallback(err, null);
      }
      if (authResult) {
        var authenticationResult = authResult.AuthenticationResult;
        if (!Object.prototype.hasOwnProperty.call(authenticationResult, "RefreshToken")) {
          authenticationResult.RefreshToken = refreshToken.getToken();
        }
        _this15.signInUserSession = _this15.getCognitoUserSession(authenticationResult);
        _this15.cacheTokens();
        return wrappedCallback(null, _this15.signInUserSession);
      }
      return void 0;
    });
  };
  _proto.cacheTokens = function cacheTokens() {
    var keyPrefix = "CognitoIdentityServiceProvider." + this.pool.getClientId();
    var idTokenKey = keyPrefix + "." + this.username + ".idToken";
    var accessTokenKey = keyPrefix + "." + this.username + ".accessToken";
    var refreshTokenKey = keyPrefix + "." + this.username + ".refreshToken";
    var clockDriftKey = keyPrefix + "." + this.username + ".clockDrift";
    var lastUserKey = keyPrefix + ".LastAuthUser";
    this.storage.setItem(idTokenKey, this.signInUserSession.getIdToken().getJwtToken());
    this.storage.setItem(accessTokenKey, this.signInUserSession.getAccessToken().getJwtToken());
    this.storage.setItem(refreshTokenKey, this.signInUserSession.getRefreshToken().getToken());
    this.storage.setItem(clockDriftKey, "" + this.signInUserSession.getClockDrift());
    this.storage.setItem(lastUserKey, this.username);
  };
  _proto.cacheUserData = function cacheUserData(userData) {
    this.storage.setItem(this.userDataKey, JSON.stringify(userData));
  };
  _proto.clearCachedUserData = function clearCachedUserData() {
    this.storage.removeItem(this.userDataKey);
  };
  _proto.clearCachedUser = function clearCachedUser() {
    this.clearCachedTokens();
    this.clearCachedUserData();
  };
  _proto.cacheDeviceKeyAndPassword = function cacheDeviceKeyAndPassword() {
    var keyPrefix = "CognitoIdentityServiceProvider." + this.pool.getClientId() + "." + this.username;
    var deviceKeyKey = keyPrefix + ".deviceKey";
    var randomPasswordKey = keyPrefix + ".randomPasswordKey";
    var deviceGroupKeyKey = keyPrefix + ".deviceGroupKey";
    this.storage.setItem(deviceKeyKey, this.deviceKey);
    this.storage.setItem(randomPasswordKey, this.randomPassword);
    this.storage.setItem(deviceGroupKeyKey, this.deviceGroupKey);
  };
  _proto.getCachedDeviceKeyAndPassword = function getCachedDeviceKeyAndPassword() {
    var keyPrefix = "CognitoIdentityServiceProvider." + this.pool.getClientId() + "." + this.username;
    var deviceKeyKey = keyPrefix + ".deviceKey";
    var randomPasswordKey = keyPrefix + ".randomPasswordKey";
    var deviceGroupKeyKey = keyPrefix + ".deviceGroupKey";
    if (this.storage.getItem(deviceKeyKey)) {
      this.deviceKey = this.storage.getItem(deviceKeyKey);
      this.randomPassword = this.storage.getItem(randomPasswordKey);
      this.deviceGroupKey = this.storage.getItem(deviceGroupKeyKey);
    }
  };
  _proto.clearCachedDeviceKeyAndPassword = function clearCachedDeviceKeyAndPassword() {
    var keyPrefix = "CognitoIdentityServiceProvider." + this.pool.getClientId() + "." + this.username;
    var deviceKeyKey = keyPrefix + ".deviceKey";
    var randomPasswordKey = keyPrefix + ".randomPasswordKey";
    var deviceGroupKeyKey = keyPrefix + ".deviceGroupKey";
    this.storage.removeItem(deviceKeyKey);
    this.storage.removeItem(randomPasswordKey);
    this.storage.removeItem(deviceGroupKeyKey);
  };
  _proto.clearCachedTokens = function clearCachedTokens() {
    var keyPrefix = "CognitoIdentityServiceProvider." + this.pool.getClientId();
    var idTokenKey = keyPrefix + "." + this.username + ".idToken";
    var accessTokenKey = keyPrefix + "." + this.username + ".accessToken";
    var refreshTokenKey = keyPrefix + "." + this.username + ".refreshToken";
    var lastUserKey = keyPrefix + ".LastAuthUser";
    var clockDriftKey = keyPrefix + "." + this.username + ".clockDrift";
    this.storage.removeItem(idTokenKey);
    this.storage.removeItem(accessTokenKey);
    this.storage.removeItem(refreshTokenKey);
    this.storage.removeItem(lastUserKey);
    this.storage.removeItem(clockDriftKey);
  };
  _proto.getCognitoUserSession = function getCognitoUserSession(authResult) {
    var idToken = new CognitoIdToken(authResult);
    var accessToken = new CognitoAccessToken(authResult);
    var refreshToken = new CognitoRefreshToken(authResult);
    var sessionData = {
      IdToken: idToken,
      AccessToken: accessToken,
      RefreshToken: refreshToken
    };
    return new CognitoUserSession(sessionData);
  };
  _proto.forgotPassword = function forgotPassword(callback, clientMetadata) {
    var jsonReq = {
      ClientId: this.pool.getClientId(),
      Username: this.username,
      ClientMetadata: clientMetadata
    };
    if (this.getUserContextData()) {
      jsonReq.UserContextData = this.getUserContextData();
    }
    this.client.request("ForgotPassword", jsonReq, function(err, data) {
      if (err) {
        return callback.onFailure(err);
      }
      if (typeof callback.inputVerificationCode === "function") {
        return callback.inputVerificationCode(data);
      }
      return callback.onSuccess(data);
    });
  };
  _proto.confirmPassword = function confirmPassword(confirmationCode, newPassword, callback, clientMetadata) {
    var jsonReq = {
      ClientId: this.pool.getClientId(),
      Username: this.username,
      ConfirmationCode: confirmationCode,
      Password: newPassword,
      ClientMetadata: clientMetadata
    };
    if (this.getUserContextData()) {
      jsonReq.UserContextData = this.getUserContextData();
    }
    this.client.request("ConfirmForgotPassword", jsonReq, function(err) {
      if (err) {
        return callback.onFailure(err);
      }
      return callback.onSuccess("SUCCESS");
    });
  };
  _proto.getAttributeVerificationCode = function getAttributeVerificationCode(attributeName, callback, clientMetadata) {
    if (this.signInUserSession == null || !this.signInUserSession.isValid()) {
      return callback.onFailure(new Error("User is not authenticated"));
    }
    this.client.request("GetUserAttributeVerificationCode", {
      AttributeName: attributeName,
      AccessToken: this.signInUserSession.getAccessToken().getJwtToken(),
      ClientMetadata: clientMetadata
    }, function(err, data) {
      if (err) {
        return callback.onFailure(err);
      }
      if (typeof callback.inputVerificationCode === "function") {
        return callback.inputVerificationCode(data);
      }
      return callback.onSuccess("SUCCESS");
    });
    return void 0;
  };
  _proto.verifyAttribute = function verifyAttribute(attributeName, confirmationCode, callback) {
    if (this.signInUserSession == null || !this.signInUserSession.isValid()) {
      return callback.onFailure(new Error("User is not authenticated"));
    }
    this.client.request("VerifyUserAttribute", {
      AttributeName: attributeName,
      Code: confirmationCode,
      AccessToken: this.signInUserSession.getAccessToken().getJwtToken()
    }, function(err) {
      if (err) {
        return callback.onFailure(err);
      }
      return callback.onSuccess("SUCCESS");
    });
    return void 0;
  };
  _proto.getDevice = function getDevice(callback) {
    if (this.signInUserSession == null || !this.signInUserSession.isValid()) {
      return callback.onFailure(new Error("User is not authenticated"));
    }
    this.client.request("GetDevice", {
      AccessToken: this.signInUserSession.getAccessToken().getJwtToken(),
      DeviceKey: this.deviceKey
    }, function(err, data) {
      if (err) {
        return callback.onFailure(err);
      }
      return callback.onSuccess(data);
    });
    return void 0;
  };
  _proto.forgetSpecificDevice = function forgetSpecificDevice(deviceKey, callback) {
    if (this.signInUserSession == null || !this.signInUserSession.isValid()) {
      return callback.onFailure(new Error("User is not authenticated"));
    }
    this.client.request("ForgetDevice", {
      AccessToken: this.signInUserSession.getAccessToken().getJwtToken(),
      DeviceKey: deviceKey
    }, function(err) {
      if (err) {
        return callback.onFailure(err);
      }
      return callback.onSuccess("SUCCESS");
    });
    return void 0;
  };
  _proto.forgetDevice = function forgetDevice(callback) {
    var _this16 = this;
    this.forgetSpecificDevice(this.deviceKey, {
      onFailure: callback.onFailure,
      onSuccess: function onSuccess(result) {
        _this16.deviceKey = null;
        _this16.deviceGroupKey = null;
        _this16.randomPassword = null;
        _this16.clearCachedDeviceKeyAndPassword();
        return callback.onSuccess(result);
      }
    });
  };
  _proto.setDeviceStatusRemembered = function setDeviceStatusRemembered(callback) {
    if (this.signInUserSession == null || !this.signInUserSession.isValid()) {
      return callback.onFailure(new Error("User is not authenticated"));
    }
    this.client.request("UpdateDeviceStatus", {
      AccessToken: this.signInUserSession.getAccessToken().getJwtToken(),
      DeviceKey: this.deviceKey,
      DeviceRememberedStatus: "remembered"
    }, function(err) {
      if (err) {
        return callback.onFailure(err);
      }
      return callback.onSuccess("SUCCESS");
    });
    return void 0;
  };
  _proto.setDeviceStatusNotRemembered = function setDeviceStatusNotRemembered(callback) {
    if (this.signInUserSession == null || !this.signInUserSession.isValid()) {
      return callback.onFailure(new Error("User is not authenticated"));
    }
    this.client.request("UpdateDeviceStatus", {
      AccessToken: this.signInUserSession.getAccessToken().getJwtToken(),
      DeviceKey: this.deviceKey,
      DeviceRememberedStatus: "not_remembered"
    }, function(err) {
      if (err) {
        return callback.onFailure(err);
      }
      return callback.onSuccess("SUCCESS");
    });
    return void 0;
  };
  _proto.listDevices = function listDevices(limit, paginationToken, callback) {
    if (this.signInUserSession == null || !this.signInUserSession.isValid()) {
      return callback.onFailure(new Error("User is not authenticated"));
    }
    var requestParams = {
      AccessToken: this.signInUserSession.getAccessToken().getJwtToken(),
      Limit: limit
    };
    if (paginationToken) {
      requestParams.PaginationToken = paginationToken;
    }
    this.client.request("ListDevices", requestParams, function(err, data) {
      if (err) {
        return callback.onFailure(err);
      }
      return callback.onSuccess(data);
    });
    return void 0;
  };
  _proto.globalSignOut = function globalSignOut(callback) {
    var _this17 = this;
    if (this.signInUserSession == null || !this.signInUserSession.isValid()) {
      return callback.onFailure(new Error("User is not authenticated"));
    }
    this.client.request("GlobalSignOut", {
      AccessToken: this.signInUserSession.getAccessToken().getJwtToken()
    }, function(err) {
      if (err) {
        return callback.onFailure(err);
      }
      _this17.clearCachedUser();
      return callback.onSuccess("SUCCESS");
    });
    return void 0;
  };
  _proto.signOut = function signOut(revokeTokenCallback) {
    var _this18 = this;
    if (!revokeTokenCallback || typeof revokeTokenCallback !== "function") {
      this.cleanClientData();
      return;
    }
    this.getSession(function(error, _session) {
      if (error) {
        return revokeTokenCallback(error);
      }
      _this18.revokeTokens(function(err) {
        _this18.cleanClientData();
        revokeTokenCallback(err);
      });
    });
  };
  _proto.revokeTokens = function revokeTokens(revokeTokenCallback) {
    if (revokeTokenCallback === void 0) {
      revokeTokenCallback = function revokeTokenCallback2() {
      };
    }
    if (typeof revokeTokenCallback !== "function") {
      throw new Error("Invalid revokeTokenCallback. It should be a function.");
    }
    if (!this.signInUserSession) {
      var error = new Error("User is not authenticated");
      return revokeTokenCallback(error);
    }
    if (!this.signInUserSession.getAccessToken()) {
      var _error = new Error("No Access token available");
      return revokeTokenCallback(_error);
    }
    var refreshToken = this.signInUserSession.getRefreshToken().getToken();
    var accessToken = this.signInUserSession.getAccessToken();
    if (this.isSessionRevocable(accessToken)) {
      if (refreshToken) {
        return this.revokeToken({
          token: refreshToken,
          callback: revokeTokenCallback
        });
      }
    }
    revokeTokenCallback();
  };
  _proto.isSessionRevocable = function isSessionRevocable(token) {
    if (token && typeof token.decodePayload === "function") {
      try {
        var _token$decodePayload = token.decodePayload(), origin_jti = _token$decodePayload.origin_jti;
        return !!origin_jti;
      } catch (err) {
      }
    }
    return false;
  };
  _proto.cleanClientData = function cleanClientData() {
    this.signInUserSession = null;
    this.clearCachedUser();
  };
  _proto.revokeToken = function revokeToken(_ref2) {
    var token = _ref2.token, callback = _ref2.callback;
    this.client.requestWithRetry("RevokeToken", {
      Token: token,
      ClientId: this.pool.getClientId()
    }, function(err) {
      if (err) {
        return callback(err);
      }
      callback();
    });
  };
  _proto.sendMFASelectionAnswer = function sendMFASelectionAnswer(answerChallenge, callback) {
    var _this19 = this;
    var challengeResponses = {};
    challengeResponses.USERNAME = this.username;
    challengeResponses.ANSWER = answerChallenge;
    var jsonReq = {
      ChallengeName: "SELECT_MFA_TYPE",
      ChallengeResponses: challengeResponses,
      ClientId: this.pool.getClientId(),
      Session: this.Session
    };
    if (this.getUserContextData()) {
      jsonReq.UserContextData = this.getUserContextData();
    }
    this.client.request("RespondToAuthChallenge", jsonReq, function(err, data) {
      if (err) {
        return callback.onFailure(err);
      }
      _this19.Session = data.Session;
      if (answerChallenge === "SMS_MFA") {
        return callback.mfaRequired(data.ChallengeName, data.ChallengeParameters);
      }
      if (answerChallenge === "SOFTWARE_TOKEN_MFA") {
        return callback.totpRequired(data.ChallengeName, data.ChallengeParameters);
      }
      return void 0;
    });
  };
  _proto.getUserContextData = function getUserContextData() {
    var pool = this.pool;
    return pool.getUserContextData(this.username);
  };
  _proto.associateSoftwareToken = function associateSoftwareToken(callback) {
    var _this20 = this;
    if (!(this.signInUserSession != null && this.signInUserSession.isValid())) {
      this.client.request("AssociateSoftwareToken", {
        Session: this.Session
      }, function(err, data) {
        if (err) {
          return callback.onFailure(err);
        }
        _this20.Session = data.Session;
        return callback.associateSecretCode(data.SecretCode);
      });
    } else {
      this.client.request("AssociateSoftwareToken", {
        AccessToken: this.signInUserSession.getAccessToken().getJwtToken()
      }, function(err, data) {
        if (err) {
          return callback.onFailure(err);
        }
        return callback.associateSecretCode(data.SecretCode);
      });
    }
  };
  _proto.verifySoftwareToken = function verifySoftwareToken(totpCode, friendlyDeviceName, callback) {
    var _this21 = this;
    if (!(this.signInUserSession != null && this.signInUserSession.isValid())) {
      this.client.request("VerifySoftwareToken", {
        Session: this.Session,
        UserCode: totpCode,
        FriendlyDeviceName: friendlyDeviceName
      }, function(err, data) {
        if (err) {
          return callback.onFailure(err);
        }
        _this21.Session = data.Session;
        var challengeResponses = {};
        challengeResponses.USERNAME = _this21.username;
        var jsonReq = {
          ChallengeName: "MFA_SETUP",
          ClientId: _this21.pool.getClientId(),
          ChallengeResponses: challengeResponses,
          Session: _this21.Session
        };
        if (_this21.getUserContextData()) {
          jsonReq.UserContextData = _this21.getUserContextData();
        }
        _this21.client.request("RespondToAuthChallenge", jsonReq, function(errRespond, dataRespond) {
          if (errRespond) {
            return callback.onFailure(errRespond);
          }
          _this21.signInUserSession = _this21.getCognitoUserSession(dataRespond.AuthenticationResult);
          _this21.cacheTokens();
          return callback.onSuccess(_this21.signInUserSession);
        });
        return void 0;
      });
    } else {
      this.client.request("VerifySoftwareToken", {
        AccessToken: this.signInUserSession.getAccessToken().getJwtToken(),
        UserCode: totpCode,
        FriendlyDeviceName: friendlyDeviceName
      }, function(err, data) {
        if (err) {
          return callback.onFailure(err);
        }
        return callback.onSuccess(data);
      });
    }
  };
  return CognitoUser2;
}();
function unfetch_module(e3, n2) {
  return n2 = n2 || {}, new Promise(function(t3, r2) {
    var s3 = new XMLHttpRequest(), o2 = [], u2 = [], i2 = {}, a3 = function() {
      return { ok: 2 == (s3.status / 100 | 0), statusText: s3.statusText, status: s3.status, url: s3.responseURL, text: function() {
        return Promise.resolve(s3.responseText);
      }, json: function() {
        return Promise.resolve(s3.responseText).then(JSON.parse);
      }, blob: function() {
        return Promise.resolve(new Blob([s3.response]));
      }, clone: a3, headers: { keys: function() {
        return o2;
      }, entries: function() {
        return u2;
      }, get: function(e4) {
        return i2[e4.toLowerCase()];
      }, has: function(e4) {
        return e4.toLowerCase() in i2;
      } } };
    };
    for (var l in s3.open(n2.method || "get", e3, true), s3.onload = function() {
      s3.getAllResponseHeaders().replace(/^(.*?):[^\S\n]*([\s\S]*?)$/gm, function(e4, n3, t4) {
        o2.push(n3 = n3.toLowerCase()), u2.push([n3, t4]), i2[n3] = i2[n3] ? i2[n3] + "," + t4 : t4;
      }), t3(a3());
    }, s3.onerror = r2, s3.withCredentials = "include" == n2.credentials, n2.headers)
      s3.setRequestHeader(l, n2.headers[l]);
    s3.send(n2.body || null);
  });
}
const unfetch_module$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: unfetch_module
}, Symbol.toStringTag, { value: "Module" }));
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(unfetch_module$1);
self.fetch || (self.fetch = require$$0.default || require$$0);
function UserAgent() {
}
UserAgent.prototype.userAgent = getUserAgent();
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf$w(subClass, superClass);
}
function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
  _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
    if (Class2 === null || !_isNativeFunction(Class2))
      return Class2;
    if (typeof Class2 !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }
    if (typeof _cache !== "undefined") {
      if (_cache.has(Class2))
        return _cache.get(Class2);
      _cache.set(Class2, Wrapper);
    }
    function Wrapper() {
      return _construct(Class2, arguments, _getPrototypeOf$w(this).constructor);
    }
    Wrapper.prototype = Object.create(Class2.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } });
    return _setPrototypeOf$w(Wrapper, Class2);
  };
  return _wrapNativeSuper(Class);
}
function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct$w()) {
    _construct = Reflect.construct.bind();
  } else {
    _construct = function _construct2(Parent2, args2, Class2) {
      var a3 = [null];
      a3.push.apply(a3, args2);
      var Constructor = Function.bind.apply(Parent2, a3);
      var instance = new Constructor();
      if (Class2)
        _setPrototypeOf$w(instance, Class2.prototype);
      return instance;
    };
  }
  return _construct.apply(null, arguments);
}
function _isNativeReflectConstruct$w() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _isNativeFunction(fn2) {
  return Function.toString.call(fn2).indexOf("[native code]") !== -1;
}
function _setPrototypeOf$w(o2, p2) {
  _setPrototypeOf$w = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf$w(o2, p2);
}
function _getPrototypeOf$w(o2) {
  _getPrototypeOf$w = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf$w(o2);
}
var CognitoError = /* @__PURE__ */ function(_Error) {
  _inheritsLoose(CognitoError2, _Error);
  function CognitoError2(message, code2, name2, statusCode) {
    var _this;
    _this = _Error.call(this, message) || this;
    _this.code = code2;
    _this.name = name2;
    _this.statusCode = statusCode;
    return _this;
  }
  return CognitoError2;
}(/* @__PURE__ */ _wrapNativeSuper(Error));
var Client = /* @__PURE__ */ function() {
  function Client2(region, endpoint, fetchOptions) {
    this.endpoint = endpoint || "https://cognito-idp." + region + ".amazonaws.com/";
    var _ref = fetchOptions || {}, credentials = _ref.credentials;
    this.fetchOptions = credentials ? {
      credentials
    } : {};
  }
  var _proto = Client2.prototype;
  _proto.promisifyRequest = function promisifyRequest(operation, params) {
    var _this2 = this;
    return new Promise(function(resolve2, reject) {
      _this2.request(operation, params, function(err, data) {
        if (err) {
          reject(new CognitoError(err.message, err.code, err.name, err.statusCode));
        } else {
          resolve2(data);
        }
      });
    });
  };
  _proto.requestWithRetry = function requestWithRetry(operation, params, callback) {
    var _this3 = this;
    var MAX_DELAY_IN_MILLIS = 5 * 1e3;
    jitteredExponentialRetry(function(p2) {
      return new Promise(function(res, rej) {
        _this3.request(operation, p2, function(error, result) {
          if (error) {
            rej(error);
          } else {
            res(result);
          }
        });
      });
    }, [params], MAX_DELAY_IN_MILLIS).then(function(result) {
      return callback(null, result);
    })["catch"](function(error) {
      return callback(error);
    });
  };
  _proto.request = function request(operation, params, callback) {
    var headers = {
      "Content-Type": "application/x-amz-json-1.1",
      "X-Amz-Target": "AWSCognitoIdentityProviderService." + operation,
      "X-Amz-User-Agent": UserAgent.prototype.userAgent,
      "Cache-Control": "no-store"
    };
    var options = Object.assign({}, this.fetchOptions, {
      headers,
      method: "POST",
      mode: "cors",
      body: JSON.stringify(params)
    });
    var response;
    fetch(this.endpoint, options).then(function(resp) {
      response = resp;
      return resp;
    }, function(err) {
      if (err instanceof TypeError) {
        throw new Error("Network error");
      }
      throw err;
    }).then(function(resp) {
      return resp.json()["catch"](function() {
        return {};
      });
    }).then(function(data) {
      if (response.ok)
        return callback(null, data);
      var code2 = (data.__type || data.code).split("#").pop();
      var error = new Error(data.message || data.Message || null);
      error.name = code2;
      error.code = code2;
      return callback(error);
    })["catch"](function(err) {
      if (response && response.headers && response.headers.get("x-amzn-errortype")) {
        try {
          var code2 = response.headers.get("x-amzn-errortype").split(":")[0];
          var error = new Error(response.status ? response.status.toString() : null);
          error.code = code2;
          error.name = code2;
          error.statusCode = response.status;
          return callback(error);
        } catch (ex) {
          return callback(err);
        }
      } else if (err instanceof Error && err.message === "Network error") {
        err.code = "NetworkError";
      }
      return callback(err);
    });
  };
  return Client2;
}();
var logger$3 = {
  debug: function debug() {
  }
};
var isNonRetryableError = function isNonRetryableError2(obj) {
  var key = "nonRetryable";
  return obj && obj[key];
};
function retry(functionToRetry, args, delayFn, attempt) {
  if (attempt === void 0) {
    attempt = 1;
  }
  if (typeof functionToRetry !== "function") {
    throw Error("functionToRetry must be a function");
  }
  logger$3.debug(functionToRetry.name + " attempt #" + attempt + " with args: " + JSON.stringify(args));
  return functionToRetry.apply(void 0, args)["catch"](function(err) {
    logger$3.debug("error on " + functionToRetry.name, err);
    if (isNonRetryableError(err)) {
      logger$3.debug(functionToRetry.name + " non retryable error", err);
      throw err;
    }
    var retryIn = delayFn(attempt, args, err);
    logger$3.debug(functionToRetry.name + " retrying in " + retryIn + " ms");
    if (retryIn !== false) {
      return new Promise(function(res) {
        return setTimeout(res, retryIn);
      }).then(function() {
        return retry(functionToRetry, args, delayFn, attempt + 1);
      });
    } else {
      throw err;
    }
  });
}
function jitteredBackoff(maxDelayMs) {
  var BASE_TIME_MS = 100;
  var JITTER_FACTOR = 100;
  return function(attempt) {
    var delay = Math.pow(2, attempt) * BASE_TIME_MS + JITTER_FACTOR * Math.random();
    return delay > maxDelayMs ? false : delay;
  };
}
var MAX_DELAY_MS = 5 * 60 * 1e3;
function jitteredExponentialRetry(functionToRetry, args, maxDelayMs) {
  if (maxDelayMs === void 0) {
    maxDelayMs = MAX_DELAY_MS;
  }
  return retry(functionToRetry, args, jitteredBackoff(maxDelayMs));
}
/*!
 * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
 * SPDX-License-Identifier: Apache-2.0
 */
var USER_POOL_ID_MAX_LENGTH = 55;
var CognitoUserPool = /* @__PURE__ */ function() {
  function CognitoUserPool2(data, wrapRefreshSessionCallback) {
    var _ref = data || {}, UserPoolId = _ref.UserPoolId, ClientId = _ref.ClientId, endpoint = _ref.endpoint, fetchOptions = _ref.fetchOptions, AdvancedSecurityDataCollectionFlag = _ref.AdvancedSecurityDataCollectionFlag;
    if (!UserPoolId || !ClientId) {
      throw new Error("Both UserPoolId and ClientId are required.");
    }
    if (UserPoolId.length > USER_POOL_ID_MAX_LENGTH || !/^[\w-]+_[0-9a-zA-Z]+$/.test(UserPoolId)) {
      throw new Error("Invalid UserPoolId format.");
    }
    var region = UserPoolId.split("_")[0];
    this.userPoolId = UserPoolId;
    this.clientId = ClientId;
    this.client = new Client(region, endpoint, fetchOptions);
    this.advancedSecurityDataCollectionFlag = AdvancedSecurityDataCollectionFlag !== false;
    this.storage = data.Storage || new StorageHelper().getStorage();
    if (wrapRefreshSessionCallback) {
      this.wrapRefreshSessionCallback = wrapRefreshSessionCallback;
    }
  }
  var _proto = CognitoUserPool2.prototype;
  _proto.getUserPoolId = function getUserPoolId() {
    return this.userPoolId;
  };
  _proto.getUserPoolName = function getUserPoolName() {
    return this.getUserPoolId().split("_")[1];
  };
  _proto.getClientId = function getClientId() {
    return this.clientId;
  };
  _proto.signUp = function signUp(username, password, userAttributes, validationData, callback, clientMetadata) {
    var _this = this;
    var jsonReq = {
      ClientId: this.clientId,
      Username: username,
      Password: password,
      UserAttributes: userAttributes,
      ValidationData: validationData,
      ClientMetadata: clientMetadata
    };
    if (this.getUserContextData(username)) {
      jsonReq.UserContextData = this.getUserContextData(username);
    }
    this.client.request("SignUp", jsonReq, function(err, data) {
      if (err) {
        return callback(err, null);
      }
      var cognitoUser = {
        Username: username,
        Pool: _this,
        Storage: _this.storage
      };
      var returnData = {
        user: new CognitoUser(cognitoUser),
        userConfirmed: data.UserConfirmed,
        userSub: data.UserSub,
        codeDeliveryDetails: data.CodeDeliveryDetails
      };
      return callback(null, returnData);
    });
  };
  _proto.getCurrentUser = function getCurrentUser() {
    var lastUserKey = "CognitoIdentityServiceProvider." + this.clientId + ".LastAuthUser";
    var lastAuthUser = this.storage.getItem(lastUserKey);
    if (lastAuthUser) {
      var cognitoUser = {
        Username: lastAuthUser,
        Pool: this,
        Storage: this.storage
      };
      return new CognitoUser(cognitoUser);
    }
    return null;
  };
  _proto.getUserContextData = function getUserContextData(username) {
    if (typeof AmazonCognitoAdvancedSecurityData === "undefined") {
      return void 0;
    }
    var amazonCognitoAdvancedSecurityDataConst = AmazonCognitoAdvancedSecurityData;
    if (this.advancedSecurityDataCollectionFlag) {
      var advancedSecurityData = amazonCognitoAdvancedSecurityDataConst.getData(username, this.userPoolId, this.clientId);
      if (advancedSecurityData) {
        var userContextData = {
          EncodedData: advancedSecurityData
        };
        return userContextData;
      }
    }
    return {};
  };
  return CognitoUserPool2;
}();
var js_cookie = { exports: {} };
/*!
 * JavaScript Cookie v2.2.1
 * https://github.com/js-cookie/js-cookie
 *
 * Copyright 2006, 2015 Klaus Hartl & Fagner Brack
 * Released under the MIT license
 */
(function(module2, exports) {
  (function(factory) {
    var registeredInModuleLoader;
    {
      module2.exports = factory();
      registeredInModuleLoader = true;
    }
    if (!registeredInModuleLoader) {
      var OldCookies = window.Cookies;
      var api = window.Cookies = factory();
      api.noConflict = function() {
        window.Cookies = OldCookies;
        return api;
      };
    }
  })(function() {
    function extend2() {
      var i2 = 0;
      var result = {};
      for (; i2 < arguments.length; i2++) {
        var attributes = arguments[i2];
        for (var key in attributes) {
          result[key] = attributes[key];
        }
      }
      return result;
    }
    function decode2(s3) {
      return s3.replace(/(%[0-9A-Z]{2})+/g, decodeURIComponent);
    }
    function init(converter) {
      function api() {
      }
      function set2(key, value, attributes) {
        if (typeof document === "undefined") {
          return;
        }
        attributes = extend2({
          path: "/"
        }, api.defaults, attributes);
        if (typeof attributes.expires === "number") {
          attributes.expires = new Date(new Date() * 1 + attributes.expires * 864e5);
        }
        attributes.expires = attributes.expires ? attributes.expires.toUTCString() : "";
        try {
          var result = JSON.stringify(value);
          if (/^[\{\[]/.test(result)) {
            value = result;
          }
        } catch (e3) {
        }
        value = converter.write ? converter.write(value, key) : encodeURIComponent(String(value)).replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent);
        key = encodeURIComponent(String(key)).replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent).replace(/[\(\)]/g, escape);
        var stringifiedAttributes = "";
        for (var attributeName in attributes) {
          if (!attributes[attributeName]) {
            continue;
          }
          stringifiedAttributes += "; " + attributeName;
          if (attributes[attributeName] === true) {
            continue;
          }
          stringifiedAttributes += "=" + attributes[attributeName].split(";")[0];
        }
        return document.cookie = key + "=" + value + stringifiedAttributes;
      }
      function get2(key, json) {
        if (typeof document === "undefined") {
          return;
        }
        var jar = {};
        var cookies2 = document.cookie ? document.cookie.split("; ") : [];
        var i2 = 0;
        for (; i2 < cookies2.length; i2++) {
          var parts = cookies2[i2].split("=");
          var cookie = parts.slice(1).join("=");
          if (!json && cookie.charAt(0) === '"') {
            cookie = cookie.slice(1, -1);
          }
          try {
            var name2 = decode2(parts[0]);
            cookie = (converter.read || converter)(cookie, name2) || decode2(cookie);
            if (json) {
              try {
                cookie = JSON.parse(cookie);
              } catch (e3) {
              }
            }
            jar[name2] = cookie;
            if (key === name2) {
              break;
            }
          } catch (e3) {
          }
        }
        return key ? jar[key] : jar;
      }
      api.set = set2;
      api.get = function(key) {
        return get2(key, false);
      };
      api.getJSON = function(key) {
        return get2(key, true);
      };
      api.remove = function(key, attributes) {
        set2(key, "", extend2(attributes, {
          expires: -1
        }));
      };
      api.defaults = {};
      api.withConverter = init;
      return api;
    }
    return init(function() {
    });
  });
})(js_cookie);
var CookieStorage = /* @__PURE__ */ function() {
  function CookieStorage2(data) {
    if (data.domain) {
      this.domain = data.domain;
    } else {
      throw new Error("The domain of cookieStorage can not be undefined.");
    }
    if (data.path) {
      this.path = data.path;
    } else {
      this.path = "/";
    }
    if (Object.prototype.hasOwnProperty.call(data, "expires")) {
      this.expires = data.expires;
    } else {
      this.expires = 365;
    }
    if (Object.prototype.hasOwnProperty.call(data, "secure")) {
      this.secure = data.secure;
    } else {
      this.secure = true;
    }
    if (Object.prototype.hasOwnProperty.call(data, "sameSite")) {
      if (!["strict", "lax", "none"].includes(data.sameSite)) {
        throw new Error('The sameSite value of cookieStorage must be "lax", "strict" or "none".');
      }
      if (data.sameSite === "none" && !this.secure) {
        throw new Error("sameSite = None requires the Secure attribute in latest browser versions.");
      }
      this.sameSite = data.sameSite;
    } else {
      this.sameSite = null;
    }
  }
  var _proto = CookieStorage2.prototype;
  _proto.setItem = function setItem(key, value) {
    var options = {
      path: this.path,
      expires: this.expires,
      domain: this.domain,
      secure: this.secure
    };
    if (this.sameSite) {
      options.sameSite = this.sameSite;
    }
    js_cookie.exports.set(key, value, options);
    return js_cookie.exports.get(key);
  };
  _proto.getItem = function getItem(key) {
    return js_cookie.exports.get(key);
  };
  _proto.removeItem = function removeItem(key) {
    var options = {
      path: this.path,
      expires: this.expires,
      domain: this.domain,
      secure: this.secure
    };
    if (this.sameSite) {
      options.sameSite = this.sameSite;
    }
    return js_cookie.exports.remove(key, options);
  };
  _proto.clear = function clear2() {
    var cookies2 = js_cookie.exports.get();
    var numKeys = Object.keys(cookies2).length;
    for (var index2 = 0; index2 < numKeys; ++index2) {
      this.removeItem(Object.keys(cookies2)[index2]);
    }
    return {};
  };
  return CookieStorage2;
}();
var SELF = "_self";
var launchUri = function(url) {
  var windowProxy = window.open(url, SELF);
  if (windowProxy) {
    return Promise.resolve(windowProxy);
  } else {
    return Promise.reject();
  }
};
var setState = function(state) {
  window.sessionStorage.setItem("oauth_state", state);
};
var getState = function() {
  var oauth_state = window.sessionStorage.getItem("oauth_state");
  window.sessionStorage.removeItem("oauth_state");
  return oauth_state;
};
var setPKCE = function(private_key) {
  window.sessionStorage.setItem("ouath_pkce_key", private_key);
};
var getPKCE = function() {
  var ouath_pkce_key = window.sessionStorage.getItem("ouath_pkce_key");
  window.sessionStorage.removeItem("ouath_pkce_key");
  return ouath_pkce_key;
};
var AMPLIFY_SYMBOL$1 = typeof Symbol !== "undefined" && typeof Symbol.for === "function" ? Symbol.for("amplify_default") : "@@amplify_default";
var dispatchAuthEvent$1 = function(event, data, message) {
  Hub.dispatch("auth", { event, data, message }, "Auth", AMPLIFY_SYMBOL$1);
};
var logger$2 = new ConsoleLogger("OAuth");
var OAuth = function() {
  function OAuth2(_a2) {
    var config = _a2.config, cognitoClientId = _a2.cognitoClientId, _b = _a2.scopes, scopes = _b === void 0 ? [] : _b;
    this._urlOpener = config.urlOpener || launchUri;
    this._config = config;
    this._cognitoClientId = cognitoClientId;
    if (!this.isValidScopes(scopes))
      throw Error("scopes must be a String Array");
    this._scopes = scopes;
  }
  OAuth2.prototype.isValidScopes = function(scopes) {
    return Array.isArray(scopes) && scopes.every(function(scope) {
      return typeof scope === "string";
    });
  };
  OAuth2.prototype.oauthSignIn = function(responseType, domain, redirectSignIn, clientId, provider, customState) {
    if (responseType === void 0) {
      responseType = "code";
    }
    if (provider === void 0) {
      provider = CognitoHostedUIIdentityProvider.Cognito;
    }
    var generatedState = this._generateState(32);
    var state = customState ? generatedState + "-" + urlSafeEncode(customState) : generatedState;
    setState(state);
    var pkce_key = this._generateRandom(128);
    setPKCE(pkce_key);
    var code_challenge = this._generateChallenge(pkce_key);
    var code_challenge_method = "S256";
    var scopesString = this._scopes.join(" ");
    var queryString = Object.entries(__assign(__assign({ redirect_uri: redirectSignIn, response_type: responseType, client_id: clientId, identity_provider: provider, scope: scopesString, state }, responseType === "code" ? { code_challenge } : {}), responseType === "code" ? { code_challenge_method } : {})).map(function(_a2) {
      var _b = __read(_a2, 2), k2 = _b[0], v = _b[1];
      return encodeURIComponent(k2) + "=" + encodeURIComponent(v);
    }).join("&");
    var URL2 = "https://" + domain + "/oauth2/authorize?" + queryString;
    logger$2.debug("Redirecting to " + URL2);
    this._urlOpener(URL2, redirectSignIn);
  };
  OAuth2.prototype._handleCodeFlow = function(currentUrl) {
    return __awaiter(this, void 0, void 0, function() {
      var code2, currentUrlPathname, redirectSignInPathname, oAuthTokenEndpoint, client_id, redirect_uri, code_verifier, oAuthTokenBody, body, _a2, access_token, refresh_token, id_token, error;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            code2 = (parse$2(currentUrl).query || "").split("&").map(function(pairings) {
              return pairings.split("=");
            }).reduce(function(accum, _a3) {
              var _b2;
              var _c = __read(_a3, 2), k2 = _c[0], v = _c[1];
              return __assign(__assign({}, accum), (_b2 = {}, _b2[k2] = v, _b2));
            }, { code: void 0 }).code;
            currentUrlPathname = parse$2(currentUrl).pathname || "/";
            redirectSignInPathname = parse$2(this._config.redirectSignIn).pathname || "/";
            if (!code2 || currentUrlPathname !== redirectSignInPathname) {
              return [2];
            }
            oAuthTokenEndpoint = "https://" + this._config.domain + "/oauth2/token";
            dispatchAuthEvent$1("codeFlow", {}, "Retrieving tokens from " + oAuthTokenEndpoint);
            client_id = isCognitoHostedOpts(this._config) ? this._cognitoClientId : this._config.clientID;
            redirect_uri = isCognitoHostedOpts(this._config) ? this._config.redirectSignIn : this._config.redirectUri;
            code_verifier = getPKCE();
            oAuthTokenBody = __assign({
              grant_type: "authorization_code",
              code: code2,
              client_id,
              redirect_uri
            }, code_verifier ? { code_verifier } : {});
            logger$2.debug("Calling token endpoint: " + oAuthTokenEndpoint + " with", oAuthTokenBody);
            body = Object.entries(oAuthTokenBody).map(function(_a3) {
              var _b2 = __read(_a3, 2), k2 = _b2[0], v = _b2[1];
              return encodeURIComponent(k2) + "=" + encodeURIComponent(v);
            }).join("&");
            return [4, fetch(oAuthTokenEndpoint, {
              method: "POST",
              headers: {
                "Content-Type": "application/x-www-form-urlencoded"
              },
              body
            })];
          case 1:
            return [4, _b.sent().json()];
          case 2:
            _a2 = _b.sent(), access_token = _a2.access_token, refresh_token = _a2.refresh_token, id_token = _a2.id_token, error = _a2.error;
            if (error) {
              throw new Error(error);
            }
            return [2, {
              accessToken: access_token,
              refreshToken: refresh_token,
              idToken: id_token
            }];
        }
      });
    });
  };
  OAuth2.prototype._handleImplicitFlow = function(currentUrl) {
    return __awaiter(this, void 0, void 0, function() {
      var _a2, id_token, access_token;
      return __generator(this, function(_b) {
        _a2 = (parse$2(currentUrl).hash || "#").substr(1).split("&").map(function(pairings) {
          return pairings.split("=");
        }).reduce(function(accum, _a3) {
          var _b2;
          var _c = __read(_a3, 2), k2 = _c[0], v = _c[1];
          return __assign(__assign({}, accum), (_b2 = {}, _b2[k2] = v, _b2));
        }, {
          id_token: void 0,
          access_token: void 0
        }), id_token = _a2.id_token, access_token = _a2.access_token;
        dispatchAuthEvent$1("implicitFlow", {}, "Got tokens from " + currentUrl);
        logger$2.debug("Retrieving implicit tokens from " + currentUrl + " with");
        return [2, {
          accessToken: access_token,
          idToken: id_token,
          refreshToken: null
        }];
      });
    });
  };
  OAuth2.prototype.handleAuthResponse = function(currentUrl) {
    return __awaiter(this, void 0, void 0, function() {
      var urlParams, error, error_description, state, _a2, _b, e_1;
      return __generator(this, function(_c) {
        switch (_c.label) {
          case 0:
            _c.trys.push([0, 5, , 6]);
            urlParams = currentUrl ? __assign(__assign({}, (parse$2(currentUrl).hash || "#").substr(1).split("&").map(function(entry) {
              return entry.split("=");
            }).reduce(function(acc, _a3) {
              var _b2 = __read(_a3, 2), k2 = _b2[0], v = _b2[1];
              return acc[k2] = v, acc;
            }, {})), (parse$2(currentUrl).query || "").split("&").map(function(entry) {
              return entry.split("=");
            }).reduce(function(acc, _a3) {
              var _b2 = __read(_a3, 2), k2 = _b2[0], v = _b2[1];
              return acc[k2] = v, acc;
            }, {})) : {};
            error = urlParams.error, error_description = urlParams.error_description;
            if (error) {
              throw new Error(error_description);
            }
            state = this._validateState(urlParams);
            logger$2.debug("Starting " + this._config.responseType + " flow with " + currentUrl);
            if (!(this._config.responseType === "code"))
              return [3, 2];
            _a2 = [{}];
            return [4, this._handleCodeFlow(currentUrl)];
          case 1:
            return [2, __assign.apply(void 0, [__assign.apply(void 0, _a2.concat([_c.sent()])), { state }])];
          case 2:
            _b = [{}];
            return [4, this._handleImplicitFlow(currentUrl)];
          case 3:
            return [2, __assign.apply(void 0, [__assign.apply(void 0, _b.concat([_c.sent()])), { state }])];
          case 4:
            return [3, 6];
          case 5:
            e_1 = _c.sent();
            logger$2.error("Error handling auth response.", e_1);
            throw e_1;
          case 6:
            return [2];
        }
      });
    });
  };
  OAuth2.prototype._validateState = function(urlParams) {
    if (!urlParams) {
      return;
    }
    var savedState = getState();
    var returnedState = urlParams.state;
    if (savedState && savedState !== returnedState) {
      throw new Error("Invalid state in OAuth flow");
    }
    return returnedState;
  };
  OAuth2.prototype.signOut = function() {
    return __awaiter(this, void 0, void 0, function() {
      var oAuthLogoutEndpoint, client_id, signout_uri;
      return __generator(this, function(_a2) {
        oAuthLogoutEndpoint = "https://" + this._config.domain + "/logout?";
        client_id = isCognitoHostedOpts(this._config) ? this._cognitoClientId : this._config.oauth.clientID;
        signout_uri = isCognitoHostedOpts(this._config) ? this._config.redirectSignOut : this._config.returnTo;
        oAuthLogoutEndpoint += Object.entries({
          client_id,
          logout_uri: encodeURIComponent(signout_uri)
        }).map(function(_a3) {
          var _b = __read(_a3, 2), k2 = _b[0], v = _b[1];
          return k2 + "=" + v;
        }).join("&");
        dispatchAuthEvent$1("oAuthSignOut", { oAuth: "signOut" }, "Signing out from " + oAuthLogoutEndpoint);
        logger$2.debug("Signing out from " + oAuthLogoutEndpoint);
        return [2, this._urlOpener(oAuthLogoutEndpoint, signout_uri)];
      });
    });
  };
  OAuth2.prototype._generateState = function(length) {
    var result = "";
    var i2 = length;
    var chars = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
    for (; i2 > 0; --i2)
      result += chars[Math.round(Math.random() * (chars.length - 1))];
    return result;
  };
  OAuth2.prototype._generateChallenge = function(code2) {
    var awsCryptoHash = new build$4.Sha256();
    awsCryptoHash.update(code2);
    var resultFromAWSCrypto = awsCryptoHash.digestSync();
    var b64 = buffer.Buffer.from(resultFromAWSCrypto).toString("base64");
    var base64URLFromAWSCrypto = this._base64URL(b64);
    return base64URLFromAWSCrypto;
  };
  OAuth2.prototype._base64URL = function(string) {
    return string.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
  };
  OAuth2.prototype._generateRandom = function(size2) {
    var CHARSET = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~";
    var buffer2 = new Uint8Array(size2);
    if (typeof window !== "undefined" && !!window.crypto) {
      window.crypto.getRandomValues(buffer2);
    } else {
      for (var i2 = 0; i2 < size2; i2 += 1) {
        buffer2[i2] = Math.random() * CHARSET.length | 0;
      }
    }
    return this._bufferToString(buffer2);
  };
  OAuth2.prototype._bufferToString = function(buffer2) {
    var CHARSET = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    var state = [];
    for (var i2 = 0; i2 < buffer2.byteLength; i2 += 1) {
      var index2 = buffer2[i2] % CHARSET.length;
      state.push(CHARSET[index2]);
    }
    return state.join("");
  };
  return OAuth2;
}();
const OAuth$1 = OAuth;
const urlListener = function(callback) {
  if (browserOrNode().isBrowser && window.location) {
    var url = window.location.href;
    callback({ url });
  } else if (browserOrNode().isNode)
    ;
  else {
    throw new Error("Not supported");
  }
};
var AuthErrorStrings;
(function(AuthErrorStrings2) {
  AuthErrorStrings2["DEFAULT_MSG"] = "Authentication Error";
  AuthErrorStrings2["EMPTY_EMAIL"] = "Email cannot be empty";
  AuthErrorStrings2["EMPTY_PHONE"] = "Phone number cannot be empty";
  AuthErrorStrings2["EMPTY_USERNAME"] = "Username cannot be empty";
  AuthErrorStrings2["INVALID_USERNAME"] = "The username should either be a string or one of the sign in types";
  AuthErrorStrings2["EMPTY_PASSWORD"] = "Password cannot be empty";
  AuthErrorStrings2["EMPTY_CODE"] = "Confirmation code cannot be empty";
  AuthErrorStrings2["SIGN_UP_ERROR"] = "Error creating account";
  AuthErrorStrings2["NO_MFA"] = "No valid MFA method provided";
  AuthErrorStrings2["INVALID_MFA"] = "Invalid MFA type";
  AuthErrorStrings2["EMPTY_CHALLENGE"] = "Challenge response cannot be empty";
  AuthErrorStrings2["NO_USER_SESSION"] = "Failed to get the session because the user is empty";
  AuthErrorStrings2["NETWORK_ERROR"] = "Network Error";
  AuthErrorStrings2["DEVICE_CONFIG"] = "Device tracking has not been configured in this User Pool";
  AuthErrorStrings2["AUTOSIGNIN_ERROR"] = "Please use your credentials to sign in";
})(AuthErrorStrings || (AuthErrorStrings = {}));
var logger$1 = new ConsoleLogger("AuthError");
var AuthError = function(_super) {
  __extends(AuthError2, _super);
  function AuthError2(type) {
    var _this = this;
    var _a2 = authErrorMessages[type], message = _a2.message, log = _a2.log;
    _this = _super.call(this, message) || this;
    _this.constructor = AuthError2;
    Object.setPrototypeOf(_this, AuthError2.prototype);
    _this.name = "AuthError";
    _this.log = log || message;
    logger$1.error(_this.log);
    return _this;
  }
  return AuthError2;
}(Error);
var NoUserPoolError = function(_super) {
  __extends(NoUserPoolError2, _super);
  function NoUserPoolError2(type) {
    var _this = _super.call(this, type) || this;
    _this.constructor = NoUserPoolError2;
    Object.setPrototypeOf(_this, NoUserPoolError2.prototype);
    _this.name = "NoUserPoolError";
    return _this;
  }
  return NoUserPoolError2;
}(AuthError);
var authErrorMessages = {
  noConfig: {
    message: AuthErrorStrings.DEFAULT_MSG,
    log: "\n            Error: Amplify has not been configured correctly.\n            This error is typically caused by one of the following scenarios:\n\n            1. Make sure you're passing the awsconfig object to Amplify.configure() in your app's entry point\n                See https://aws-amplify.github.io/docs/js/authentication#configure-your-app for more information\n            \n            2. There might be multiple conflicting versions of amplify packages in your node_modules.\n				Refer to our docs site for help upgrading Amplify packages (https://docs.amplify.aws/lib/troubleshooting/upgrading/q/platform/js)\n        "
  },
  missingAuthConfig: {
    message: AuthErrorStrings.DEFAULT_MSG,
    log: "\n            Error: Amplify has not been configured correctly. \n            The configuration object is missing required auth properties.\n            This error is typically caused by one of the following scenarios:\n\n            1. Did you run `amplify push` after adding auth via `amplify add auth`?\n                See https://aws-amplify.github.io/docs/js/authentication#amplify-project-setup for more information\n\n            2. This could also be caused by multiple conflicting versions of amplify packages, see (https://docs.amplify.aws/lib/troubleshooting/upgrading/q/platform/js) for help upgrading Amplify packages.\n        "
  },
  emptyUsername: {
    message: AuthErrorStrings.EMPTY_USERNAME
  },
  invalidUsername: {
    message: AuthErrorStrings.INVALID_USERNAME
  },
  emptyPassword: {
    message: AuthErrorStrings.EMPTY_PASSWORD
  },
  emptyCode: {
    message: AuthErrorStrings.EMPTY_CODE
  },
  signUpError: {
    message: AuthErrorStrings.SIGN_UP_ERROR,
    log: "The first parameter should either be non-null string or object"
  },
  noMFA: {
    message: AuthErrorStrings.NO_MFA
  },
  invalidMFA: {
    message: AuthErrorStrings.INVALID_MFA
  },
  emptyChallengeResponse: {
    message: AuthErrorStrings.EMPTY_CHALLENGE
  },
  noUserSession: {
    message: AuthErrorStrings.NO_USER_SESSION
  },
  deviceConfig: {
    message: AuthErrorStrings.DEVICE_CONFIG
  },
  networkError: {
    message: AuthErrorStrings.NETWORK_ERROR
  },
  autoSignInError: {
    message: AuthErrorStrings.AUTOSIGNIN_ERROR
  },
  default: {
    message: AuthErrorStrings.DEFAULT_MSG
  }
};
var logger = new ConsoleLogger("AuthClass");
var USER_ADMIN_SCOPE = "aws.cognito.signin.user.admin";
var OAUTH_FLOW_MS_TIMEOUT = 10 * 1e3;
var AMPLIFY_SYMBOL = typeof Symbol !== "undefined" && typeof Symbol.for === "function" ? Symbol.for("amplify_default") : "@@amplify_default";
var dispatchAuthEvent = function(event, data, message) {
  Hub.dispatch("auth", { event, data, message }, "Auth", AMPLIFY_SYMBOL);
};
var MAX_DEVICES = 60;
var MAX_AUTOSIGNIN_POLLING_MS = 3 * 60 * 1e3;
var AuthClass = function() {
  function AuthClass2(config) {
    var _this = this;
    this.userPool = null;
    this.user = null;
    this.oAuthFlowInProgress = false;
    this.autoSignInInitiated = false;
    this.inflightSessionPromise = null;
    this.inflightSessionPromiseCounter = 0;
    this.Credentials = Credentials;
    this.wrapRefreshSessionCallback = function(callback) {
      var wrapped = function(error, data) {
        if (data) {
          dispatchAuthEvent("tokenRefresh", void 0, "New token retrieved");
        } else {
          dispatchAuthEvent("tokenRefresh_failure", error, "Failed to retrieve new token");
        }
        return callback(error, data);
      };
      return wrapped;
    };
    this.configure(config);
    this.currentCredentials = this.currentCredentials.bind(this);
    this.currentUserCredentials = this.currentUserCredentials.bind(this);
    Hub.listen("auth", function(_a2) {
      var payload = _a2.payload;
      var event = payload.event;
      switch (event) {
        case "verify":
        case "signIn":
          _this._storage.setItem("amplify-signin-with-hostedUI", "false");
          break;
        case "signOut":
          _this._storage.removeItem("amplify-signin-with-hostedUI");
          break;
        case "cognitoHostedUI":
          _this._storage.setItem("amplify-signin-with-hostedUI", "true");
          break;
      }
    });
  }
  AuthClass2.prototype.getModuleName = function() {
    return "Auth";
  };
  AuthClass2.prototype.configure = function(config) {
    var _this = this;
    if (!config)
      return this._config || {};
    logger.debug("configure Auth");
    var conf = Object.assign({}, this._config, parseAWSExports(config).Auth, config);
    this._config = conf;
    var _a2 = this._config, userPoolId = _a2.userPoolId, userPoolWebClientId = _a2.userPoolWebClientId, cookieStorage = _a2.cookieStorage, oauth = _a2.oauth, region = _a2.region, identityPoolId = _a2.identityPoolId, mandatorySignIn = _a2.mandatorySignIn, refreshHandlers = _a2.refreshHandlers, identityPoolRegion = _a2.identityPoolRegion, clientMetadata = _a2.clientMetadata, endpoint = _a2.endpoint;
    if (!this._config.storage) {
      if (cookieStorage)
        this._storage = new CookieStorage(cookieStorage);
      else {
        this._storage = config.ssr ? new UniversalStorage() : new StorageHelper$1().getStorage();
      }
    } else {
      if (!this._isValidAuthStorage(this._config.storage)) {
        logger.error("The storage in the Auth config is not valid!");
        throw new Error("Empty storage object");
      }
      this._storage = this._config.storage;
    }
    this._storageSync = Promise.resolve();
    if (typeof this._storage["sync"] === "function") {
      this._storageSync = this._storage["sync"]();
    }
    if (userPoolId) {
      var userPoolData = {
        UserPoolId: userPoolId,
        ClientId: userPoolWebClientId,
        endpoint
      };
      userPoolData.Storage = this._storage;
      this.userPool = new CognitoUserPool(userPoolData, this.wrapRefreshSessionCallback);
    }
    this.Credentials.configure({
      mandatorySignIn,
      region,
      userPoolId,
      identityPoolId,
      refreshHandlers,
      storage: this._storage,
      identityPoolRegion
    });
    var cognitoHostedUIConfig = oauth ? isCognitoHostedOpts(this._config.oauth) ? oauth : oauth.awsCognito : void 0;
    if (cognitoHostedUIConfig) {
      var cognitoAuthParams = Object.assign({
        cognitoClientId: userPoolWebClientId,
        UserPoolId: userPoolId,
        domain: cognitoHostedUIConfig["domain"],
        scopes: cognitoHostedUIConfig["scope"],
        redirectSignIn: cognitoHostedUIConfig["redirectSignIn"],
        redirectSignOut: cognitoHostedUIConfig["redirectSignOut"],
        responseType: cognitoHostedUIConfig["responseType"],
        Storage: this._storage,
        urlOpener: cognitoHostedUIConfig["urlOpener"],
        clientMetadata
      }, cognitoHostedUIConfig["options"]);
      this._oAuthHandler = new OAuth$1({
        scopes: cognitoAuthParams.scopes,
        config: cognitoAuthParams,
        cognitoClientId: cognitoAuthParams.cognitoClientId
      });
      var usedResponseUrls_1 = {};
      urlListener(function(_a3) {
        var url = _a3.url;
        if (usedResponseUrls_1[url]) {
          return;
        }
        usedResponseUrls_1[url] = true;
        _this._handleAuthResponse(url);
      });
    }
    dispatchAuthEvent("configured", null, "The Auth category has been configured successfully");
    if (!this.autoSignInInitiated && typeof this._storage["getItem"] === "function") {
      var pollingInitiated = this.isTrueStorageValue("amplify-polling-started");
      if (pollingInitiated) {
        dispatchAuthEvent("autoSignIn_failure", null, AuthErrorTypes.AutoSignInError);
        this._storage.removeItem("amplify-auto-sign-in");
      }
      this._storage.removeItem("amplify-polling-started");
    }
    return this._config;
  };
  AuthClass2.prototype.signUp = function(params) {
    var _this = this;
    var restOfAttrs = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      restOfAttrs[_i - 1] = arguments[_i];
    }
    var _a2, _b, _c;
    if (!this.userPool) {
      return this.rejectNoUserPool();
    }
    var username = null;
    var password = null;
    var attributes = [];
    var validationData = null;
    var clientMetadata;
    var autoSignIn = { enabled: false };
    var autoSignInValidationData = {};
    var autoSignInClientMetaData = {};
    if (params && typeof params === "string") {
      username = params;
      password = restOfAttrs ? restOfAttrs[0] : null;
      var email = restOfAttrs ? restOfAttrs[1] : null;
      var phone_number = restOfAttrs ? restOfAttrs[2] : null;
      if (email)
        attributes.push(new CognitoUserAttribute({ Name: "email", Value: email }));
      if (phone_number)
        attributes.push(new CognitoUserAttribute({
          Name: "phone_number",
          Value: phone_number
        }));
    } else if (params && typeof params === "object") {
      username = params["username"];
      password = params["password"];
      if (params && params.clientMetadata) {
        clientMetadata = params.clientMetadata;
      } else if (this._config.clientMetadata) {
        clientMetadata = this._config.clientMetadata;
      }
      var attrs_1 = params["attributes"];
      if (attrs_1) {
        Object.keys(attrs_1).map(function(key) {
          attributes.push(new CognitoUserAttribute({ Name: key, Value: attrs_1[key] }));
        });
      }
      var validationDataObject_1 = params["validationData"];
      if (validationDataObject_1) {
        validationData = [];
        Object.keys(validationDataObject_1).map(function(key) {
          validationData.push(new CognitoUserAttribute({
            Name: key,
            Value: validationDataObject_1[key]
          }));
        });
      }
      autoSignIn = (_a2 = params.autoSignIn) !== null && _a2 !== void 0 ? _a2 : { enabled: false };
      if (autoSignIn.enabled) {
        this._storage.setItem("amplify-auto-sign-in", "true");
        autoSignInValidationData = (_b = autoSignIn.validationData) !== null && _b !== void 0 ? _b : {};
        autoSignInClientMetaData = (_c = autoSignIn.clientMetaData) !== null && _c !== void 0 ? _c : {};
      }
    } else {
      return this.rejectAuthError(AuthErrorTypes.SignUpError);
    }
    if (!username) {
      return this.rejectAuthError(AuthErrorTypes.EmptyUsername);
    }
    if (!password) {
      return this.rejectAuthError(AuthErrorTypes.EmptyPassword);
    }
    logger.debug("signUp attrs:", attributes);
    logger.debug("signUp validation data:", validationData);
    return new Promise(function(resolve2, reject) {
      _this.userPool.signUp(username, password, attributes, validationData, function(err, data) {
        if (err) {
          dispatchAuthEvent("signUp_failure", err, username + " failed to signup");
          reject(err);
        } else {
          dispatchAuthEvent("signUp", data, username + " has signed up successfully");
          if (autoSignIn.enabled) {
            _this.handleAutoSignIn(username, password, autoSignInValidationData, autoSignInClientMetaData, data);
          }
          resolve2(data);
        }
      }, clientMetadata);
    });
  };
  AuthClass2.prototype.handleAutoSignIn = function(username, password, validationData, clientMetadata, data) {
    this.autoSignInInitiated = true;
    var authDetails = new AuthenticationDetails({
      Username: username,
      Password: password,
      ValidationData: validationData,
      ClientMetadata: clientMetadata
    });
    if (data.userConfirmed) {
      this.signInAfterUserConfirmed(authDetails);
    } else if (this._config.signUpVerificationMethod === "link") {
      this.handleLinkAutoSignIn(authDetails);
    } else {
      this.handleCodeAutoSignIn(authDetails);
    }
  };
  AuthClass2.prototype.handleCodeAutoSignIn = function(authDetails) {
    var _this = this;
    var listenEvent = function(_a2) {
      var payload = _a2.payload;
      if (payload.event === "confirmSignUp") {
        _this.signInAfterUserConfirmed(authDetails, listenEvent);
      }
    };
    Hub.listen("auth", listenEvent);
  };
  AuthClass2.prototype.handleLinkAutoSignIn = function(authDetails) {
    var _this = this;
    this._storage.setItem("amplify-polling-started", "true");
    var start = Date.now();
    var autoSignInPollingIntervalId = setInterval(function() {
      if (Date.now() - start > MAX_AUTOSIGNIN_POLLING_MS) {
        clearInterval(autoSignInPollingIntervalId);
        dispatchAuthEvent("autoSignIn_failure", null, "Please confirm your account and use your credentials to sign in.");
        _this._storage.removeItem("amplify-auto-sign-in");
      } else {
        _this.signInAfterUserConfirmed(authDetails, null, autoSignInPollingIntervalId);
      }
    }, 5e3);
  };
  AuthClass2.prototype.signInAfterUserConfirmed = function(authDetails, listenEvent, autoSignInPollingIntervalId) {
    return __awaiter(this, void 0, void 0, function() {
      var user, error_1;
      var _this = this;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            user = this.createCognitoUser(authDetails.getUsername());
            _a2.label = 1;
          case 1:
            _a2.trys.push([1, 3, , 4]);
            return [4, user.authenticateUser(authDetails, this.authCallbacks(user, function(value) {
              dispatchAuthEvent("autoSignIn", value, authDetails.getUsername() + " has signed in successfully");
              if (listenEvent) {
                Hub.remove("auth", listenEvent);
              }
              if (autoSignInPollingIntervalId) {
                clearInterval(autoSignInPollingIntervalId);
                _this._storage.removeItem("amplify-polling-started");
              }
              _this._storage.removeItem("amplify-auto-sign-in");
            }, function(error) {
              logger.error(error);
              _this._storage.removeItem("amplify-auto-sign-in");
            }))];
          case 2:
            _a2.sent();
            return [3, 4];
          case 3:
            error_1 = _a2.sent();
            logger.error(error_1);
            return [3, 4];
          case 4:
            return [2];
        }
      });
    });
  };
  AuthClass2.prototype.confirmSignUp = function(username, code2, options) {
    var _this = this;
    if (!this.userPool) {
      return this.rejectNoUserPool();
    }
    if (!username) {
      return this.rejectAuthError(AuthErrorTypes.EmptyUsername);
    }
    if (!code2) {
      return this.rejectAuthError(AuthErrorTypes.EmptyCode);
    }
    var user = this.createCognitoUser(username);
    var forceAliasCreation = options && typeof options.forceAliasCreation === "boolean" ? options.forceAliasCreation : true;
    var clientMetadata;
    if (options && options.clientMetadata) {
      clientMetadata = options.clientMetadata;
    } else if (this._config.clientMetadata) {
      clientMetadata = this._config.clientMetadata;
    }
    return new Promise(function(resolve2, reject) {
      user.confirmRegistration(code2, forceAliasCreation, function(err, data) {
        if (err) {
          reject(err);
        } else {
          dispatchAuthEvent("confirmSignUp", data, username + " has been confirmed successfully");
          var autoSignIn = _this.isTrueStorageValue("amplify-auto-sign-in");
          if (autoSignIn && !_this.autoSignInInitiated) {
            dispatchAuthEvent("autoSignIn_failure", null, AuthErrorTypes.AutoSignInError);
            _this._storage.removeItem("amplify-auto-sign-in");
          }
          resolve2(data);
        }
      }, clientMetadata);
    });
  };
  AuthClass2.prototype.isTrueStorageValue = function(value) {
    var item = this._storage.getItem(value);
    return item ? item === "true" : false;
  };
  AuthClass2.prototype.resendSignUp = function(username, clientMetadata) {
    if (clientMetadata === void 0) {
      clientMetadata = this._config.clientMetadata;
    }
    if (!this.userPool) {
      return this.rejectNoUserPool();
    }
    if (!username) {
      return this.rejectAuthError(AuthErrorTypes.EmptyUsername);
    }
    var user = this.createCognitoUser(username);
    return new Promise(function(resolve2, reject) {
      user.resendConfirmationCode(function(err, data) {
        if (err) {
          reject(err);
        } else {
          resolve2(data);
        }
      }, clientMetadata);
    });
  };
  AuthClass2.prototype.signIn = function(usernameOrSignInOpts, pw, clientMetadata) {
    if (clientMetadata === void 0) {
      clientMetadata = this._config.clientMetadata;
    }
    if (!this.userPool) {
      return this.rejectNoUserPool();
    }
    var username = null;
    var password = null;
    var validationData = {};
    if (typeof usernameOrSignInOpts === "string") {
      username = usernameOrSignInOpts;
      password = pw;
    } else if (isUsernamePasswordOpts(usernameOrSignInOpts)) {
      if (typeof pw !== "undefined") {
        logger.warn("The password should be defined under the first parameter object!");
      }
      username = usernameOrSignInOpts.username;
      password = usernameOrSignInOpts.password;
      validationData = usernameOrSignInOpts.validationData;
    } else {
      return this.rejectAuthError(AuthErrorTypes.InvalidUsername);
    }
    if (!username) {
      return this.rejectAuthError(AuthErrorTypes.EmptyUsername);
    }
    var authDetails = new AuthenticationDetails({
      Username: username,
      Password: password,
      ValidationData: validationData,
      ClientMetadata: clientMetadata
    });
    if (password) {
      return this.signInWithPassword(authDetails);
    } else {
      return this.signInWithoutPassword(authDetails);
    }
  };
  AuthClass2.prototype.authCallbacks = function(user, resolve2, reject) {
    var _this = this;
    var that = this;
    return {
      onSuccess: function(session) {
        return __awaiter(_this, void 0, void 0, function() {
          var cred, e_1, currentUser, e_2;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                logger.debug(session);
                delete user["challengeName"];
                delete user["challengeParam"];
                _a2.label = 1;
              case 1:
                _a2.trys.push([1, 4, 5, 9]);
                return [4, this.Credentials.clear()];
              case 2:
                _a2.sent();
                return [4, this.Credentials.set(session, "session")];
              case 3:
                cred = _a2.sent();
                logger.debug("succeed to get cognito credentials", cred);
                return [3, 9];
              case 4:
                e_1 = _a2.sent();
                logger.debug("cannot get cognito credentials", e_1);
                return [3, 9];
              case 5:
                _a2.trys.push([5, 7, , 8]);
                return [4, this.currentUserPoolUser()];
              case 6:
                currentUser = _a2.sent();
                that.user = currentUser;
                dispatchAuthEvent("signIn", currentUser, "A user " + user.getUsername() + " has been signed in");
                resolve2(currentUser);
                return [3, 8];
              case 7:
                e_2 = _a2.sent();
                logger.error("Failed to get the signed in user", e_2);
                reject(e_2);
                return [3, 8];
              case 8:
                return [7];
              case 9:
                return [2];
            }
          });
        });
      },
      onFailure: function(err) {
        logger.debug("signIn failure", err);
        dispatchAuthEvent("signIn_failure", err, user.getUsername() + " failed to signin");
        reject(err);
      },
      customChallenge: function(challengeParam) {
        logger.debug("signIn custom challenge answer required");
        user["challengeName"] = "CUSTOM_CHALLENGE";
        user["challengeParam"] = challengeParam;
        resolve2(user);
      },
      mfaRequired: function(challengeName, challengeParam) {
        logger.debug("signIn MFA required");
        user["challengeName"] = challengeName;
        user["challengeParam"] = challengeParam;
        resolve2(user);
      },
      mfaSetup: function(challengeName, challengeParam) {
        logger.debug("signIn mfa setup", challengeName);
        user["challengeName"] = challengeName;
        user["challengeParam"] = challengeParam;
        resolve2(user);
      },
      newPasswordRequired: function(userAttributes, requiredAttributes) {
        logger.debug("signIn new password");
        user["challengeName"] = "NEW_PASSWORD_REQUIRED";
        user["challengeParam"] = {
          userAttributes,
          requiredAttributes
        };
        resolve2(user);
      },
      totpRequired: function(challengeName, challengeParam) {
        logger.debug("signIn totpRequired");
        user["challengeName"] = challengeName;
        user["challengeParam"] = challengeParam;
        resolve2(user);
      },
      selectMFAType: function(challengeName, challengeParam) {
        logger.debug("signIn selectMFAType", challengeName);
        user["challengeName"] = challengeName;
        user["challengeParam"] = challengeParam;
        resolve2(user);
      }
    };
  };
  AuthClass2.prototype.signInWithPassword = function(authDetails) {
    var _this = this;
    if (this.pendingSignIn) {
      throw new Error("Pending sign-in attempt already in progress");
    }
    var user = this.createCognitoUser(authDetails.getUsername());
    this.pendingSignIn = new Promise(function(resolve2, reject) {
      user.authenticateUser(authDetails, _this.authCallbacks(user, function(value) {
        _this.pendingSignIn = null;
        resolve2(value);
      }, function(error) {
        _this.pendingSignIn = null;
        reject(error);
      }));
    });
    return this.pendingSignIn;
  };
  AuthClass2.prototype.signInWithoutPassword = function(authDetails) {
    var _this = this;
    var user = this.createCognitoUser(authDetails.getUsername());
    user.setAuthenticationFlowType("CUSTOM_AUTH");
    return new Promise(function(resolve2, reject) {
      user.initiateAuth(authDetails, _this.authCallbacks(user, resolve2, reject));
    });
  };
  AuthClass2.prototype.getMFAOptions = function(user) {
    return new Promise(function(res, rej) {
      user.getMFAOptions(function(err, mfaOptions) {
        if (err) {
          logger.debug("get MFA Options failed", err);
          rej(err);
          return;
        }
        logger.debug("get MFA options success", mfaOptions);
        res(mfaOptions);
        return;
      });
    });
  };
  AuthClass2.prototype.getPreferredMFA = function(user, params) {
    var _this = this;
    var that = this;
    return new Promise(function(res, rej) {
      var clientMetadata = _this._config.clientMetadata;
      var bypassCache = params ? params.bypassCache : false;
      user.getUserData(function(err, data) {
        return __awaiter(_this, void 0, void 0, function() {
          var cleanUpError_1, mfaType;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                if (!err)
                  return [3, 5];
                logger.debug("getting preferred mfa failed", err);
                if (!this.isSessionInvalid(err))
                  return [3, 4];
                _a2.label = 1;
              case 1:
                _a2.trys.push([1, 3, , 4]);
                return [4, this.cleanUpInvalidSession(user)];
              case 2:
                _a2.sent();
                return [3, 4];
              case 3:
                cleanUpError_1 = _a2.sent();
                rej(new Error("Session is invalid due to: " + err.message + " and failed to clean up invalid session: " + cleanUpError_1.message));
                return [2];
              case 4:
                rej(err);
                return [2];
              case 5:
                mfaType = that._getMfaTypeFromUserData(data);
                if (!mfaType) {
                  rej("invalid MFA Type");
                  return [2];
                } else {
                  res(mfaType);
                  return [2];
                }
            }
          });
        });
      }, { bypassCache, clientMetadata });
    });
  };
  AuthClass2.prototype._getMfaTypeFromUserData = function(data) {
    var ret = null;
    var preferredMFA = data.PreferredMfaSetting;
    if (preferredMFA) {
      ret = preferredMFA;
    } else {
      var mfaList = data.UserMFASettingList;
      if (!mfaList) {
        var MFAOptions = data.MFAOptions;
        if (MFAOptions) {
          ret = "SMS_MFA";
        } else {
          ret = "NOMFA";
        }
      } else if (mfaList.length === 0) {
        ret = "NOMFA";
      } else {
        logger.debug("invalid case for getPreferredMFA", data);
      }
    }
    return ret;
  };
  AuthClass2.prototype._getUserData = function(user, params) {
    var _this = this;
    return new Promise(function(res, rej) {
      user.getUserData(function(err, data) {
        return __awaiter(_this, void 0, void 0, function() {
          var cleanUpError_2;
          return __generator(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                if (!err)
                  return [3, 5];
                logger.debug("getting user data failed", err);
                if (!this.isSessionInvalid(err))
                  return [3, 4];
                _a2.label = 1;
              case 1:
                _a2.trys.push([1, 3, , 4]);
                return [4, this.cleanUpInvalidSession(user)];
              case 2:
                _a2.sent();
                return [3, 4];
              case 3:
                cleanUpError_2 = _a2.sent();
                rej(new Error("Session is invalid due to: " + err.message + " and failed to clean up invalid session: " + cleanUpError_2.message));
                return [2];
              case 4:
                rej(err);
                return [2];
              case 5:
                res(data);
                _a2.label = 6;
              case 6:
                return [2];
            }
          });
        });
      }, params);
    });
  };
  AuthClass2.prototype.setPreferredMFA = function(user, mfaMethod) {
    return __awaiter(this, void 0, void 0, function() {
      var clientMetadata, userData, smsMfaSettings, totpMfaSettings, _a2, mfaList, currentMFAType;
      var _this = this;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            clientMetadata = this._config.clientMetadata;
            return [4, this._getUserData(user, {
              bypassCache: true,
              clientMetadata
            })];
          case 1:
            userData = _b.sent();
            smsMfaSettings = null;
            totpMfaSettings = null;
            _a2 = mfaMethod;
            switch (_a2) {
              case "TOTP":
                return [3, 2];
              case "SOFTWARE_TOKEN_MFA":
                return [3, 2];
              case "SMS":
                return [3, 3];
              case "SMS_MFA":
                return [3, 3];
              case "NOMFA":
                return [3, 4];
            }
            return [3, 6];
          case 2:
            totpMfaSettings = {
              PreferredMfa: true,
              Enabled: true
            };
            return [3, 7];
          case 3:
            smsMfaSettings = {
              PreferredMfa: true,
              Enabled: true
            };
            return [3, 7];
          case 4:
            mfaList = userData["UserMFASettingList"];
            return [4, this._getMfaTypeFromUserData(userData)];
          case 5:
            currentMFAType = _b.sent();
            if (currentMFAType === "NOMFA") {
              return [2, Promise.resolve("No change for mfa type")];
            } else if (currentMFAType === "SMS_MFA") {
              smsMfaSettings = {
                PreferredMfa: false,
                Enabled: false
              };
            } else if (currentMFAType === "SOFTWARE_TOKEN_MFA") {
              totpMfaSettings = {
                PreferredMfa: false,
                Enabled: false
              };
            } else {
              return [2, this.rejectAuthError(AuthErrorTypes.InvalidMFA)];
            }
            if (mfaList && mfaList.length !== 0) {
              mfaList.forEach(function(mfaType) {
                if (mfaType === "SMS_MFA") {
                  smsMfaSettings = {
                    PreferredMfa: false,
                    Enabled: false
                  };
                } else if (mfaType === "SOFTWARE_TOKEN_MFA") {
                  totpMfaSettings = {
                    PreferredMfa: false,
                    Enabled: false
                  };
                }
              });
            }
            return [3, 7];
          case 6:
            logger.debug("no validmfa method provided");
            return [2, this.rejectAuthError(AuthErrorTypes.NoMFA)];
          case 7:
            return [2, new Promise(function(res, rej) {
              user.setUserMfaPreference(smsMfaSettings, totpMfaSettings, function(err, result) {
                if (err) {
                  logger.debug("Set user mfa preference error", err);
                  return rej(err);
                }
                logger.debug("Set user mfa success", result);
                logger.debug("Caching the latest user data into local");
                user.getUserData(function(err2, data) {
                  return __awaiter(_this, void 0, void 0, function() {
                    var cleanUpError_3;
                    return __generator(this, function(_a3) {
                      switch (_a3.label) {
                        case 0:
                          if (!err2)
                            return [3, 5];
                          logger.debug("getting user data failed", err2);
                          if (!this.isSessionInvalid(err2))
                            return [3, 4];
                          _a3.label = 1;
                        case 1:
                          _a3.trys.push([1, 3, , 4]);
                          return [4, this.cleanUpInvalidSession(user)];
                        case 2:
                          _a3.sent();
                          return [3, 4];
                        case 3:
                          cleanUpError_3 = _a3.sent();
                          rej(new Error("Session is invalid due to: " + err2.message + " and failed to clean up invalid session: " + cleanUpError_3.message));
                          return [2];
                        case 4:
                          return [2, rej(err2)];
                        case 5:
                          return [2, res(result)];
                      }
                    });
                  });
                }, {
                  bypassCache: true,
                  clientMetadata
                });
              });
            })];
        }
      });
    });
  };
  AuthClass2.prototype.disableSMS = function(user) {
    return new Promise(function(res, rej) {
      user.disableMFA(function(err, data) {
        if (err) {
          logger.debug("disable mfa failed", err);
          rej(err);
          return;
        }
        logger.debug("disable mfa succeed", data);
        res(data);
        return;
      });
    });
  };
  AuthClass2.prototype.enableSMS = function(user) {
    return new Promise(function(res, rej) {
      user.enableMFA(function(err, data) {
        if (err) {
          logger.debug("enable mfa failed", err);
          rej(err);
          return;
        }
        logger.debug("enable mfa succeed", data);
        res(data);
        return;
      });
    });
  };
  AuthClass2.prototype.setupTOTP = function(user) {
    return new Promise(function(res, rej) {
      user.associateSoftwareToken({
        onFailure: function(err) {
          logger.debug("associateSoftwareToken failed", err);
          rej(err);
          return;
        },
        associateSecretCode: function(secretCode) {
          logger.debug("associateSoftwareToken sucess", secretCode);
          res(secretCode);
          return;
        }
      });
    });
  };
  AuthClass2.prototype.verifyTotpToken = function(user, challengeAnswer) {
    logger.debug("verification totp token", user, challengeAnswer);
    return new Promise(function(res, rej) {
      user.verifySoftwareToken(challengeAnswer, "My TOTP device", {
        onFailure: function(err) {
          logger.debug("verifyTotpToken failed", err);
          rej(err);
          return;
        },
        onSuccess: function(data) {
          dispatchAuthEvent("signIn", user, "A user " + user.getUsername() + " has been signed in");
          dispatchAuthEvent("verify", user, "A user " + user.getUsername() + " has been verified");
          logger.debug("verifyTotpToken success", data);
          res(data);
          return;
        }
      });
    });
  };
  AuthClass2.prototype.confirmSignIn = function(user, code2, mfaType, clientMetadata) {
    var _this = this;
    if (clientMetadata === void 0) {
      clientMetadata = this._config.clientMetadata;
    }
    if (!code2) {
      return this.rejectAuthError(AuthErrorTypes.EmptyCode);
    }
    var that = this;
    return new Promise(function(resolve2, reject) {
      user.sendMFACode(code2, {
        onSuccess: function(session) {
          return __awaiter(_this, void 0, void 0, function() {
            var cred, e_3;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  logger.debug(session);
                  _a2.label = 1;
                case 1:
                  _a2.trys.push([1, 4, 5, 6]);
                  return [4, this.Credentials.clear()];
                case 2:
                  _a2.sent();
                  return [4, this.Credentials.set(session, "session")];
                case 3:
                  cred = _a2.sent();
                  logger.debug("succeed to get cognito credentials", cred);
                  return [3, 6];
                case 4:
                  e_3 = _a2.sent();
                  logger.debug("cannot get cognito credentials", e_3);
                  return [3, 6];
                case 5:
                  that.user = user;
                  dispatchAuthEvent("signIn", user, "A user " + user.getUsername() + " has been signed in");
                  resolve2(user);
                  return [7];
                case 6:
                  return [2];
              }
            });
          });
        },
        onFailure: function(err) {
          logger.debug("confirm signIn failure", err);
          reject(err);
        }
      }, mfaType, clientMetadata);
    });
  };
  AuthClass2.prototype.completeNewPassword = function(user, password, requiredAttributes, clientMetadata) {
    var _this = this;
    if (requiredAttributes === void 0) {
      requiredAttributes = {};
    }
    if (clientMetadata === void 0) {
      clientMetadata = this._config.clientMetadata;
    }
    if (!password) {
      return this.rejectAuthError(AuthErrorTypes.EmptyPassword);
    }
    var that = this;
    return new Promise(function(resolve2, reject) {
      user.completeNewPasswordChallenge(password, requiredAttributes, {
        onSuccess: function(session) {
          return __awaiter(_this, void 0, void 0, function() {
            var cred, e_4;
            return __generator(this, function(_a2) {
              switch (_a2.label) {
                case 0:
                  logger.debug(session);
                  _a2.label = 1;
                case 1:
                  _a2.trys.push([1, 4, 5, 6]);
                  return [4, this.Credentials.clear()];
                case 2:
                  _a2.sent();
                  return [4, this.Credentials.set(session, "session")];
                case 3:
                  cred = _a2.sent();
                  logger.debug("succeed to get cognito credentials", cred);
                  return [3, 6];
                case 4:
                  e_4 = _a2.sent();
                  logger.debug("cannot get cognito credentials", e_4);
                  return [3, 6];
                case 5:
                  that.user = user;
                  dispatchAuthEvent("signIn", user, "A user " + user.getUsername() + " has been signed in");
                  resolve2(user);
                  return [7];
                case 6:
                  return [2];
              }
            });
          });
        },
        onFailure: function(err) {
          logger.debug("completeNewPassword failure", err);
          dispatchAuthEvent("completeNewPassword_failure", err, _this.user + " failed to complete the new password flow");
          reject(err);
        },
        mfaRequired: function(challengeName, challengeParam) {
          logger.debug("signIn MFA required");
          user["challengeName"] = challengeName;
          user["challengeParam"] = challengeParam;
          resolve2(user);
        },
        mfaSetup: function(challengeName, challengeParam) {
          logger.debug("signIn mfa setup", challengeName);
          user["challengeName"] = challengeName;
          user["challengeParam"] = challengeParam;
          resolve2(user);
        },
        totpRequired: function(challengeName, challengeParam) {
          logger.debug("signIn mfa setup", challengeName);
          user["challengeName"] = challengeName;
          user["challengeParam"] = challengeParam;
          resolve2(user);
        }
      }, clientMetadata);
    });
  };
  AuthClass2.prototype.sendCustomChallengeAnswer = function(user, challengeResponses, clientMetadata) {
    var _this = this;
    if (clientMetadata === void 0) {
      clientMetadata = this._config.clientMetadata;
    }
    if (!this.userPool) {
      return this.rejectNoUserPool();
    }
    if (!challengeResponses) {
      return this.rejectAuthError(AuthErrorTypes.EmptyChallengeResponse);
    }
    return new Promise(function(resolve2, reject) {
      user.sendCustomChallengeAnswer(challengeResponses, _this.authCallbacks(user, resolve2, reject), clientMetadata);
    });
  };
  AuthClass2.prototype.deleteUserAttributes = function(user, attributeNames) {
    var that = this;
    return new Promise(function(resolve2, reject) {
      that.userSession(user).then(function(session) {
        user.deleteAttributes(attributeNames, function(err, result) {
          if (err) {
            return reject(err);
          } else {
            return resolve2(result);
          }
        });
      });
    });
  };
  AuthClass2.prototype.deleteUser = function() {
    return __awaiter(this, void 0, void 0, function() {
      var e_5, isSignedInHostedUI;
      var _this = this;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            _a2.trys.push([0, 2, , 3]);
            return [4, this._storageSync];
          case 1:
            _a2.sent();
            return [3, 3];
          case 2:
            e_5 = _a2.sent();
            logger.debug("Failed to sync cache info into memory", e_5);
            throw new Error(e_5);
          case 3:
            isSignedInHostedUI = this._oAuthHandler && this._storage.getItem("amplify-signin-with-hostedUI") === "true";
            return [2, new Promise(function(res, rej) {
              return __awaiter(_this, void 0, void 0, function() {
                var user_1;
                var _this2 = this;
                return __generator(this, function(_a3) {
                  if (this.userPool) {
                    user_1 = this.userPool.getCurrentUser();
                    if (!user_1) {
                      logger.debug("Failed to get user from user pool");
                      return [2, rej(new Error("No current user."))];
                    } else {
                      user_1.getSession(function(err, session) {
                        return __awaiter(_this2, void 0, void 0, function() {
                          var cleanUpError_4;
                          var _this3 = this;
                          return __generator(this, function(_a4) {
                            switch (_a4.label) {
                              case 0:
                                if (!err)
                                  return [3, 5];
                                logger.debug("Failed to get the user session", err);
                                if (!this.isSessionInvalid(err))
                                  return [3, 4];
                                _a4.label = 1;
                              case 1:
                                _a4.trys.push([1, 3, , 4]);
                                return [4, this.cleanUpInvalidSession(user_1)];
                              case 2:
                                _a4.sent();
                                return [3, 4];
                              case 3:
                                cleanUpError_4 = _a4.sent();
                                rej(new Error("Session is invalid due to: " + err.message + " and failed to clean up invalid session: " + cleanUpError_4.message));
                                return [2];
                              case 4:
                                return [2, rej(err)];
                              case 5:
                                user_1.deleteUser(function(err2, result) {
                                  if (err2) {
                                    rej(err2);
                                  } else {
                                    dispatchAuthEvent("userDeleted", result, "The authenticated user has been deleted.");
                                    user_1.signOut();
                                    _this3.user = null;
                                    try {
                                      _this3.cleanCachedItems();
                                    } catch (e3) {
                                      logger.debug("failed to clear cached items");
                                    }
                                    if (isSignedInHostedUI) {
                                      _this3.oAuthSignOutRedirect(res, rej);
                                    } else {
                                      dispatchAuthEvent("signOut", _this3.user, "A user has been signed out");
                                      res(result);
                                    }
                                  }
                                });
                                _a4.label = 6;
                              case 6:
                                return [2];
                            }
                          });
                        });
                      });
                    }
                  } else {
                    logger.debug("no Congito User pool");
                    rej(new Error("Cognito User pool does not exist"));
                  }
                  return [2];
                });
              });
            })];
        }
      });
    });
  };
  AuthClass2.prototype.updateUserAttributes = function(user, attributes, clientMetadata) {
    var _this = this;
    if (clientMetadata === void 0) {
      clientMetadata = this._config.clientMetadata;
    }
    var attributeList = [];
    var that = this;
    return new Promise(function(resolve2, reject) {
      that.userSession(user).then(function(session) {
        for (var key in attributes) {
          if (key !== "sub" && key.indexOf("_verified") < 0) {
            var attr = {
              Name: key,
              Value: attributes[key]
            };
            attributeList.push(attr);
          }
        }
        user.updateAttributes(attributeList, function(err, result, details) {
          if (err) {
            dispatchAuthEvent("updateUserAttributes_failure", err, "Failed to update attributes");
            return reject(err);
          } else {
            var attrs = _this.createUpdateAttributesResultList(attributes, details === null || details === void 0 ? void 0 : details.CodeDeliveryDetailsList);
            dispatchAuthEvent("updateUserAttributes", attrs, "Attributes successfully updated");
            return resolve2(result);
          }
        }, clientMetadata);
      });
    });
  };
  AuthClass2.prototype.createUpdateAttributesResultList = function(attributes, codeDeliveryDetailsList) {
    var attrs = {};
    Object.keys(attributes).forEach(function(key) {
      attrs[key] = {
        isUpdated: true
      };
      var codeDeliveryDetails = codeDeliveryDetailsList === null || codeDeliveryDetailsList === void 0 ? void 0 : codeDeliveryDetailsList.find(function(value) {
        return value.AttributeName === key;
      });
      if (codeDeliveryDetails) {
        attrs[key].isUpdated = false;
        attrs[key].codeDeliveryDetails = codeDeliveryDetails;
      }
    });
    return attrs;
  };
  AuthClass2.prototype.userAttributes = function(user) {
    var _this = this;
    return new Promise(function(resolve2, reject) {
      _this.userSession(user).then(function(session) {
        user.getUserAttributes(function(err, attributes) {
          if (err) {
            reject(err);
          } else {
            resolve2(attributes);
          }
        });
      });
    });
  };
  AuthClass2.prototype.verifiedContact = function(user) {
    var that = this;
    return this.userAttributes(user).then(function(attributes) {
      var attrs = that.attributesToObject(attributes);
      var unverified = {};
      var verified = {};
      if (attrs["email"]) {
        if (attrs["email_verified"]) {
          verified["email"] = attrs["email"];
        } else {
          unverified["email"] = attrs["email"];
        }
      }
      if (attrs["phone_number"]) {
        if (attrs["phone_number_verified"]) {
          verified["phone_number"] = attrs["phone_number"];
        } else {
          unverified["phone_number"] = attrs["phone_number"];
        }
      }
      return {
        verified,
        unverified
      };
    });
  };
  AuthClass2.prototype.isErrorWithMessage = function(err) {
    return typeof err === "object" && Object.prototype.hasOwnProperty.call(err, "message");
  };
  AuthClass2.prototype.isTokenRevokedError = function(err) {
    return this.isErrorWithMessage(err) && err.message === "Access Token has been revoked";
  };
  AuthClass2.prototype.isRefreshTokenRevokedError = function(err) {
    return this.isErrorWithMessage(err) && err.message === "Refresh Token has been revoked";
  };
  AuthClass2.prototype.isUserDisabledError = function(err) {
    return this.isErrorWithMessage(err) && err.message === "User is disabled.";
  };
  AuthClass2.prototype.isUserDoesNotExistError = function(err) {
    return this.isErrorWithMessage(err) && err.message === "User does not exist.";
  };
  AuthClass2.prototype.isRefreshTokenExpiredError = function(err) {
    return this.isErrorWithMessage(err) && err.message === "Refresh Token has expired";
  };
  AuthClass2.prototype.isSignedInHostedUI = function() {
    return this._oAuthHandler && this._storage.getItem("amplify-signin-with-hostedUI") === "true";
  };
  AuthClass2.prototype.isSessionInvalid = function(err) {
    return this.isUserDisabledError(err) || this.isUserDoesNotExistError(err) || this.isTokenRevokedError(err) || this.isRefreshTokenRevokedError(err) || this.isRefreshTokenExpiredError(err);
  };
  AuthClass2.prototype.cleanUpInvalidSession = function(user) {
    return __awaiter(this, void 0, void 0, function() {
      var _this = this;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            user.signOut();
            this.user = null;
            _a2.label = 1;
          case 1:
            _a2.trys.push([1, 3, , 4]);
            return [4, this.cleanCachedItems()];
          case 2:
            _a2.sent();
            return [3, 4];
          case 3:
            _a2.sent();
            logger.debug("failed to clear cached items");
            return [3, 4];
          case 4:
            if (this.isSignedInHostedUI()) {
              return [2, new Promise(function(res, rej) {
                _this.oAuthSignOutRedirect(res, rej);
              })];
            } else {
              dispatchAuthEvent("signOut", this.user, "A user has been signed out");
            }
            return [2];
        }
      });
    });
  };
  AuthClass2.prototype.currentUserPoolUser = function(params) {
    var _this = this;
    if (!this.userPool) {
      return this.rejectNoUserPool();
    }
    return new Promise(function(res, rej) {
      _this._storageSync.then(function() {
        return __awaiter(_this, void 0, void 0, function() {
          var user, session, bypassCache, clientMetadata, _a2, scope, err_1;
          var _this2 = this;
          return __generator(this, function(_b) {
            switch (_b.label) {
              case 0:
                if (!this.isOAuthInProgress())
                  return [3, 2];
                logger.debug("OAuth signIn in progress, waiting for resolution...");
                return [4, new Promise(function(res2) {
                  var timeoutId = setTimeout(function() {
                    logger.debug("OAuth signIn in progress timeout");
                    Hub.remove("auth", hostedUISignCallback);
                    res2();
                  }, OAUTH_FLOW_MS_TIMEOUT);
                  Hub.listen("auth", hostedUISignCallback);
                  function hostedUISignCallback(_a3) {
                    var payload = _a3.payload;
                    var event = payload.event;
                    if (event === "cognitoHostedUI" || event === "cognitoHostedUI_failure") {
                      logger.debug("OAuth signIn resolved: " + event);
                      clearTimeout(timeoutId);
                      Hub.remove("auth", hostedUISignCallback);
                      res2();
                    }
                  }
                })];
              case 1:
                _b.sent();
                _b.label = 2;
              case 2:
                user = this.userPool.getCurrentUser();
                if (!user) {
                  logger.debug("Failed to get user from user pool");
                  rej("No current user");
                  return [2];
                }
                _b.label = 3;
              case 3:
                _b.trys.push([3, 7, , 8]);
                return [4, this._userSession(user)];
              case 4:
                session = _b.sent();
                bypassCache = params ? params.bypassCache : false;
                if (!bypassCache)
                  return [3, 6];
                return [4, this.Credentials.clear()];
              case 5:
                _b.sent();
                _b.label = 6;
              case 6:
                clientMetadata = this._config.clientMetadata;
                _a2 = session.getAccessToken().decodePayload().scope, scope = _a2 === void 0 ? "" : _a2;
                if (scope.split(" ").includes(USER_ADMIN_SCOPE)) {
                  user.getUserData(function(err, data) {
                    return __awaiter(_this2, void 0, void 0, function() {
                      var cleanUpError_5, preferredMFA, attributeList, i2, attribute, userAttribute, attributes;
                      return __generator(this, function(_a3) {
                        switch (_a3.label) {
                          case 0:
                            if (!err)
                              return [3, 7];
                            logger.debug("getting user data failed", err);
                            if (!this.isSessionInvalid(err))
                              return [3, 5];
                            _a3.label = 1;
                          case 1:
                            _a3.trys.push([1, 3, , 4]);
                            return [4, this.cleanUpInvalidSession(user)];
                          case 2:
                            _a3.sent();
                            return [3, 4];
                          case 3:
                            cleanUpError_5 = _a3.sent();
                            rej(new Error("Session is invalid due to: " + err.message + " and failed to clean up invalid session: " + cleanUpError_5.message));
                            return [2];
                          case 4:
                            rej(err);
                            return [3, 6];
                          case 5:
                            res(user);
                            _a3.label = 6;
                          case 6:
                            return [2];
                          case 7:
                            preferredMFA = data.PreferredMfaSetting || "NOMFA";
                            attributeList = [];
                            for (i2 = 0; i2 < data.UserAttributes.length; i2++) {
                              attribute = {
                                Name: data.UserAttributes[i2].Name,
                                Value: data.UserAttributes[i2].Value
                              };
                              userAttribute = new CognitoUserAttribute(attribute);
                              attributeList.push(userAttribute);
                            }
                            attributes = this.attributesToObject(attributeList);
                            Object.assign(user, { attributes, preferredMFA });
                            return [2, res(user)];
                        }
                      });
                    });
                  }, { bypassCache, clientMetadata });
                } else {
                  logger.debug("Unable to get the user data because the " + USER_ADMIN_SCOPE + " is not in the scopes of the access token");
                  return [2, res(user)];
                }
                return [3, 8];
              case 7:
                err_1 = _b.sent();
                rej(err_1);
                return [3, 8];
              case 8:
                return [2];
            }
          });
        });
      }).catch(function(e3) {
        logger.debug("Failed to sync cache info into memory", e3);
        return rej(e3);
      });
    });
  };
  AuthClass2.prototype.isOAuthInProgress = function() {
    return this.oAuthFlowInProgress;
  };
  AuthClass2.prototype.currentAuthenticatedUser = function(params) {
    return __awaiter(this, void 0, void 0, function() {
      var federatedUser, e_7, federatedInfo, user, e_8;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            logger.debug("getting current authenticated user");
            federatedUser = null;
            _a2.label = 1;
          case 1:
            _a2.trys.push([1, 3, , 4]);
            return [4, this._storageSync];
          case 2:
            _a2.sent();
            return [3, 4];
          case 3:
            e_7 = _a2.sent();
            logger.debug("Failed to sync cache info into memory", e_7);
            throw e_7;
          case 4:
            try {
              federatedInfo = JSON.parse(this._storage.getItem("aws-amplify-federatedInfo"));
              if (federatedInfo) {
                federatedUser = __assign(__assign({}, federatedInfo.user), { token: federatedInfo.token });
              }
            } catch (e3) {
              logger.debug("cannot load federated user from auth storage");
            }
            if (!federatedUser)
              return [3, 5];
            this.user = federatedUser;
            logger.debug("get current authenticated federated user", this.user);
            return [2, this.user];
          case 5:
            logger.debug("get current authenticated userpool user");
            user = null;
            _a2.label = 6;
          case 6:
            _a2.trys.push([6, 8, , 9]);
            return [4, this.currentUserPoolUser(params)];
          case 7:
            user = _a2.sent();
            return [3, 9];
          case 8:
            e_8 = _a2.sent();
            if (e_8 === "No userPool") {
              logger.error("Cannot get the current user because the user pool is missing. Please make sure the Auth module is configured with a valid Cognito User Pool ID");
            }
            logger.debug("The user is not authenticated by the error", e_8);
            return [2, Promise.reject("The user is not authenticated")];
          case 9:
            this.user = user;
            return [2, this.user];
        }
      });
    });
  };
  AuthClass2.prototype.currentSession = function() {
    var that = this;
    logger.debug("Getting current session");
    if (!this.userPool) {
      return Promise.reject(new Error("No User Pool in the configuration."));
    }
    return new Promise(function(res, rej) {
      that.currentUserPoolUser().then(function(user) {
        that.userSession(user).then(function(session) {
          res(session);
          return;
        }).catch(function(e3) {
          logger.debug("Failed to get the current session", e3);
          rej(e3);
          return;
        });
      }).catch(function(e3) {
        logger.debug("Failed to get the current user", e3);
        rej(e3);
        return;
      });
    });
  };
  AuthClass2.prototype._userSession = function(user) {
    return __awaiter(this, void 0, void 0, function() {
      var clientMetadata, userSession;
      var _this = this;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            if (!user) {
              logger.debug("the user is null");
              return [2, this.rejectAuthError(AuthErrorTypes.NoUserSession)];
            }
            clientMetadata = this._config.clientMetadata;
            if (this.inflightSessionPromiseCounter === 0) {
              this.inflightSessionPromise = new Promise(function(res, rej) {
                user.getSession(function(err, session) {
                  return __awaiter(_this, void 0, void 0, function() {
                    var cleanUpError_6;
                    return __generator(this, function(_a3) {
                      switch (_a3.label) {
                        case 0:
                          if (!err)
                            return [3, 5];
                          logger.debug("Failed to get the session from user", user);
                          if (!this.isSessionInvalid(err))
                            return [3, 4];
                          _a3.label = 1;
                        case 1:
                          _a3.trys.push([1, 3, , 4]);
                          return [4, this.cleanUpInvalidSession(user)];
                        case 2:
                          _a3.sent();
                          return [3, 4];
                        case 3:
                          cleanUpError_6 = _a3.sent();
                          rej(new Error("Session is invalid due to: " + err.message + " and failed to clean up invalid session: " + cleanUpError_6.message));
                          return [2];
                        case 4:
                          rej(err);
                          return [2];
                        case 5:
                          logger.debug("Succeed to get the user session", session);
                          res(session);
                          return [2];
                      }
                    });
                  });
                }, { clientMetadata });
              });
            }
            this.inflightSessionPromiseCounter++;
            _a2.label = 1;
          case 1:
            _a2.trys.push([1, , 3, 4]);
            return [4, this.inflightSessionPromise];
          case 2:
            userSession = _a2.sent();
            user.signInUserSession = userSession;
            return [2, userSession];
          case 3:
            this.inflightSessionPromiseCounter--;
            return [7];
          case 4:
            return [2];
        }
      });
    });
  };
  AuthClass2.prototype.userSession = function(user) {
    return this._userSession(user);
  };
  AuthClass2.prototype.currentUserCredentials = function() {
    return __awaiter(this, void 0, void 0, function() {
      var e_9, federatedInfo;
      var _this = this;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            logger.debug("Getting current user credentials");
            _a2.label = 1;
          case 1:
            _a2.trys.push([1, 3, , 4]);
            return [4, this._storageSync];
          case 2:
            _a2.sent();
            return [3, 4];
          case 3:
            e_9 = _a2.sent();
            logger.debug("Failed to sync cache info into memory", e_9);
            throw e_9;
          case 4:
            federatedInfo = null;
            try {
              federatedInfo = JSON.parse(this._storage.getItem("aws-amplify-federatedInfo"));
            } catch (e3) {
              logger.debug("failed to get or parse item aws-amplify-federatedInfo", e3);
            }
            if (federatedInfo) {
              return [2, this.Credentials.refreshFederatedToken(federatedInfo)];
            } else {
              return [2, this.currentSession().then(function(session) {
                logger.debug("getting session success", session);
                return _this.Credentials.set(session, "session");
              }).catch(function() {
                logger.debug("getting guest credentials");
                return _this.Credentials.set(null, "guest");
              })];
            }
        }
      });
    });
  };
  AuthClass2.prototype.currentCredentials = function() {
    logger.debug("getting current credentials");
    return this.Credentials.get();
  };
  AuthClass2.prototype.verifyUserAttribute = function(user, attr, clientMetadata) {
    if (clientMetadata === void 0) {
      clientMetadata = this._config.clientMetadata;
    }
    return new Promise(function(resolve2, reject) {
      user.getAttributeVerificationCode(attr, {
        onSuccess: function(success) {
          return resolve2(success);
        },
        onFailure: function(err) {
          return reject(err);
        }
      }, clientMetadata);
    });
  };
  AuthClass2.prototype.verifyUserAttributeSubmit = function(user, attr, code2) {
    if (!code2) {
      return this.rejectAuthError(AuthErrorTypes.EmptyCode);
    }
    return new Promise(function(resolve2, reject) {
      user.verifyAttribute(attr, code2, {
        onSuccess: function(data) {
          resolve2(data);
          return;
        },
        onFailure: function(err) {
          reject(err);
          return;
        }
      });
    });
  };
  AuthClass2.prototype.verifyCurrentUserAttribute = function(attr) {
    var that = this;
    return that.currentUserPoolUser().then(function(user) {
      return that.verifyUserAttribute(user, attr);
    });
  };
  AuthClass2.prototype.verifyCurrentUserAttributeSubmit = function(attr, code2) {
    var that = this;
    return that.currentUserPoolUser().then(function(user) {
      return that.verifyUserAttributeSubmit(user, attr, code2);
    });
  };
  AuthClass2.prototype.cognitoIdentitySignOut = function(opts, user) {
    return __awaiter(this, void 0, void 0, function() {
      var e_10, isSignedInHostedUI;
      var _this = this;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            _a2.trys.push([0, 2, , 3]);
            return [4, this._storageSync];
          case 1:
            _a2.sent();
            return [3, 3];
          case 2:
            e_10 = _a2.sent();
            logger.debug("Failed to sync cache info into memory", e_10);
            throw e_10;
          case 3:
            isSignedInHostedUI = this._oAuthHandler && this._storage.getItem("amplify-signin-with-hostedUI") === "true";
            return [2, new Promise(function(res, rej) {
              if (opts && opts.global) {
                logger.debug("user global sign out", user);
                var clientMetadata = _this._config.clientMetadata;
                user.getSession(function(err, result) {
                  return __awaiter(_this, void 0, void 0, function() {
                    var cleanUpError_7;
                    var _this2 = this;
                    return __generator(this, function(_a3) {
                      switch (_a3.label) {
                        case 0:
                          if (!err)
                            return [3, 5];
                          logger.debug("failed to get the user session", err);
                          if (!this.isSessionInvalid(err))
                            return [3, 4];
                          _a3.label = 1;
                        case 1:
                          _a3.trys.push([1, 3, , 4]);
                          return [4, this.cleanUpInvalidSession(user)];
                        case 2:
                          _a3.sent();
                          return [3, 4];
                        case 3:
                          cleanUpError_7 = _a3.sent();
                          rej(new Error("Session is invalid due to: " + err.message + " and failed to clean up invalid session: " + cleanUpError_7.message));
                          return [2];
                        case 4:
                          return [2, rej(err)];
                        case 5:
                          user.globalSignOut({
                            onSuccess: function(data) {
                              logger.debug("global sign out success");
                              if (isSignedInHostedUI) {
                                _this2.oAuthSignOutRedirect(res, rej);
                              } else {
                                return res();
                              }
                            },
                            onFailure: function(err2) {
                              logger.debug("global sign out failed", err2);
                              return rej(err2);
                            }
                          });
                          return [2];
                      }
                    });
                  });
                }, { clientMetadata });
              } else {
                logger.debug("user sign out", user);
                user.signOut(function() {
                  if (isSignedInHostedUI) {
                    _this.oAuthSignOutRedirect(res, rej);
                  } else {
                    return res();
                  }
                });
              }
            })];
        }
      });
    });
  };
  AuthClass2.prototype.oAuthSignOutRedirect = function(resolve2, reject) {
    var isBrowser2 = browserOrNode().isBrowser;
    if (isBrowser2) {
      this.oAuthSignOutRedirectOrReject(reject);
    } else {
      this.oAuthSignOutAndResolve(resolve2);
    }
  };
  AuthClass2.prototype.oAuthSignOutAndResolve = function(resolve2) {
    this._oAuthHandler.signOut();
    resolve2();
  };
  AuthClass2.prototype.oAuthSignOutRedirectOrReject = function(reject) {
    this._oAuthHandler.signOut();
    setTimeout(function() {
      return reject(Error("Signout timeout fail"));
    }, 3e3);
  };
  AuthClass2.prototype.signOut = function(opts) {
    return __awaiter(this, void 0, void 0, function() {
      var user;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            _a2.trys.push([0, 2, , 3]);
            return [4, this.cleanCachedItems()];
          case 1:
            _a2.sent();
            return [3, 3];
          case 2:
            _a2.sent();
            logger.debug("failed to clear cached items");
            return [3, 3];
          case 3:
            if (!this.userPool)
              return [3, 7];
            user = this.userPool.getCurrentUser();
            if (!user)
              return [3, 5];
            return [4, this.cognitoIdentitySignOut(opts, user)];
          case 4:
            _a2.sent();
            return [3, 6];
          case 5:
            logger.debug("no current Cognito user");
            _a2.label = 6;
          case 6:
            return [3, 8];
          case 7:
            logger.debug("no Cognito User pool");
            _a2.label = 8;
          case 8:
            dispatchAuthEvent("signOut", this.user, "A user has been signed out");
            this.user = null;
            return [2];
        }
      });
    });
  };
  AuthClass2.prototype.cleanCachedItems = function() {
    return __awaiter(this, void 0, void 0, function() {
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, this.Credentials.clear()];
          case 1:
            _a2.sent();
            return [2];
        }
      });
    });
  };
  AuthClass2.prototype.changePassword = function(user, oldPassword, newPassword, clientMetadata) {
    var _this = this;
    if (clientMetadata === void 0) {
      clientMetadata = this._config.clientMetadata;
    }
    return new Promise(function(resolve2, reject) {
      _this.userSession(user).then(function(session) {
        user.changePassword(oldPassword, newPassword, function(err, data) {
          if (err) {
            logger.debug("change password failure", err);
            return reject(err);
          } else {
            return resolve2(data);
          }
        }, clientMetadata);
      });
    });
  };
  AuthClass2.prototype.forgotPassword = function(username, clientMetadata) {
    if (clientMetadata === void 0) {
      clientMetadata = this._config.clientMetadata;
    }
    if (!this.userPool) {
      return this.rejectNoUserPool();
    }
    if (!username) {
      return this.rejectAuthError(AuthErrorTypes.EmptyUsername);
    }
    var user = this.createCognitoUser(username);
    return new Promise(function(resolve2, reject) {
      user.forgotPassword({
        onSuccess: function() {
          resolve2();
          return;
        },
        onFailure: function(err) {
          logger.debug("forgot password failure", err);
          dispatchAuthEvent("forgotPassword_failure", err, username + " forgotPassword failed");
          reject(err);
          return;
        },
        inputVerificationCode: function(data) {
          dispatchAuthEvent("forgotPassword", user, username + " has initiated forgot password flow");
          resolve2(data);
          return;
        }
      }, clientMetadata);
    });
  };
  AuthClass2.prototype.forgotPasswordSubmit = function(username, code2, password, clientMetadata) {
    if (clientMetadata === void 0) {
      clientMetadata = this._config.clientMetadata;
    }
    if (!this.userPool) {
      return this.rejectNoUserPool();
    }
    if (!username) {
      return this.rejectAuthError(AuthErrorTypes.EmptyUsername);
    }
    if (!code2) {
      return this.rejectAuthError(AuthErrorTypes.EmptyCode);
    }
    if (!password) {
      return this.rejectAuthError(AuthErrorTypes.EmptyPassword);
    }
    var user = this.createCognitoUser(username);
    return new Promise(function(resolve2, reject) {
      user.confirmPassword(code2, password, {
        onSuccess: function(success) {
          dispatchAuthEvent("forgotPasswordSubmit", user, username + " forgotPasswordSubmit successful");
          resolve2(success);
          return;
        },
        onFailure: function(err) {
          dispatchAuthEvent("forgotPasswordSubmit_failure", err, username + " forgotPasswordSubmit failed");
          reject(err);
          return;
        }
      }, clientMetadata);
    });
  };
  AuthClass2.prototype.currentUserInfo = function() {
    return __awaiter(this, void 0, void 0, function() {
      var source, user, attributes, userAttrs, credentials, e_12, info, err_2, user;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            source = this.Credentials.getCredSource();
            if (!(!source || source === "aws" || source === "userPool"))
              return [3, 9];
            return [4, this.currentUserPoolUser().catch(function(err) {
              return logger.error(err);
            })];
          case 1:
            user = _a2.sent();
            if (!user) {
              return [2, null];
            }
            _a2.label = 2;
          case 2:
            _a2.trys.push([2, 8, , 9]);
            return [4, this.userAttributes(user)];
          case 3:
            attributes = _a2.sent();
            userAttrs = this.attributesToObject(attributes);
            credentials = null;
            _a2.label = 4;
          case 4:
            _a2.trys.push([4, 6, , 7]);
            return [4, this.currentCredentials()];
          case 5:
            credentials = _a2.sent();
            return [3, 7];
          case 6:
            e_12 = _a2.sent();
            logger.debug("Failed to retrieve credentials while getting current user info", e_12);
            return [3, 7];
          case 7:
            info = {
              id: credentials ? credentials.identityId : void 0,
              username: user.getUsername(),
              attributes: userAttrs
            };
            return [2, info];
          case 8:
            err_2 = _a2.sent();
            logger.error("currentUserInfo error", err_2);
            return [2, {}];
          case 9:
            if (source === "federated") {
              user = this.user;
              return [2, user ? user : {}];
            }
            return [2];
        }
      });
    });
  };
  AuthClass2.prototype.federatedSignIn = function(providerOrOptions, response, user) {
    return __awaiter(this, void 0, void 0, function() {
      var options, provider, customState, client_id, redirect_uri, provider, loggedInUser, token, identity_id, expires_at, credentials, currentUser;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            if (!this._config.identityPoolId && !this._config.userPoolId) {
              throw new Error("Federation requires either a User Pool or Identity Pool in config");
            }
            if (typeof providerOrOptions === "undefined") {
              if (this._config.identityPoolId && !this._config.userPoolId) {
                throw new Error("Federation with Identity Pools requires tokens passed as arguments");
              }
            }
            if (!(isFederatedSignInOptions(providerOrOptions) || isFederatedSignInOptionsCustom(providerOrOptions) || hasCustomState(providerOrOptions) || typeof providerOrOptions === "undefined"))
              return [3, 1];
            options = providerOrOptions || {
              provider: CognitoHostedUIIdentityProvider.Cognito
            };
            provider = isFederatedSignInOptions(options) ? options.provider : options.customProvider;
            customState = isFederatedSignInOptions(options) ? options.customState : options.customState;
            if (this._config.userPoolId) {
              client_id = isCognitoHostedOpts(this._config.oauth) ? this._config.userPoolWebClientId : this._config.oauth.clientID;
              redirect_uri = isCognitoHostedOpts(this._config.oauth) ? this._config.oauth.redirectSignIn : this._config.oauth.redirectUri;
              this._oAuthHandler.oauthSignIn(this._config.oauth.responseType, this._config.oauth.domain, redirect_uri, client_id, provider, customState);
            }
            return [3, 4];
          case 1:
            provider = providerOrOptions;
            try {
              loggedInUser = JSON.stringify(JSON.parse(this._storage.getItem("aws-amplify-federatedInfo")).user);
              if (loggedInUser) {
                logger.warn("There is already a signed in user: " + loggedInUser + " in your app.\n																	You should not call Auth.federatedSignIn method again as it may cause unexpected behavior.");
              }
            } catch (e3) {
            }
            token = response.token, identity_id = response.identity_id, expires_at = response.expires_at;
            return [4, this.Credentials.set({ provider, token, identity_id, user, expires_at }, "federation")];
          case 2:
            credentials = _a2.sent();
            return [4, this.currentAuthenticatedUser()];
          case 3:
            currentUser = _a2.sent();
            dispatchAuthEvent("signIn", currentUser, "A user " + currentUser.username + " has been signed in");
            logger.debug("federated sign in credentials", credentials);
            return [2, credentials];
          case 4:
            return [2];
        }
      });
    });
  };
  AuthClass2.prototype._handleAuthResponse = function(URL2) {
    return __awaiter(this, void 0, void 0, function() {
      var currentUrl, hasCodeOrError, hasTokenOrError, _a2, accessToken, idToken, refreshToken, state, session, credentials, isCustomStateIncluded, currentUser, customState, err_3;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            if (this.oAuthFlowInProgress) {
              logger.debug("Skipping URL " + URL2 + " current flow in progress");
              return [2];
            }
            _b.label = 1;
          case 1:
            _b.trys.push([1, , 8, 9]);
            this.oAuthFlowInProgress = true;
            if (!this._config.userPoolId) {
              throw new Error("OAuth responses require a User Pool defined in config");
            }
            dispatchAuthEvent("parsingCallbackUrl", { url: URL2 }, "The callback url is being parsed");
            currentUrl = URL2 || (browserOrNode().isBrowser ? window.location.href : "");
            hasCodeOrError = !!(parse$2(currentUrl).query || "").split("&").map(function(entry) {
              return entry.split("=");
            }).find(function(_a3) {
              var _b2 = __read(_a3, 1), k2 = _b2[0];
              return k2 === "code" || k2 === "error";
            });
            hasTokenOrError = !!(parse$2(currentUrl).hash || "#").substr(1).split("&").map(function(entry) {
              return entry.split("=");
            }).find(function(_a3) {
              var _b2 = __read(_a3, 1), k2 = _b2[0];
              return k2 === "access_token" || k2 === "error";
            });
            if (!(hasCodeOrError || hasTokenOrError))
              return [3, 7];
            this._storage.setItem("amplify-redirected-from-hosted-ui", "true");
            _b.label = 2;
          case 2:
            _b.trys.push([2, 6, , 7]);
            return [4, this._oAuthHandler.handleAuthResponse(currentUrl)];
          case 3:
            _a2 = _b.sent(), accessToken = _a2.accessToken, idToken = _a2.idToken, refreshToken = _a2.refreshToken, state = _a2.state;
            session = new CognitoUserSession({
              IdToken: new CognitoIdToken({ IdToken: idToken }),
              RefreshToken: new CognitoRefreshToken({
                RefreshToken: refreshToken
              }),
              AccessToken: new CognitoAccessToken({
                AccessToken: accessToken
              })
            });
            credentials = void 0;
            if (!this._config.identityPoolId)
              return [3, 5];
            return [4, this.Credentials.set(session, "session")];
          case 4:
            credentials = _b.sent();
            logger.debug("AWS credentials", credentials);
            _b.label = 5;
          case 5:
            isCustomStateIncluded = /-/.test(state);
            currentUser = this.createCognitoUser(session.getIdToken().decodePayload()["cognito:username"]);
            currentUser.setSignInUserSession(session);
            if (window && typeof window.history !== "undefined") {
              window.history.replaceState({}, null, this._config.oauth.redirectSignIn);
            }
            dispatchAuthEvent("signIn", currentUser, "A user " + currentUser.getUsername() + " has been signed in");
            dispatchAuthEvent("cognitoHostedUI", currentUser, "A user " + currentUser.getUsername() + " has been signed in via Cognito Hosted UI");
            if (isCustomStateIncluded) {
              customState = state.split("-").splice(1).join("-");
              dispatchAuthEvent("customOAuthState", urlSafeDecode(customState), "State for user " + currentUser.getUsername());
            }
            return [2, credentials];
          case 6:
            err_3 = _b.sent();
            logger.debug("Error in cognito hosted auth response", err_3);
            if (window && typeof window.history !== "undefined") {
              window.history.replaceState({}, null, this._config.oauth.redirectSignIn);
            }
            dispatchAuthEvent("signIn_failure", err_3, "The OAuth response flow failed");
            dispatchAuthEvent("cognitoHostedUI_failure", err_3, "A failure occurred when returning to the Cognito Hosted UI");
            dispatchAuthEvent("customState_failure", err_3, "A failure occurred when returning state");
            return [3, 7];
          case 7:
            return [3, 9];
          case 8:
            this.oAuthFlowInProgress = false;
            return [7];
          case 9:
            return [2];
        }
      });
    });
  };
  AuthClass2.prototype.essentialCredentials = function(credentials) {
    return {
      accessKeyId: credentials.accessKeyId,
      sessionToken: credentials.sessionToken,
      secretAccessKey: credentials.secretAccessKey,
      identityId: credentials.identityId,
      authenticated: credentials.authenticated
    };
  };
  AuthClass2.prototype.attributesToObject = function(attributes) {
    var _this = this;
    var obj = {};
    if (attributes) {
      attributes.map(function(attribute) {
        if (attribute.Name === "email_verified" || attribute.Name === "phone_number_verified") {
          obj[attribute.Name] = _this.isTruthyString(attribute.Value) || attribute.Value === true;
        } else {
          obj[attribute.Name] = attribute.Value;
        }
      });
    }
    return obj;
  };
  AuthClass2.prototype.isTruthyString = function(value) {
    return typeof value.toLowerCase === "function" && value.toLowerCase() === "true";
  };
  AuthClass2.prototype.createCognitoUser = function(username) {
    var userData = {
      Username: username,
      Pool: this.userPool
    };
    userData.Storage = this._storage;
    var authenticationFlowType = this._config.authenticationFlowType;
    var user = new CognitoUser(userData);
    if (authenticationFlowType) {
      user.setAuthenticationFlowType(authenticationFlowType);
    }
    return user;
  };
  AuthClass2.prototype._isValidAuthStorage = function(obj) {
    return !!obj && typeof obj.getItem === "function" && typeof obj.setItem === "function" && typeof obj.removeItem === "function" && typeof obj.clear === "function";
  };
  AuthClass2.prototype.noUserPoolErrorHandler = function(config) {
    if (config) {
      if (!config.userPoolId || !config.identityPoolId) {
        return AuthErrorTypes.MissingAuthConfig;
      }
    }
    return AuthErrorTypes.NoConfig;
  };
  AuthClass2.prototype.rejectAuthError = function(type) {
    return Promise.reject(new AuthError(type));
  };
  AuthClass2.prototype.rejectNoUserPool = function() {
    var type = this.noUserPoolErrorHandler(this._config);
    return Promise.reject(new NoUserPoolError(type));
  };
  AuthClass2.prototype.rememberDevice = function() {
    return __awaiter(this, void 0, void 0, function() {
      var currUser, error_2;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            _a2.trys.push([0, 2, , 3]);
            return [4, this.currentUserPoolUser()];
          case 1:
            currUser = _a2.sent();
            return [3, 3];
          case 2:
            error_2 = _a2.sent();
            logger.debug("The user is not authenticated by the error", error_2);
            return [2, Promise.reject("The user is not authenticated")];
          case 3:
            currUser.getCachedDeviceKeyAndPassword();
            return [2, new Promise(function(res, rej) {
              currUser.setDeviceStatusRemembered({
                onSuccess: function(data) {
                  res(data);
                },
                onFailure: function(err) {
                  if (err.code === "InvalidParameterException") {
                    rej(new AuthError(AuthErrorTypes.DeviceConfig));
                  } else if (err.code === "NetworkError") {
                    rej(new AuthError(AuthErrorTypes.NetworkError));
                  } else {
                    rej(err);
                  }
                }
              });
            })];
        }
      });
    });
  };
  AuthClass2.prototype.forgetDevice = function() {
    return __awaiter(this, void 0, void 0, function() {
      var currUser, error_3;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            _a2.trys.push([0, 2, , 3]);
            return [4, this.currentUserPoolUser()];
          case 1:
            currUser = _a2.sent();
            return [3, 3];
          case 2:
            error_3 = _a2.sent();
            logger.debug("The user is not authenticated by the error", error_3);
            return [2, Promise.reject("The user is not authenticated")];
          case 3:
            currUser.getCachedDeviceKeyAndPassword();
            return [2, new Promise(function(res, rej) {
              currUser.forgetDevice({
                onSuccess: function(data) {
                  res(data);
                },
                onFailure: function(err) {
                  if (err.code === "InvalidParameterException") {
                    rej(new AuthError(AuthErrorTypes.DeviceConfig));
                  } else if (err.code === "NetworkError") {
                    rej(new AuthError(AuthErrorTypes.NetworkError));
                  } else {
                    rej(err);
                  }
                }
              });
            })];
        }
      });
    });
  };
  AuthClass2.prototype.fetchDevices = function() {
    return __awaiter(this, void 0, void 0, function() {
      var currUser, error_4;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            _a2.trys.push([0, 2, , 3]);
            return [4, this.currentUserPoolUser()];
          case 1:
            currUser = _a2.sent();
            return [3, 3];
          case 2:
            error_4 = _a2.sent();
            logger.debug("The user is not authenticated by the error", error_4);
            throw new Error("The user is not authenticated");
          case 3:
            currUser.getCachedDeviceKeyAndPassword();
            return [2, new Promise(function(res, rej) {
              var cb = {
                onSuccess: function(data) {
                  var deviceList = data.Devices.map(function(device) {
                    var deviceName = device.DeviceAttributes.find(function(_a3) {
                      var Name = _a3.Name;
                      return Name === "device_name";
                    }) || {};
                    var deviceInfo = {
                      id: device.DeviceKey,
                      name: deviceName.Value
                    };
                    return deviceInfo;
                  });
                  res(deviceList);
                },
                onFailure: function(err) {
                  if (err.code === "InvalidParameterException") {
                    rej(new AuthError(AuthErrorTypes.DeviceConfig));
                  } else if (err.code === "NetworkError") {
                    rej(new AuthError(AuthErrorTypes.NetworkError));
                  } else {
                    rej(err);
                  }
                }
              };
              currUser.listDevices(MAX_DEVICES, null, cb);
            })];
        }
      });
    });
  };
  return AuthClass2;
}();
var Auth = new AuthClass(null);
Amplify.register(Auth);
function bind(fn2, thisArg) {
  return function wrap() {
    return fn2.apply(thisArg, arguments);
  };
}
const { toString } = Object.prototype;
const { getPrototypeOf } = Object;
const kindOf = ((cache) => (thing) => {
  const str = toString.call(thing);
  return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
const kindOfTest = (type) => {
  type = type.toLowerCase();
  return (thing) => kindOf(thing) === type;
};
const typeOfTest = (type) => (thing) => typeof thing === type;
const { isArray } = Array;
const isUndefined = typeOfTest("undefined");
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
const isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
const isString = typeOfTest("string");
const isFunction = typeOfTest("function");
const isNumber = typeOfTest("number");
const isObject$1 = (thing) => thing !== null && typeof thing === "object";
const isBoolean = (thing) => thing === true || thing === false;
const isPlainObject = (val) => {
  if (kindOf(val) !== "object") {
    return false;
  }
  const prototype2 = getPrototypeOf(val);
  return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
};
const isDate$1 = kindOfTest("Date");
const isFile = kindOfTest("File");
const isBlob = kindOfTest("Blob");
const isFileList = kindOfTest("FileList");
const isStream = (val) => isObject$1(val) && isFunction(val.pipe);
const isFormData = (thing) => {
  const pattern = "[object FormData]";
  return thing && (typeof FormData === "function" && thing instanceof FormData || toString.call(thing) === pattern || isFunction(thing.toString) && thing.toString() === pattern);
};
const isURLSearchParams = kindOfTest("URLSearchParams");
const trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach(obj, fn2, { allOwnKeys = false } = {}) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  let i2;
  let l;
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray(obj)) {
    for (i2 = 0, l = obj.length; i2 < l; i2++) {
      fn2.call(null, obj[i2], i2, obj);
    }
  } else {
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key;
    for (i2 = 0; i2 < len; i2++) {
      key = keys[i2];
      fn2.call(null, obj[key], key, obj);
    }
  }
}
function findKey$1(obj, key) {
  key = key.toLowerCase();
  const keys = Object.keys(obj);
  let i2 = keys.length;
  let _key;
  while (i2-- > 0) {
    _key = keys[i2];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
const _global = (() => {
  if (typeof globalThis !== "undefined")
    return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
})();
const isContextDefined = (context) => !isUndefined(context) && context !== _global;
function merge() {
  const { caseless } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey$1(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  };
  for (let i2 = 0, l = arguments.length; i2 < l; i2++) {
    arguments[i2] && forEach(arguments[i2], assignValue);
  }
  return result;
}
const extend = (a3, b3, thisArg, { allOwnKeys } = {}) => {
  forEach(b3, (val, key) => {
    if (thisArg && isFunction(val)) {
      a3[key] = bind(val, thisArg);
    } else {
      a3[key] = val;
    }
  }, { allOwnKeys });
  return a3;
};
const stripBOM = (content) => {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
};
const inherits = (constructor, superConstructor, props, descriptors2) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};
const toFlatObject = (sourceObj, destObj, filter2, propFilter) => {
  let props;
  let i2;
  let prop;
  const merged = {};
  destObj = destObj || {};
  if (sourceObj == null)
    return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i2 = props.length;
    while (i2-- > 0) {
      prop = props[i2];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter2 !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter2 || filter2(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
};
const endsWith = (str, searchString, position) => {
  str = String(str);
  if (position === void 0 || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
};
const toArray = (thing) => {
  if (!thing)
    return null;
  if (isArray(thing))
    return thing;
  let i2 = thing.length;
  if (!isNumber(i2))
    return null;
  const arr = new Array(i2);
  while (i2-- > 0) {
    arr[i2] = thing[i2];
  }
  return arr;
};
const isTypedArray = ((TypedArray) => {
  return (thing) => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
const forEachEntry = (obj, fn2) => {
  const generator = obj && obj[Symbol.iterator];
  const iterator = generator.call(obj);
  let result;
  while ((result = iterator.next()) && !result.done) {
    const pair = result.value;
    fn2.call(obj, pair[0], pair[1]);
  }
};
const matchAll = (regExp, str) => {
  let matches;
  const arr = [];
  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }
  return arr;
};
const isHTMLForm = kindOfTest("HTMLFormElement");
const toCamelCase = (str) => {
  return str.toLowerCase().replace(
    /[-_\s]([a-z\d])(\w*)/g,
    function replacer2(m3, p1, p2) {
      return p1.toUpperCase() + p2;
    }
  );
};
const hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
const isRegExp = kindOfTest("RegExp");
const reduceDescriptors = (obj, reducer) => {
  const descriptors2 = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach(descriptors2, (descriptor, name2) => {
    if (reducer(descriptor, name2, obj) !== false) {
      reducedDescriptors[name2] = descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
};
const freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name2) => {
    if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name2) !== -1) {
      return false;
    }
    const value = obj[name2];
    if (!isFunction(value))
      return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not rewrite read-only method '" + name2 + "'");
      };
    }
  });
};
const toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};
  const define = (arr) => {
    arr.forEach((value) => {
      obj[value] = true;
    });
  };
  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
  return obj;
};
const noop = () => {
};
const toFiniteNumber = (value, defaultValue) => {
  value = +value;
  return Number.isFinite(value) ? value : defaultValue;
};
const ALPHA = "abcdefghijklmnopqrstuvwxyz";
const DIGIT = "0123456789";
const ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
};
const generateString = (size2 = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
  let str = "";
  const { length } = alphabet;
  while (size2--) {
    str += alphabet[Math.random() * length | 0];
  }
  return str;
};
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
}
const toJSONObject = (obj) => {
  const stack = new Array(10);
  const visit = (source, i2) => {
    if (isObject$1(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }
      if (!("toJSON" in source)) {
        stack[i2] = source;
        const target = isArray(source) ? [] : {};
        forEach(source, (value, key) => {
          const reducedValue = visit(value, i2 + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });
        stack[i2] = void 0;
        return target;
      }
    }
    return source;
  };
  return visit(obj, 0);
};
const utils = {
  isArray,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject: isObject$1,
  isPlainObject,
  isUndefined,
  isDate: isDate$1,
  isFile,
  isBlob,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty,
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop,
  toFiniteNumber,
  findKey: findKey$1,
  global: _global,
  isContextDefined,
  ALPHABET,
  generateString,
  isSpecCompliantForm,
  toJSONObject
};
function AxiosError(message, code2, config, request, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message;
  this.name = "AxiosError";
  code2 && (this.code = code2);
  config && (this.config = config);
  request && (this.request = request);
  response && (this.response = response);
}
utils.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      message: this.message,
      name: this.name,
      description: this.description,
      number: this.number,
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      config: utils.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
const prototype$1 = AxiosError.prototype;
const descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
].forEach((code2) => {
  descriptors[code2] = { value: code2 };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype$1, "isAxiosError", { value: true });
AxiosError.from = (error, code2, config, request, response, customProps) => {
  const axiosError = Object.create(prototype$1);
  utils.toFlatObject(error, axiosError, function filter2(obj) {
    return obj !== Error.prototype;
  }, (prop) => {
    return prop !== "isAxiosError";
  });
  AxiosError.call(axiosError, error.message, code2, config, request, response);
  axiosError.cause = error;
  axiosError.name = error.name;
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
const httpAdapter = null;
function isVisitable(thing) {
  return utils.isPlainObject(thing) || utils.isArray(thing);
}
function removeBrackets(key) {
  return utils.endsWith(key, "[]") ? key.slice(0, -2) : key;
}
function renderKey(path, key, dots) {
  if (!path)
    return key;
  return path.concat(key).map(function each(token, i2) {
    token = removeBrackets(token);
    return !dots && i2 ? "[" + token + "]" : token;
  }).join(dots ? "." : "");
}
function isFlatArray(arr) {
  return utils.isArray(arr) && !arr.some(isVisitable);
}
const predicates = utils.toFlatObject(utils, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});
function toFormData(obj, formData, options) {
  if (!utils.isObject(obj)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new FormData();
  options = utils.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    return !utils.isUndefined(source[option]);
  });
  const metaTokens = options.metaTokens;
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && utils.isSpecCompliantForm(formData);
  if (!utils.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue(value) {
    if (value === null)
      return "";
    if (utils.isDate(value)) {
      return value.toISOString();
    }
    if (!useBlob && utils.isBlob(value)) {
      throw new AxiosError("Blob is not supported. Use a Buffer instead.");
    }
    if (utils.isArrayBuffer(value) || utils.isTypedArray(value)) {
      return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
    }
    return value;
  }
  function defaultVisitor(value, key, path) {
    let arr = value;
    if (value && !path && typeof value === "object") {
      if (utils.endsWith(key, "{}")) {
        key = metaTokens ? key : key.slice(0, -2);
        value = JSON.stringify(value);
      } else if (utils.isArray(value) && isFlatArray(value) || (utils.isFileList(value) || utils.endsWith(key, "[]")) && (arr = utils.toArray(value))) {
        key = removeBrackets(key);
        arr.forEach(function each(el2, index2) {
          !(utils.isUndefined(el2) || el2 === null) && formData.append(
            indexes === true ? renderKey([key], index2, dots) : indexes === null ? key : key + "[]",
            convertValue(el2)
          );
        });
        return false;
      }
    }
    if (isVisitable(value)) {
      return true;
    }
    formData.append(renderKey(path, key, dots), convertValue(value));
    return false;
  }
  const stack = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build2(value, path) {
    if (utils.isUndefined(value))
      return;
    if (stack.indexOf(value) !== -1) {
      throw Error("Circular reference detected in " + path.join("."));
    }
    stack.push(value);
    utils.forEach(value, function each(el2, key) {
      const result = !(utils.isUndefined(el2) || el2 === null) && visitor.call(
        formData,
        el2,
        utils.isString(key) ? key.trim() : key,
        path,
        exposedHelpers
      );
      if (result === true) {
        build2(el2, path ? path.concat(key) : [key]);
      }
    });
    stack.pop();
  }
  if (!utils.isObject(obj)) {
    throw new TypeError("data must be an object");
  }
  build2(obj);
  return formData;
}
function encode$1(str) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer2(match2) {
    return charMap[match2];
  });
}
function AxiosURLSearchParams(params, options) {
  this._pairs = [];
  params && toFormData(params, this, options);
}
const prototype = AxiosURLSearchParams.prototype;
prototype.append = function append(name2, value) {
  this._pairs.push([name2, value]);
};
prototype.toString = function toString2(encoder) {
  const _encode = encoder ? function(value) {
    return encoder.call(this, value, encode$1);
  } : encode$1;
  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + "=" + _encode(pair[1]);
  }, "").join("&");
};
function encode(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL(url, params, options) {
  if (!params) {
    return url;
  }
  const _encode = options && options.encode || encode;
  const serializeFn = options && options.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url;
}
class InterceptorManager {
  constructor() {
    this.handlers = [];
  }
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }
  forEach(fn2) {
    utils.forEach(this.handlers, function forEachHandler(h4) {
      if (h4 !== null) {
        fn2(h4);
      }
    });
  }
}
const InterceptorManager$1 = InterceptorManager;
const transitionalDefaults = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};
const URLSearchParams$1 = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams;
const FormData$1 = typeof FormData !== "undefined" ? FormData : null;
const Blob$1 = typeof Blob !== "undefined" ? Blob : null;
const isStandardBrowserEnv = (() => {
  let product;
  if (typeof navigator !== "undefined" && ((product = navigator.product) === "ReactNative" || product === "NativeScript" || product === "NS")) {
    return false;
  }
  return typeof window !== "undefined" && typeof document !== "undefined";
})();
const isStandardBrowserWebWorkerEnv = (() => {
  return typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();
const platform = {
  isBrowser: true,
  classes: {
    URLSearchParams: URLSearchParams$1,
    FormData: FormData$1,
    Blob: Blob$1
  },
  isStandardBrowserEnv,
  isStandardBrowserWebWorkerEnv,
  protocols: ["http", "https", "file", "blob", "url", "data"]
};
function toURLEncodedForm(data, options) {
  return toFormData(data, new platform.classes.URLSearchParams(), Object.assign({
    visitor: function(value, key, path, helpers) {
      if (platform.isNode && utils.isBuffer(value)) {
        this.append(key, value.toString("base64"));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}
function parsePropPath(name2) {
  return utils.matchAll(/\w+|\[(\w*)]/g, name2).map((match2) => {
    return match2[0] === "[]" ? "" : match2[1] || match2[0];
  });
}
function arrayToObject(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i2;
  const len = keys.length;
  let key;
  for (i2 = 0; i2 < len; i2++) {
    key = keys[i2];
    obj[key] = arr[key];
  }
  return obj;
}
function formDataToJSON(formData) {
  function buildPath(path, value, target, index2) {
    let name2 = path[index2++];
    const isNumericKey = Number.isFinite(+name2);
    const isLast = index2 >= path.length;
    name2 = !name2 && utils.isArray(target) ? target.length : name2;
    if (isLast) {
      if (utils.hasOwnProp(target, name2)) {
        target[name2] = [target[name2], value];
      } else {
        target[name2] = value;
      }
      return !isNumericKey;
    }
    if (!target[name2] || !utils.isObject(target[name2])) {
      target[name2] = [];
    }
    const result = buildPath(path, value, target[name2], index2);
    if (result && utils.isArray(target[name2])) {
      target[name2] = arrayToObject(target[name2]);
    }
    return !isNumericKey;
  }
  if (utils.isFormData(formData) && utils.isFunction(formData.entries)) {
    const obj = {};
    utils.forEachEntry(formData, (name2, value) => {
      buildPath(parsePropPath(name2), value, obj, 0);
    });
    return obj;
  }
  return null;
}
const DEFAULT_CONTENT_TYPE = {
  "Content-Type": void 0
};
function stringifySafely(rawValue, parser, encoder) {
  if (utils.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils.trim(rawValue);
    } catch (e3) {
      if (e3.name !== "SyntaxError") {
        throw e3;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
const defaults = {
  transitional: transitionalDefaults,
  adapter: ["xhr", "http"],
  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || "";
    const hasJSONContentType = contentType.indexOf("application/json") > -1;
    const isObjectPayload = utils.isObject(data);
    if (isObjectPayload && utils.isHTMLForm(data)) {
      data = new FormData(data);
    }
    const isFormData2 = utils.isFormData(data);
    if (isFormData2) {
      if (!hasJSONContentType) {
        return data;
      }
      return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
    }
    if (utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
      return data.toString();
    }
    let isFileList2;
    if (isObjectPayload) {
      if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }
      if ((isFileList2 = utils.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData(
          isFileList2 ? { "files[]": data } : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType("application/json", false);
      return stringifySafely(data);
    }
    return data;
  }],
  transformResponse: [function transformResponse(data) {
    const transitional2 = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    const JSONRequested = this.responseType === "json";
    if (data && utils.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data);
      } catch (e3) {
        if (strictJSONParsing) {
          if (e3.name === "SyntaxError") {
            throw AxiosError.from(e3, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e3;
        }
      }
    }
    return data;
  }],
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform.classes.FormData,
    Blob: platform.classes.Blob
  },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*"
    }
  }
};
utils.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});
utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});
const defaults$1 = defaults;
const ignoreDuplicateOf = utils.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
const parseHeaders = (rawHeaders) => {
  const parsed = {};
  let key;
  let val;
  let i2;
  rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
    i2 = line.indexOf(":");
    key = line.substring(0, i2).trim().toLowerCase();
    val = line.substring(i2 + 1).trim();
    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
      return;
    }
    if (key === "set-cookie") {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
    }
  });
  return parsed;
};
const $internals = Symbol("internals");
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }
  return utils.isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str) {
  const tokens = /* @__PURE__ */ Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match2;
  while (match2 = tokensRE.exec(str)) {
    tokens[match2[1]] = match2[2];
  }
  return tokens;
}
function isValidHeaderName(str) {
  return /^[-_a-zA-Z]+$/.test(str.trim());
}
function matchHeaderValue(context, value, header, filter2, isHeaderNameFilter) {
  if (utils.isFunction(filter2)) {
    return filter2.call(this, value, header);
  }
  if (isHeaderNameFilter) {
    value = header;
  }
  if (!utils.isString(value))
    return;
  if (utils.isString(filter2)) {
    return value.indexOf(filter2) !== -1;
  }
  if (utils.isRegExp(filter2)) {
    return filter2.test(value);
  }
}
function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w2, char, str) => {
    return char.toUpperCase() + str;
  });
}
function buildAccessors(obj, header) {
  const accessorName = utils.toCamelCase(" " + header);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}
class AxiosHeaders {
  constructor(headers) {
    headers && this.set(headers);
  }
  set(header, valueOrRewrite, rewrite) {
    const self2 = this;
    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error("header name must be a non-empty string");
      }
      const key = utils.findKey(self2, lHeader);
      if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
        self2[key || _header] = normalizeValue(_value);
      }
    }
    const setHeaders = (headers, _rewrite) => utils.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
    if (utils.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if (utils.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders(header), valueOrRewrite);
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }
    return this;
  }
  get(header, parser) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils.findKey(this, header);
      if (key) {
        const value = this[key];
        if (!parser) {
          return value;
        }
        if (parser === true) {
          return parseTokens(value);
        }
        if (utils.isFunction(parser)) {
          return parser.call(this, value, key);
        }
        if (utils.isRegExp(parser)) {
          return parser.exec(value);
        }
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(header, matcher) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils.findKey(this, header);
      return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }
    return false;
  }
  delete(header, matcher) {
    const self2 = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key = utils.findKey(self2, _header);
        if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
          delete self2[key];
          deleted = true;
        }
      }
    }
    if (utils.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }
    return deleted;
  }
  clear(matcher) {
    const keys = Object.keys(this);
    let i2 = keys.length;
    let deleted = false;
    while (i2--) {
      const key = keys[i2];
      if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }
    return deleted;
  }
  normalize(format2) {
    const self2 = this;
    const headers = {};
    utils.forEach(this, (value, header) => {
      const key = utils.findKey(headers, header);
      if (key) {
        self2[key] = normalizeValue(value);
        delete self2[header];
        return;
      }
      const normalized = format2 ? formatHeader(header) : String(header).trim();
      if (normalized !== header) {
        delete self2[header];
      }
      self2[normalized] = normalizeValue(value);
      headers[normalized] = true;
    });
    return this;
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
  toJSON(asStrings) {
    const obj = /* @__PURE__ */ Object.create(null);
    utils.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils.isArray(value) ? value.join(", ") : value);
    });
    return obj;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first, ...targets) {
    const computed2 = new this(first);
    targets.forEach((target) => computed2.set(target));
    return computed2;
  }
  static accessor(header) {
    const internals = this[$internals] = this[$internals] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype2 = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype2, _header);
        accessors[lHeader] = true;
      }
    }
    utils.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
    return this;
  }
}
AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils.freezeMethods(AxiosHeaders.prototype);
utils.freezeMethods(AxiosHeaders);
const AxiosHeaders$1 = AxiosHeaders;
function transformData(fns, response) {
  const config = this || defaults$1;
  const context = response || config;
  const headers = AxiosHeaders$1.from(context.headers);
  let data = context.data;
  utils.forEach(fns, function transform2(fn2) {
    data = fn2.call(config, data, headers.normalize(), response ? response.status : void 0);
  });
  headers.normalize();
  return data;
}
function isCancel(value) {
  return !!(value && value.__CANCEL__);
}
function CanceledError(message, config, request) {
  AxiosError.call(this, message == null ? "canceled" : message, AxiosError.ERR_CANCELED, config, request);
  this.name = "CanceledError";
}
utils.inherits(CanceledError, AxiosError, {
  __CANCEL__: true
});
function settle(resolve2, reject, response) {
  const validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve2(response);
  } else {
    reject(new AxiosError(
      "Request failed with status code " + response.status,
      [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}
const cookies = platform.isStandardBrowserEnv ? function standardBrowserEnv() {
  return {
    write: function write(name2, value, expires, path, domain, secure) {
      const cookie = [];
      cookie.push(name2 + "=" + encodeURIComponent(value));
      if (utils.isNumber(expires)) {
        cookie.push("expires=" + new Date(expires).toGMTString());
      }
      if (utils.isString(path)) {
        cookie.push("path=" + path);
      }
      if (utils.isString(domain)) {
        cookie.push("domain=" + domain);
      }
      if (secure === true) {
        cookie.push("secure");
      }
      document.cookie = cookie.join("; ");
    },
    read: function read(name2) {
      const match2 = document.cookie.match(new RegExp("(^|;\\s*)(" + name2 + ")=([^;]*)"));
      return match2 ? decodeURIComponent(match2[3]) : null;
    },
    remove: function remove2(name2) {
      this.write(name2, "", Date.now() - 864e5);
    }
  };
}() : function nonStandardBrowserEnv() {
  return {
    write: function write() {
    },
    read: function read() {
      return null;
    },
    remove: function remove2() {
    }
  };
}();
function isAbsoluteURL(url) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}
function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}
const isURLSameOrigin = platform.isStandardBrowserEnv ? function standardBrowserEnv2() {
  const msie = /(msie|trident)/i.test(navigator.userAgent);
  const urlParsingNode = document.createElement("a");
  let originURL;
  function resolveURL(url) {
    let href = url;
    if (msie) {
      urlParsingNode.setAttribute("href", href);
      href = urlParsingNode.href;
    }
    urlParsingNode.setAttribute("href", href);
    return {
      href: urlParsingNode.href,
      protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
      host: urlParsingNode.host,
      search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
      hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
      hostname: urlParsingNode.hostname,
      port: urlParsingNode.port,
      pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
    };
  }
  originURL = resolveURL(window.location.href);
  return function isURLSameOrigin2(requestURL) {
    const parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
    return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
  };
}() : function nonStandardBrowserEnv2() {
  return function isURLSameOrigin2() {
    return true;
  };
}();
function parseProtocol(url) {
  const match2 = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match2 && match2[1] || "";
}
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;
  min = min !== void 0 ? min : 1e3;
  return function push(chunkLength) {
    const now = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now;
    }
    bytes[head] = chunkLength;
    timestamps[head] = now;
    let i2 = tail;
    let bytesCount = 0;
    while (i2 !== head) {
      bytesCount += bytes[i2++];
      i2 = i2 % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now - firstSampleTS < min) {
      return;
    }
    const passed = startedAt && now - startedAt;
    return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
  };
}
function progressEventReducer(listener, isDownloadStream) {
  let bytesNotified = 0;
  const _speedometer = speedometer(50, 250);
  return (e3) => {
    const loaded = e3.loaded;
    const total = e3.lengthComputable ? e3.total : void 0;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;
    bytesNotified = loaded;
    const data = {
      loaded,
      total,
      progress: total ? loaded / total : void 0,
      bytes: progressBytes,
      rate: rate ? rate : void 0,
      estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
      event: e3
    };
    data[isDownloadStream ? "download" : "upload"] = true;
    listener(data);
  };
}
const isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
const xhrAdapter = isXHRAdapterSupported && function(config) {
  return new Promise(function dispatchXhrRequest(resolve2, reject) {
    let requestData = config.data;
    const requestHeaders = AxiosHeaders$1.from(config.headers).normalize();
    const responseType = config.responseType;
    let onCanceled;
    function done() {
      if (config.cancelToken) {
        config.cancelToken.unsubscribe(onCanceled);
      }
      if (config.signal) {
        config.signal.removeEventListener("abort", onCanceled);
      }
    }
    if (utils.isFormData(requestData) && (platform.isStandardBrowserEnv || platform.isStandardBrowserWebWorkerEnv)) {
      requestHeaders.setContentType(false);
    }
    let request = new XMLHttpRequest();
    if (config.auth) {
      const username = config.auth.username || "";
      const password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
      requestHeaders.set("Authorization", "Basic " + btoa(username + ":" + password));
    }
    const fullPath = buildFullPath(config.baseURL, config.url);
    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
    request.timeout = config.timeout;
    function onloadend() {
      if (!request) {
        return;
      }
      const responseHeaders = AxiosHeaders$1.from(
        "getAllResponseHeaders" in request && request.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config,
        request
      };
      settle(function _resolve(value) {
        resolve2(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);
      request = null;
    }
    if ("onloadend" in request) {
      request.onloadend = onloadend;
    } else {
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }
      reject(new AxiosError("Request aborted", AxiosError.ECONNABORTED, config, request));
      request = null;
    };
    request.onerror = function handleError2() {
      reject(new AxiosError("Network Error", AxiosError.ERR_NETWORK, config, request));
      request = null;
    };
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
      const transitional2 = config.transitional || transitionalDefaults;
      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }
      reject(new AxiosError(
        timeoutErrorMessage,
        transitional2.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
        config,
        request
      ));
      request = null;
    };
    if (platform.isStandardBrowserEnv) {
      const xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName && cookies.read(config.xsrfCookieName);
      if (xsrfValue) {
        requestHeaders.set(config.xsrfHeaderName, xsrfValue);
      }
    }
    requestData === void 0 && requestHeaders.setContentType(null);
    if ("setRequestHeader" in request) {
      utils.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      });
    }
    if (!utils.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request.responseType = config.responseType;
    }
    if (typeof config.onDownloadProgress === "function") {
      request.addEventListener("progress", progressEventReducer(config.onDownloadProgress, true));
    }
    if (typeof config.onUploadProgress === "function" && request.upload) {
      request.upload.addEventListener("progress", progressEventReducer(config.onUploadProgress));
    }
    if (config.cancelToken || config.signal) {
      onCanceled = (cancel) => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError(null, config, request) : cancel);
        request.abort();
        request = null;
      };
      config.cancelToken && config.cancelToken.subscribe(onCanceled);
      if (config.signal) {
        config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
      }
    }
    const protocol = parseProtocol(fullPath);
    if (protocol && platform.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError("Unsupported protocol " + protocol + ":", AxiosError.ERR_BAD_REQUEST, config));
      return;
    }
    request.send(requestData || null);
  });
};
const knownAdapters = {
  http: httpAdapter,
  xhr: xhrAdapter
};
utils.forEach(knownAdapters, (fn2, value) => {
  if (fn2) {
    try {
      Object.defineProperty(fn2, "name", { value });
    } catch (e3) {
    }
    Object.defineProperty(fn2, "adapterName", { value });
  }
});
const adapters = {
  getAdapter: (adapters2) => {
    adapters2 = utils.isArray(adapters2) ? adapters2 : [adapters2];
    const { length } = adapters2;
    let nameOrAdapter;
    let adapter;
    for (let i2 = 0; i2 < length; i2++) {
      nameOrAdapter = adapters2[i2];
      if (adapter = utils.isString(nameOrAdapter) ? knownAdapters[nameOrAdapter.toLowerCase()] : nameOrAdapter) {
        break;
      }
    }
    if (!adapter) {
      if (adapter === false) {
        throw new AxiosError(
          `Adapter ${nameOrAdapter} is not supported by the environment`,
          "ERR_NOT_SUPPORT"
        );
      }
      throw new Error(
        utils.hasOwnProp(knownAdapters, nameOrAdapter) ? `Adapter '${nameOrAdapter}' is not available in the build` : `Unknown adapter '${nameOrAdapter}'`
      );
    }
    if (!utils.isFunction(adapter)) {
      throw new TypeError("adapter is not a function");
    }
    return adapter;
  },
  adapters: knownAdapters
};
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
  if (config.signal && config.signal.aborted) {
    throw new CanceledError(null, config);
  }
}
function dispatchRequest(config) {
  throwIfCancellationRequested(config);
  config.headers = AxiosHeaders$1.from(config.headers);
  config.data = transformData.call(
    config,
    config.transformRequest
  );
  if (["post", "put", "patch"].indexOf(config.method) !== -1) {
    config.headers.setContentType("application/x-www-form-urlencoded", false);
  }
  const adapter = adapters.getAdapter(config.adapter || defaults$1.adapter);
  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);
    response.data = transformData.call(
      config,
      config.transformResponse,
      response
    );
    response.headers = AxiosHeaders$1.from(response.headers);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          config.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}
const headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? thing.toJSON() : thing;
function mergeConfig(config1, config2) {
  config2 = config2 || {};
  const config = {};
  function getMergedValue(target, source, caseless) {
    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
      return utils.merge.call({ caseless }, target, source);
    } else if (utils.isPlainObject(source)) {
      return utils.merge({}, source);
    } else if (utils.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(a3, b3, caseless) {
    if (!utils.isUndefined(b3)) {
      return getMergedValue(a3, b3, caseless);
    } else if (!utils.isUndefined(a3)) {
      return getMergedValue(void 0, a3, caseless);
    }
  }
  function valueFromConfig2(a3, b3) {
    if (!utils.isUndefined(b3)) {
      return getMergedValue(void 0, b3);
    }
  }
  function defaultToConfig2(a3, b3) {
    if (!utils.isUndefined(b3)) {
      return getMergedValue(void 0, b3);
    } else if (!utils.isUndefined(a3)) {
      return getMergedValue(void 0, a3);
    }
  }
  function mergeDirectKeys(a3, b3, prop) {
    if (prop in config2) {
      return getMergedValue(a3, b3);
    } else if (prop in config1) {
      return getMergedValue(void 0, a3);
    }
  }
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a3, b3) => mergeDeepProperties(headersToObject(a3), headersToObject(b3), true)
  };
  utils.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
    const merge2 = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge2(config1[prop], config2[prop], prop);
    utils.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
  });
  return config;
}
const VERSION = "1.3.4";
const validators$1 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i2) => {
  validators$1[type] = function validator2(thing) {
    return typeof thing === type || "a" + (i2 < 1 ? "n " : " ") + type;
  };
});
const deprecatedWarnings = {};
validators$1.transitional = function transitional(validator2, version2, message) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return (value, opt, opts) => {
    if (validator2 === false) {
      throw new AxiosError(
        formatMessage(opt, " has been removed" + (version2 ? " in " + version2 : "")),
        AxiosError.ERR_DEPRECATED
      );
    }
    if (version2 && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version2 + " and will be removed in the near future"
        )
      );
    }
    return validator2 ? validator2(value, opt, opts) : true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i2 = keys.length;
  while (i2-- > 0) {
    const opt = keys[i2];
    const validator2 = schema[opt];
    if (validator2) {
      const value = options[opt];
      const result = value === void 0 || validator2(value, opt, options);
      if (result !== true) {
        throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
    }
  }
}
const validator = {
  assertOptions,
  validators: validators$1
};
const validators = validator.validators;
class Axios {
  constructor(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager$1(),
      response: new InterceptorManager$1()
    };
  }
  request(configOrUrl, config) {
    if (typeof configOrUrl === "string") {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }
    config = mergeConfig(this.defaults, config);
    const { transitional: transitional2, paramsSerializer, headers } = config;
    if (transitional2 !== void 0) {
      validator.assertOptions(transitional2, {
        silentJSONParsing: validators.transitional(validators.boolean),
        forcedJSONParsing: validators.transitional(validators.boolean),
        clarifyTimeoutError: validators.transitional(validators.boolean)
      }, false);
    }
    if (paramsSerializer !== void 0) {
      validator.assertOptions(paramsSerializer, {
        encode: validators.function,
        serialize: validators.function
      }, true);
    }
    config.method = (config.method || this.defaults.method || "get").toLowerCase();
    let contextHeaders;
    contextHeaders = headers && utils.merge(
      headers.common,
      headers[config.method]
    );
    contextHeaders && utils.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (method) => {
        delete headers[method];
      }
    );
    config.headers = AxiosHeaders$1.concat(contextHeaders, headers);
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    let promise;
    let i2 = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), void 0];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;
      promise = Promise.resolve(config);
      while (i2 < len) {
        promise = promise.then(chain[i2++], chain[i2++]);
      }
      return promise;
    }
    len = requestInterceptorChain.length;
    let newConfig = config;
    i2 = 0;
    while (i2 < len) {
      const onFulfilled = requestInterceptorChain[i2++];
      const onRejected = requestInterceptorChain[i2++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }
    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }
    i2 = 0;
    len = responseInterceptorChain.length;
    while (i2 < len) {
      promise = promise.then(responseInterceptorChain[i2++], responseInterceptorChain[i2++]);
    }
    return promise;
  }
  getUri(config) {
    config = mergeConfig(this.defaults, config);
    const fullPath = buildFullPath(config.baseURL, config.url);
    return buildURL(fullPath, config.params, config.paramsSerializer);
  }
}
utils.forEach(["delete", "get", "head", "options"], function forEachMethodNoData2(method) {
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method,
      url,
      data: (config || {}).data
    }));
  };
});
utils.forEach(["post", "put", "patch"], function forEachMethodWithData2(method) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config) {
      return this.request(mergeConfig(config || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url,
        data
      }));
    };
  }
  Axios.prototype[method] = generateHTTPMethod();
  Axios.prototype[method + "Form"] = generateHTTPMethod(true);
});
const Axios$1 = Axios;
class CancelToken {
  constructor(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve2) {
      resolvePromise = resolve2;
    });
    const token = this;
    this.promise.then((cancel) => {
      if (!token._listeners)
        return;
      let i2 = token._listeners.length;
      while (i2-- > 0) {
        token._listeners[i2](cancel);
      }
      token._listeners = null;
    });
    this.promise.then = (onfulfilled) => {
      let _resolve;
      const promise = new Promise((resolve2) => {
        token.subscribe(resolve2);
        _resolve = resolve2;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };
      return promise;
    };
    executor(function cancel(message, config, request) {
      if (token.reason) {
        return;
      }
      token.reason = new CanceledError(message, config, request);
      resolvePromise(token.reason);
    });
  }
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }
  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }
  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index2 = this._listeners.indexOf(listener);
    if (index2 !== -1) {
      this._listeners.splice(index2, 1);
    }
  }
  static source() {
    let cancel;
    const token = new CancelToken(function executor(c2) {
      cancel = c2;
    });
    return {
      token,
      cancel
    };
  }
}
const CancelToken$1 = CancelToken;
function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}
function isAxiosError(payload) {
  return utils.isObject(payload) && payload.isAxiosError === true;
}
const HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode).forEach(([key, value]) => {
  HttpStatusCode[value] = key;
});
const HttpStatusCode$1 = HttpStatusCode;
function createInstance(defaultConfig) {
  const context = new Axios$1(defaultConfig);
  const instance = bind(Axios$1.prototype.request, context);
  utils.extend(instance, Axios$1.prototype, context, { allOwnKeys: true });
  utils.extend(instance, context, null, { allOwnKeys: true });
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };
  return instance;
}
const axios = createInstance(defaults$1);
axios.Axios = Axios$1;
axios.CanceledError = CanceledError;
axios.CancelToken = CancelToken$1;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData;
axios.AxiosError = AxiosError;
axios.Cancel = axios.CanceledError;
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = spread;
axios.isAxiosError = isAxiosError;
axios.mergeConfig = mergeConfig;
axios.AxiosHeaders = AxiosHeaders$1;
axios.formToJSON = (thing) => formDataToJSON(utils.isHTMLForm(thing) ? new FormData(thing) : thing);
axios.HttpStatusCode = HttpStatusCode$1;
axios.default = axios;
const axios$1 = axios;
let idpData;
function setIdpData(data) {
  idpData = data;
  configureAuth({ ...data });
}
const configureAuth = ({
  region,
  userPoolId,
  userPoolWebClientId,
  oauthDomain,
  redirectSignIn,
  redirectSignOut,
  clientId
}) => {
  Amplify.configure({
    aws_project_region: region,
    aws_cognito_region: region,
    aws_user_pools_id: userPoolId,
    aws_user_pools_web_client_id: userPoolWebClientId,
    Auth: {
      oauth: {
        domain: oauthDomain,
        scope: ["email", "openid", "profile", `tenant/${clientId}`],
        redirectSignIn,
        redirectSignOut,
        responseType: "code"
      }
    }
  });
};
async function getAuthDetails() {
  const { token, userPoolId, accessToken } = await authenticate() || {};
  return { token, userPoolId, accessToken };
}
async function authenticate() {
  let authSession;
  try {
    authSession = await Auth.currentSession();
  } catch (e3) {
  }
  if (authSession) {
    const session = await authSession;
    const idToken = await session.getIdToken();
    const accessToken = await session.getAccessToken();
    return {
      token: idToken.jwtToken,
      userPoolId: idpData.userPoolId,
      accessToken: accessToken.jwtToken
    };
  } else {
    return {};
  }
}
async function doFederatedSignIn() {
  await Auth.federatedSignIn();
}
async function logout() {
  try {
    await Auth.signOut();
    return true;
  } catch (error) {
    console.log("Error signing out: ", error);
  }
}
async function invokeGetApi(apiName, payload) {
  var _a2;
  const { accessToken } = await getAuthDetails();
  const response = await axios$1.get(
    `https://${idpData.apiPrefix}/${idpData.stage}/${apiName}`,
    {
      headers: {
        Authorization: accessToken
      },
      params: payload
    }
  );
  return (_a2 = response == null ? void 0 : response.data) == null ? void 0 : _a2.body;
}
async function invokePostApi(apiName, payload) {
  var _a2;
  const { accessToken } = await getAuthDetails();
  const response = await axios$1.post(
    `https://${idpData.apiPrefix}/${idpData.stage}/${apiName}`,
    payload,
    {
      headers: {
        Authorization: accessToken,
        "Content-Type": "application/json"
      }
    }
  );
  return (_a2 = response == null ? void 0 : response.data) == null ? void 0 : _a2.body;
}
const TheHeader_vue_vue_type_style_index_0_lang = "";
const _sfc_main$q = {
  name: "TheHeader",
  data() {
    return {
      AnyUser,
      dropdownMenuIsShown: false,
      selectedOption: 1
    };
  },
  props: {
    userdata: {
      type: Object,
      required: true
    }
  },
  methods: {
    hideDropdownMenu() {
      this.dropdownMenuIsShown = false;
    },
    dropdownClickHandler(event) {
      event.stopPropagation();
      this.dropdownMenuIsShown = true;
      const screen = document.querySelector(".screen");
      screen.addEventListener("click", this.hideDropdownMenu, { once: true });
    },
    handleLogout() {
      logout();
    }
  }
};
const _hoisted_1$n = { class: "account-control" };
const _hoisted_2$l = { class: "control-section" };
const _hoisted_3$l = { class: "dropdown-container" };
const _hoisted_4$l = { class: "user-icon" };
const _hoisted_5$i = ["src"];
const _hoisted_6$h = /* @__PURE__ */ createBaseVNode("span", { class: "dropdown-text" }, "My Account", -1);
const _hoisted_7$f = /* @__PURE__ */ createBaseVNode("div", { class: "down-arrow" }, null, -1);
const _hoisted_8$f = {
  key: 0,
  class: "dropdown-menu"
};
function _sfc_render$q(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$n, [
    createBaseVNode("div", _hoisted_2$l, [
      createBaseVNode("div", _hoisted_3$l, [
        createBaseVNode("button", {
          class: "dropdown-button",
          onClick: _cache[0] || (_cache[0] = (...args) => $options.dropdownClickHandler && $options.dropdownClickHandler(...args))
        }, [
          createBaseVNode("div", _hoisted_4$l, [
            createBaseVNode("img", { src: $data.AnyUser }, null, 8, _hoisted_5$i)
          ]),
          _hoisted_6$h,
          _hoisted_7$f
        ]),
        $data.dropdownMenuIsShown ? (openBlock(), createElementBlock("div", _hoisted_8$f, [
          createBaseVNode("a", {
            class: normalizeClass($data.selectedOption === 1 ? "selected" : "menu-option")
          }, " Hello! " + toDisplayString($props.userdata.userName) + toDisplayString($props.userdata.isAdmin ? "(Admin)" : ""), 3),
          createBaseVNode("a", {
            class: normalizeClass($data.selectedOption === 2 ? "selected" : "menu-option"),
            onClick: _cache[1] || (_cache[1] = (...args) => $options.handleLogout && $options.handleLogout(...args))
          }, "Logout", 2)
        ])) : createCommentVNode("", true)
      ])
    ])
  ]);
}
const TheHeader = /* @__PURE__ */ _export_sfc(_sfc_main$q, [["render", _sfc_render$q]]);
const TheSckeleton_vue_vue_type_style_index_0_scoped_262fcb2f_lang = "";
const VApp$1 = "";
const IN_BROWSER = typeof window !== "undefined";
const SUPPORTS_INTERSECTION = IN_BROWSER && "IntersectionObserver" in window;
const SUPPORTS_TOUCH = IN_BROWSER && ("ontouchstart" in window || window.navigator.maxTouchPoints > 0);
const SUPPORTS_FOCUS_VISIBLE = IN_BROWSER && typeof CSS !== "undefined" && CSS.supports("selector(:focus-visible)");
function useResizeObserver(callback) {
  const resizeRef = ref();
  const contentRect = ref();
  if (IN_BROWSER) {
    const observer = new ResizeObserver((entries) => {
      callback == null ? void 0 : callback(entries, observer);
      if (!entries.length)
        return;
      contentRect.value = entries[0].contentRect;
    });
    onBeforeUnmount(() => {
      observer.disconnect();
    });
    watch(resizeRef, (newValue, oldValue) => {
      if (oldValue) {
        observer.unobserve(oldValue);
        contentRect.value = void 0;
      }
      if (newValue)
        observer.observe(newValue);
    }, {
      flush: "post"
    });
  }
  return {
    resizeRef,
    contentRect: readonly(contentRect)
  };
}
function getNestedValue(obj, path, fallback) {
  const last = path.length - 1;
  if (last < 0)
    return obj === void 0 ? fallback : obj;
  for (let i2 = 0; i2 < last; i2++) {
    if (obj == null) {
      return fallback;
    }
    obj = obj[path[i2]];
  }
  if (obj == null)
    return fallback;
  return obj[path[last]] === void 0 ? fallback : obj[path[last]];
}
function deepEqual(a3, b3) {
  if (a3 === b3)
    return true;
  if (a3 instanceof Date && b3 instanceof Date && a3.getTime() !== b3.getTime()) {
    return false;
  }
  if (a3 !== Object(a3) || b3 !== Object(b3)) {
    return false;
  }
  const props = Object.keys(a3);
  if (props.length !== Object.keys(b3).length) {
    return false;
  }
  return props.every((p2) => deepEqual(a3[p2], b3[p2]));
}
function getObjectValueByPath(obj, path, fallback) {
  if (obj == null || !path || typeof path !== "string")
    return fallback;
  if (obj[path] !== void 0)
    return obj[path];
  path = path.replace(/\[(\w+)\]/g, ".$1");
  path = path.replace(/^\./, "");
  return getNestedValue(obj, path.split("."), fallback);
}
function getPropertyFromItem(item, property, fallback) {
  if (property == null)
    return item === void 0 ? fallback : item;
  if (item !== Object(item)) {
    if (typeof property !== "function")
      return fallback;
    const value2 = property(item, fallback);
    return typeof value2 === "undefined" ? fallback : value2;
  }
  if (typeof property === "string")
    return getObjectValueByPath(item, property, fallback);
  if (Array.isArray(property))
    return getNestedValue(item, property, fallback);
  if (typeof property !== "function")
    return fallback;
  const value = property(item, fallback);
  return typeof value === "undefined" ? fallback : value;
}
function createRange(length) {
  let start = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  return Array.from({
    length
  }, (v, k2) => start + k2);
}
function convertToUnit(str) {
  let unit = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "px";
  if (str == null || str === "") {
    return void 0;
  } else if (isNaN(+str)) {
    return String(str);
  } else if (!isFinite(+str)) {
    return void 0;
  } else {
    return `${Number(str)}${unit}`;
  }
}
function isObject(obj) {
  return obj !== null && typeof obj === "object" && !Array.isArray(obj);
}
function isComponentInstance(obj) {
  return obj == null ? void 0 : obj.$el;
}
const keyCodes = Object.freeze({
  enter: 13,
  tab: 9,
  delete: 46,
  esc: 27,
  space: 32,
  up: 38,
  down: 40,
  left: 37,
  right: 39,
  end: 35,
  home: 36,
  del: 46,
  backspace: 8,
  insert: 45,
  pageup: 33,
  pagedown: 34,
  shift: 16
});
Object.freeze({
  enter: "Enter",
  tab: "Tab",
  delete: "Delete",
  esc: "Escape",
  space: "Space",
  up: "ArrowUp",
  down: "ArrowDown",
  left: "ArrowLeft",
  right: "ArrowRight",
  end: "End",
  home: "Home",
  del: "Delete",
  backspace: "Backspace",
  insert: "Insert",
  pageup: "PageUp",
  pagedown: "PageDown",
  shift: "Shift"
});
function pick(obj, paths) {
  const found = /* @__PURE__ */ Object.create(null);
  const rest = /* @__PURE__ */ Object.create(null);
  for (const key in obj) {
    if (paths.some((path) => path instanceof RegExp ? path.test(key) : path === key)) {
      found[key] = obj[key];
    } else {
      rest[key] = obj[key];
    }
  }
  return [found, rest];
}
function omit(obj, exclude) {
  const clone = {
    ...obj
  };
  exclude.forEach((prop) => delete clone[prop]);
  return clone;
}
function filterInputAttrs(attrs) {
  return pick(attrs, ["class", "style", "id", /^data-/]);
}
function wrapInArray(v) {
  return v == null ? [] : Array.isArray(v) ? v : [v];
}
function clamp(value) {
  let min = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  let max = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
  return Math.max(min, Math.min(max, value));
}
function chunk(str) {
  let size2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
  const chunked = [];
  let index2 = 0;
  while (index2 < str.length) {
    chunked.push(str.substr(index2, size2));
    index2 += size2;
  }
  return chunked;
}
function mergeDeep() {
  let source = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  let target = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  let arrayFn = arguments.length > 2 ? arguments[2] : void 0;
  const out = {};
  for (const key in source) {
    out[key] = source[key];
  }
  for (const key in target) {
    const sourceProperty = source[key];
    const targetProperty = target[key];
    if (isObject(sourceProperty) && isObject(targetProperty)) {
      out[key] = mergeDeep(sourceProperty, targetProperty, arrayFn);
      continue;
    }
    if (Array.isArray(sourceProperty) && Array.isArray(targetProperty) && arrayFn) {
      out[key] = arrayFn(sourceProperty, targetProperty);
      continue;
    }
    out[key] = targetProperty;
  }
  return out;
}
function toKebabCase() {
  let str = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
  if (toKebabCase.cache.has(str))
    return toKebabCase.cache.get(str);
  const kebab = str.replace(/[^a-z]/gi, "-").replace(/\B([A-Z])/g, "-$1").toLowerCase();
  toKebabCase.cache.set(str, kebab);
  return kebab;
}
toKebabCase.cache = /* @__PURE__ */ new Map();
function findChildrenWithProvide(key, vnode) {
  if (!vnode || typeof vnode !== "object")
    return [];
  if (Array.isArray(vnode)) {
    return vnode.map((child) => findChildrenWithProvide(key, child)).flat(1);
  } else if (Array.isArray(vnode.children)) {
    return vnode.children.map((child) => findChildrenWithProvide(key, child)).flat(1);
  } else if (vnode.component) {
    if (Object.getOwnPropertySymbols(vnode.component.provides).includes(key)) {
      return [vnode.component];
    } else if (vnode.component.subTree) {
      return findChildrenWithProvide(key, vnode.component.subTree).flat(1);
    }
  }
  return [];
}
function destructComputed(getter) {
  const refs = reactive({});
  const base = computed(getter);
  watchEffect(() => {
    for (const key in base.value) {
      refs[key] = base.value[key];
    }
  }, {
    flush: "sync"
  });
  return toRefs(refs);
}
function includes(arr, val) {
  return arr.includes(val);
}
const onRE = /^on[^a-z]/;
const isOn = (key) => onRE.test(key);
const EventProp = [Function, Array];
function hasEvent(props, name2) {
  name2 = "on" + capitalize(name2);
  return !!(props[name2] || props[`${name2}Once`] || props[`${name2}Capture`] || props[`${name2}OnceCapture`] || props[`${name2}CaptureOnce`]);
}
function callEvent(handler) {
  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    args[_key2 - 1] = arguments[_key2];
  }
  if (Array.isArray(handler)) {
    for (const h4 of handler) {
      h4(...args);
    }
  } else if (typeof handler === "function") {
    handler(...args);
  }
}
const block = ["top", "bottom"];
const inline = ["start", "end", "left", "right"];
function parseAnchor(anchor, isRtl) {
  let [side, align] = anchor.split(" ");
  if (!align) {
    align = includes(block, side) ? "start" : includes(inline, side) ? "top" : "center";
  }
  return {
    side: toPhysical(side, isRtl),
    align: toPhysical(align, isRtl)
  };
}
function toPhysical(str, isRtl) {
  if (str === "start")
    return isRtl ? "right" : "left";
  if (str === "end")
    return isRtl ? "left" : "right";
  return str;
}
function flipSide(anchor) {
  return {
    side: {
      center: "center",
      top: "bottom",
      bottom: "top",
      left: "right",
      right: "left"
    }[anchor.side],
    align: anchor.align
  };
}
function flipAlign(anchor) {
  return {
    side: anchor.side,
    align: {
      center: "center",
      top: "bottom",
      bottom: "top",
      left: "right",
      right: "left"
    }[anchor.align]
  };
}
function flipCorner(anchor) {
  return {
    side: anchor.align,
    align: anchor.side
  };
}
function getAxis(anchor) {
  return includes(block, anchor.side) ? "y" : "x";
}
class Box {
  constructor(_ref) {
    let {
      x: x2,
      y: y3,
      width,
      height
    } = _ref;
    this.x = x2;
    this.y = y3;
    this.width = width;
    this.height = height;
  }
  get top() {
    return this.y;
  }
  get bottom() {
    return this.y + this.height;
  }
  get left() {
    return this.x;
  }
  get right() {
    return this.x + this.width;
  }
}
function getOverflow(a3, b3) {
  return {
    x: {
      before: Math.max(0, b3.left - a3.left),
      after: Math.max(0, a3.right - b3.right)
    },
    y: {
      before: Math.max(0, b3.top - a3.top),
      after: Math.max(0, a3.bottom - b3.bottom)
    }
  };
}
function nullifyTransforms(el2) {
  const rect = el2.getBoundingClientRect();
  const style = getComputedStyle(el2);
  const tx = style.transform;
  if (tx) {
    let ta, sx, sy, dx, dy;
    if (tx.startsWith("matrix3d(")) {
      ta = tx.slice(9, -1).split(/, /);
      sx = +ta[0];
      sy = +ta[5];
      dx = +ta[12];
      dy = +ta[13];
    } else if (tx.startsWith("matrix(")) {
      ta = tx.slice(7, -1).split(/, /);
      sx = +ta[0];
      sy = +ta[3];
      dx = +ta[4];
      dy = +ta[5];
    } else {
      return new Box(rect);
    }
    const to = style.transformOrigin;
    const x2 = rect.x - dx - (1 - sx) * parseFloat(to);
    const y3 = rect.y - dy - (1 - sy) * parseFloat(to.slice(to.indexOf(" ") + 1));
    const w2 = sx ? rect.width / sx : el2.offsetWidth + 1;
    const h4 = sy ? rect.height / sy : el2.offsetHeight + 1;
    return new Box({
      x: x2,
      y: y3,
      width: w2,
      height: h4
    });
  } else {
    return new Box(rect);
  }
}
function animate(el2, keyframes, options) {
  if (typeof el2.animate === "undefined")
    return {
      finished: Promise.resolve()
    };
  const animation = el2.animate(keyframes, options);
  if (typeof animation.finished === "undefined") {
    animation.finished = new Promise((resolve2) => {
      animation.onfinish = () => {
        resolve2(animation);
      };
    });
  }
  return animation;
}
function createMessage(message, vm, parent) {
  if (parent) {
    vm = {
      __isVue: true,
      $parent: parent,
      $options: vm
    };
  }
  if (vm) {
    vm.$_alreadyWarned = vm.$_alreadyWarned || [];
    if (vm.$_alreadyWarned.includes(message))
      return;
    vm.$_alreadyWarned.push(message);
  }
  return `[Vuetify] ${message}` + (vm ? generateComponentTrace(vm) : "");
}
function consoleWarn(message, vm, parent) {
  const newMessage = createMessage(message, vm, parent);
  newMessage != null && console.warn(newMessage);
}
function consoleError(message, vm, parent) {
  const newMessage = createMessage(message, vm, parent);
  newMessage != null && console.error(newMessage);
}
const classifyRE = /(?:^|[-_])(\w)/g;
const classify = (str) => str.replace(classifyRE, (c2) => c2.toUpperCase()).replace(/[-_]/g, "");
function formatComponentName(vm, includeFile) {
  if (vm.$root === vm) {
    return "<Root>";
  }
  const options = typeof vm === "function" && vm.cid != null ? vm.options : vm.__isVue ? vm.$options || vm.constructor.options : vm || {};
  let name2 = options.name || options._componentTag;
  const file = options.__file;
  if (!name2 && file) {
    const match2 = file.match(/([^/\\]+)\.vue$/);
    name2 = match2 == null ? void 0 : match2[1];
  }
  return (name2 ? `<${classify(name2)}>` : `<Anonymous>`) + (file && includeFile !== false ? ` at ${file}` : "");
}
function generateComponentTrace(vm) {
  if (vm.__isVue && vm.$parent) {
    const tree = [];
    let currentRecursiveSequence = 0;
    while (vm) {
      if (tree.length > 0) {
        const last = tree[tree.length - 1];
        if (last.constructor === vm.constructor) {
          currentRecursiveSequence++;
          vm = vm.$parent;
          continue;
        } else if (currentRecursiveSequence > 0) {
          tree[tree.length - 1] = [last, currentRecursiveSequence];
          currentRecursiveSequence = 0;
        }
      }
      tree.push(vm);
      vm = vm.$parent;
    }
    return "\n\nfound in\n\n" + tree.map((vm2, i2) => `${i2 === 0 ? "---> " : " ".repeat(5 + i2 * 2)}${Array.isArray(vm2) ? `${formatComponentName(vm2[0])}... (${vm2[1]} recursive calls)` : formatComponentName(vm2)}`).join("\n");
  } else {
    return `

(found in ${formatComponentName(vm)})`;
  }
}
const srgbForwardMatrix = [[3.2406, -1.5372, -0.4986], [-0.9689, 1.8758, 0.0415], [0.0557, -0.204, 1.057]];
const srgbForwardTransform = (C) => C <= 31308e-7 ? C * 12.92 : 1.055 * C ** (1 / 2.4) - 0.055;
const srgbReverseMatrix = [[0.4124, 0.3576, 0.1805], [0.2126, 0.7152, 0.0722], [0.0193, 0.1192, 0.9505]];
const srgbReverseTransform = (C) => C <= 0.04045 ? C / 12.92 : ((C + 0.055) / 1.055) ** 2.4;
function fromXYZ$1(xyz) {
  const rgb = Array(3);
  const transform2 = srgbForwardTransform;
  const matrix = srgbForwardMatrix;
  for (let i2 = 0; i2 < 3; ++i2) {
    rgb[i2] = Math.round(clamp(transform2(matrix[i2][0] * xyz[0] + matrix[i2][1] * xyz[1] + matrix[i2][2] * xyz[2])) * 255);
  }
  return {
    r: rgb[0],
    g: rgb[1],
    b: rgb[2]
  };
}
function toXYZ$1(_ref) {
  let {
    r: r2,
    g,
    b: b3
  } = _ref;
  const xyz = [0, 0, 0];
  const transform2 = srgbReverseTransform;
  const matrix = srgbReverseMatrix;
  r2 = transform2(r2 / 255);
  g = transform2(g / 255);
  b3 = transform2(b3 / 255);
  for (let i2 = 0; i2 < 3; ++i2) {
    xyz[i2] = matrix[i2][0] * r2 + matrix[i2][1] * g + matrix[i2][2] * b3;
  }
  return xyz;
}
const delta = 0.20689655172413793;
const cielabForwardTransform = (t3) => t3 > delta ** 3 ? Math.cbrt(t3) : t3 / (3 * delta ** 2) + 4 / 29;
const cielabReverseTransform = (t3) => t3 > delta ? t3 ** 3 : 3 * delta ** 2 * (t3 - 4 / 29);
function fromXYZ(xyz) {
  const transform2 = cielabForwardTransform;
  const transformedY = transform2(xyz[1]);
  return [116 * transformedY - 16, 500 * (transform2(xyz[0] / 0.95047) - transformedY), 200 * (transformedY - transform2(xyz[2] / 1.08883))];
}
function toXYZ(lab) {
  const transform2 = cielabReverseTransform;
  const Ln = (lab[0] + 16) / 116;
  return [transform2(Ln + lab[1] / 500) * 0.95047, transform2(Ln), transform2(Ln - lab[2] / 200) * 1.08883];
}
function isCssColor(color) {
  return !!color && /^(#|var\(--|(rgb|hsl)a?\()/.test(color);
}
function parseColor(color) {
  if (typeof color === "number") {
    if (isNaN(color) || color < 0 || color > 16777215) {
      consoleWarn(`'${color}' is not a valid hex color`);
    }
    return {
      r: (color & 16711680) >> 16,
      g: (color & 65280) >> 8,
      b: color & 255
    };
  } else if (typeof color === "string") {
    let hex = color.startsWith("#") ? color.slice(1) : color;
    if ([3, 4].includes(hex.length)) {
      hex = hex.split("").map((char) => char + char).join("");
    } else if (![6, 8].includes(hex.length)) {
      consoleWarn(`'${color}' is not a valid hex(a) color`);
    }
    const int = parseInt(hex, 16);
    if (isNaN(int) || int < 0 || int > 4294967295) {
      consoleWarn(`'${color}' is not a valid hex(a) color`);
    }
    return HexToRGB(hex);
  } else {
    throw new TypeError(`Colors can only be numbers or strings, recieved ${color == null ? color : color.constructor.name} instead`);
  }
}
function toHex(v) {
  const h4 = Math.round(v).toString(16);
  return ("00".substr(0, 2 - h4.length) + h4).toUpperCase();
}
function RGBtoHex(_ref2) {
  let {
    r: r2,
    g,
    b: b3,
    a: a3
  } = _ref2;
  return `#${[toHex(r2), toHex(g), toHex(b3), a3 !== void 0 ? toHex(Math.round(a3 * 255)) : "FF"].join("")}`;
}
function HexToRGB(hex) {
  let [r2, g, b3, a3] = chunk(hex, 2).map((c2) => parseInt(c2, 16));
  a3 = a3 === void 0 ? a3 : Math.round(a3 / 255 * 100) / 100;
  return {
    r: r2,
    g,
    b: b3,
    a: a3
  };
}
function lighten(value, amount) {
  const lab = fromXYZ(toXYZ$1(value));
  lab[0] = lab[0] + amount * 10;
  return fromXYZ$1(toXYZ(lab));
}
function darken(value, amount) {
  const lab = fromXYZ(toXYZ$1(value));
  lab[0] = lab[0] - amount * 10;
  return fromXYZ$1(toXYZ(lab));
}
function getLuma(color) {
  const rgb = parseColor(color);
  return toXYZ$1(rgb)[1];
}
function getCurrentInstance(name2, message) {
  const vm = getCurrentInstance$1();
  if (!vm) {
    throw new Error(`[Vuetify] ${name2} ${message || "must be called from inside a setup function"}`);
  }
  return vm;
}
function getCurrentInstanceName() {
  let name2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "composables";
  const vm = getCurrentInstance(name2).type;
  return toKebabCase((vm == null ? void 0 : vm.aliasName) || (vm == null ? void 0 : vm.name));
}
let _uid = 0;
let _map = /* @__PURE__ */ new WeakMap();
function getUid() {
  const vm = getCurrentInstance("getUid");
  if (_map.has(vm))
    return _map.get(vm);
  else {
    const uid2 = _uid++;
    _map.set(vm, uid2);
    return uid2;
  }
}
getUid.reset = () => {
  _uid = 0;
  _map = /* @__PURE__ */ new WeakMap();
};
function injectSelf(key) {
  const {
    provides
  } = getCurrentInstance("injectSelf");
  if (provides && key in provides) {
    return provides[key];
  }
}
const DefaultsSymbol = Symbol.for("vuetify:defaults");
function createDefaults(options) {
  return ref(options);
}
function useDefaults() {
  const defaults2 = inject$1(DefaultsSymbol);
  if (!defaults2)
    throw new Error("[Vuetify] Could not find defaults instance");
  return defaults2;
}
function provideDefaults(defaults2, options) {
  const injectedDefaults = useDefaults();
  const providedDefaults = ref(defaults2);
  const newDefaults = computed(() => {
    const scoped = unref(options == null ? void 0 : options.scoped);
    const reset = unref(options == null ? void 0 : options.reset);
    const root = unref(options == null ? void 0 : options.root);
    let properties = mergeDeep(providedDefaults.value, {
      prev: injectedDefaults.value
    });
    if (scoped)
      return properties;
    if (reset || root) {
      const len = Number(reset || Infinity);
      for (let i2 = 0; i2 <= len; i2++) {
        if (!properties.prev)
          break;
        properties = properties.prev;
      }
      return properties;
    }
    return mergeDeep(properties.prev, properties);
  });
  provide(DefaultsSymbol, newDefaults);
  return newDefaults;
}
function useToggleScope(source, fn2) {
  let scope;
  function start() {
    scope = effectScope();
    scope.run(() => fn2.length ? fn2(() => {
      var _scope;
      (_scope = scope) == null ? void 0 : _scope.stop();
      start();
    }) : fn2());
  }
  watch(source, (active) => {
    if (active && !scope) {
      start();
    } else if (!active) {
      var _scope2;
      (_scope2 = scope) == null ? void 0 : _scope2.stop();
      scope = void 0;
    }
  }, {
    immediate: true
  });
  onScopeDispose(() => {
    var _scope3;
    (_scope3 = scope) == null ? void 0 : _scope3.stop();
  });
}
function propsFactory(props, source) {
  return (defaults2) => {
    return Object.keys(props).reduce((obj, prop) => {
      const isObjectDefinition = typeof props[prop] === "object" && props[prop] != null && !Array.isArray(props[prop]);
      const definition = isObjectDefinition ? props[prop] : {
        type: props[prop]
      };
      if (defaults2 && prop in defaults2) {
        obj[prop] = {
          ...definition,
          default: defaults2[prop]
        };
      } else {
        obj[prop] = definition;
      }
      if (source && !obj[prop].source) {
        obj[prop].source = source;
      }
      return obj;
    }, {});
  };
}
function propIsDefined(vnode, prop) {
  var _vnode$props, _vnode$props2;
  return typeof ((_vnode$props = vnode.props) == null ? void 0 : _vnode$props[prop]) !== "undefined" || typeof ((_vnode$props2 = vnode.props) == null ? void 0 : _vnode$props2[toKebabCase(prop)]) !== "undefined";
}
const defineComponent = function defineComponent2(options) {
  var _a2, _b;
  options._setup = (_a2 = options._setup) != null ? _a2 : options.setup;
  if (!options.name) {
    consoleWarn("The component is missing an explicit name, unable to generate default prop value");
    return options;
  }
  if (options._setup) {
    options.props = (_b = options.props) != null ? _b : {};
    options.props = propsFactory(options.props, toKebabCase(options.name))();
    options.props._as = String;
    options.setup = function setup(props, ctx) {
      const defaults2 = useDefaults();
      if (!defaults2.value)
        return options._setup(props, ctx);
      const vm = getCurrentInstance$1();
      const componentDefaults = computed(() => {
        var _a3;
        return defaults2.value[(_a3 = props._as) != null ? _a3 : options.name];
      });
      const _props = new Proxy(props, {
        get(target, prop) {
          var _a3, _b2;
          if (!propIsDefined(vm.vnode, prop)) {
            var _componentDefaults$va, _global2;
            return (_b2 = (_a3 = (_componentDefaults$va = componentDefaults.value) == null ? void 0 : _componentDefaults$va[prop]) != null ? _a3 : (_global2 = defaults2.value.global) == null ? void 0 : _global2[prop]) != null ? _b2 : target[prop];
          }
          return Reflect.get(target, prop);
        }
      });
      const _subcomponentDefaults = shallowRef();
      watchEffect(() => {
        if (componentDefaults.value) {
          const subComponents = Object.entries(componentDefaults.value).filter((_ref) => {
            let [key] = _ref;
            return key.startsWith(key[0].toUpperCase());
          });
          if (subComponents.length)
            _subcomponentDefaults.value = Object.fromEntries(subComponents);
        }
      });
      const setupBindings = options._setup(_props, ctx);
      useToggleScope(_subcomponentDefaults, () => {
        var _a3;
        var _injectSelf;
        provideDefaults(mergeDeep((_a3 = (_injectSelf = injectSelf(DefaultsSymbol)) == null ? void 0 : _injectSelf.value) != null ? _a3 : {}, _subcomponentDefaults.value));
      });
      return setupBindings;
    };
  }
  return options;
};
function genericComponent() {
  let exposeDefaults = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
  return (options) => (exposeDefaults ? defineComponent : defineComponent$1)(options);
}
function createSimpleFunctional(klass) {
  let tag = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "div";
  let name2 = arguments.length > 2 ? arguments[2] : void 0;
  return defineComponent({
    name: name2 != null ? name2 : capitalize(camelize(klass.replace(/__/g, "-"))),
    props: {
      tag: {
        type: String,
        default: tag
      }
    },
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      return () => {
        var _slots$default;
        return h(props.tag, {
          class: klass
        }, (_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots));
      };
    }
  });
}
function attachedRoot(node) {
  if (typeof node.getRootNode !== "function") {
    while (node.parentNode)
      node = node.parentNode;
    if (node !== document)
      return null;
    return document;
  }
  const root = node.getRootNode();
  if (root !== document && root.getRootNode({
    composed: true
  }) !== document)
    return null;
  return root;
}
const standardEasing = "cubic-bezier(0.4, 0, 0.2, 1)";
const deceleratedEasing = "cubic-bezier(0.0, 0, 0.2, 1)";
const acceleratedEasing = "cubic-bezier(0.4, 0, 1, 1)";
function getScrollParent(el2) {
  while (el2) {
    if (hasScrollbar(el2))
      return el2;
    el2 = el2.parentElement;
  }
  return document.scrollingElement;
}
function getScrollParents(el2, stopAt) {
  const elements = [];
  if (stopAt && el2 && !stopAt.contains(el2))
    return elements;
  while (el2) {
    if (hasScrollbar(el2))
      elements.push(el2);
    if (el2 === stopAt)
      break;
    el2 = el2.parentElement;
  }
  return elements;
}
function hasScrollbar(el2) {
  if (!el2 || el2.nodeType !== Node.ELEMENT_NODE)
    return false;
  const style = window.getComputedStyle(el2);
  return style.overflowY === "scroll" || style.overflowY === "auto" && el2.scrollHeight > el2.clientHeight;
}
function isFixedPosition(el2) {
  while (el2) {
    if (window.getComputedStyle(el2).position === "fixed") {
      return true;
    }
    el2 = el2.offsetParent;
  }
  return false;
}
function useRender(render) {
  const vm = getCurrentInstance("useRender");
  vm.render = render;
}
const VuetifyLayoutKey = Symbol.for("vuetify:layout");
const VuetifyLayoutItemKey = Symbol.for("vuetify:layout-item");
const ROOT_ZINDEX = 1e3;
const makeLayoutProps = propsFactory({
  overlaps: {
    type: Array,
    default: () => []
  },
  fullHeight: Boolean
}, "layout");
const generateLayers = (layout, positions, layoutSizes, activeItems) => {
  let previousLayer = {
    top: 0,
    left: 0,
    right: 0,
    bottom: 0
  };
  const layers = [{
    id: "",
    layer: {
      ...previousLayer
    }
  }];
  for (const id of layout) {
    const position = positions.get(id);
    const amount = layoutSizes.get(id);
    const active = activeItems.get(id);
    if (!position || !amount || !active)
      continue;
    const layer = {
      ...previousLayer,
      [position.value]: parseInt(previousLayer[position.value], 10) + (active.value ? parseInt(amount.value, 10) : 0)
    };
    layers.push({
      id,
      layer
    });
    previousLayer = layer;
  }
  return layers;
};
function createLayout(props) {
  const parentLayout = inject$1(VuetifyLayoutKey, null);
  const rootZIndex = computed(() => parentLayout ? parentLayout.rootZIndex.value - 100 : ROOT_ZINDEX);
  const registered = ref([]);
  const positions = reactive(/* @__PURE__ */ new Map());
  const layoutSizes = reactive(/* @__PURE__ */ new Map());
  const priorities = reactive(/* @__PURE__ */ new Map());
  const activeItems = reactive(/* @__PURE__ */ new Map());
  const disabledTransitions = reactive(/* @__PURE__ */ new Map());
  const {
    resizeRef,
    contentRect: layoutRect
  } = useResizeObserver();
  const computedOverlaps = computed(() => {
    var _a2;
    const map = /* @__PURE__ */ new Map();
    const overlaps = (_a2 = props.overlaps) != null ? _a2 : [];
    for (const overlap of overlaps.filter((item) => item.includes(":"))) {
      const [top, bottom] = overlap.split(":");
      if (!registered.value.includes(top) || !registered.value.includes(bottom))
        continue;
      const topPosition = positions.get(top);
      const bottomPosition = positions.get(bottom);
      const topAmount = layoutSizes.get(top);
      const bottomAmount = layoutSizes.get(bottom);
      if (!topPosition || !bottomPosition || !topAmount || !bottomAmount)
        continue;
      map.set(bottom, {
        position: topPosition.value,
        amount: parseInt(topAmount.value, 10)
      });
      map.set(top, {
        position: bottomPosition.value,
        amount: -parseInt(bottomAmount.value, 10)
      });
    }
    return map;
  });
  const layers = computed(() => {
    const uniquePriorities = [...new Set([...priorities.values()].map((p2) => p2.value))].sort((a3, b3) => a3 - b3);
    const layout = [];
    for (const p2 of uniquePriorities) {
      const items2 = registered.value.filter((id) => {
        var _priorities$get;
        return ((_priorities$get = priorities.get(id)) == null ? void 0 : _priorities$get.value) === p2;
      });
      layout.push(...items2);
    }
    return generateLayers(layout, positions, layoutSizes, activeItems);
  });
  const transitionsEnabled = computed(() => {
    return !Array.from(disabledTransitions.values()).some((ref2) => ref2.value);
  });
  const mainRect = computed(() => {
    return layers.value[layers.value.length - 1].layer;
  });
  const mainStyles = computed(() => {
    return {
      "--v-layout-left": convertToUnit(mainRect.value.left),
      "--v-layout-right": convertToUnit(mainRect.value.right),
      "--v-layout-top": convertToUnit(mainRect.value.top),
      "--v-layout-bottom": convertToUnit(mainRect.value.bottom),
      ...transitionsEnabled.value ? void 0 : {
        transition: "none"
      }
    };
  });
  const items = computed(() => {
    return layers.value.slice(1).map((_ref, index2) => {
      let {
        id
      } = _ref;
      const {
        layer
      } = layers.value[index2];
      const size2 = layoutSizes.get(id);
      const position = positions.get(id);
      return {
        id,
        ...layer,
        size: Number(size2.value),
        position: position.value
      };
    });
  });
  const getLayoutItem = (id) => {
    return items.value.find((item) => item.id === id);
  };
  const rootVm = getCurrentInstance("createLayout");
  const isMounted = ref(false);
  onMounted(() => {
    isMounted.value = true;
  });
  provide(VuetifyLayoutKey, {
    register: (vm, _ref2) => {
      let {
        id,
        order,
        position,
        layoutSize,
        elementSize,
        active,
        disableTransitions,
        absolute
      } = _ref2;
      priorities.set(id, order);
      positions.set(id, position);
      layoutSizes.set(id, layoutSize);
      activeItems.set(id, active);
      disableTransitions && disabledTransitions.set(id, disableTransitions);
      const instances = findChildrenWithProvide(VuetifyLayoutItemKey, rootVm == null ? void 0 : rootVm.vnode);
      const instanceIndex = instances.indexOf(vm);
      if (instanceIndex > -1)
        registered.value.splice(instanceIndex, 0, id);
      else
        registered.value.push(id);
      const index2 = computed(() => items.value.findIndex((i2) => i2.id === id));
      const zIndex = computed(() => rootZIndex.value + layers.value.length * 2 - index2.value * 2);
      const layoutItemStyles = computed(() => {
        const isHorizontal = position.value === "left" || position.value === "right";
        const isOppositeHorizontal = position.value === "right";
        const isOppositeVertical = position.value === "bottom";
        const styles = {
          [position.value]: 0,
          zIndex: zIndex.value,
          transform: `translate${isHorizontal ? "X" : "Y"}(${(active.value ? 0 : -110) * (isOppositeHorizontal || isOppositeVertical ? -1 : 1)}%)`,
          position: absolute.value || rootZIndex.value !== ROOT_ZINDEX ? "absolute" : "fixed",
          ...transitionsEnabled.value ? void 0 : {
            transition: "none"
          }
        };
        if (!isMounted.value)
          return styles;
        const item = items.value[index2.value];
        if (!item)
          throw new Error(`[Vuetify] Could not find layout item "${id}"`);
        const overlap = computedOverlaps.value.get(id);
        if (overlap) {
          item[overlap.position] += overlap.amount;
        }
        return {
          ...styles,
          height: isHorizontal ? `calc(100% - ${item.top}px - ${item.bottom}px)` : elementSize.value ? `${elementSize.value}px` : void 0,
          left: isOppositeHorizontal ? void 0 : `${item.left}px`,
          right: isOppositeHorizontal ? `${item.right}px` : void 0,
          top: position.value !== "bottom" ? `${item.top}px` : void 0,
          bottom: position.value !== "top" ? `${item.bottom}px` : void 0,
          width: !isHorizontal ? `calc(100% - ${item.left}px - ${item.right}px)` : elementSize.value ? `${elementSize.value}px` : void 0
        };
      });
      const layoutItemScrimStyles = computed(() => ({
        zIndex: zIndex.value - 1
      }));
      return {
        layoutItemStyles,
        layoutItemScrimStyles,
        zIndex
      };
    },
    unregister: (id) => {
      priorities.delete(id);
      positions.delete(id);
      layoutSizes.delete(id);
      activeItems.delete(id);
      disabledTransitions.delete(id);
      registered.value = registered.value.filter((v) => v !== id);
    },
    mainRect,
    mainStyles,
    getLayoutItem,
    items,
    layoutRect,
    rootZIndex
  });
  const layoutClasses = computed(() => ["v-layout", {
    "v-layout--full-height": props.fullHeight
  }]);
  const layoutStyles = computed(() => ({
    zIndex: rootZIndex.value,
    position: parentLayout ? "relative" : void 0,
    overflow: parentLayout ? "hidden" : void 0
  }));
  return {
    layoutClasses,
    layoutStyles,
    getLayoutItem,
    items,
    layoutRect,
    layoutRef: resizeRef
  };
}
const mainTRC = 2.4;
const Rco = 0.2126729;
const Gco = 0.7151522;
const Bco = 0.072175;
const normBG = 0.55;
const normTXT = 0.58;
const revTXT = 0.57;
const revBG = 0.62;
const blkThrs = 0.03;
const blkClmp = 1.45;
const deltaYmin = 5e-4;
const scaleBoW = 1.25;
const scaleWoB = 1.25;
const loConThresh = 0.078;
const loConFactor = 12.82051282051282;
const loConOffset = 0.06;
const loClip = 1e-3;
function APCAcontrast(text, background) {
  const Rtxt = (text.r / 255) ** mainTRC;
  const Gtxt = (text.g / 255) ** mainTRC;
  const Btxt = (text.b / 255) ** mainTRC;
  const Rbg = (background.r / 255) ** mainTRC;
  const Gbg = (background.g / 255) ** mainTRC;
  const Bbg = (background.b / 255) ** mainTRC;
  let Ytxt = Rtxt * Rco + Gtxt * Gco + Btxt * Bco;
  let Ybg = Rbg * Rco + Gbg * Gco + Bbg * Bco;
  if (Ytxt <= blkThrs)
    Ytxt += (blkThrs - Ytxt) ** blkClmp;
  if (Ybg <= blkThrs)
    Ybg += (blkThrs - Ybg) ** blkClmp;
  if (Math.abs(Ybg - Ytxt) < deltaYmin)
    return 0;
  let outputContrast;
  if (Ybg > Ytxt) {
    const SAPC = (Ybg ** normBG - Ytxt ** normTXT) * scaleBoW;
    outputContrast = SAPC < loClip ? 0 : SAPC < loConThresh ? SAPC - SAPC * loConFactor * loConOffset : SAPC - loConOffset;
  } else {
    const SAPC = (Ybg ** revBG - Ytxt ** revTXT) * scaleWoB;
    outputContrast = SAPC > -loClip ? 0 : SAPC > -loConThresh ? SAPC - SAPC * loConFactor * loConOffset : SAPC + loConOffset;
  }
  return outputContrast * 100;
}
const ThemeSymbol = Symbol.for("vuetify:theme");
const makeThemeProps = propsFactory({
  theme: String
}, "theme");
const defaultThemeOptions = {
  defaultTheme: "light",
  variations: {
    colors: [],
    lighten: 0,
    darken: 0
  },
  themes: {
    light: {
      dark: false,
      colors: {
        background: "#FFFFFF",
        surface: "#FFFFFF",
        "surface-variant": "#424242",
        "on-surface-variant": "#EEEEEE",
        primary: "#6200EE",
        "primary-darken-1": "#3700B3",
        secondary: "#03DAC6",
        "secondary-darken-1": "#018786",
        error: "#B00020",
        info: "#2196F3",
        success: "#4CAF50",
        warning: "#FB8C00"
      },
      variables: {
        "border-color": "#000000",
        "border-opacity": 0.12,
        "high-emphasis-opacity": 0.87,
        "medium-emphasis-opacity": 0.6,
        "disabled-opacity": 0.38,
        "idle-opacity": 0.04,
        "hover-opacity": 0.04,
        "focus-opacity": 0.12,
        "selected-opacity": 0.08,
        "activated-opacity": 0.12,
        "pressed-opacity": 0.12,
        "dragged-opacity": 0.08,
        "theme-kbd": "#212529",
        "theme-on-kbd": "#FFFFFF",
        "theme-code": "#F5F5F5",
        "theme-on-code": "#000000"
      }
    },
    dark: {
      dark: true,
      colors: {
        background: "#121212",
        surface: "#212121",
        "surface-variant": "#BDBDBD",
        "on-surface-variant": "#424242",
        primary: "#BB86FC",
        "primary-darken-1": "#3700B3",
        secondary: "#03DAC5",
        "secondary-darken-1": "#03DAC5",
        error: "#CF6679",
        info: "#2196F3",
        success: "#4CAF50",
        warning: "#FB8C00"
      },
      variables: {
        "border-color": "#FFFFFF",
        "border-opacity": 0.12,
        "high-emphasis-opacity": 0.87,
        "medium-emphasis-opacity": 0.6,
        "disabled-opacity": 0.38,
        "idle-opacity": 0.1,
        "hover-opacity": 0.04,
        "focus-opacity": 0.12,
        "selected-opacity": 0.08,
        "activated-opacity": 0.12,
        "pressed-opacity": 0.16,
        "dragged-opacity": 0.08,
        "theme-kbd": "#212529",
        "theme-on-kbd": "#FFFFFF",
        "theme-code": "#343434",
        "theme-on-code": "#CCCCCC"
      }
    }
  }
};
function parseThemeOptions() {
  var _a2;
  let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : defaultThemeOptions;
  if (!options)
    return {
      ...defaultThemeOptions,
      isDisabled: true
    };
  const themes = {};
  for (const [key, theme] of Object.entries((_a2 = options.themes) != null ? _a2 : {})) {
    var _defaultThemeOptions$, _defaultThemeOptions$2;
    const defaultTheme = theme.dark || key === "dark" ? (_defaultThemeOptions$ = defaultThemeOptions.themes) == null ? void 0 : _defaultThemeOptions$.dark : (_defaultThemeOptions$2 = defaultThemeOptions.themes) == null ? void 0 : _defaultThemeOptions$2.light;
    themes[key] = mergeDeep(defaultTheme, theme);
  }
  return mergeDeep(defaultThemeOptions, {
    ...options,
    themes
  });
}
function createTheme(options) {
  const parsedOptions = reactive(parseThemeOptions(options));
  const name2 = ref(parsedOptions.defaultTheme);
  const themes = ref(parsedOptions.themes);
  const computedThemes = computed(() => {
    const acc = {};
    for (const [name3, original] of Object.entries(themes.value)) {
      const theme = acc[name3] = {
        ...original,
        colors: {
          ...original.colors
        }
      };
      if (parsedOptions.variations) {
        for (const name4 of parsedOptions.variations.colors) {
          const color = theme.colors[name4];
          if (!color)
            continue;
          for (const variation of ["lighten", "darken"]) {
            const fn2 = variation === "lighten" ? lighten : darken;
            for (const amount of createRange(parsedOptions.variations[variation], 1)) {
              theme.colors[`${name4}-${variation}-${amount}`] = RGBtoHex(fn2(parseColor(color), amount));
            }
          }
        }
      }
      for (const color of Object.keys(theme.colors)) {
        if (/^on-[a-z]/.test(color) || theme.colors[`on-${color}`])
          continue;
        const onColor = `on-${color}`;
        const colorVal = parseColor(theme.colors[color]);
        const blackContrast = Math.abs(APCAcontrast(parseColor(0), colorVal));
        const whiteContrast = Math.abs(APCAcontrast(parseColor(16777215), colorVal));
        theme.colors[onColor] = whiteContrast > Math.min(blackContrast, 50) ? "#fff" : "#000";
      }
    }
    return acc;
  });
  const current = computed(() => computedThemes.value[name2.value]);
  const styles = computed(() => {
    const lines = [];
    if (current.value.dark) {
      createCssClass(lines, ":root", ["color-scheme: dark"]);
    }
    for (const [themeName, theme] of Object.entries(computedThemes.value)) {
      const {
        variables,
        dark
      } = theme;
      createCssClass(lines, `.v-theme--${themeName}`, [`color-scheme: ${dark ? "dark" : "normal"}`, ...genCssVariables(theme), ...Object.keys(variables).map((key) => {
        const value = variables[key];
        const color = typeof value === "string" && value.startsWith("#") ? parseColor(value) : void 0;
        const rgb = color ? `${color.r}, ${color.g}, ${color.b}` : void 0;
        return `--v-${key}: ${rgb != null ? rgb : value}`;
      })]);
    }
    const bgLines = [];
    const fgLines = [];
    const colors = new Set(Object.values(computedThemes.value).flatMap((theme) => Object.keys(theme.colors)));
    for (const key of colors) {
      if (/^on-[a-z]/.test(key)) {
        createCssClass(fgLines, `.${key}`, [`color: rgb(var(--v-theme-${key})) !important`]);
      } else {
        createCssClass(bgLines, `.bg-${key}`, [`--v-theme-overlay-multiplier: var(--v-theme-${key}-overlay-multiplier)`, `background: rgb(var(--v-theme-${key})) !important`, `color: rgb(var(--v-theme-on-${key})) !important`]);
        createCssClass(fgLines, `.text-${key}`, [`color: rgb(var(--v-theme-${key})) !important`]);
        createCssClass(fgLines, `.border-${key}`, [`--v-border-color: var(--v-theme-${key})`]);
      }
    }
    lines.push(...bgLines, ...fgLines);
    return lines.map((str, i2) => i2 === 0 ? str : `    ${str}`).join("");
  });
  function install2(app2) {
    const head = app2._context.provides.usehead;
    if (head) {
      head.addHeadObjs(computed(() => {
        const style = {
          children: styles.value,
          type: "text/css",
          id: "vuetify-theme-stylesheet"
        };
        if (parsedOptions.cspNonce)
          style.nonce = parsedOptions.cspNonce;
        return {
          style: [style]
        };
      }));
      if (IN_BROWSER) {
        watchEffect(() => head.updateDOM());
      }
    } else {
      let updateStyles = function() {
        if (parsedOptions.isDisabled)
          return;
        if (typeof document !== "undefined" && !styleEl) {
          const el2 = document.createElement("style");
          el2.type = "text/css";
          el2.id = "vuetify-theme-stylesheet";
          if (parsedOptions.cspNonce)
            el2.setAttribute("nonce", parsedOptions.cspNonce);
          styleEl = el2;
          document.head.appendChild(styleEl);
        }
        if (styleEl)
          styleEl.innerHTML = styles.value;
      };
      let styleEl = IN_BROWSER ? document.getElementById("vuetify-theme-stylesheet") : null;
      watch(styles, updateStyles, {
        immediate: true
      });
    }
  }
  const themeClasses = computed(() => parsedOptions.isDisabled ? void 0 : `v-theme--${name2.value}`);
  return {
    install: install2,
    isDisabled: parsedOptions.isDisabled,
    name: name2,
    themes,
    current,
    computedThemes,
    themeClasses,
    styles,
    global: {
      name: name2,
      current
    }
  };
}
function provideTheme(props) {
  getCurrentInstance("provideTheme");
  const theme = inject$1(ThemeSymbol, null);
  if (!theme)
    throw new Error("Could not find Vuetify theme injection");
  const name2 = computed(() => {
    var _a2;
    return (_a2 = props.theme) != null ? _a2 : theme == null ? void 0 : theme.name.value;
  });
  const themeClasses = computed(() => theme.isDisabled ? void 0 : `v-theme--${name2.value}`);
  const newTheme = {
    ...theme,
    name: name2,
    themeClasses
  };
  provide(ThemeSymbol, newTheme);
  return newTheme;
}
function createCssClass(lines, selector, content) {
  lines.push(`${selector} {
`, ...content.map((line) => `  ${line};
`), "}\n");
}
function genCssVariables(theme) {
  const lightOverlay = theme.dark ? 2 : 1;
  const darkOverlay = theme.dark ? 1 : 2;
  const variables = [];
  for (const [key, value] of Object.entries(theme.colors)) {
    const rgb = parseColor(value);
    variables.push(`--v-theme-${key}: ${rgb.r},${rgb.g},${rgb.b}`);
    if (!key.startsWith("on-")) {
      variables.push(`--v-theme-${key}-overlay-multiplier: ${getLuma(value) > 0.18 ? lightOverlay : darkOverlay}`);
    }
  }
  return variables;
}
function useProxiedModel(props, prop, defaultValue) {
  let transformIn = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : (v) => v;
  let transformOut = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : (v) => v;
  const vm = getCurrentInstance("useProxiedModel");
  const internal = ref(props[prop] !== void 0 ? props[prop] : defaultValue);
  const kebabProp = toKebabCase(prop);
  const checkKebab = kebabProp !== prop;
  const isControlled = checkKebab ? computed(() => {
    var _vm$vnode$props, _vm$vnode$props2, _vm$vnode$props3, _vm$vnode$props4;
    void props[prop];
    return !!(((_vm$vnode$props = vm.vnode.props) != null && _vm$vnode$props.hasOwnProperty(prop) || (_vm$vnode$props2 = vm.vnode.props) != null && _vm$vnode$props2.hasOwnProperty(kebabProp)) && ((_vm$vnode$props3 = vm.vnode.props) != null && _vm$vnode$props3.hasOwnProperty(`onUpdate:${prop}`) || (_vm$vnode$props4 = vm.vnode.props) != null && _vm$vnode$props4.hasOwnProperty(`onUpdate:${kebabProp}`)));
  }) : computed(() => {
    var _vm$vnode$props5, _vm$vnode$props6;
    void props[prop];
    return !!((_vm$vnode$props5 = vm.vnode.props) != null && _vm$vnode$props5.hasOwnProperty(prop) && (_vm$vnode$props6 = vm.vnode.props) != null && _vm$vnode$props6.hasOwnProperty(`onUpdate:${prop}`));
  });
  useToggleScope(() => !isControlled.value, () => {
    watch(() => props[prop], (val) => {
      internal.value = val;
    });
  });
  const model = computed({
    get() {
      return transformIn(isControlled.value ? props[prop] : internal.value);
    },
    set(value) {
      const newValue = transformOut(value);
      if ((isControlled.value ? props[prop] : internal.value) === newValue || transformIn(isControlled.value ? props[prop] : internal.value) === value) {
        return;
      }
      internal.value = newValue;
      vm == null ? void 0 : vm.emit(`update:${prop}`, newValue);
    }
  });
  Object.defineProperty(model, "externalValue", {
    get: () => isControlled.value ? props[prop] : internal.value
  });
  return model;
}
const en$1 = {
  badge: "Badge",
  close: "Close",
  dataIterator: {
    noResultsText: "No matching records found",
    loadingText: "Loading items..."
  },
  dataTable: {
    itemsPerPageText: "Rows per page:",
    ariaLabel: {
      sortDescending: "Sorted descending.",
      sortAscending: "Sorted ascending.",
      sortNone: "Not sorted.",
      activateNone: "Activate to remove sorting.",
      activateDescending: "Activate to sort descending.",
      activateAscending: "Activate to sort ascending."
    },
    sortBy: "Sort by"
  },
  dataFooter: {
    itemsPerPageText: "Items per page:",
    itemsPerPageAll: "All",
    nextPage: "Next page",
    prevPage: "Previous page",
    firstPage: "First page",
    lastPage: "Last page",
    pageText: "{0}-{1} of {2}"
  },
  datePicker: {
    itemsSelected: "{0} selected",
    nextMonthAriaLabel: "Next month",
    nextYearAriaLabel: "Next year",
    prevMonthAriaLabel: "Previous month",
    prevYearAriaLabel: "Previous year"
  },
  noDataText: "No data available",
  carousel: {
    prev: "Previous visual",
    next: "Next visual",
    ariaLabel: {
      delimiter: "Carousel slide {0} of {1}"
    }
  },
  calendar: {
    moreEvents: "{0} more"
  },
  input: {
    clear: "Clear {0}",
    prependAction: "{0} prepended action",
    appendAction: "{0} appended action"
  },
  fileInput: {
    counter: "{0} files",
    counterSize: "{0} files ({1} in total)"
  },
  timePicker: {
    am: "AM",
    pm: "PM"
  },
  pagination: {
    ariaLabel: {
      root: "Pagination Navigation",
      next: "Next page",
      previous: "Previous page",
      page: "Go to page {0}",
      currentPage: "Page {0}, Current page",
      first: "First page",
      last: "Last page"
    }
  },
  rating: {
    ariaLabel: {
      item: "Rating {0} of {1}"
    }
  }
};
const LANG_PREFIX = "$vuetify.";
const replace = (str, params) => {
  return str.replace(/\{(\d+)\}/g, (match2, index2) => {
    return String(params[+index2]);
  });
};
const createTranslateFunction = (current, fallback, messages) => {
  return function(key) {
    for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      params[_key - 1] = arguments[_key];
    }
    if (!key.startsWith(LANG_PREFIX)) {
      return replace(key, params);
    }
    const shortKey = key.replace(LANG_PREFIX, "");
    const currentLocale = current.value && messages.value[current.value];
    const fallbackLocale = fallback.value && messages.value[fallback.value];
    let str = getObjectValueByPath(currentLocale, shortKey, null);
    if (!str) {
      consoleWarn(`Translation key "${key}" not found in "${current.value}", trying fallback locale`);
      str = getObjectValueByPath(fallbackLocale, shortKey, null);
    }
    if (!str) {
      consoleError(`Translation key "${key}" not found in fallback`);
      str = key;
    }
    if (typeof str !== "string") {
      consoleError(`Translation key "${key}" has a non-string value`);
      str = key;
    }
    return replace(str, params);
  };
};
function createNumberFunction(current, fallback) {
  return (value, options) => {
    const numberFormat = new Intl.NumberFormat([current.value, fallback.value], options);
    return numberFormat.format(value);
  };
}
function useProvided(props, prop, provided) {
  var _a2, _b;
  const internal = useProxiedModel(props, prop, (_a2 = props[prop]) != null ? _a2 : provided.value);
  internal.value = (_b = props[prop]) != null ? _b : provided.value;
  watch(provided, (v) => {
    if (props[prop] == null) {
      internal.value = provided.value;
    }
  });
  return internal;
}
function createProvideFunction(state) {
  return (props) => {
    const current = useProvided(props, "locale", state.current);
    const fallback = useProvided(props, "fallback", state.fallback);
    const messages = useProvided(props, "messages", state.messages);
    return {
      name: "vuetify",
      current,
      fallback,
      messages,
      t: createTranslateFunction(current, fallback, messages),
      n: createNumberFunction(current, fallback),
      provide: createProvideFunction({
        current,
        fallback,
        messages
      })
    };
  };
}
function createVuetifyAdapter(options) {
  var _a2, _b;
  const current = ref((_a2 = options == null ? void 0 : options.locale) != null ? _a2 : "en");
  const fallback = ref((_b = options == null ? void 0 : options.fallback) != null ? _b : "en");
  const messages = ref({
    en: en$1,
    ...options == null ? void 0 : options.messages
  });
  return {
    name: "vuetify",
    current,
    fallback,
    messages,
    t: createTranslateFunction(current, fallback, messages),
    n: createNumberFunction(current, fallback),
    provide: createProvideFunction({
      current,
      fallback,
      messages
    })
  };
}
const defaultRtl = {
  af: false,
  ar: true,
  bg: false,
  ca: false,
  ckb: false,
  cs: false,
  de: false,
  el: false,
  en: false,
  es: false,
  et: false,
  fa: false,
  fi: false,
  fr: false,
  hr: false,
  hu: false,
  he: true,
  id: false,
  it: false,
  ja: false,
  ko: false,
  lv: false,
  lt: false,
  nl: false,
  no: false,
  pl: false,
  pt: false,
  ro: false,
  ru: false,
  sk: false,
  sl: false,
  srCyrl: false,
  srLatn: false,
  sv: false,
  th: false,
  tr: false,
  az: false,
  uk: false,
  vi: false,
  zhHans: false,
  zhHant: false
};
const LocaleSymbol = Symbol.for("vuetify:locale");
function isLocaleInstance(obj) {
  return obj.name != null;
}
function createLocale(options) {
  const i18n = options != null && options.adapter && isLocaleInstance(options == null ? void 0 : options.adapter) ? options == null ? void 0 : options.adapter : createVuetifyAdapter(options);
  const rtl = createRtl(i18n, options);
  return {
    ...i18n,
    ...rtl
  };
}
function useLocale() {
  const locale2 = inject$1(LocaleSymbol);
  if (!locale2)
    throw new Error("[Vuetify] Could not find injected locale instance");
  return locale2;
}
function createRtl(i18n, options) {
  var _a2;
  const rtl = ref((_a2 = options == null ? void 0 : options.rtl) != null ? _a2 : defaultRtl);
  const isRtl = computed(() => {
    var _a3;
    return (_a3 = rtl.value[i18n.current.value]) != null ? _a3 : false;
  });
  return {
    isRtl,
    rtl,
    rtlClasses: computed(() => `v-locale--is-${isRtl.value ? "rtl" : "ltr"}`)
  };
}
function useRtl() {
  const locale2 = inject$1(LocaleSymbol);
  if (!locale2)
    throw new Error("[Vuetify] Could not find injected rtl instance");
  return {
    isRtl: locale2.isRtl,
    rtlClasses: locale2.rtlClasses
  };
}
const VApp = defineComponent({
  name: "VApp",
  props: {
    ...makeLayoutProps({
      fullHeight: true
    }),
    ...makeThemeProps()
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const theme = provideTheme(props);
    const {
      layoutClasses,
      layoutStyles,
      getLayoutItem,
      items,
      layoutRef
    } = createLayout(props);
    const {
      rtlClasses
    } = useRtl();
    useRender(() => {
      var _slots$default;
      return createVNode("div", {
        "ref": layoutRef,
        "class": ["v-application", theme.themeClasses.value, layoutClasses.value, rtlClasses.value],
        "style": layoutStyles.value
      }, [createVNode("div", {
        "class": "v-application__wrap"
      }, [(_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots)])]);
    });
    return {
      getLayoutItem,
      items,
      theme
    };
  }
});
const DESKTOP_SCREEN_MIN_WIDTH_PIXELS = 1440;
const FAQS_URL = "https://xebiagroup.sharepoint.com/sites/ProjectKearney/Gedeelde%20documenten/Forms/AllItems.aspx?id=%2Fsites%2FProjectKearney%2FGedeelde%20documenten%2FGeneral%2FContent%2FKearney%5FMS%20Demand%20Dashboard%20FAQ%2Epdf&parent=%2Fsites%2FProjectKearney%2FGedeelde%20documenten%2FGeneral%2FContent&p=true&ct=1684174121283&or=OWA%2DNT&cid=1b364130%2Dcec9%2D447e%2D6e14%2D746cabb41467&ga=1";
const _sfc_main$p = {
  name: "TheSckeleton",
  components: {
    SideBar,
    TheHeader
  },
  props: {
    orgLogo: {
      type: String,
      required: true
    },
    orgLogoSmall: {
      type: String,
      required: true
    },
    userdata: {
      type: Object,
      required: false
    },
    PAGES_CONFIG: { type: Object, required: true },
    PAGE_KEYS: { type: Object, required: true }
  },
  data() {
    return {
      activePageKey: this.PAGE_KEYS.DEMAND_PLANNER,
      isSidebarCollapsed: false
    };
  },
  computed: {
    ActiveComponent() {
      return this.PAGES_CONFIG[this.activePageKey].component;
    }
  },
  methods: {
    pageSelectionHandler(key) {
      if (key === this.PAGE_KEYS.FAQS) {
        window.open(FAQS_URL, "_blank");
        return;
      }
      this.activePageKey = key;
      sessionStorage.setItem("pageKey", key);
    },
    expandSidebarHandler() {
      if (window.screen.availWidth < DESKTOP_SCREEN_MIN_WIDTH_PIXELS) {
        const sidebar = document.querySelector(".sidebar");
        sidebar.style.minWidth = "13rem";
        sidebar.style.maxWidth = "10%";
        sidebar.style["z-index"] = 9999;
        this.isSidebarCollapsed = false;
      }
    },
    collapseSidebarHandler() {
      if (window.screen.availWidth < DESKTOP_SCREEN_MIN_WIDTH_PIXELS) {
        const sidebar = document.querySelector(".sidebar");
        sidebar.style.minWidth = "0px";
        sidebar.style.maxWidth = "48px";
        sidebar.style["z-index"] = 0;
        this.isSidebarCollapsed = true;
      }
    }
  },
  created() {
    const currentPageKey = sessionStorage.getItem("pageKey");
    if (_.includes(this.PAGE_KEYS, currentPageKey)) {
      this.activePageKey = currentPageKey;
    } else {
      this.activePageKey = this.PAGE_KEYS.DEMAND_PLANNER;
      sessionStorage.setItem("pageKey", this.activePageKey);
    }
  },
  mounted() {
    if (window.screen.availWidth < DESKTOP_SCREEN_MIN_WIDTH_PIXELS) {
      this.isSidebarCollapsed = true;
    } else {
      this.isSidebarCollapsed = false;
    }
    const resizeObserver = new ResizeObserver(() => {
      if (window.screen.availWidth < DESKTOP_SCREEN_MIN_WIDTH_PIXELS) {
        this.collapseSidebarHandler();
      } else {
        const sidebar = document.querySelector(".sidebar");
        sidebar.style.minWidth = "13rem";
        sidebar.style.maxWidth = "10%";
        this.isSidebarCollapsed = false;
      }
    });
    resizeObserver.observe(document.querySelector(".screen"));
  }
};
const _withScopeId$1 = (n2) => (pushScopeId("data-v-262fcb2f"), n2 = n2(), popScopeId(), n2);
const _hoisted_1$m = { class: "screen" };
const _hoisted_2$k = { class: "main-area" };
const _hoisted_3$k = { class: "control-container" };
const _hoisted_4$k = { class: "control-section" };
const _hoisted_5$h = { class: "content-container" };
const _hoisted_6$g = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createBaseVNode("div", { class: "tw-px-5 tw-bg-brand-gray-1" }, [
  /* @__PURE__ */ createBaseVNode("footer", { class: "tw-w-full tw-flex tw-p-4 tw-border-t tw-border-solid tw-border-brand-gray-2" }, [
    /* @__PURE__ */ createBaseVNode("div", { class: "tw-ml-auto tw-flex tw-items-center" }, " Copyright @ Kearney 2023 ")
  ])
], -1));
function _sfc_render$p(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_SideBar = resolveComponent("SideBar");
  const _component_TheHeader = resolveComponent("TheHeader");
  return openBlock(), createBlock(VApp, null, {
    default: withCtx(() => [
      createBaseVNode("div", _hoisted_1$m, [
        createBaseVNode("div", {
          class: "sidebar",
          onMouseover: _cache[0] || (_cache[0] = (...args) => $options.expandSidebarHandler && $options.expandSidebarHandler(...args)),
          onMouseout: _cache[1] || (_cache[1] = (...args) => $options.collapseSidebarHandler && $options.collapseSidebarHandler(...args))
        }, [
          createVNode(_component_SideBar, {
            "org-logo": $data.isSidebarCollapsed ? $props.orgLogoSmall : $props.orgLogo,
            isSidebarCollapsed: $data.isSidebarCollapsed,
            PAGES_CONFIG: $props.PAGES_CONFIG,
            PAGE_KEYS: $props.PAGE_KEYS,
            activePageKey: $data.activePageKey,
            onPageSelected: $options.pageSelectionHandler
          }, null, 8, ["org-logo", "isSidebarCollapsed", "PAGES_CONFIG", "PAGE_KEYS", "activePageKey", "onPageSelected"])
        ], 32),
        createBaseVNode("div", _hoisted_2$k, [
          createBaseVNode("div", _hoisted_3$k, [
            createBaseVNode("div", _hoisted_4$k, [
              createVNode(_component_TheHeader, { userdata: $props.userdata }, null, 8, ["userdata"])
            ])
          ]),
          createBaseVNode("div", _hoisted_5$h, [
            (openBlock(), createBlock(resolveDynamicComponent($options.ActiveComponent), normalizeProps(guardReactiveProps({ userdata: $props.userdata })), null, 16))
          ]),
          _hoisted_6$g
        ])
      ])
    ]),
    _: 1
  });
}
const TheSckeleton = /* @__PURE__ */ _export_sfc(_sfc_main$p, [["render", _sfc_render$p], ["__scopeId", "data-v-262fcb2f"]]);
const KearneyHomeLogo = "/assets/kearneyHomeLogo.844c6fa2.png";
const kearneyInfographicImage = "/assets/kearneyInfographic.040bba2c.png";
const _sfc_main$o = {
  name: "LoginButton",
  props: {
    label: {
      type: String,
      required: true
    },
    type: {
      type: String,
      default: "primary",
      required: false,
      validator(value) {
        const acceptedValues = ["primary", "secondary"];
        return acceptedValues.indexOf(value) >= 0;
      }
    }
  }
};
function _sfc_render$o(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("button", {
    class: normalizeClass(`tw-px-4 tw-py-2 tw-text-white ${$props.type === "primary" ? "tw-bg-brand-primary" : ""}`)
  }, toDisplayString($props.label), 3);
}
const LoginButton = /* @__PURE__ */ _export_sfc(_sfc_main$o, [["render", _sfc_render$o]]);
const LoginPage_vue_vue_type_style_index_0_scoped_992a43da_lang = "";
const _sfc_main$n = {
  name: "LoginPage",
  components: {
    LoginButton
  },
  data() {
    return {
      KearneyHomeLogo,
      kearneyInfographicImage
    };
  },
  methods: {
    handleLoginIn() {
      doFederatedSignIn();
    }
  }
};
const _withScopeId = (n2) => (pushScopeId("data-v-992a43da"), n2 = n2(), popScopeId(), n2);
const _hoisted_1$l = { class: "tw-flex tw-h-screen tw-flex-col" };
const _hoisted_2$j = { class: "tw-grid tw-grid-cols-12 tw-my-auto" };
const _hoisted_3$j = { class: "tw-col-span-6 tw-col-start-1 tw-self-center tw-justify-self-center" };
const _hoisted_4$j = ["src"];
const _hoisted_5$g = { class: "tw-col-span-6 tw-col-start-7 tw-px-20 desktop:tw-px-10 small-laptop:tw-px-10" };
const _hoisted_6$f = { class: "tw-flex tw-flex-col tw-justify-center tw-h-full" };
const _hoisted_7$e = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("h1", { class: "tw-text-4xl desktop:tw-text-3xl small-laptop:tw-text-xl tw-text-black tw-font-medium" }, " Kearney\u2019s Sensing Solution ", -1));
const _hoisted_8$e = { class: "tw-py-6 desktop:tw-py-2 small-laptop:tw-py-1" };
const _hoisted_9$e = ["src"];
const _hoisted_10$c = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("p", { class: "tw-text-lg desktop:tw-text-base small-laptop:tw-text-sm tw-text-black tw-break-words" }, " Demand Dashboard uses rigorous analytics to project demand growth and compare against internal forecasts. The goal is to help users identify \u201Ctriggers\u201D to review projection calibration. ", -1));
const _hoisted_11$b = { class: "tw-pt-8 small-laptop:tw-pt-5 small-laptop:tw-pb-2" };
const _hoisted_12$9 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("div", { class: "tw-px-5" }, [
  /* @__PURE__ */ createBaseVNode("footer", { class: "tw-w-full tw-flex tw-p-4 tw-border-t tw-border-solid tw-border-brand-gray-2" }, [
    /* @__PURE__ */ createBaseVNode("div", { class: "tw-ml-auto tw-flex tw-items-center" }, " Copyright @ Kearney 2023 ")
  ])
], -1));
function _sfc_render$n(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_LoginButton = resolveComponent("LoginButton");
  return openBlock(), createElementBlock("section", _hoisted_1$l, [
    createBaseVNode("div", _hoisted_2$j, [
      createBaseVNode("div", _hoisted_3$j, [
        createBaseVNode("img", {
          class: "kearney-home-logo",
          src: $data.KearneyHomeLogo
        }, null, 8, _hoisted_4$j)
      ]),
      createBaseVNode("div", _hoisted_5$g, [
        createBaseVNode("div", _hoisted_6$f, [
          _hoisted_7$e,
          createBaseVNode("div", _hoisted_8$e, [
            createBaseVNode("img", {
              class: "kearney-infographic-image",
              src: $data.kearneyInfographicImage
            }, null, 8, _hoisted_9$e)
          ]),
          _hoisted_10$c,
          createBaseVNode("div", _hoisted_11$b, [
            createVNode(_component_LoginButton, {
              label: "Proceed to Sign In",
              type: "primary",
              onClick: $options.handleLoginIn
            }, null, 8, ["onClick"])
          ])
        ])
      ])
    ]),
    _hoisted_12$9
  ]);
}
const LoginPage = /* @__PURE__ */ _export_sfc(_sfc_main$n, [["render", _sfc_render$n], ["__scopeId", "data-v-992a43da"]]);
const _sfc_main$m = {
  name: "App",
  components: {
    LoginPage,
    TheSckeleton
  },
  props: {
    idpConfig: {
      type: Object,
      required: true
    },
    OrgLogo: {
      type: String,
      required: true
    },
    OrgLogoSmall: {
      type: String,
      required: true
    },
    PAGES_CONFIG: { type: Object, required: true },
    PAGE_KEYS: { type: Object, required: true }
  },
  data() {
    return {
      isLoggedIn: false,
      loading: true,
      loggedInUserData: {}
    };
  },
  created() {
    setIdpData(this.idpConfig);
  },
  async mounted() {
    const { token, userPoolId } = await getAuthDetails();
    this.userHasAuthenticated(!!token, token, userPoolId);
  },
  methods: {
    userHasAuthenticated(autheticated, token, usrPoolId) {
      var _a2;
      this.isLoggedIn = autheticated;
      this.loading = false;
      if (autheticated) {
        this.loggedInUserData.token = token;
        this.loggedInUserData.userPoolId = usrPoolId;
        const jwtDecoded = o(token);
        this.loggedInUserData.deocdedJWT = jwtDecoded;
        this.loggedInUserData.isAdmin = _.filter(
          _.get(jwtDecoded, "['cognito:groups']", []),
          (v) => v === "admin"
        ).length > 0;
        this.loggedInUserData.userName = (_a2 = _.get(jwtDecoded, "name", null)) != null ? _a2 : _.get(jwtDecoded, "email", "---");
      } else {
        this.loggedInUserData.token = null;
        this.loggedInUserData.userPoolId = null;
      }
    }
  }
};
function _sfc_render$m(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_LoginPage = resolveComponent("LoginPage");
  const _component_TheSckeleton = resolveComponent("TheSckeleton");
  return openBlock(), createElementBlock(Fragment, null, [
    !$data.isLoggedIn && !$data.loading ? (openBlock(), createBlock(_component_LoginPage, { key: 0 })) : createCommentVNode("", true),
    $data.isLoggedIn && !$data.loading ? (openBlock(), createBlock(_component_TheSckeleton, {
      key: 1,
      "org-logo": $props.OrgLogo,
      "org-logo-small": $props.OrgLogoSmall,
      userdata: this.loggedInUserData,
      PAGES_CONFIG: $props.PAGES_CONFIG,
      PAGE_KEYS: $props.PAGE_KEYS
    }, null, 8, ["org-logo", "org-logo-small", "userdata", "PAGES_CONFIG", "PAGE_KEYS"])) : createCommentVNode("", true)
  ], 64);
}
const App = /* @__PURE__ */ _export_sfc(_sfc_main$m, [["render", _sfc_render$m]]);
function toInteger(dirtyNumber) {
  if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {
    return NaN;
  }
  var number = Number(dirtyNumber);
  if (isNaN(number)) {
    return number;
  }
  return number < 0 ? Math.ceil(number) : Math.floor(number);
}
function requiredArgs(required, args) {
  if (args.length < required) {
    throw new TypeError(required + " argument" + (required > 1 ? "s" : "") + " required, but only " + args.length + " present");
  }
}
function _typeof$B(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$B = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$B = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$B(obj);
}
function toDate(argument) {
  requiredArgs(1, arguments);
  var argStr = Object.prototype.toString.call(argument);
  if (argument instanceof Date || _typeof$B(argument) === "object" && argStr === "[object Date]") {
    return new Date(argument.getTime());
  } else if (typeof argument === "number" || argStr === "[object Number]") {
    return new Date(argument);
  } else {
    if ((typeof argument === "string" || argStr === "[object String]") && typeof console !== "undefined") {
      console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#string-arguments");
      console.warn(new Error().stack);
    }
    return new Date(NaN);
  }
}
function addDays(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var amount = toInteger(dirtyAmount);
  if (isNaN(amount)) {
    return new Date(NaN);
  }
  if (!amount) {
    return date;
  }
  date.setDate(date.getDate() + amount);
  return date;
}
function addMonths(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var amount = toInteger(dirtyAmount);
  if (isNaN(amount)) {
    return new Date(NaN);
  }
  if (!amount) {
    return date;
  }
  var dayOfMonth = date.getDate();
  var endOfDesiredMonth = new Date(date.getTime());
  endOfDesiredMonth.setMonth(date.getMonth() + amount + 1, 0);
  var daysInMonth = endOfDesiredMonth.getDate();
  if (dayOfMonth >= daysInMonth) {
    return endOfDesiredMonth;
  } else {
    date.setFullYear(endOfDesiredMonth.getFullYear(), endOfDesiredMonth.getMonth(), dayOfMonth);
    return date;
  }
}
function _typeof$A(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$A = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$A = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$A(obj);
}
function add(dirtyDate, duration) {
  requiredArgs(2, arguments);
  if (!duration || _typeof$A(duration) !== "object")
    return new Date(NaN);
  var years = duration.years ? toInteger(duration.years) : 0;
  var months = duration.months ? toInteger(duration.months) : 0;
  var weeks = duration.weeks ? toInteger(duration.weeks) : 0;
  var days = duration.days ? toInteger(duration.days) : 0;
  var hours = duration.hours ? toInteger(duration.hours) : 0;
  var minutes = duration.minutes ? toInteger(duration.minutes) : 0;
  var seconds = duration.seconds ? toInteger(duration.seconds) : 0;
  var date = toDate(dirtyDate);
  var dateWithMonths = months || years ? addMonths(date, months + years * 12) : date;
  var dateWithDays = days || weeks ? addDays(dateWithMonths, days + weeks * 7) : dateWithMonths;
  var minutesToAdd = minutes + hours * 60;
  var secondsToAdd = seconds + minutesToAdd * 60;
  var msToAdd = secondsToAdd * 1e3;
  var finalDate = new Date(dateWithDays.getTime() + msToAdd);
  return finalDate;
}
function addMilliseconds(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var timestamp = toDate(dirtyDate).getTime();
  var amount = toInteger(dirtyAmount);
  return new Date(timestamp + amount);
}
var defaultOptions = {};
function getDefaultOptions() {
  return defaultOptions;
}
function startOfWeek(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var defaultOptions2 = getDefaultOptions();
  var weekStartsOn = toInteger((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  var date = toDate(dirtyDate);
  var day = date.getDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setDate(date.getDate() - diff);
  date.setHours(0, 0, 0, 0);
  return date;
}
function startOfISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  return startOfWeek(dirtyDate, {
    weekStartsOn: 1
  });
}
function getISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getFullYear();
  var fourthOfJanuaryOfNextYear = new Date(0);
  fourthOfJanuaryOfNextYear.setFullYear(year + 1, 0, 4);
  fourthOfJanuaryOfNextYear.setHours(0, 0, 0, 0);
  var startOfNextYear = startOfISOWeek(fourthOfJanuaryOfNextYear);
  var fourthOfJanuaryOfThisYear = new Date(0);
  fourthOfJanuaryOfThisYear.setFullYear(year, 0, 4);
  fourthOfJanuaryOfThisYear.setHours(0, 0, 0, 0);
  var startOfThisYear = startOfISOWeek(fourthOfJanuaryOfThisYear);
  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}
function startOfISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var year = getISOWeekYear(dirtyDate);
  var fourthOfJanuary = new Date(0);
  fourthOfJanuary.setFullYear(year, 0, 4);
  fourthOfJanuary.setHours(0, 0, 0, 0);
  var date = startOfISOWeek(fourthOfJanuary);
  return date;
}
function getTimezoneOffsetInMilliseconds(date) {
  var utcDate = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));
  utcDate.setUTCFullYear(date.getFullYear());
  return date.getTime() - utcDate.getTime();
}
function startOfDay(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  date.setHours(0, 0, 0, 0);
  return date;
}
var MILLISECONDS_IN_DAY$1 = 864e5;
function differenceInCalendarDays(dirtyDateLeft, dirtyDateRight) {
  requiredArgs(2, arguments);
  var startOfDayLeft = startOfDay(dirtyDateLeft);
  var startOfDayRight = startOfDay(dirtyDateRight);
  var timestampLeft = startOfDayLeft.getTime() - getTimezoneOffsetInMilliseconds(startOfDayLeft);
  var timestampRight = startOfDayRight.getTime() - getTimezoneOffsetInMilliseconds(startOfDayRight);
  return Math.round((timestampLeft - timestampRight) / MILLISECONDS_IN_DAY$1);
}
function addYears(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMonths(dirtyDate, amount * 12);
}
var millisecondsInMinute = 6e4;
var millisecondsInHour = 36e5;
var millisecondsInSecond = 1e3;
function _typeof$z(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$z = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$z = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$z(obj);
}
function isDate(value) {
  requiredArgs(1, arguments);
  return value instanceof Date || _typeof$z(value) === "object" && Object.prototype.toString.call(value) === "[object Date]";
}
function isValid(dirtyDate) {
  requiredArgs(1, arguments);
  if (!isDate(dirtyDate) && typeof dirtyDate !== "number") {
    return false;
  }
  var date = toDate(dirtyDate);
  return !isNaN(Number(date));
}
function getQuarter(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var quarter = Math.floor(date.getMonth() / 3) + 1;
  return quarter;
}
function endOfMonth(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var month = date.getMonth();
  date.setFullYear(date.getFullYear(), month + 1, 0);
  date.setHours(23, 59, 59, 999);
  return date;
}
function eachDayOfInterval(dirtyInterval, options) {
  var _options$step;
  requiredArgs(1, arguments);
  var interval = dirtyInterval || {};
  var startDate = toDate(interval.start);
  var endDate = toDate(interval.end);
  var endTime = endDate.getTime();
  if (!(startDate.getTime() <= endTime)) {
    throw new RangeError("Invalid interval");
  }
  var dates = [];
  var currentDate = startDate;
  currentDate.setHours(0, 0, 0, 0);
  var step = Number((_options$step = options === null || options === void 0 ? void 0 : options.step) !== null && _options$step !== void 0 ? _options$step : 1);
  if (step < 1 || isNaN(step))
    throw new RangeError("`options.step` must be a number greater than 1");
  while (currentDate.getTime() <= endTime) {
    dates.push(toDate(currentDate));
    currentDate.setDate(currentDate.getDate() + step);
    currentDate.setHours(0, 0, 0, 0);
  }
  return dates;
}
function startOfQuarter(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var currentMonth = date.getMonth();
  var month = currentMonth - currentMonth % 3;
  date.setMonth(month, 1);
  date.setHours(0, 0, 0, 0);
  return date;
}
function startOfMonth(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  date.setDate(1);
  date.setHours(0, 0, 0, 0);
  return date;
}
function endOfWeek(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var defaultOptions2 = getDefaultOptions();
  var weekStartsOn = toInteger((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  var date = toDate(dirtyDate);
  var day = date.getDay();
  var diff = (day < weekStartsOn ? -7 : 0) + 6 - (day - weekStartsOn);
  date.setDate(date.getDate() + diff);
  date.setHours(23, 59, 59, 999);
  return date;
}
function subMilliseconds(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMilliseconds(dirtyDate, -amount);
}
var MILLISECONDS_IN_DAY = 864e5;
function getUTCDayOfYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var timestamp = date.getTime();
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
  var startOfYearTimestamp = date.getTime();
  var difference = timestamp - startOfYearTimestamp;
  return Math.floor(difference / MILLISECONDS_IN_DAY) + 1;
}
function startOfUTCISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  var weekStartsOn = 1;
  var date = toDate(dirtyDate);
  var day = date.getUTCDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setUTCDate(date.getUTCDate() - diff);
  date.setUTCHours(0, 0, 0, 0);
  return date;
}
function getUTCISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getUTCFullYear();
  var fourthOfJanuaryOfNextYear = new Date(0);
  fourthOfJanuaryOfNextYear.setUTCFullYear(year + 1, 0, 4);
  fourthOfJanuaryOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = startOfUTCISOWeek(fourthOfJanuaryOfNextYear);
  var fourthOfJanuaryOfThisYear = new Date(0);
  fourthOfJanuaryOfThisYear.setUTCFullYear(year, 0, 4);
  fourthOfJanuaryOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = startOfUTCISOWeek(fourthOfJanuaryOfThisYear);
  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}
function startOfUTCISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var year = getUTCISOWeekYear(dirtyDate);
  var fourthOfJanuary = new Date(0);
  fourthOfJanuary.setUTCFullYear(year, 0, 4);
  fourthOfJanuary.setUTCHours(0, 0, 0, 0);
  var date = startOfUTCISOWeek(fourthOfJanuary);
  return date;
}
var MILLISECONDS_IN_WEEK$3 = 6048e5;
function getUTCISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var diff = startOfUTCISOWeek(date).getTime() - startOfUTCISOWeekYear(date).getTime();
  return Math.round(diff / MILLISECONDS_IN_WEEK$3) + 1;
}
function startOfUTCWeek(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var defaultOptions2 = getDefaultOptions();
  var weekStartsOn = toInteger((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  var date = toDate(dirtyDate);
  var day = date.getUTCDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setUTCDate(date.getUTCDate() - diff);
  date.setUTCHours(0, 0, 0, 0);
  return date;
}
function getUTCWeekYear(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getUTCFullYear();
  var defaultOptions2 = getDefaultOptions();
  var firstWeekContainsDate = toInteger((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1);
  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
  }
  var firstWeekOfNextYear = new Date(0);
  firstWeekOfNextYear.setUTCFullYear(year + 1, 0, firstWeekContainsDate);
  firstWeekOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = startOfUTCWeek(firstWeekOfNextYear, options);
  var firstWeekOfThisYear = new Date(0);
  firstWeekOfThisYear.setUTCFullYear(year, 0, firstWeekContainsDate);
  firstWeekOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = startOfUTCWeek(firstWeekOfThisYear, options);
  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}
function startOfUTCWeekYear(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var defaultOptions2 = getDefaultOptions();
  var firstWeekContainsDate = toInteger((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1);
  var year = getUTCWeekYear(dirtyDate, options);
  var firstWeek = new Date(0);
  firstWeek.setUTCFullYear(year, 0, firstWeekContainsDate);
  firstWeek.setUTCHours(0, 0, 0, 0);
  var date = startOfUTCWeek(firstWeek, options);
  return date;
}
var MILLISECONDS_IN_WEEK$2 = 6048e5;
function getUTCWeek(dirtyDate, options) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var diff = startOfUTCWeek(date, options).getTime() - startOfUTCWeekYear(date, options).getTime();
  return Math.round(diff / MILLISECONDS_IN_WEEK$2) + 1;
}
function addLeadingZeros(number, targetLength) {
  var sign = number < 0 ? "-" : "";
  var output = Math.abs(number).toString();
  while (output.length < targetLength) {
    output = "0" + output;
  }
  return sign + output;
}
var formatters$2 = {
  y: function y(date, token) {
    var signedYear = date.getUTCFullYear();
    var year = signedYear > 0 ? signedYear : 1 - signedYear;
    return addLeadingZeros(token === "yy" ? year % 100 : year, token.length);
  },
  M: function M(date, token) {
    var month = date.getUTCMonth();
    return token === "M" ? String(month + 1) : addLeadingZeros(month + 1, 2);
  },
  d: function d(date, token) {
    return addLeadingZeros(date.getUTCDate(), token.length);
  },
  a: function a(date, token) {
    var dayPeriodEnumValue = date.getUTCHours() / 12 >= 1 ? "pm" : "am";
    switch (token) {
      case "a":
      case "aa":
        return dayPeriodEnumValue.toUpperCase();
      case "aaa":
        return dayPeriodEnumValue;
      case "aaaaa":
        return dayPeriodEnumValue[0];
      case "aaaa":
      default:
        return dayPeriodEnumValue === "am" ? "a.m." : "p.m.";
    }
  },
  h: function h2(date, token) {
    return addLeadingZeros(date.getUTCHours() % 12 || 12, token.length);
  },
  H: function H(date, token) {
    return addLeadingZeros(date.getUTCHours(), token.length);
  },
  m: function m(date, token) {
    return addLeadingZeros(date.getUTCMinutes(), token.length);
  },
  s: function s(date, token) {
    return addLeadingZeros(date.getUTCSeconds(), token.length);
  },
  S: function S(date, token) {
    var numberOfDigits = token.length;
    var milliseconds = date.getUTCMilliseconds();
    var fractionalSeconds = Math.floor(milliseconds * Math.pow(10, numberOfDigits - 3));
    return addLeadingZeros(fractionalSeconds, token.length);
  }
};
const formatters$3 = formatters$2;
var dayPeriodEnum = {
  am: "am",
  pm: "pm",
  midnight: "midnight",
  noon: "noon",
  morning: "morning",
  afternoon: "afternoon",
  evening: "evening",
  night: "night"
};
var formatters = {
  G: function G(date, token, localize2) {
    var era = date.getUTCFullYear() > 0 ? 1 : 0;
    switch (token) {
      case "G":
      case "GG":
      case "GGG":
        return localize2.era(era, {
          width: "abbreviated"
        });
      case "GGGGG":
        return localize2.era(era, {
          width: "narrow"
        });
      case "GGGG":
      default:
        return localize2.era(era, {
          width: "wide"
        });
    }
  },
  y: function y2(date, token, localize2) {
    if (token === "yo") {
      var signedYear = date.getUTCFullYear();
      var year = signedYear > 0 ? signedYear : 1 - signedYear;
      return localize2.ordinalNumber(year, {
        unit: "year"
      });
    }
    return formatters$3.y(date, token);
  },
  Y: function Y(date, token, localize2, options) {
    var signedWeekYear = getUTCWeekYear(date, options);
    var weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear;
    if (token === "YY") {
      var twoDigitYear = weekYear % 100;
      return addLeadingZeros(twoDigitYear, 2);
    }
    if (token === "Yo") {
      return localize2.ordinalNumber(weekYear, {
        unit: "year"
      });
    }
    return addLeadingZeros(weekYear, token.length);
  },
  R: function R(date, token) {
    var isoWeekYear = getUTCISOWeekYear(date);
    return addLeadingZeros(isoWeekYear, token.length);
  },
  u: function u(date, token) {
    var year = date.getUTCFullYear();
    return addLeadingZeros(year, token.length);
  },
  Q: function Q(date, token, localize2) {
    var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);
    switch (token) {
      case "Q":
        return String(quarter);
      case "QQ":
        return addLeadingZeros(quarter, 2);
      case "Qo":
        return localize2.ordinalNumber(quarter, {
          unit: "quarter"
        });
      case "QQQ":
        return localize2.quarter(quarter, {
          width: "abbreviated",
          context: "formatting"
        });
      case "QQQQQ":
        return localize2.quarter(quarter, {
          width: "narrow",
          context: "formatting"
        });
      case "QQQQ":
      default:
        return localize2.quarter(quarter, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  q: function q(date, token, localize2) {
    var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);
    switch (token) {
      case "q":
        return String(quarter);
      case "qq":
        return addLeadingZeros(quarter, 2);
      case "qo":
        return localize2.ordinalNumber(quarter, {
          unit: "quarter"
        });
      case "qqq":
        return localize2.quarter(quarter, {
          width: "abbreviated",
          context: "standalone"
        });
      case "qqqqq":
        return localize2.quarter(quarter, {
          width: "narrow",
          context: "standalone"
        });
      case "qqqq":
      default:
        return localize2.quarter(quarter, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  M: function M2(date, token, localize2) {
    var month = date.getUTCMonth();
    switch (token) {
      case "M":
      case "MM":
        return formatters$3.M(date, token);
      case "Mo":
        return localize2.ordinalNumber(month + 1, {
          unit: "month"
        });
      case "MMM":
        return localize2.month(month, {
          width: "abbreviated",
          context: "formatting"
        });
      case "MMMMM":
        return localize2.month(month, {
          width: "narrow",
          context: "formatting"
        });
      case "MMMM":
      default:
        return localize2.month(month, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  L: function L(date, token, localize2) {
    var month = date.getUTCMonth();
    switch (token) {
      case "L":
        return String(month + 1);
      case "LL":
        return addLeadingZeros(month + 1, 2);
      case "Lo":
        return localize2.ordinalNumber(month + 1, {
          unit: "month"
        });
      case "LLL":
        return localize2.month(month, {
          width: "abbreviated",
          context: "standalone"
        });
      case "LLLLL":
        return localize2.month(month, {
          width: "narrow",
          context: "standalone"
        });
      case "LLLL":
      default:
        return localize2.month(month, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  w: function w(date, token, localize2, options) {
    var week = getUTCWeek(date, options);
    if (token === "wo") {
      return localize2.ordinalNumber(week, {
        unit: "week"
      });
    }
    return addLeadingZeros(week, token.length);
  },
  I: function I(date, token, localize2) {
    var isoWeek = getUTCISOWeek(date);
    if (token === "Io") {
      return localize2.ordinalNumber(isoWeek, {
        unit: "week"
      });
    }
    return addLeadingZeros(isoWeek, token.length);
  },
  d: function d2(date, token, localize2) {
    if (token === "do") {
      return localize2.ordinalNumber(date.getUTCDate(), {
        unit: "date"
      });
    }
    return formatters$3.d(date, token);
  },
  D: function D(date, token, localize2) {
    var dayOfYear = getUTCDayOfYear(date);
    if (token === "Do") {
      return localize2.ordinalNumber(dayOfYear, {
        unit: "dayOfYear"
      });
    }
    return addLeadingZeros(dayOfYear, token.length);
  },
  E: function E(date, token, localize2) {
    var dayOfWeek = date.getUTCDay();
    switch (token) {
      case "E":
      case "EE":
      case "EEE":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      case "EEEEE":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      case "EEEEEE":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      case "EEEE":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  e: function e2(date, token, localize2, options) {
    var dayOfWeek = date.getUTCDay();
    var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
    switch (token) {
      case "e":
        return String(localDayOfWeek);
      case "ee":
        return addLeadingZeros(localDayOfWeek, 2);
      case "eo":
        return localize2.ordinalNumber(localDayOfWeek, {
          unit: "day"
        });
      case "eee":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      case "eeeee":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      case "eeeeee":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      case "eeee":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  c: function c(date, token, localize2, options) {
    var dayOfWeek = date.getUTCDay();
    var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
    switch (token) {
      case "c":
        return String(localDayOfWeek);
      case "cc":
        return addLeadingZeros(localDayOfWeek, token.length);
      case "co":
        return localize2.ordinalNumber(localDayOfWeek, {
          unit: "day"
        });
      case "ccc":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "standalone"
        });
      case "ccccc":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "standalone"
        });
      case "cccccc":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "standalone"
        });
      case "cccc":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  i: function i(date, token, localize2) {
    var dayOfWeek = date.getUTCDay();
    var isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;
    switch (token) {
      case "i":
        return String(isoDayOfWeek);
      case "ii":
        return addLeadingZeros(isoDayOfWeek, token.length);
      case "io":
        return localize2.ordinalNumber(isoDayOfWeek, {
          unit: "day"
        });
      case "iii":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      case "iiiii":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      case "iiiiii":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      case "iiii":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  a: function a2(date, token, localize2) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
    switch (token) {
      case "a":
      case "aa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "aaa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "aaaaa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaa":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  b: function b(date, token, localize2) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue;
    if (hours === 12) {
      dayPeriodEnumValue = dayPeriodEnum.noon;
    } else if (hours === 0) {
      dayPeriodEnumValue = dayPeriodEnum.midnight;
    } else {
      dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
    }
    switch (token) {
      case "b":
      case "bb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "bbb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "bbbbb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbb":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  B: function B(date, token, localize2) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue;
    if (hours >= 17) {
      dayPeriodEnumValue = dayPeriodEnum.evening;
    } else if (hours >= 12) {
      dayPeriodEnumValue = dayPeriodEnum.afternoon;
    } else if (hours >= 4) {
      dayPeriodEnumValue = dayPeriodEnum.morning;
    } else {
      dayPeriodEnumValue = dayPeriodEnum.night;
    }
    switch (token) {
      case "B":
      case "BB":
      case "BBB":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "BBBBB":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBB":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  h: function h3(date, token, localize2) {
    if (token === "ho") {
      var hours = date.getUTCHours() % 12;
      if (hours === 0)
        hours = 12;
      return localize2.ordinalNumber(hours, {
        unit: "hour"
      });
    }
    return formatters$3.h(date, token);
  },
  H: function H2(date, token, localize2) {
    if (token === "Ho") {
      return localize2.ordinalNumber(date.getUTCHours(), {
        unit: "hour"
      });
    }
    return formatters$3.H(date, token);
  },
  K: function K(date, token, localize2) {
    var hours = date.getUTCHours() % 12;
    if (token === "Ko") {
      return localize2.ordinalNumber(hours, {
        unit: "hour"
      });
    }
    return addLeadingZeros(hours, token.length);
  },
  k: function k(date, token, localize2) {
    var hours = date.getUTCHours();
    if (hours === 0)
      hours = 24;
    if (token === "ko") {
      return localize2.ordinalNumber(hours, {
        unit: "hour"
      });
    }
    return addLeadingZeros(hours, token.length);
  },
  m: function m2(date, token, localize2) {
    if (token === "mo") {
      return localize2.ordinalNumber(date.getUTCMinutes(), {
        unit: "minute"
      });
    }
    return formatters$3.m(date, token);
  },
  s: function s2(date, token, localize2) {
    if (token === "so") {
      return localize2.ordinalNumber(date.getUTCSeconds(), {
        unit: "second"
      });
    }
    return formatters$3.s(date, token);
  },
  S: function S2(date, token) {
    return formatters$3.S(date, token);
  },
  X: function X(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    if (timezoneOffset === 0) {
      return "Z";
    }
    switch (token) {
      case "X":
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      case "XXXX":
      case "XX":
        return formatTimezone(timezoneOffset);
      case "XXXXX":
      case "XXX":
      default:
        return formatTimezone(timezoneOffset, ":");
    }
  },
  x: function x(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    switch (token) {
      case "x":
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      case "xxxx":
      case "xx":
        return formatTimezone(timezoneOffset);
      case "xxxxx":
      case "xxx":
      default:
        return formatTimezone(timezoneOffset, ":");
    }
  },
  O: function O(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    switch (token) {
      case "O":
      case "OO":
      case "OOO":
        return "GMT" + formatTimezoneShort(timezoneOffset, ":");
      case "OOOO":
      default:
        return "GMT" + formatTimezone(timezoneOffset, ":");
    }
  },
  z: function z(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    switch (token) {
      case "z":
      case "zz":
      case "zzz":
        return "GMT" + formatTimezoneShort(timezoneOffset, ":");
      case "zzzz":
      default:
        return "GMT" + formatTimezone(timezoneOffset, ":");
    }
  },
  t: function t2(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timestamp = Math.floor(originalDate.getTime() / 1e3);
    return addLeadingZeros(timestamp, token.length);
  },
  T: function T(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timestamp = originalDate.getTime();
    return addLeadingZeros(timestamp, token.length);
  }
};
function formatTimezoneShort(offset, dirtyDelimiter) {
  var sign = offset > 0 ? "-" : "+";
  var absOffset = Math.abs(offset);
  var hours = Math.floor(absOffset / 60);
  var minutes = absOffset % 60;
  if (minutes === 0) {
    return sign + String(hours);
  }
  var delimiter = dirtyDelimiter || "";
  return sign + String(hours) + delimiter + addLeadingZeros(minutes, 2);
}
function formatTimezoneWithOptionalMinutes(offset, dirtyDelimiter) {
  if (offset % 60 === 0) {
    var sign = offset > 0 ? "-" : "+";
    return sign + addLeadingZeros(Math.abs(offset) / 60, 2);
  }
  return formatTimezone(offset, dirtyDelimiter);
}
function formatTimezone(offset, dirtyDelimiter) {
  var delimiter = dirtyDelimiter || "";
  var sign = offset > 0 ? "-" : "+";
  var absOffset = Math.abs(offset);
  var hours = addLeadingZeros(Math.floor(absOffset / 60), 2);
  var minutes = addLeadingZeros(absOffset % 60, 2);
  return sign + hours + delimiter + minutes;
}
const formatters$1 = formatters;
var dateLongFormatter = function dateLongFormatter2(pattern, formatLong2) {
  switch (pattern) {
    case "P":
      return formatLong2.date({
        width: "short"
      });
    case "PP":
      return formatLong2.date({
        width: "medium"
      });
    case "PPP":
      return formatLong2.date({
        width: "long"
      });
    case "PPPP":
    default:
      return formatLong2.date({
        width: "full"
      });
  }
};
var timeLongFormatter = function timeLongFormatter2(pattern, formatLong2) {
  switch (pattern) {
    case "p":
      return formatLong2.time({
        width: "short"
      });
    case "pp":
      return formatLong2.time({
        width: "medium"
      });
    case "ppp":
      return formatLong2.time({
        width: "long"
      });
    case "pppp":
    default:
      return formatLong2.time({
        width: "full"
      });
  }
};
var dateTimeLongFormatter = function dateTimeLongFormatter2(pattern, formatLong2) {
  var matchResult = pattern.match(/(P+)(p+)?/) || [];
  var datePattern = matchResult[1];
  var timePattern = matchResult[2];
  if (!timePattern) {
    return dateLongFormatter(pattern, formatLong2);
  }
  var dateTimeFormat;
  switch (datePattern) {
    case "P":
      dateTimeFormat = formatLong2.dateTime({
        width: "short"
      });
      break;
    case "PP":
      dateTimeFormat = formatLong2.dateTime({
        width: "medium"
      });
      break;
    case "PPP":
      dateTimeFormat = formatLong2.dateTime({
        width: "long"
      });
      break;
    case "PPPP":
    default:
      dateTimeFormat = formatLong2.dateTime({
        width: "full"
      });
      break;
  }
  return dateTimeFormat.replace("{{date}}", dateLongFormatter(datePattern, formatLong2)).replace("{{time}}", timeLongFormatter(timePattern, formatLong2));
};
var longFormatters = {
  p: timeLongFormatter,
  P: dateTimeLongFormatter
};
const longFormatters$1 = longFormatters;
var protectedDayOfYearTokens = ["D", "DD"];
var protectedWeekYearTokens = ["YY", "YYYY"];
function isProtectedDayOfYearToken(token) {
  return protectedDayOfYearTokens.indexOf(token) !== -1;
}
function isProtectedWeekYearToken(token) {
  return protectedWeekYearTokens.indexOf(token) !== -1;
}
function throwProtectedError(token, format2, input) {
  if (token === "YYYY") {
    throw new RangeError("Use `yyyy` instead of `YYYY` (in `".concat(format2, "`) for formatting years to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  } else if (token === "YY") {
    throw new RangeError("Use `yy` instead of `YY` (in `".concat(format2, "`) for formatting years to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  } else if (token === "D") {
    throw new RangeError("Use `d` instead of `D` (in `".concat(format2, "`) for formatting days of the month to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  } else if (token === "DD") {
    throw new RangeError("Use `dd` instead of `DD` (in `".concat(format2, "`) for formatting days of the month to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  }
}
var formatDistanceLocale = {
  lessThanXSeconds: {
    one: "less than a second",
    other: "less than {{count}} seconds"
  },
  xSeconds: {
    one: "1 second",
    other: "{{count}} seconds"
  },
  halfAMinute: "half a minute",
  lessThanXMinutes: {
    one: "less than a minute",
    other: "less than {{count}} minutes"
  },
  xMinutes: {
    one: "1 minute",
    other: "{{count}} minutes"
  },
  aboutXHours: {
    one: "about 1 hour",
    other: "about {{count}} hours"
  },
  xHours: {
    one: "1 hour",
    other: "{{count}} hours"
  },
  xDays: {
    one: "1 day",
    other: "{{count}} days"
  },
  aboutXWeeks: {
    one: "about 1 week",
    other: "about {{count}} weeks"
  },
  xWeeks: {
    one: "1 week",
    other: "{{count}} weeks"
  },
  aboutXMonths: {
    one: "about 1 month",
    other: "about {{count}} months"
  },
  xMonths: {
    one: "1 month",
    other: "{{count}} months"
  },
  aboutXYears: {
    one: "about 1 year",
    other: "about {{count}} years"
  },
  xYears: {
    one: "1 year",
    other: "{{count}} years"
  },
  overXYears: {
    one: "over 1 year",
    other: "over {{count}} years"
  },
  almostXYears: {
    one: "almost 1 year",
    other: "almost {{count}} years"
  }
};
var formatDistance = function formatDistance2(token, count, options) {
  var result;
  var tokenValue = formatDistanceLocale[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", count.toString());
  }
  if (options !== null && options !== void 0 && options.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "in " + result;
    } else {
      return result + " ago";
    }
  }
  return result;
};
const formatDistance$1 = formatDistance;
function buildFormatLongFn(args) {
  return function() {
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var width = options.width ? String(options.width) : args.defaultWidth;
    var format2 = args.formats[width] || args.formats[args.defaultWidth];
    return format2;
  };
}
var dateFormats = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy"
};
var timeFormats = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
};
var dateTimeFormats = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong = {
  date: buildFormatLongFn({
    formats: dateFormats,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats,
    defaultWidth: "full"
  })
};
const formatLong$1 = formatLong;
var formatRelativeLocale = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: "P"
};
var formatRelative = function formatRelative2(token, _date, _baseDate, _options) {
  return formatRelativeLocale[token];
};
const formatRelative$1 = formatRelative;
function buildLocalizeFn(args) {
  return function(dirtyIndex, options) {
    var context = options !== null && options !== void 0 && options.context ? String(options.context) : "standalone";
    var valuesArray;
    if (context === "formatting" && args.formattingValues) {
      var defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
      var width = options !== null && options !== void 0 && options.width ? String(options.width) : defaultWidth;
      valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
    } else {
      var _defaultWidth = args.defaultWidth;
      var _width = options !== null && options !== void 0 && options.width ? String(options.width) : args.defaultWidth;
      valuesArray = args.values[_width] || args.values[_defaultWidth];
    }
    var index2 = args.argumentCallback ? args.argumentCallback(dirtyIndex) : dirtyIndex;
    return valuesArray[index2];
  };
}
var eraValues = {
  narrow: ["B", "A"],
  abbreviated: ["BC", "AD"],
  wide: ["Before Christ", "Anno Domini"]
};
var quarterValues = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
};
var monthValues = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
  wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
};
var dayValues = {
  narrow: ["S", "M", "T", "W", "T", "F", "S"],
  short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
  abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
};
var dayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  }
};
var formattingDayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  }
};
var ordinalNumber = function ordinalNumber2(dirtyNumber, _options) {
  var number = Number(dirtyNumber);
  var rem100 = number % 100;
  if (rem100 > 20 || rem100 < 10) {
    switch (rem100 % 10) {
      case 1:
        return number + "st";
      case 2:
        return number + "nd";
      case 3:
        return number + "rd";
    }
  }
  return number + "th";
};
var localize = {
  ordinalNumber,
  era: buildLocalizeFn({
    values: eraValues,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues,
    defaultWidth: "wide",
    argumentCallback: function argumentCallback(quarter) {
      return quarter - 1;
    }
  }),
  month: buildLocalizeFn({
    values: monthValues,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues,
    defaultFormattingWidth: "wide"
  })
};
const localize$1 = localize;
function buildMatchFn(args) {
  return function(string) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var width = options.width;
    var matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
    var matchResult = string.match(matchPattern);
    if (!matchResult) {
      return null;
    }
    var matchedString = matchResult[0];
    var parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
    var key = Array.isArray(parsePatterns) ? findIndex(parsePatterns, function(pattern) {
      return pattern.test(matchedString);
    }) : findKey(parsePatterns, function(pattern) {
      return pattern.test(matchedString);
    });
    var value;
    value = args.valueCallback ? args.valueCallback(key) : key;
    value = options.valueCallback ? options.valueCallback(value) : value;
    var rest = string.slice(matchedString.length);
    return {
      value,
      rest
    };
  };
}
function findKey(object, predicate) {
  for (var key in object) {
    if (object.hasOwnProperty(key) && predicate(object[key])) {
      return key;
    }
  }
  return void 0;
}
function findIndex(array, predicate) {
  for (var key = 0; key < array.length; key++) {
    if (predicate(array[key])) {
      return key;
    }
  }
  return void 0;
}
function buildMatchPatternFn(args) {
  return function(string) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var matchResult = string.match(args.matchPattern);
    if (!matchResult)
      return null;
    var matchedString = matchResult[0];
    var parseResult = string.match(args.parsePattern);
    if (!parseResult)
      return null;
    var value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
    value = options.valueCallback ? options.valueCallback(value) : value;
    var rest = string.slice(matchedString.length);
    return {
      value,
      rest
    };
  };
}
var matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
var parseOrdinalNumberPattern = /\d+/i;
var matchEraPatterns = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i
};
var parseEraPatterns = {
  any: [/^b/i, /^(a|c)/i]
};
var matchQuarterPatterns = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i
};
var parseQuarterPatterns = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
};
var parseMonthPatterns = {
  narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
  any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
};
var matchDayPatterns = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
};
var parseDayPatterns = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
};
var matchDayPeriodPatterns = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
};
var parseDayPeriodPatterns = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
};
var match = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern,
    parsePattern: parseOrdinalNumberPattern,
    valueCallback: function valueCallback(value) {
      return parseInt(value, 10);
    }
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns,
    defaultParseWidth: "any",
    valueCallback: function valueCallback2(index2) {
      return index2 + 1;
    }
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns,
    defaultParseWidth: "any"
  })
};
const match$1 = match;
var locale = {
  code: "en-US",
  formatDistance: formatDistance$1,
  formatLong: formatLong$1,
  formatRelative: formatRelative$1,
  localize: localize$1,
  match: match$1,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};
const defaultLocale = locale;
var formattingTokensRegExp$1 = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
var longFormattingTokensRegExp$1 = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
var escapedStringRegExp$1 = /^'([^]*?)'?$/;
var doubleQuoteRegExp$1 = /''/g;
var unescapedLatinCharacterRegExp$1 = /[a-zA-Z]/;
function format(dirtyDate, dirtyFormatStr, options) {
  var _ref, _options$locale, _ref2, _ref3, _ref4, _options$firstWeekCon, _options$locale2, _options$locale2$opti, _defaultOptions$local, _defaultOptions$local2, _ref5, _ref6, _ref7, _options$weekStartsOn, _options$locale3, _options$locale3$opti, _defaultOptions$local3, _defaultOptions$local4;
  requiredArgs(2, arguments);
  var formatStr = String(dirtyFormatStr);
  var defaultOptions2 = getDefaultOptions();
  var locale2 = (_ref = (_options$locale = options === null || options === void 0 ? void 0 : options.locale) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions2.locale) !== null && _ref !== void 0 ? _ref : defaultLocale;
  var firstWeekContainsDate = toInteger((_ref2 = (_ref3 = (_ref4 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale2 = options.locale) === null || _options$locale2 === void 0 ? void 0 : (_options$locale2$opti = _options$locale2.options) === null || _options$locale2$opti === void 0 ? void 0 : _options$locale2$opti.firstWeekContainsDate) !== null && _ref4 !== void 0 ? _ref4 : defaultOptions2.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : 1);
  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
  }
  var weekStartsOn = toInteger((_ref5 = (_ref6 = (_ref7 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale3 = options.locale) === null || _options$locale3 === void 0 ? void 0 : (_options$locale3$opti = _options$locale3.options) === null || _options$locale3$opti === void 0 ? void 0 : _options$locale3$opti.weekStartsOn) !== null && _ref7 !== void 0 ? _ref7 : defaultOptions2.weekStartsOn) !== null && _ref6 !== void 0 ? _ref6 : (_defaultOptions$local3 = defaultOptions2.locale) === null || _defaultOptions$local3 === void 0 ? void 0 : (_defaultOptions$local4 = _defaultOptions$local3.options) === null || _defaultOptions$local4 === void 0 ? void 0 : _defaultOptions$local4.weekStartsOn) !== null && _ref5 !== void 0 ? _ref5 : 0);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  if (!locale2.localize) {
    throw new RangeError("locale must contain localize property");
  }
  if (!locale2.formatLong) {
    throw new RangeError("locale must contain formatLong property");
  }
  var originalDate = toDate(dirtyDate);
  if (!isValid(originalDate)) {
    throw new RangeError("Invalid time value");
  }
  var timezoneOffset = getTimezoneOffsetInMilliseconds(originalDate);
  var utcDate = subMilliseconds(originalDate, timezoneOffset);
  var formatterOptions = {
    firstWeekContainsDate,
    weekStartsOn,
    locale: locale2,
    _originalDate: originalDate
  };
  var result = formatStr.match(longFormattingTokensRegExp$1).map(function(substring) {
    var firstCharacter = substring[0];
    if (firstCharacter === "p" || firstCharacter === "P") {
      var longFormatter = longFormatters$1[firstCharacter];
      return longFormatter(substring, locale2.formatLong);
    }
    return substring;
  }).join("").match(formattingTokensRegExp$1).map(function(substring) {
    if (substring === "''") {
      return "'";
    }
    var firstCharacter = substring[0];
    if (firstCharacter === "'") {
      return cleanEscapedString$1(substring);
    }
    var formatter = formatters$1[firstCharacter];
    if (formatter) {
      if (!(options !== null && options !== void 0 && options.useAdditionalWeekYearTokens) && isProtectedWeekYearToken(substring)) {
        throwProtectedError(substring, dirtyFormatStr, String(dirtyDate));
      }
      if (!(options !== null && options !== void 0 && options.useAdditionalDayOfYearTokens) && isProtectedDayOfYearToken(substring)) {
        throwProtectedError(substring, dirtyFormatStr, String(dirtyDate));
      }
      return formatter(utcDate, substring, locale2.localize, formatterOptions);
    }
    if (firstCharacter.match(unescapedLatinCharacterRegExp$1)) {
      throw new RangeError("Format string contains an unescaped latin alphabet character `" + firstCharacter + "`");
    }
    return substring;
  }).join("");
  return result;
}
function cleanEscapedString$1(input) {
  var matched = input.match(escapedStringRegExp$1);
  if (!matched) {
    return input;
  }
  return matched[1].replace(doubleQuoteRegExp$1, "'");
}
function assign(target, object) {
  if (target == null) {
    throw new TypeError("assign requires that input parameter not be null or undefined");
  }
  for (var property in object) {
    if (Object.prototype.hasOwnProperty.call(object, property)) {
      target[property] = object[property];
    }
  }
  return target;
}
function getDay(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var day = date.getDay();
  return day;
}
function getDaysInMonth(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getFullYear();
  var monthIndex = date.getMonth();
  var lastDayOfMonth = new Date(0);
  lastDayOfMonth.setFullYear(year, monthIndex + 1, 0);
  lastDayOfMonth.setHours(0, 0, 0, 0);
  return lastDayOfMonth.getDate();
}
function getHours(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var hours = date.getHours();
  return hours;
}
var MILLISECONDS_IN_WEEK$1 = 6048e5;
function getISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var diff = startOfISOWeek(date).getTime() - startOfISOWeekYear(date).getTime();
  return Math.round(diff / MILLISECONDS_IN_WEEK$1) + 1;
}
function getMinutes(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var minutes = date.getMinutes();
  return minutes;
}
function getMonth(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var month = date.getMonth();
  return month;
}
function getSeconds(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var seconds = date.getSeconds();
  return seconds;
}
function getWeekYear(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getFullYear();
  var defaultOptions2 = getDefaultOptions();
  var firstWeekContainsDate = toInteger((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1);
  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
  }
  var firstWeekOfNextYear = new Date(0);
  firstWeekOfNextYear.setFullYear(year + 1, 0, firstWeekContainsDate);
  firstWeekOfNextYear.setHours(0, 0, 0, 0);
  var startOfNextYear = startOfWeek(firstWeekOfNextYear, options);
  var firstWeekOfThisYear = new Date(0);
  firstWeekOfThisYear.setFullYear(year, 0, firstWeekContainsDate);
  firstWeekOfThisYear.setHours(0, 0, 0, 0);
  var startOfThisYear = startOfWeek(firstWeekOfThisYear, options);
  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}
function startOfWeekYear(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var defaultOptions2 = getDefaultOptions();
  var firstWeekContainsDate = toInteger((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1);
  var year = getWeekYear(dirtyDate, options);
  var firstWeek = new Date(0);
  firstWeek.setFullYear(year, 0, firstWeekContainsDate);
  firstWeek.setHours(0, 0, 0, 0);
  var date = startOfWeek(firstWeek, options);
  return date;
}
var MILLISECONDS_IN_WEEK = 6048e5;
function getWeek(dirtyDate, options) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var diff = startOfWeek(date, options).getTime() - startOfWeekYear(date, options).getTime();
  return Math.round(diff / MILLISECONDS_IN_WEEK) + 1;
}
function getYear(dirtyDate) {
  requiredArgs(1, arguments);
  return toDate(dirtyDate).getFullYear();
}
function isAfter(dirtyDate, dirtyDateToCompare) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var dateToCompare = toDate(dirtyDateToCompare);
  return date.getTime() > dateToCompare.getTime();
}
function isBefore(dirtyDate, dirtyDateToCompare) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var dateToCompare = toDate(dirtyDateToCompare);
  return date.getTime() < dateToCompare.getTime();
}
function isEqual(dirtyLeftDate, dirtyRightDate) {
  requiredArgs(2, arguments);
  var dateLeft = toDate(dirtyLeftDate);
  var dateRight = toDate(dirtyRightDate);
  return dateLeft.getTime() === dateRight.getTime();
}
function _typeof$y(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$y = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$y = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$y(obj);
}
function _inherits$v(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf$v(subClass, superClass);
}
function _setPrototypeOf$v(o2, p2) {
  _setPrototypeOf$v = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf$v(o2, p2);
}
function _createSuper$v(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$v();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$v(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$v(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$v(this, result);
  };
}
function _possibleConstructorReturn$v(self2, call) {
  if (call && (_typeof$y(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$v(self2);
}
function _assertThisInitialized$v(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$v() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$v(o2) {
  _getPrototypeOf$v = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf$v(o2);
}
function _classCallCheck$w(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$w(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$w(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$w(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$w(Constructor, staticProps);
  return Constructor;
}
function _defineProperty$v(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var TIMEZONE_UNIT_PRIORITY = 10;
var Setter = /* @__PURE__ */ function() {
  function Setter2() {
    _classCallCheck$w(this, Setter2);
    _defineProperty$v(this, "subPriority", 0);
  }
  _createClass$w(Setter2, [{
    key: "validate",
    value: function validate(_utcDate, _options) {
      return true;
    }
  }]);
  return Setter2;
}();
var ValueSetter = /* @__PURE__ */ function(_Setter) {
  _inherits$v(ValueSetter2, _Setter);
  var _super = _createSuper$v(ValueSetter2);
  function ValueSetter2(value, validateValue, setValue, priority, subPriority) {
    var _this;
    _classCallCheck$w(this, ValueSetter2);
    _this = _super.call(this);
    _this.value = value;
    _this.validateValue = validateValue;
    _this.setValue = setValue;
    _this.priority = priority;
    if (subPriority) {
      _this.subPriority = subPriority;
    }
    return _this;
  }
  _createClass$w(ValueSetter2, [{
    key: "validate",
    value: function validate(utcDate, options) {
      return this.validateValue(utcDate, this.value, options);
    }
  }, {
    key: "set",
    value: function set2(utcDate, flags, options) {
      return this.setValue(utcDate, flags, this.value, options);
    }
  }]);
  return ValueSetter2;
}(Setter);
var DateToSystemTimezoneSetter = /* @__PURE__ */ function(_Setter2) {
  _inherits$v(DateToSystemTimezoneSetter2, _Setter2);
  var _super2 = _createSuper$v(DateToSystemTimezoneSetter2);
  function DateToSystemTimezoneSetter2() {
    var _this2;
    _classCallCheck$w(this, DateToSystemTimezoneSetter2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _super2.call.apply(_super2, [this].concat(args));
    _defineProperty$v(_assertThisInitialized$v(_this2), "priority", TIMEZONE_UNIT_PRIORITY);
    _defineProperty$v(_assertThisInitialized$v(_this2), "subPriority", -1);
    return _this2;
  }
  _createClass$w(DateToSystemTimezoneSetter2, [{
    key: "set",
    value: function set2(date, flags) {
      if (flags.timestampIsSet) {
        return date;
      }
      var convertedDate = new Date(0);
      convertedDate.setFullYear(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());
      convertedDate.setHours(date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds());
      return convertedDate;
    }
  }]);
  return DateToSystemTimezoneSetter2;
}(Setter);
function _classCallCheck$v(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$v(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$v(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$v(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$v(Constructor, staticProps);
  return Constructor;
}
var Parser = /* @__PURE__ */ function() {
  function Parser2() {
    _classCallCheck$v(this, Parser2);
  }
  _createClass$v(Parser2, [{
    key: "run",
    value: function run2(dateString, token, match2, options) {
      var result = this.parse(dateString, token, match2, options);
      if (!result) {
        return null;
      }
      return {
        setter: new ValueSetter(result.value, this.validate, this.set, this.priority, this.subPriority),
        rest: result.rest
      };
    }
  }, {
    key: "validate",
    value: function validate(_utcDate, _value, _options) {
      return true;
    }
  }]);
  return Parser2;
}();
function _typeof$x(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$x = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$x = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$x(obj);
}
function _classCallCheck$u(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$u(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$u(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$u(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$u(Constructor, staticProps);
  return Constructor;
}
function _inherits$u(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf$u(subClass, superClass);
}
function _setPrototypeOf$u(o2, p2) {
  _setPrototypeOf$u = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf$u(o2, p2);
}
function _createSuper$u(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$u();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$u(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$u(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$u(this, result);
  };
}
function _possibleConstructorReturn$u(self2, call) {
  if (call && (_typeof$x(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$u(self2);
}
function _assertThisInitialized$u(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$u() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$u(o2) {
  _getPrototypeOf$u = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf$u(o2);
}
function _defineProperty$u(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var EraParser = /* @__PURE__ */ function(_Parser) {
  _inherits$u(EraParser2, _Parser);
  var _super = _createSuper$u(EraParser2);
  function EraParser2() {
    var _this;
    _classCallCheck$u(this, EraParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$u(_assertThisInitialized$u(_this), "priority", 140);
    _defineProperty$u(_assertThisInitialized$u(_this), "incompatibleTokens", ["R", "u", "t", "T"]);
    return _this;
  }
  _createClass$u(EraParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      switch (token) {
        case "G":
        case "GG":
        case "GGG":
          return match2.era(dateString, {
            width: "abbreviated"
          }) || match2.era(dateString, {
            width: "narrow"
          });
        case "GGGGG":
          return match2.era(dateString, {
            width: "narrow"
          });
        case "GGGG":
        default:
          return match2.era(dateString, {
            width: "wide"
          }) || match2.era(dateString, {
            width: "abbreviated"
          }) || match2.era(dateString, {
            width: "narrow"
          });
      }
    }
  }, {
    key: "set",
    value: function set2(date, flags, value) {
      flags.era = value;
      date.setUTCFullYear(value, 0, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return EraParser2;
}(Parser);
var numericPatterns = {
  month: /^(1[0-2]|0?\d)/,
  date: /^(3[0-1]|[0-2]?\d)/,
  dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
  week: /^(5[0-3]|[0-4]?\d)/,
  hour23h: /^(2[0-3]|[0-1]?\d)/,
  hour24h: /^(2[0-4]|[0-1]?\d)/,
  hour11h: /^(1[0-1]|0?\d)/,
  hour12h: /^(1[0-2]|0?\d)/,
  minute: /^[0-5]?\d/,
  second: /^[0-5]?\d/,
  singleDigit: /^\d/,
  twoDigits: /^\d{1,2}/,
  threeDigits: /^\d{1,3}/,
  fourDigits: /^\d{1,4}/,
  anyDigitsSigned: /^-?\d+/,
  singleDigitSigned: /^-?\d/,
  twoDigitsSigned: /^-?\d{1,2}/,
  threeDigitsSigned: /^-?\d{1,3}/,
  fourDigitsSigned: /^-?\d{1,4}/
};
var timezonePatterns = {
  basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
  basic: /^([+-])(\d{2})(\d{2})|Z/,
  basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
  extended: /^([+-])(\d{2}):(\d{2})|Z/,
  extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/
};
function mapValue(parseFnResult, mapFn) {
  if (!parseFnResult) {
    return parseFnResult;
  }
  return {
    value: mapFn(parseFnResult.value),
    rest: parseFnResult.rest
  };
}
function parseNumericPattern(pattern, dateString) {
  var matchResult = dateString.match(pattern);
  if (!matchResult) {
    return null;
  }
  return {
    value: parseInt(matchResult[0], 10),
    rest: dateString.slice(matchResult[0].length)
  };
}
function parseTimezonePattern(pattern, dateString) {
  var matchResult = dateString.match(pattern);
  if (!matchResult) {
    return null;
  }
  if (matchResult[0] === "Z") {
    return {
      value: 0,
      rest: dateString.slice(1)
    };
  }
  var sign = matchResult[1] === "+" ? 1 : -1;
  var hours = matchResult[2] ? parseInt(matchResult[2], 10) : 0;
  var minutes = matchResult[3] ? parseInt(matchResult[3], 10) : 0;
  var seconds = matchResult[5] ? parseInt(matchResult[5], 10) : 0;
  return {
    value: sign * (hours * millisecondsInHour + minutes * millisecondsInMinute + seconds * millisecondsInSecond),
    rest: dateString.slice(matchResult[0].length)
  };
}
function parseAnyDigitsSigned(dateString) {
  return parseNumericPattern(numericPatterns.anyDigitsSigned, dateString);
}
function parseNDigits(n2, dateString) {
  switch (n2) {
    case 1:
      return parseNumericPattern(numericPatterns.singleDigit, dateString);
    case 2:
      return parseNumericPattern(numericPatterns.twoDigits, dateString);
    case 3:
      return parseNumericPattern(numericPatterns.threeDigits, dateString);
    case 4:
      return parseNumericPattern(numericPatterns.fourDigits, dateString);
    default:
      return parseNumericPattern(new RegExp("^\\d{1," + n2 + "}"), dateString);
  }
}
function parseNDigitsSigned(n2, dateString) {
  switch (n2) {
    case 1:
      return parseNumericPattern(numericPatterns.singleDigitSigned, dateString);
    case 2:
      return parseNumericPattern(numericPatterns.twoDigitsSigned, dateString);
    case 3:
      return parseNumericPattern(numericPatterns.threeDigitsSigned, dateString);
    case 4:
      return parseNumericPattern(numericPatterns.fourDigitsSigned, dateString);
    default:
      return parseNumericPattern(new RegExp("^-?\\d{1," + n2 + "}"), dateString);
  }
}
function dayPeriodEnumToHours(dayPeriod) {
  switch (dayPeriod) {
    case "morning":
      return 4;
    case "evening":
      return 17;
    case "pm":
    case "noon":
    case "afternoon":
      return 12;
    case "am":
    case "midnight":
    case "night":
    default:
      return 0;
  }
}
function normalizeTwoDigitYear(twoDigitYear, currentYear) {
  var isCommonEra = currentYear > 0;
  var absCurrentYear = isCommonEra ? currentYear : 1 - currentYear;
  var result;
  if (absCurrentYear <= 50) {
    result = twoDigitYear || 100;
  } else {
    var rangeEnd = absCurrentYear + 50;
    var rangeEndCentury = Math.floor(rangeEnd / 100) * 100;
    var isPreviousCentury = twoDigitYear >= rangeEnd % 100;
    result = twoDigitYear + rangeEndCentury - (isPreviousCentury ? 100 : 0);
  }
  return isCommonEra ? result : 1 - result;
}
function isLeapYearIndex$1(year) {
  return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
}
function _typeof$w(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$w = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$w = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$w(obj);
}
function _classCallCheck$t(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$t(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$t(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$t(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$t(Constructor, staticProps);
  return Constructor;
}
function _inherits$t(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf$t(subClass, superClass);
}
function _setPrototypeOf$t(o2, p2) {
  _setPrototypeOf$t = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf$t(o2, p2);
}
function _createSuper$t(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$t();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$t(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$t(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$t(this, result);
  };
}
function _possibleConstructorReturn$t(self2, call) {
  if (call && (_typeof$w(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$t(self2);
}
function _assertThisInitialized$t(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$t() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$t(o2) {
  _getPrototypeOf$t = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf$t(o2);
}
function _defineProperty$t(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var YearParser = /* @__PURE__ */ function(_Parser) {
  _inherits$t(YearParser2, _Parser);
  var _super = _createSuper$t(YearParser2);
  function YearParser2() {
    var _this;
    _classCallCheck$t(this, YearParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$t(_assertThisInitialized$t(_this), "priority", 130);
    _defineProperty$t(_assertThisInitialized$t(_this), "incompatibleTokens", ["Y", "R", "u", "w", "I", "i", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass$t(YearParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      var valueCallback3 = function valueCallback4(year) {
        return {
          year,
          isTwoDigitYear: token === "yy"
        };
      };
      switch (token) {
        case "y":
          return mapValue(parseNDigits(4, dateString), valueCallback3);
        case "yo":
          return mapValue(match2.ordinalNumber(dateString, {
            unit: "year"
          }), valueCallback3);
        default:
          return mapValue(parseNDigits(token.length, dateString), valueCallback3);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value.isTwoDigitYear || value.year > 0;
    }
  }, {
    key: "set",
    value: function set2(date, flags, value) {
      var currentYear = date.getUTCFullYear();
      if (value.isTwoDigitYear) {
        var normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);
        date.setUTCFullYear(normalizedTwoDigitYear, 0, 1);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      }
      var year = !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
      date.setUTCFullYear(year, 0, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return YearParser2;
}(Parser);
function _typeof$v(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$v = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$v = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$v(obj);
}
function _classCallCheck$s(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$s(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$s(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$s(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$s(Constructor, staticProps);
  return Constructor;
}
function _inherits$s(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf$s(subClass, superClass);
}
function _setPrototypeOf$s(o2, p2) {
  _setPrototypeOf$s = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf$s(o2, p2);
}
function _createSuper$s(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$s();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$s(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$s(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$s(this, result);
  };
}
function _possibleConstructorReturn$s(self2, call) {
  if (call && (_typeof$v(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$s(self2);
}
function _assertThisInitialized$s(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$s() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$s(o2) {
  _getPrototypeOf$s = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf$s(o2);
}
function _defineProperty$s(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var LocalWeekYearParser = /* @__PURE__ */ function(_Parser) {
  _inherits$s(LocalWeekYearParser2, _Parser);
  var _super = _createSuper$s(LocalWeekYearParser2);
  function LocalWeekYearParser2() {
    var _this;
    _classCallCheck$s(this, LocalWeekYearParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$s(_assertThisInitialized$s(_this), "priority", 130);
    _defineProperty$s(_assertThisInitialized$s(_this), "incompatibleTokens", ["y", "R", "u", "Q", "q", "M", "L", "I", "d", "D", "i", "t", "T"]);
    return _this;
  }
  _createClass$s(LocalWeekYearParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      var valueCallback3 = function valueCallback4(year) {
        return {
          year,
          isTwoDigitYear: token === "YY"
        };
      };
      switch (token) {
        case "Y":
          return mapValue(parseNDigits(4, dateString), valueCallback3);
        case "Yo":
          return mapValue(match2.ordinalNumber(dateString, {
            unit: "year"
          }), valueCallback3);
        default:
          return mapValue(parseNDigits(token.length, dateString), valueCallback3);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value.isTwoDigitYear || value.year > 0;
    }
  }, {
    key: "set",
    value: function set2(date, flags, value, options) {
      var currentYear = getUTCWeekYear(date, options);
      if (value.isTwoDigitYear) {
        var normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);
        date.setUTCFullYear(normalizedTwoDigitYear, 0, options.firstWeekContainsDate);
        date.setUTCHours(0, 0, 0, 0);
        return startOfUTCWeek(date, options);
      }
      var year = !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
      date.setUTCFullYear(year, 0, options.firstWeekContainsDate);
      date.setUTCHours(0, 0, 0, 0);
      return startOfUTCWeek(date, options);
    }
  }]);
  return LocalWeekYearParser2;
}(Parser);
function _typeof$u(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$u = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$u = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$u(obj);
}
function _classCallCheck$r(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$r(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$r(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$r(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$r(Constructor, staticProps);
  return Constructor;
}
function _inherits$r(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf$r(subClass, superClass);
}
function _setPrototypeOf$r(o2, p2) {
  _setPrototypeOf$r = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf$r(o2, p2);
}
function _createSuper$r(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$r();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$r(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$r(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$r(this, result);
  };
}
function _possibleConstructorReturn$r(self2, call) {
  if (call && (_typeof$u(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$r(self2);
}
function _assertThisInitialized$r(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$r() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$r(o2) {
  _getPrototypeOf$r = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf$r(o2);
}
function _defineProperty$r(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var ISOWeekYearParser = /* @__PURE__ */ function(_Parser) {
  _inherits$r(ISOWeekYearParser2, _Parser);
  var _super = _createSuper$r(ISOWeekYearParser2);
  function ISOWeekYearParser2() {
    var _this;
    _classCallCheck$r(this, ISOWeekYearParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$r(_assertThisInitialized$r(_this), "priority", 130);
    _defineProperty$r(_assertThisInitialized$r(_this), "incompatibleTokens", ["G", "y", "Y", "u", "Q", "q", "M", "L", "w", "d", "D", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass$r(ISOWeekYearParser2, [{
    key: "parse",
    value: function parse2(dateString, token) {
      if (token === "R") {
        return parseNDigitsSigned(4, dateString);
      }
      return parseNDigitsSigned(token.length, dateString);
    }
  }, {
    key: "set",
    value: function set2(_date, _flags, value) {
      var firstWeekOfYear = new Date(0);
      firstWeekOfYear.setUTCFullYear(value, 0, 4);
      firstWeekOfYear.setUTCHours(0, 0, 0, 0);
      return startOfUTCISOWeek(firstWeekOfYear);
    }
  }]);
  return ISOWeekYearParser2;
}(Parser);
function _typeof$t(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$t = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$t = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$t(obj);
}
function _classCallCheck$q(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$q(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$q(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$q(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$q(Constructor, staticProps);
  return Constructor;
}
function _inherits$q(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf$q(subClass, superClass);
}
function _setPrototypeOf$q(o2, p2) {
  _setPrototypeOf$q = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf$q(o2, p2);
}
function _createSuper$q(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$q();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$q(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$q(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$q(this, result);
  };
}
function _possibleConstructorReturn$q(self2, call) {
  if (call && (_typeof$t(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$q(self2);
}
function _assertThisInitialized$q(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$q() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$q(o2) {
  _getPrototypeOf$q = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf$q(o2);
}
function _defineProperty$q(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var ExtendedYearParser = /* @__PURE__ */ function(_Parser) {
  _inherits$q(ExtendedYearParser2, _Parser);
  var _super = _createSuper$q(ExtendedYearParser2);
  function ExtendedYearParser2() {
    var _this;
    _classCallCheck$q(this, ExtendedYearParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$q(_assertThisInitialized$q(_this), "priority", 130);
    _defineProperty$q(_assertThisInitialized$q(_this), "incompatibleTokens", ["G", "y", "Y", "R", "w", "I", "i", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass$q(ExtendedYearParser2, [{
    key: "parse",
    value: function parse2(dateString, token) {
      if (token === "u") {
        return parseNDigitsSigned(4, dateString);
      }
      return parseNDigitsSigned(token.length, dateString);
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCFullYear(value, 0, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return ExtendedYearParser2;
}(Parser);
function _typeof$s(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$s = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$s = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$s(obj);
}
function _classCallCheck$p(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$p(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$p(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$p(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$p(Constructor, staticProps);
  return Constructor;
}
function _inherits$p(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf$p(subClass, superClass);
}
function _setPrototypeOf$p(o2, p2) {
  _setPrototypeOf$p = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf$p(o2, p2);
}
function _createSuper$p(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$p();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$p(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$p(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$p(this, result);
  };
}
function _possibleConstructorReturn$p(self2, call) {
  if (call && (_typeof$s(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$p(self2);
}
function _assertThisInitialized$p(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$p() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$p(o2) {
  _getPrototypeOf$p = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf$p(o2);
}
function _defineProperty$p(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var QuarterParser = /* @__PURE__ */ function(_Parser) {
  _inherits$p(QuarterParser2, _Parser);
  var _super = _createSuper$p(QuarterParser2);
  function QuarterParser2() {
    var _this;
    _classCallCheck$p(this, QuarterParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$p(_assertThisInitialized$p(_this), "priority", 120);
    _defineProperty$p(_assertThisInitialized$p(_this), "incompatibleTokens", ["Y", "R", "q", "M", "L", "w", "I", "d", "D", "i", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass$p(QuarterParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      switch (token) {
        case "Q":
        case "QQ":
          return parseNDigits(token.length, dateString);
        case "Qo":
          return match2.ordinalNumber(dateString, {
            unit: "quarter"
          });
        case "QQQ":
          return match2.quarter(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.quarter(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "QQQQQ":
          return match2.quarter(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "QQQQ":
        default:
          return match2.quarter(dateString, {
            width: "wide",
            context: "formatting"
          }) || match2.quarter(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.quarter(dateString, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 4;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCMonth((value - 1) * 3, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return QuarterParser2;
}(Parser);
function _typeof$r(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$r = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$r = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$r(obj);
}
function _classCallCheck$o(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$o(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$o(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$o(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$o(Constructor, staticProps);
  return Constructor;
}
function _inherits$o(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf$o(subClass, superClass);
}
function _setPrototypeOf$o(o2, p2) {
  _setPrototypeOf$o = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf$o(o2, p2);
}
function _createSuper$o(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$o();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$o(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$o(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$o(this, result);
  };
}
function _possibleConstructorReturn$o(self2, call) {
  if (call && (_typeof$r(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$o(self2);
}
function _assertThisInitialized$o(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$o() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$o(o2) {
  _getPrototypeOf$o = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf$o(o2);
}
function _defineProperty$o(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var StandAloneQuarterParser = /* @__PURE__ */ function(_Parser) {
  _inherits$o(StandAloneQuarterParser2, _Parser);
  var _super = _createSuper$o(StandAloneQuarterParser2);
  function StandAloneQuarterParser2() {
    var _this;
    _classCallCheck$o(this, StandAloneQuarterParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$o(_assertThisInitialized$o(_this), "priority", 120);
    _defineProperty$o(_assertThisInitialized$o(_this), "incompatibleTokens", ["Y", "R", "Q", "M", "L", "w", "I", "d", "D", "i", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass$o(StandAloneQuarterParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      switch (token) {
        case "q":
        case "qq":
          return parseNDigits(token.length, dateString);
        case "qo":
          return match2.ordinalNumber(dateString, {
            unit: "quarter"
          });
        case "qqq":
          return match2.quarter(dateString, {
            width: "abbreviated",
            context: "standalone"
          }) || match2.quarter(dateString, {
            width: "narrow",
            context: "standalone"
          });
        case "qqqqq":
          return match2.quarter(dateString, {
            width: "narrow",
            context: "standalone"
          });
        case "qqqq":
        default:
          return match2.quarter(dateString, {
            width: "wide",
            context: "standalone"
          }) || match2.quarter(dateString, {
            width: "abbreviated",
            context: "standalone"
          }) || match2.quarter(dateString, {
            width: "narrow",
            context: "standalone"
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 4;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCMonth((value - 1) * 3, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return StandAloneQuarterParser2;
}(Parser);
function _typeof$q(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$q = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$q = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$q(obj);
}
function _classCallCheck$n(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$n(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$n(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$n(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$n(Constructor, staticProps);
  return Constructor;
}
function _inherits$n(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf$n(subClass, superClass);
}
function _setPrototypeOf$n(o2, p2) {
  _setPrototypeOf$n = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf$n(o2, p2);
}
function _createSuper$n(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$n();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$n(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$n(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$n(this, result);
  };
}
function _possibleConstructorReturn$n(self2, call) {
  if (call && (_typeof$q(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$n(self2);
}
function _assertThisInitialized$n(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$n() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$n(o2) {
  _getPrototypeOf$n = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf$n(o2);
}
function _defineProperty$n(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var MonthParser = /* @__PURE__ */ function(_Parser) {
  _inherits$n(MonthParser2, _Parser);
  var _super = _createSuper$n(MonthParser2);
  function MonthParser2() {
    var _this;
    _classCallCheck$n(this, MonthParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$n(_assertThisInitialized$n(_this), "incompatibleTokens", ["Y", "R", "q", "Q", "L", "w", "I", "D", "i", "e", "c", "t", "T"]);
    _defineProperty$n(_assertThisInitialized$n(_this), "priority", 110);
    return _this;
  }
  _createClass$n(MonthParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      var valueCallback3 = function valueCallback4(value) {
        return value - 1;
      };
      switch (token) {
        case "M":
          return mapValue(parseNumericPattern(numericPatterns.month, dateString), valueCallback3);
        case "MM":
          return mapValue(parseNDigits(2, dateString), valueCallback3);
        case "Mo":
          return mapValue(match2.ordinalNumber(dateString, {
            unit: "month"
          }), valueCallback3);
        case "MMM":
          return match2.month(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.month(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "MMMMM":
          return match2.month(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "MMMM":
        default:
          return match2.month(dateString, {
            width: "wide",
            context: "formatting"
          }) || match2.month(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.month(dateString, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 11;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCMonth(value, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return MonthParser2;
}(Parser);
function _typeof$p(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$p = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$p = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$p(obj);
}
function _classCallCheck$m(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$m(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$m(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$m(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$m(Constructor, staticProps);
  return Constructor;
}
function _inherits$m(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf$m(subClass, superClass);
}
function _setPrototypeOf$m(o2, p2) {
  _setPrototypeOf$m = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf$m(o2, p2);
}
function _createSuper$m(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$m();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$m(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$m(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$m(this, result);
  };
}
function _possibleConstructorReturn$m(self2, call) {
  if (call && (_typeof$p(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$m(self2);
}
function _assertThisInitialized$m(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$m() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$m(o2) {
  _getPrototypeOf$m = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf$m(o2);
}
function _defineProperty$m(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var StandAloneMonthParser = /* @__PURE__ */ function(_Parser) {
  _inherits$m(StandAloneMonthParser2, _Parser);
  var _super = _createSuper$m(StandAloneMonthParser2);
  function StandAloneMonthParser2() {
    var _this;
    _classCallCheck$m(this, StandAloneMonthParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$m(_assertThisInitialized$m(_this), "priority", 110);
    _defineProperty$m(_assertThisInitialized$m(_this), "incompatibleTokens", ["Y", "R", "q", "Q", "M", "w", "I", "D", "i", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass$m(StandAloneMonthParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      var valueCallback3 = function valueCallback4(value) {
        return value - 1;
      };
      switch (token) {
        case "L":
          return mapValue(parseNumericPattern(numericPatterns.month, dateString), valueCallback3);
        case "LL":
          return mapValue(parseNDigits(2, dateString), valueCallback3);
        case "Lo":
          return mapValue(match2.ordinalNumber(dateString, {
            unit: "month"
          }), valueCallback3);
        case "LLL":
          return match2.month(dateString, {
            width: "abbreviated",
            context: "standalone"
          }) || match2.month(dateString, {
            width: "narrow",
            context: "standalone"
          });
        case "LLLLL":
          return match2.month(dateString, {
            width: "narrow",
            context: "standalone"
          });
        case "LLLL":
        default:
          return match2.month(dateString, {
            width: "wide",
            context: "standalone"
          }) || match2.month(dateString, {
            width: "abbreviated",
            context: "standalone"
          }) || match2.month(dateString, {
            width: "narrow",
            context: "standalone"
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 11;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCMonth(value, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return StandAloneMonthParser2;
}(Parser);
function setUTCWeek(dirtyDate, dirtyWeek, options) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var week = toInteger(dirtyWeek);
  var diff = getUTCWeek(date, options) - week;
  date.setUTCDate(date.getUTCDate() - diff * 7);
  return date;
}
function _typeof$o(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$o = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$o = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$o(obj);
}
function _classCallCheck$l(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$l(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$l(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$l(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$l(Constructor, staticProps);
  return Constructor;
}
function _inherits$l(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf$l(subClass, superClass);
}
function _setPrototypeOf$l(o2, p2) {
  _setPrototypeOf$l = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf$l(o2, p2);
}
function _createSuper$l(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$l();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$l(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$l(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$l(this, result);
  };
}
function _possibleConstructorReturn$l(self2, call) {
  if (call && (_typeof$o(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$l(self2);
}
function _assertThisInitialized$l(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$l() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$l(o2) {
  _getPrototypeOf$l = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf$l(o2);
}
function _defineProperty$l(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var LocalWeekParser = /* @__PURE__ */ function(_Parser) {
  _inherits$l(LocalWeekParser2, _Parser);
  var _super = _createSuper$l(LocalWeekParser2);
  function LocalWeekParser2() {
    var _this;
    _classCallCheck$l(this, LocalWeekParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$l(_assertThisInitialized$l(_this), "priority", 100);
    _defineProperty$l(_assertThisInitialized$l(_this), "incompatibleTokens", ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "i", "t", "T"]);
    return _this;
  }
  _createClass$l(LocalWeekParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      switch (token) {
        case "w":
          return parseNumericPattern(numericPatterns.week, dateString);
        case "wo":
          return match2.ordinalNumber(dateString, {
            unit: "week"
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 53;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value, options) {
      return startOfUTCWeek(setUTCWeek(date, value, options), options);
    }
  }]);
  return LocalWeekParser2;
}(Parser);
function setUTCISOWeek(dirtyDate, dirtyISOWeek) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var isoWeek = toInteger(dirtyISOWeek);
  var diff = getUTCISOWeek(date) - isoWeek;
  date.setUTCDate(date.getUTCDate() - diff * 7);
  return date;
}
function _typeof$n(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$n = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$n = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$n(obj);
}
function _classCallCheck$k(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$k(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$k(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$k(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$k(Constructor, staticProps);
  return Constructor;
}
function _inherits$k(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf$k(subClass, superClass);
}
function _setPrototypeOf$k(o2, p2) {
  _setPrototypeOf$k = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf$k(o2, p2);
}
function _createSuper$k(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$k();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$k(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$k(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$k(this, result);
  };
}
function _possibleConstructorReturn$k(self2, call) {
  if (call && (_typeof$n(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$k(self2);
}
function _assertThisInitialized$k(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$k() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$k(o2) {
  _getPrototypeOf$k = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf$k(o2);
}
function _defineProperty$k(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var ISOWeekParser = /* @__PURE__ */ function(_Parser) {
  _inherits$k(ISOWeekParser2, _Parser);
  var _super = _createSuper$k(ISOWeekParser2);
  function ISOWeekParser2() {
    var _this;
    _classCallCheck$k(this, ISOWeekParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$k(_assertThisInitialized$k(_this), "priority", 100);
    _defineProperty$k(_assertThisInitialized$k(_this), "incompatibleTokens", ["y", "Y", "u", "q", "Q", "M", "L", "w", "d", "D", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass$k(ISOWeekParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      switch (token) {
        case "I":
          return parseNumericPattern(numericPatterns.week, dateString);
        case "Io":
          return match2.ordinalNumber(dateString, {
            unit: "week"
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 53;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      return startOfUTCISOWeek(setUTCISOWeek(date, value));
    }
  }]);
  return ISOWeekParser2;
}(Parser);
function _typeof$m(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$m = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$m = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$m(obj);
}
function _classCallCheck$j(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$j(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$j(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$j(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$j(Constructor, staticProps);
  return Constructor;
}
function _inherits$j(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf$j(subClass, superClass);
}
function _setPrototypeOf$j(o2, p2) {
  _setPrototypeOf$j = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf$j(o2, p2);
}
function _createSuper$j(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$j();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$j(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$j(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$j(this, result);
  };
}
function _possibleConstructorReturn$j(self2, call) {
  if (call && (_typeof$m(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$j(self2);
}
function _assertThisInitialized$j(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$j() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$j(o2) {
  _getPrototypeOf$j = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf$j(o2);
}
function _defineProperty$j(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var DAYS_IN_MONTH_LEAP_YEAR = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var DateParser = /* @__PURE__ */ function(_Parser) {
  _inherits$j(DateParser2, _Parser);
  var _super = _createSuper$j(DateParser2);
  function DateParser2() {
    var _this;
    _classCallCheck$j(this, DateParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$j(_assertThisInitialized$j(_this), "priority", 90);
    _defineProperty$j(_assertThisInitialized$j(_this), "subPriority", 1);
    _defineProperty$j(_assertThisInitialized$j(_this), "incompatibleTokens", ["Y", "R", "q", "Q", "w", "I", "D", "i", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass$j(DateParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      switch (token) {
        case "d":
          return parseNumericPattern(numericPatterns.date, dateString);
        case "do":
          return match2.ordinalNumber(dateString, {
            unit: "date"
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(date, value) {
      var year = date.getUTCFullYear();
      var isLeapYear = isLeapYearIndex$1(year);
      var month = date.getUTCMonth();
      if (isLeapYear) {
        return value >= 1 && value <= DAYS_IN_MONTH_LEAP_YEAR[month];
      } else {
        return value >= 1 && value <= DAYS_IN_MONTH[month];
      }
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCDate(value);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return DateParser2;
}(Parser);
function _typeof$l(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$l = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$l = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$l(obj);
}
function _classCallCheck$i(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$i(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$i(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$i(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$i(Constructor, staticProps);
  return Constructor;
}
function _inherits$i(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf$i(subClass, superClass);
}
function _setPrototypeOf$i(o2, p2) {
  _setPrototypeOf$i = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf$i(o2, p2);
}
function _createSuper$i(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$i();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$i(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$i(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$i(this, result);
  };
}
function _possibleConstructorReturn$i(self2, call) {
  if (call && (_typeof$l(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$i(self2);
}
function _assertThisInitialized$i(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$i() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$i(o2) {
  _getPrototypeOf$i = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf$i(o2);
}
function _defineProperty$i(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var DayOfYearParser = /* @__PURE__ */ function(_Parser) {
  _inherits$i(DayOfYearParser2, _Parser);
  var _super = _createSuper$i(DayOfYearParser2);
  function DayOfYearParser2() {
    var _this;
    _classCallCheck$i(this, DayOfYearParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$i(_assertThisInitialized$i(_this), "priority", 90);
    _defineProperty$i(_assertThisInitialized$i(_this), "subpriority", 1);
    _defineProperty$i(_assertThisInitialized$i(_this), "incompatibleTokens", ["Y", "R", "q", "Q", "M", "L", "w", "I", "d", "E", "i", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass$i(DayOfYearParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      switch (token) {
        case "D":
        case "DD":
          return parseNumericPattern(numericPatterns.dayOfYear, dateString);
        case "Do":
          return match2.ordinalNumber(dateString, {
            unit: "date"
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(date, value) {
      var year = date.getUTCFullYear();
      var isLeapYear = isLeapYearIndex$1(year);
      if (isLeapYear) {
        return value >= 1 && value <= 366;
      } else {
        return value >= 1 && value <= 365;
      }
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCMonth(0, value);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return DayOfYearParser2;
}(Parser);
function setUTCDay(dirtyDate, dirtyDay, options) {
  var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(2, arguments);
  var defaultOptions2 = getDefaultOptions();
  var weekStartsOn = toInteger((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  var date = toDate(dirtyDate);
  var day = toInteger(dirtyDay);
  var currentDay = date.getUTCDay();
  var remainder = day % 7;
  var dayIndex = (remainder + 7) % 7;
  var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
  date.setUTCDate(date.getUTCDate() + diff);
  return date;
}
function _typeof$k(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$k = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$k = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$k(obj);
}
function _classCallCheck$h(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$h(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$h(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$h(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$h(Constructor, staticProps);
  return Constructor;
}
function _inherits$h(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf$h(subClass, superClass);
}
function _setPrototypeOf$h(o2, p2) {
  _setPrototypeOf$h = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf$h(o2, p2);
}
function _createSuper$h(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$h();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$h(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$h(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$h(this, result);
  };
}
function _possibleConstructorReturn$h(self2, call) {
  if (call && (_typeof$k(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$h(self2);
}
function _assertThisInitialized$h(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$h() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$h(o2) {
  _getPrototypeOf$h = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf$h(o2);
}
function _defineProperty$h(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var DayParser = /* @__PURE__ */ function(_Parser) {
  _inherits$h(DayParser2, _Parser);
  var _super = _createSuper$h(DayParser2);
  function DayParser2() {
    var _this;
    _classCallCheck$h(this, DayParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$h(_assertThisInitialized$h(_this), "priority", 90);
    _defineProperty$h(_assertThisInitialized$h(_this), "incompatibleTokens", ["D", "i", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass$h(DayParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      switch (token) {
        case "E":
        case "EE":
        case "EEE":
          return match2.day(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "EEEEE":
          return match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "EEEEEE":
          return match2.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "EEEE":
        default:
          return match2.day(dateString, {
            width: "wide",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 6;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value, options) {
      date = setUTCDay(date, value, options);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return DayParser2;
}(Parser);
function _typeof$j(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$j = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$j = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$j(obj);
}
function _classCallCheck$g(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$g(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$g(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$g(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$g(Constructor, staticProps);
  return Constructor;
}
function _inherits$g(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf$g(subClass, superClass);
}
function _setPrototypeOf$g(o2, p2) {
  _setPrototypeOf$g = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf$g(o2, p2);
}
function _createSuper$g(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$g();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$g(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$g(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$g(this, result);
  };
}
function _possibleConstructorReturn$g(self2, call) {
  if (call && (_typeof$j(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$g(self2);
}
function _assertThisInitialized$g(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$g() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$g(o2) {
  _getPrototypeOf$g = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf$g(o2);
}
function _defineProperty$g(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var LocalDayParser = /* @__PURE__ */ function(_Parser) {
  _inherits$g(LocalDayParser2, _Parser);
  var _super = _createSuper$g(LocalDayParser2);
  function LocalDayParser2() {
    var _this;
    _classCallCheck$g(this, LocalDayParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$g(_assertThisInitialized$g(_this), "priority", 90);
    _defineProperty$g(_assertThisInitialized$g(_this), "incompatibleTokens", ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "E", "i", "c", "t", "T"]);
    return _this;
  }
  _createClass$g(LocalDayParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2, options) {
      var valueCallback3 = function valueCallback4(value) {
        var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
        return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
      };
      switch (token) {
        case "e":
        case "ee":
          return mapValue(parseNDigits(token.length, dateString), valueCallback3);
        case "eo":
          return mapValue(match2.ordinalNumber(dateString, {
            unit: "day"
          }), valueCallback3);
        case "eee":
          return match2.day(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "eeeee":
          return match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "eeeeee":
          return match2.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "eeee":
        default:
          return match2.day(dateString, {
            width: "wide",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 6;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value, options) {
      date = setUTCDay(date, value, options);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return LocalDayParser2;
}(Parser);
function _typeof$i(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$i = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$i = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$i(obj);
}
function _classCallCheck$f(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$f(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$f(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$f(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$f(Constructor, staticProps);
  return Constructor;
}
function _inherits$f(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf$f(subClass, superClass);
}
function _setPrototypeOf$f(o2, p2) {
  _setPrototypeOf$f = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf$f(o2, p2);
}
function _createSuper$f(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$f();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$f(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$f(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$f(this, result);
  };
}
function _possibleConstructorReturn$f(self2, call) {
  if (call && (_typeof$i(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$f(self2);
}
function _assertThisInitialized$f(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$f() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$f(o2) {
  _getPrototypeOf$f = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf$f(o2);
}
function _defineProperty$f(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var StandAloneLocalDayParser = /* @__PURE__ */ function(_Parser) {
  _inherits$f(StandAloneLocalDayParser2, _Parser);
  var _super = _createSuper$f(StandAloneLocalDayParser2);
  function StandAloneLocalDayParser2() {
    var _this;
    _classCallCheck$f(this, StandAloneLocalDayParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$f(_assertThisInitialized$f(_this), "priority", 90);
    _defineProperty$f(_assertThisInitialized$f(_this), "incompatibleTokens", ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "E", "i", "e", "t", "T"]);
    return _this;
  }
  _createClass$f(StandAloneLocalDayParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2, options) {
      var valueCallback3 = function valueCallback4(value) {
        var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
        return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
      };
      switch (token) {
        case "c":
        case "cc":
          return mapValue(parseNDigits(token.length, dateString), valueCallback3);
        case "co":
          return mapValue(match2.ordinalNumber(dateString, {
            unit: "day"
          }), valueCallback3);
        case "ccc":
          return match2.day(dateString, {
            width: "abbreviated",
            context: "standalone"
          }) || match2.day(dateString, {
            width: "short",
            context: "standalone"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "standalone"
          });
        case "ccccc":
          return match2.day(dateString, {
            width: "narrow",
            context: "standalone"
          });
        case "cccccc":
          return match2.day(dateString, {
            width: "short",
            context: "standalone"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "standalone"
          });
        case "cccc":
        default:
          return match2.day(dateString, {
            width: "wide",
            context: "standalone"
          }) || match2.day(dateString, {
            width: "abbreviated",
            context: "standalone"
          }) || match2.day(dateString, {
            width: "short",
            context: "standalone"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "standalone"
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 6;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value, options) {
      date = setUTCDay(date, value, options);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return StandAloneLocalDayParser2;
}(Parser);
function setUTCISODay(dirtyDate, dirtyDay) {
  requiredArgs(2, arguments);
  var day = toInteger(dirtyDay);
  if (day % 7 === 0) {
    day = day - 7;
  }
  var weekStartsOn = 1;
  var date = toDate(dirtyDate);
  var currentDay = date.getUTCDay();
  var remainder = day % 7;
  var dayIndex = (remainder + 7) % 7;
  var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
  date.setUTCDate(date.getUTCDate() + diff);
  return date;
}
function _typeof$h(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$h = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$h = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$h(obj);
}
function _classCallCheck$e(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$e(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$e(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$e(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$e(Constructor, staticProps);
  return Constructor;
}
function _inherits$e(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf$e(subClass, superClass);
}
function _setPrototypeOf$e(o2, p2) {
  _setPrototypeOf$e = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf$e(o2, p2);
}
function _createSuper$e(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$e();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$e(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$e(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$e(this, result);
  };
}
function _possibleConstructorReturn$e(self2, call) {
  if (call && (_typeof$h(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$e(self2);
}
function _assertThisInitialized$e(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$e() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$e(o2) {
  _getPrototypeOf$e = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf$e(o2);
}
function _defineProperty$e(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var ISODayParser = /* @__PURE__ */ function(_Parser) {
  _inherits$e(ISODayParser2, _Parser);
  var _super = _createSuper$e(ISODayParser2);
  function ISODayParser2() {
    var _this;
    _classCallCheck$e(this, ISODayParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$e(_assertThisInitialized$e(_this), "priority", 90);
    _defineProperty$e(_assertThisInitialized$e(_this), "incompatibleTokens", ["y", "Y", "u", "q", "Q", "M", "L", "w", "d", "D", "E", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass$e(ISODayParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      var valueCallback3 = function valueCallback4(value) {
        if (value === 0) {
          return 7;
        }
        return value;
      };
      switch (token) {
        case "i":
        case "ii":
          return parseNDigits(token.length, dateString);
        case "io":
          return match2.ordinalNumber(dateString, {
            unit: "day"
          });
        case "iii":
          return mapValue(match2.day(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          }), valueCallback3);
        case "iiiii":
          return mapValue(match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          }), valueCallback3);
        case "iiiiii":
          return mapValue(match2.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          }), valueCallback3);
        case "iiii":
        default:
          return mapValue(match2.day(dateString, {
            width: "wide",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          }), valueCallback3);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 7;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date = setUTCISODay(date, value);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return ISODayParser2;
}(Parser);
function _typeof$g(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$g = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$g = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$g(obj);
}
function _classCallCheck$d(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$d(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$d(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$d(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$d(Constructor, staticProps);
  return Constructor;
}
function _inherits$d(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf$d(subClass, superClass);
}
function _setPrototypeOf$d(o2, p2) {
  _setPrototypeOf$d = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf$d(o2, p2);
}
function _createSuper$d(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$d();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$d(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$d(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$d(this, result);
  };
}
function _possibleConstructorReturn$d(self2, call) {
  if (call && (_typeof$g(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$d(self2);
}
function _assertThisInitialized$d(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$d() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$d(o2) {
  _getPrototypeOf$d = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf$d(o2);
}
function _defineProperty$d(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var AMPMParser = /* @__PURE__ */ function(_Parser) {
  _inherits$d(AMPMParser2, _Parser);
  var _super = _createSuper$d(AMPMParser2);
  function AMPMParser2() {
    var _this;
    _classCallCheck$d(this, AMPMParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$d(_assertThisInitialized$d(_this), "priority", 80);
    _defineProperty$d(_assertThisInitialized$d(_this), "incompatibleTokens", ["b", "B", "H", "k", "t", "T"]);
    return _this;
  }
  _createClass$d(AMPMParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      switch (token) {
        case "a":
        case "aa":
        case "aaa":
          return match2.dayPeriod(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "aaaaa":
          return match2.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "aaaa":
        default:
          return match2.dayPeriod(dateString, {
            width: "wide",
            context: "formatting"
          }) || match2.dayPeriod(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
      return date;
    }
  }]);
  return AMPMParser2;
}(Parser);
function _typeof$f(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$f = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$f = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$f(obj);
}
function _classCallCheck$c(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$c(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$c(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$c(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$c(Constructor, staticProps);
  return Constructor;
}
function _inherits$c(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf$c(subClass, superClass);
}
function _setPrototypeOf$c(o2, p2) {
  _setPrototypeOf$c = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf$c(o2, p2);
}
function _createSuper$c(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$c();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$c(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$c(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$c(this, result);
  };
}
function _possibleConstructorReturn$c(self2, call) {
  if (call && (_typeof$f(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$c(self2);
}
function _assertThisInitialized$c(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$c() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$c(o2) {
  _getPrototypeOf$c = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf$c(o2);
}
function _defineProperty$c(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var AMPMMidnightParser = /* @__PURE__ */ function(_Parser) {
  _inherits$c(AMPMMidnightParser2, _Parser);
  var _super = _createSuper$c(AMPMMidnightParser2);
  function AMPMMidnightParser2() {
    var _this;
    _classCallCheck$c(this, AMPMMidnightParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$c(_assertThisInitialized$c(_this), "priority", 80);
    _defineProperty$c(_assertThisInitialized$c(_this), "incompatibleTokens", ["a", "B", "H", "k", "t", "T"]);
    return _this;
  }
  _createClass$c(AMPMMidnightParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      switch (token) {
        case "b":
        case "bb":
        case "bbb":
          return match2.dayPeriod(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "bbbbb":
          return match2.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "bbbb":
        default:
          return match2.dayPeriod(dateString, {
            width: "wide",
            context: "formatting"
          }) || match2.dayPeriod(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
      return date;
    }
  }]);
  return AMPMMidnightParser2;
}(Parser);
function _typeof$e(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$e = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$e = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$e(obj);
}
function _classCallCheck$b(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$b(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$b(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$b(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$b(Constructor, staticProps);
  return Constructor;
}
function _inherits$b(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf$b(subClass, superClass);
}
function _setPrototypeOf$b(o2, p2) {
  _setPrototypeOf$b = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf$b(o2, p2);
}
function _createSuper$b(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$b();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$b(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$b(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$b(this, result);
  };
}
function _possibleConstructorReturn$b(self2, call) {
  if (call && (_typeof$e(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$b(self2);
}
function _assertThisInitialized$b(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$b() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$b(o2) {
  _getPrototypeOf$b = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf$b(o2);
}
function _defineProperty$b(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var DayPeriodParser = /* @__PURE__ */ function(_Parser) {
  _inherits$b(DayPeriodParser2, _Parser);
  var _super = _createSuper$b(DayPeriodParser2);
  function DayPeriodParser2() {
    var _this;
    _classCallCheck$b(this, DayPeriodParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$b(_assertThisInitialized$b(_this), "priority", 80);
    _defineProperty$b(_assertThisInitialized$b(_this), "incompatibleTokens", ["a", "b", "t", "T"]);
    return _this;
  }
  _createClass$b(DayPeriodParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      switch (token) {
        case "B":
        case "BB":
        case "BBB":
          return match2.dayPeriod(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "BBBBB":
          return match2.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "BBBB":
        default:
          return match2.dayPeriod(dateString, {
            width: "wide",
            context: "formatting"
          }) || match2.dayPeriod(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
      return date;
    }
  }]);
  return DayPeriodParser2;
}(Parser);
function _typeof$d(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$d = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$d = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$d(obj);
}
function _classCallCheck$a(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$a(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$a(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$a(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$a(Constructor, staticProps);
  return Constructor;
}
function _inherits$a(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf$a(subClass, superClass);
}
function _setPrototypeOf$a(o2, p2) {
  _setPrototypeOf$a = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf$a(o2, p2);
}
function _createSuper$a(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$a();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$a(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$a(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$a(this, result);
  };
}
function _possibleConstructorReturn$a(self2, call) {
  if (call && (_typeof$d(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$a(self2);
}
function _assertThisInitialized$a(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$a() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$a(o2) {
  _getPrototypeOf$a = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf$a(o2);
}
function _defineProperty$a(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var Hour1to12Parser = /* @__PURE__ */ function(_Parser) {
  _inherits$a(Hour1to12Parser2, _Parser);
  var _super = _createSuper$a(Hour1to12Parser2);
  function Hour1to12Parser2() {
    var _this;
    _classCallCheck$a(this, Hour1to12Parser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$a(_assertThisInitialized$a(_this), "priority", 70);
    _defineProperty$a(_assertThisInitialized$a(_this), "incompatibleTokens", ["H", "K", "k", "t", "T"]);
    return _this;
  }
  _createClass$a(Hour1to12Parser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      switch (token) {
        case "h":
          return parseNumericPattern(numericPatterns.hour12h, dateString);
        case "ho":
          return match2.ordinalNumber(dateString, {
            unit: "hour"
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 12;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      var isPM = date.getUTCHours() >= 12;
      if (isPM && value < 12) {
        date.setUTCHours(value + 12, 0, 0, 0);
      } else if (!isPM && value === 12) {
        date.setUTCHours(0, 0, 0, 0);
      } else {
        date.setUTCHours(value, 0, 0, 0);
      }
      return date;
    }
  }]);
  return Hour1to12Parser2;
}(Parser);
function _typeof$c(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$c = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$c = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$c(obj);
}
function _classCallCheck$9(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$9(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$9(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$9(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$9(Constructor, staticProps);
  return Constructor;
}
function _inherits$9(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf$9(subClass, superClass);
}
function _setPrototypeOf$9(o2, p2) {
  _setPrototypeOf$9 = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf$9(o2, p2);
}
function _createSuper$9(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$9();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$9(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$9(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$9(this, result);
  };
}
function _possibleConstructorReturn$9(self2, call) {
  if (call && (_typeof$c(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$9(self2);
}
function _assertThisInitialized$9(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$9() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$9(o2) {
  _getPrototypeOf$9 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf$9(o2);
}
function _defineProperty$9(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var Hour0to23Parser = /* @__PURE__ */ function(_Parser) {
  _inherits$9(Hour0to23Parser2, _Parser);
  var _super = _createSuper$9(Hour0to23Parser2);
  function Hour0to23Parser2() {
    var _this;
    _classCallCheck$9(this, Hour0to23Parser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$9(_assertThisInitialized$9(_this), "priority", 70);
    _defineProperty$9(_assertThisInitialized$9(_this), "incompatibleTokens", ["a", "b", "h", "K", "k", "t", "T"]);
    return _this;
  }
  _createClass$9(Hour0to23Parser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      switch (token) {
        case "H":
          return parseNumericPattern(numericPatterns.hour23h, dateString);
        case "Ho":
          return match2.ordinalNumber(dateString, {
            unit: "hour"
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 23;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCHours(value, 0, 0, 0);
      return date;
    }
  }]);
  return Hour0to23Parser2;
}(Parser);
function _typeof$b(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$b = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$b = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$b(obj);
}
function _classCallCheck$8(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$8(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$8(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$8(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$8(Constructor, staticProps);
  return Constructor;
}
function _inherits$8(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf$8(subClass, superClass);
}
function _setPrototypeOf$8(o2, p2) {
  _setPrototypeOf$8 = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf$8(o2, p2);
}
function _createSuper$8(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$8();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$8(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$8(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$8(this, result);
  };
}
function _possibleConstructorReturn$8(self2, call) {
  if (call && (_typeof$b(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$8(self2);
}
function _assertThisInitialized$8(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$8() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$8(o2) {
  _getPrototypeOf$8 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf$8(o2);
}
function _defineProperty$8(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var Hour0To11Parser = /* @__PURE__ */ function(_Parser) {
  _inherits$8(Hour0To11Parser2, _Parser);
  var _super = _createSuper$8(Hour0To11Parser2);
  function Hour0To11Parser2() {
    var _this;
    _classCallCheck$8(this, Hour0To11Parser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$8(_assertThisInitialized$8(_this), "priority", 70);
    _defineProperty$8(_assertThisInitialized$8(_this), "incompatibleTokens", ["h", "H", "k", "t", "T"]);
    return _this;
  }
  _createClass$8(Hour0To11Parser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      switch (token) {
        case "K":
          return parseNumericPattern(numericPatterns.hour11h, dateString);
        case "Ko":
          return match2.ordinalNumber(dateString, {
            unit: "hour"
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 11;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      var isPM = date.getUTCHours() >= 12;
      if (isPM && value < 12) {
        date.setUTCHours(value + 12, 0, 0, 0);
      } else {
        date.setUTCHours(value, 0, 0, 0);
      }
      return date;
    }
  }]);
  return Hour0To11Parser2;
}(Parser);
function _typeof$a(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$a = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$a = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$a(obj);
}
function _classCallCheck$7(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$7(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$7(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$7(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$7(Constructor, staticProps);
  return Constructor;
}
function _inherits$7(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf$7(subClass, superClass);
}
function _setPrototypeOf$7(o2, p2) {
  _setPrototypeOf$7 = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf$7(o2, p2);
}
function _createSuper$7(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$7();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$7(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$7(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$7(this, result);
  };
}
function _possibleConstructorReturn$7(self2, call) {
  if (call && (_typeof$a(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$7(self2);
}
function _assertThisInitialized$7(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$7() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$7(o2) {
  _getPrototypeOf$7 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf$7(o2);
}
function _defineProperty$7(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var Hour1To24Parser = /* @__PURE__ */ function(_Parser) {
  _inherits$7(Hour1To24Parser2, _Parser);
  var _super = _createSuper$7(Hour1To24Parser2);
  function Hour1To24Parser2() {
    var _this;
    _classCallCheck$7(this, Hour1To24Parser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$7(_assertThisInitialized$7(_this), "priority", 70);
    _defineProperty$7(_assertThisInitialized$7(_this), "incompatibleTokens", ["a", "b", "h", "H", "K", "t", "T"]);
    return _this;
  }
  _createClass$7(Hour1To24Parser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      switch (token) {
        case "k":
          return parseNumericPattern(numericPatterns.hour24h, dateString);
        case "ko":
          return match2.ordinalNumber(dateString, {
            unit: "hour"
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 24;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      var hours = value <= 24 ? value % 24 : value;
      date.setUTCHours(hours, 0, 0, 0);
      return date;
    }
  }]);
  return Hour1To24Parser2;
}(Parser);
function _typeof$9(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$9 = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$9 = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$9(obj);
}
function _classCallCheck$6(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$6(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$6(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$6(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$6(Constructor, staticProps);
  return Constructor;
}
function _inherits$6(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf$6(subClass, superClass);
}
function _setPrototypeOf$6(o2, p2) {
  _setPrototypeOf$6 = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf$6(o2, p2);
}
function _createSuper$6(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$6();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$6(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$6(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$6(this, result);
  };
}
function _possibleConstructorReturn$6(self2, call) {
  if (call && (_typeof$9(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$6(self2);
}
function _assertThisInitialized$6(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$6() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$6(o2) {
  _getPrototypeOf$6 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf$6(o2);
}
function _defineProperty$6(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var MinuteParser = /* @__PURE__ */ function(_Parser) {
  _inherits$6(MinuteParser2, _Parser);
  var _super = _createSuper$6(MinuteParser2);
  function MinuteParser2() {
    var _this;
    _classCallCheck$6(this, MinuteParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$6(_assertThisInitialized$6(_this), "priority", 60);
    _defineProperty$6(_assertThisInitialized$6(_this), "incompatibleTokens", ["t", "T"]);
    return _this;
  }
  _createClass$6(MinuteParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      switch (token) {
        case "m":
          return parseNumericPattern(numericPatterns.minute, dateString);
        case "mo":
          return match2.ordinalNumber(dateString, {
            unit: "minute"
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 59;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCMinutes(value, 0, 0);
      return date;
    }
  }]);
  return MinuteParser2;
}(Parser);
function _typeof$8(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$8 = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$8 = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$8(obj);
}
function _classCallCheck$5(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$5(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$5(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$5(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$5(Constructor, staticProps);
  return Constructor;
}
function _inherits$5(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf$5(subClass, superClass);
}
function _setPrototypeOf$5(o2, p2) {
  _setPrototypeOf$5 = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf$5(o2, p2);
}
function _createSuper$5(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$5();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$5(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$5(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$5(this, result);
  };
}
function _possibleConstructorReturn$5(self2, call) {
  if (call && (_typeof$8(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$5(self2);
}
function _assertThisInitialized$5(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$5() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$5(o2) {
  _getPrototypeOf$5 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf$5(o2);
}
function _defineProperty$5(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var SecondParser = /* @__PURE__ */ function(_Parser) {
  _inherits$5(SecondParser2, _Parser);
  var _super = _createSuper$5(SecondParser2);
  function SecondParser2() {
    var _this;
    _classCallCheck$5(this, SecondParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$5(_assertThisInitialized$5(_this), "priority", 50);
    _defineProperty$5(_assertThisInitialized$5(_this), "incompatibleTokens", ["t", "T"]);
    return _this;
  }
  _createClass$5(SecondParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      switch (token) {
        case "s":
          return parseNumericPattern(numericPatterns.second, dateString);
        case "so":
          return match2.ordinalNumber(dateString, {
            unit: "second"
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 59;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCSeconds(value, 0);
      return date;
    }
  }]);
  return SecondParser2;
}(Parser);
function _typeof$7(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$7 = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$7 = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$7(obj);
}
function _classCallCheck$4(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$4(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$4(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$4(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$4(Constructor, staticProps);
  return Constructor;
}
function _inherits$4(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf$4(subClass, superClass);
}
function _setPrototypeOf$4(o2, p2) {
  _setPrototypeOf$4 = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf$4(o2, p2);
}
function _createSuper$4(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$4();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$4(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$4(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$4(this, result);
  };
}
function _possibleConstructorReturn$4(self2, call) {
  if (call && (_typeof$7(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$4(self2);
}
function _assertThisInitialized$4(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$4() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$4(o2) {
  _getPrototypeOf$4 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf$4(o2);
}
function _defineProperty$4(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var FractionOfSecondParser = /* @__PURE__ */ function(_Parser) {
  _inherits$4(FractionOfSecondParser2, _Parser);
  var _super = _createSuper$4(FractionOfSecondParser2);
  function FractionOfSecondParser2() {
    var _this;
    _classCallCheck$4(this, FractionOfSecondParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$4(_assertThisInitialized$4(_this), "priority", 30);
    _defineProperty$4(_assertThisInitialized$4(_this), "incompatibleTokens", ["t", "T"]);
    return _this;
  }
  _createClass$4(FractionOfSecondParser2, [{
    key: "parse",
    value: function parse2(dateString, token) {
      var valueCallback3 = function valueCallback4(value) {
        return Math.floor(value * Math.pow(10, -token.length + 3));
      };
      return mapValue(parseNDigits(token.length, dateString), valueCallback3);
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCMilliseconds(value);
      return date;
    }
  }]);
  return FractionOfSecondParser2;
}(Parser);
function _typeof$6(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$6 = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$6 = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$6(obj);
}
function _classCallCheck$3(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$3(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$3(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$3(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$3(Constructor, staticProps);
  return Constructor;
}
function _inherits$3(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf$3(subClass, superClass);
}
function _setPrototypeOf$3(o2, p2) {
  _setPrototypeOf$3 = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf$3(o2, p2);
}
function _createSuper$3(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$3();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$3(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$3(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$3(this, result);
  };
}
function _possibleConstructorReturn$3(self2, call) {
  if (call && (_typeof$6(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$3(self2);
}
function _assertThisInitialized$3(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$3() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$3(o2) {
  _getPrototypeOf$3 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf$3(o2);
}
function _defineProperty$3(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var ISOTimezoneWithZParser = /* @__PURE__ */ function(_Parser) {
  _inherits$3(ISOTimezoneWithZParser2, _Parser);
  var _super = _createSuper$3(ISOTimezoneWithZParser2);
  function ISOTimezoneWithZParser2() {
    var _this;
    _classCallCheck$3(this, ISOTimezoneWithZParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$3(_assertThisInitialized$3(_this), "priority", 10);
    _defineProperty$3(_assertThisInitialized$3(_this), "incompatibleTokens", ["t", "T", "x"]);
    return _this;
  }
  _createClass$3(ISOTimezoneWithZParser2, [{
    key: "parse",
    value: function parse2(dateString, token) {
      switch (token) {
        case "X":
          return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, dateString);
        case "XX":
          return parseTimezonePattern(timezonePatterns.basic, dateString);
        case "XXXX":
          return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, dateString);
        case "XXXXX":
          return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, dateString);
        case "XXX":
        default:
          return parseTimezonePattern(timezonePatterns.extended, dateString);
      }
    }
  }, {
    key: "set",
    value: function set2(date, flags, value) {
      if (flags.timestampIsSet) {
        return date;
      }
      return new Date(date.getTime() - value);
    }
  }]);
  return ISOTimezoneWithZParser2;
}(Parser);
function _typeof$5(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$5 = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$5 = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$5(obj);
}
function _classCallCheck$2(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$2(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$2(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$2(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$2(Constructor, staticProps);
  return Constructor;
}
function _inherits$2(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf$2(subClass, superClass);
}
function _setPrototypeOf$2(o2, p2) {
  _setPrototypeOf$2 = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf$2(o2, p2);
}
function _createSuper$2(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$2();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$2(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$2(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$2(this, result);
  };
}
function _possibleConstructorReturn$2(self2, call) {
  if (call && (_typeof$5(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$2(self2);
}
function _assertThisInitialized$2(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$2() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$2(o2) {
  _getPrototypeOf$2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf$2(o2);
}
function _defineProperty$2(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var ISOTimezoneParser = /* @__PURE__ */ function(_Parser) {
  _inherits$2(ISOTimezoneParser2, _Parser);
  var _super = _createSuper$2(ISOTimezoneParser2);
  function ISOTimezoneParser2() {
    var _this;
    _classCallCheck$2(this, ISOTimezoneParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$2(_assertThisInitialized$2(_this), "priority", 10);
    _defineProperty$2(_assertThisInitialized$2(_this), "incompatibleTokens", ["t", "T", "X"]);
    return _this;
  }
  _createClass$2(ISOTimezoneParser2, [{
    key: "parse",
    value: function parse2(dateString, token) {
      switch (token) {
        case "x":
          return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, dateString);
        case "xx":
          return parseTimezonePattern(timezonePatterns.basic, dateString);
        case "xxxx":
          return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, dateString);
        case "xxxxx":
          return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, dateString);
        case "xxx":
        default:
          return parseTimezonePattern(timezonePatterns.extended, dateString);
      }
    }
  }, {
    key: "set",
    value: function set2(date, flags, value) {
      if (flags.timestampIsSet) {
        return date;
      }
      return new Date(date.getTime() - value);
    }
  }]);
  return ISOTimezoneParser2;
}(Parser);
function _typeof$4(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$4 = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$4 = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$4(obj);
}
function _classCallCheck$1(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1(Constructor, staticProps);
  return Constructor;
}
function _inherits$1(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf$1(subClass, superClass);
}
function _setPrototypeOf$1(o2, p2) {
  _setPrototypeOf$1 = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf$1(o2, p2);
}
function _createSuper$1(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$1(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$1(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$1(this, result);
  };
}
function _possibleConstructorReturn$1(self2, call) {
  if (call && (_typeof$4(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$1(self2);
}
function _assertThisInitialized$1(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$1() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$1(o2) {
  _getPrototypeOf$1 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf$1(o2);
}
function _defineProperty$1(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var TimestampSecondsParser = /* @__PURE__ */ function(_Parser) {
  _inherits$1(TimestampSecondsParser2, _Parser);
  var _super = _createSuper$1(TimestampSecondsParser2);
  function TimestampSecondsParser2() {
    var _this;
    _classCallCheck$1(this, TimestampSecondsParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$1(_assertThisInitialized$1(_this), "priority", 40);
    _defineProperty$1(_assertThisInitialized$1(_this), "incompatibleTokens", "*");
    return _this;
  }
  _createClass$1(TimestampSecondsParser2, [{
    key: "parse",
    value: function parse2(dateString) {
      return parseAnyDigitsSigned(dateString);
    }
  }, {
    key: "set",
    value: function set2(_date, _flags, value) {
      return [new Date(value * 1e3), {
        timestampIsSet: true
      }];
    }
  }]);
  return TimestampSecondsParser2;
}(Parser);
function _typeof$3(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$3 = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$3 = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$3(obj);
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  return Constructor;
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o2, p2) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  };
  return _setPrototypeOf(o2, p2);
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _possibleConstructorReturn(self2, call) {
  if (call && (_typeof$3(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized(self2);
}
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf(o2) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o3) {
    return o3.__proto__ || Object.getPrototypeOf(o3);
  };
  return _getPrototypeOf(o2);
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var TimestampMillisecondsParser = /* @__PURE__ */ function(_Parser) {
  _inherits(TimestampMillisecondsParser2, _Parser);
  var _super = _createSuper(TimestampMillisecondsParser2);
  function TimestampMillisecondsParser2() {
    var _this;
    _classCallCheck(this, TimestampMillisecondsParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 20);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", "*");
    return _this;
  }
  _createClass(TimestampMillisecondsParser2, [{
    key: "parse",
    value: function parse2(dateString) {
      return parseAnyDigitsSigned(dateString);
    }
  }, {
    key: "set",
    value: function set2(_date, _flags, value) {
      return [new Date(value), {
        timestampIsSet: true
      }];
    }
  }]);
  return TimestampMillisecondsParser2;
}(Parser);
var parsers = {
  G: new EraParser(),
  y: new YearParser(),
  Y: new LocalWeekYearParser(),
  R: new ISOWeekYearParser(),
  u: new ExtendedYearParser(),
  Q: new QuarterParser(),
  q: new StandAloneQuarterParser(),
  M: new MonthParser(),
  L: new StandAloneMonthParser(),
  w: new LocalWeekParser(),
  I: new ISOWeekParser(),
  d: new DateParser(),
  D: new DayOfYearParser(),
  E: new DayParser(),
  e: new LocalDayParser(),
  c: new StandAloneLocalDayParser(),
  i: new ISODayParser(),
  a: new AMPMParser(),
  b: new AMPMMidnightParser(),
  B: new DayPeriodParser(),
  h: new Hour1to12Parser(),
  H: new Hour0to23Parser(),
  K: new Hour0To11Parser(),
  k: new Hour1To24Parser(),
  m: new MinuteParser(),
  s: new SecondParser(),
  S: new FractionOfSecondParser(),
  X: new ISOTimezoneWithZParser(),
  x: new ISOTimezoneParser(),
  t: new TimestampSecondsParser(),
  T: new TimestampMillisecondsParser()
};
function _typeof$2(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$2 = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$2 = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$2(obj);
}
function _createForOfIteratorHelper(o2, allowArrayLike) {
  var it;
  if (typeof Symbol === "undefined" || o2[Symbol.iterator] == null) {
    if (Array.isArray(o2) || (it = _unsupportedIterableToArray(o2)) || allowArrayLike && o2 && typeof o2.length === "number") {
      if (it)
        o2 = it;
      var i2 = 0;
      var F = function F2() {
      };
      return { s: F, n: function n2() {
        if (i2 >= o2.length)
          return { done: true };
        return { done: false, value: o2[i2++] };
      }, e: function e3(_e2) {
        throw _e2;
      }, f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return { s: function s3() {
    it = o2[Symbol.iterator]();
  }, n: function n2() {
    var step = it.next();
    normalCompletion = step.done;
    return step;
  }, e: function e3(_e2) {
    didErr = true;
    err = _e2;
  }, f: function f() {
    try {
      if (!normalCompletion && it.return != null)
        it.return();
    } finally {
      if (didErr)
        throw err;
    }
  } };
}
function _unsupportedIterableToArray(o2, minLen) {
  if (!o2)
    return;
  if (typeof o2 === "string")
    return _arrayLikeToArray(o2, minLen);
  var n2 = Object.prototype.toString.call(o2).slice(8, -1);
  if (n2 === "Object" && o2.constructor)
    n2 = o2.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o2);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray(o2, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
    arr2[i2] = arr[i2];
  }
  return arr2;
}
var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
var escapedStringRegExp = /^'([^]*?)'?$/;
var doubleQuoteRegExp = /''/g;
var notWhitespaceRegExp = /\S/;
var unescapedLatinCharacterRegExp = /[a-zA-Z]/;
function parse(dirtyDateString, dirtyFormatString, dirtyReferenceDate, options) {
  var _ref, _options$locale, _ref2, _ref3, _ref4, _options$firstWeekCon, _options$locale2, _options$locale2$opti, _defaultOptions$local, _defaultOptions$local2, _ref5, _ref6, _ref7, _options$weekStartsOn, _options$locale3, _options$locale3$opti, _defaultOptions$local3, _defaultOptions$local4;
  requiredArgs(3, arguments);
  var dateString = String(dirtyDateString);
  var formatString = String(dirtyFormatString);
  var defaultOptions2 = getDefaultOptions();
  var locale2 = (_ref = (_options$locale = options === null || options === void 0 ? void 0 : options.locale) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions2.locale) !== null && _ref !== void 0 ? _ref : defaultLocale;
  if (!locale2.match) {
    throw new RangeError("locale must contain match property");
  }
  var firstWeekContainsDate = toInteger((_ref2 = (_ref3 = (_ref4 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale2 = options.locale) === null || _options$locale2 === void 0 ? void 0 : (_options$locale2$opti = _options$locale2.options) === null || _options$locale2$opti === void 0 ? void 0 : _options$locale2$opti.firstWeekContainsDate) !== null && _ref4 !== void 0 ? _ref4 : defaultOptions2.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : 1);
  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
  }
  var weekStartsOn = toInteger((_ref5 = (_ref6 = (_ref7 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale3 = options.locale) === null || _options$locale3 === void 0 ? void 0 : (_options$locale3$opti = _options$locale3.options) === null || _options$locale3$opti === void 0 ? void 0 : _options$locale3$opti.weekStartsOn) !== null && _ref7 !== void 0 ? _ref7 : defaultOptions2.weekStartsOn) !== null && _ref6 !== void 0 ? _ref6 : (_defaultOptions$local3 = defaultOptions2.locale) === null || _defaultOptions$local3 === void 0 ? void 0 : (_defaultOptions$local4 = _defaultOptions$local3.options) === null || _defaultOptions$local4 === void 0 ? void 0 : _defaultOptions$local4.weekStartsOn) !== null && _ref5 !== void 0 ? _ref5 : 0);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  if (formatString === "") {
    if (dateString === "") {
      return toDate(dirtyReferenceDate);
    } else {
      return new Date(NaN);
    }
  }
  var subFnOptions = {
    firstWeekContainsDate,
    weekStartsOn,
    locale: locale2
  };
  var setters = [new DateToSystemTimezoneSetter()];
  var tokens = formatString.match(longFormattingTokensRegExp).map(function(substring) {
    var firstCharacter = substring[0];
    if (firstCharacter in longFormatters$1) {
      var longFormatter = longFormatters$1[firstCharacter];
      return longFormatter(substring, locale2.formatLong);
    }
    return substring;
  }).join("").match(formattingTokensRegExp);
  var usedTokens = [];
  var _iterator = _createForOfIteratorHelper(tokens), _step;
  try {
    var _loop = function _loop2() {
      var token = _step.value;
      if (!(options !== null && options !== void 0 && options.useAdditionalWeekYearTokens) && isProtectedWeekYearToken(token)) {
        throwProtectedError(token, formatString, dirtyDateString);
      }
      if (!(options !== null && options !== void 0 && options.useAdditionalDayOfYearTokens) && isProtectedDayOfYearToken(token)) {
        throwProtectedError(token, formatString, dirtyDateString);
      }
      var firstCharacter = token[0];
      var parser = parsers[firstCharacter];
      if (parser) {
        var incompatibleTokens = parser.incompatibleTokens;
        if (Array.isArray(incompatibleTokens)) {
          var incompatibleToken = usedTokens.find(function(usedToken) {
            return incompatibleTokens.includes(usedToken.token) || usedToken.token === firstCharacter;
          });
          if (incompatibleToken) {
            throw new RangeError("The format string mustn't contain `".concat(incompatibleToken.fullToken, "` and `").concat(token, "` at the same time"));
          }
        } else if (parser.incompatibleTokens === "*" && usedTokens.length > 0) {
          throw new RangeError("The format string mustn't contain `".concat(token, "` and any other token at the same time"));
        }
        usedTokens.push({
          token: firstCharacter,
          fullToken: token
        });
        var parseResult = parser.run(dateString, token, locale2.match, subFnOptions);
        if (!parseResult) {
          return {
            v: new Date(NaN)
          };
        }
        setters.push(parseResult.setter);
        dateString = parseResult.rest;
      } else {
        if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
          throw new RangeError("Format string contains an unescaped latin alphabet character `" + firstCharacter + "`");
        }
        if (token === "''") {
          token = "'";
        } else if (firstCharacter === "'") {
          token = cleanEscapedString(token);
        }
        if (dateString.indexOf(token) === 0) {
          dateString = dateString.slice(token.length);
        } else {
          return {
            v: new Date(NaN)
          };
        }
      }
    };
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var _ret = _loop();
      if (_typeof$2(_ret) === "object")
        return _ret.v;
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  if (dateString.length > 0 && notWhitespaceRegExp.test(dateString)) {
    return new Date(NaN);
  }
  var uniquePrioritySetters = setters.map(function(setter2) {
    return setter2.priority;
  }).sort(function(a3, b3) {
    return b3 - a3;
  }).filter(function(priority, index2, array) {
    return array.indexOf(priority) === index2;
  }).map(function(priority) {
    return setters.filter(function(setter2) {
      return setter2.priority === priority;
    }).sort(function(a3, b3) {
      return b3.subPriority - a3.subPriority;
    });
  }).map(function(setterArray) {
    return setterArray[0];
  });
  var date = toDate(dirtyReferenceDate);
  if (isNaN(date.getTime())) {
    return new Date(NaN);
  }
  var utcDate = subMilliseconds(date, getTimezoneOffsetInMilliseconds(date));
  var flags = {};
  var _iterator2 = _createForOfIteratorHelper(uniquePrioritySetters), _step2;
  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
      var setter = _step2.value;
      if (!setter.validate(utcDate, subFnOptions)) {
        return new Date(NaN);
      }
      var result = setter.set(utcDate, flags, subFnOptions);
      if (Array.isArray(result)) {
        utcDate = result[0];
        assign(flags, result[1]);
      } else {
        utcDate = result;
      }
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
  return utcDate;
}
function cleanEscapedString(input) {
  return input.match(escapedStringRegExp)[1].replace(doubleQuoteRegExp, "'");
}
function subDays(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addDays(dirtyDate, -amount);
}
function parseISO(argument, options) {
  var _options$additionalDi;
  requiredArgs(1, arguments);
  var additionalDigits = toInteger((_options$additionalDi = options === null || options === void 0 ? void 0 : options.additionalDigits) !== null && _options$additionalDi !== void 0 ? _options$additionalDi : 2);
  if (additionalDigits !== 2 && additionalDigits !== 1 && additionalDigits !== 0) {
    throw new RangeError("additionalDigits must be 0, 1 or 2");
  }
  if (!(typeof argument === "string" || Object.prototype.toString.call(argument) === "[object String]")) {
    return new Date(NaN);
  }
  var dateStrings = splitDateString(argument);
  var date;
  if (dateStrings.date) {
    var parseYearResult = parseYear(dateStrings.date, additionalDigits);
    date = parseDate(parseYearResult.restDateString, parseYearResult.year);
  }
  if (!date || isNaN(date.getTime())) {
    return new Date(NaN);
  }
  var timestamp = date.getTime();
  var time = 0;
  var offset;
  if (dateStrings.time) {
    time = parseTime(dateStrings.time);
    if (isNaN(time)) {
      return new Date(NaN);
    }
  }
  if (dateStrings.timezone) {
    offset = parseTimezone(dateStrings.timezone);
    if (isNaN(offset)) {
      return new Date(NaN);
    }
  } else {
    var dirtyDate = new Date(timestamp + time);
    var result = new Date(0);
    result.setFullYear(dirtyDate.getUTCFullYear(), dirtyDate.getUTCMonth(), dirtyDate.getUTCDate());
    result.setHours(dirtyDate.getUTCHours(), dirtyDate.getUTCMinutes(), dirtyDate.getUTCSeconds(), dirtyDate.getUTCMilliseconds());
    return result;
  }
  return new Date(timestamp + time + offset);
}
var patterns = {
  dateTimeDelimiter: /[T ]/,
  timeZoneDelimiter: /[Z ]/i,
  timezone: /([Z+-].*)$/
};
var dateRegex = /^-?(?:(\d{3})|(\d{2})(?:-?(\d{2}))?|W(\d{2})(?:-?(\d{1}))?|)$/;
var timeRegex = /^(\d{2}(?:[.,]\d*)?)(?::?(\d{2}(?:[.,]\d*)?))?(?::?(\d{2}(?:[.,]\d*)?))?$/;
var timezoneRegex = /^([+-])(\d{2})(?::?(\d{2}))?$/;
function splitDateString(dateString) {
  var dateStrings = {};
  var array = dateString.split(patterns.dateTimeDelimiter);
  var timeString;
  if (array.length > 2) {
    return dateStrings;
  }
  if (/:/.test(array[0])) {
    timeString = array[0];
  } else {
    dateStrings.date = array[0];
    timeString = array[1];
    if (patterns.timeZoneDelimiter.test(dateStrings.date)) {
      dateStrings.date = dateString.split(patterns.timeZoneDelimiter)[0];
      timeString = dateString.substr(dateStrings.date.length, dateString.length);
    }
  }
  if (timeString) {
    var token = patterns.timezone.exec(timeString);
    if (token) {
      dateStrings.time = timeString.replace(token[1], "");
      dateStrings.timezone = token[1];
    } else {
      dateStrings.time = timeString;
    }
  }
  return dateStrings;
}
function parseYear(dateString, additionalDigits) {
  var regex = new RegExp("^(?:(\\d{4}|[+-]\\d{" + (4 + additionalDigits) + "})|(\\d{2}|[+-]\\d{" + (2 + additionalDigits) + "})$)");
  var captures = dateString.match(regex);
  if (!captures)
    return {
      year: NaN,
      restDateString: ""
    };
  var year = captures[1] ? parseInt(captures[1]) : null;
  var century = captures[2] ? parseInt(captures[2]) : null;
  return {
    year: century === null ? year : century * 100,
    restDateString: dateString.slice((captures[1] || captures[2]).length)
  };
}
function parseDate(dateString, year) {
  if (year === null)
    return new Date(NaN);
  var captures = dateString.match(dateRegex);
  if (!captures)
    return new Date(NaN);
  var isWeekDate = !!captures[4];
  var dayOfYear = parseDateUnit(captures[1]);
  var month = parseDateUnit(captures[2]) - 1;
  var day = parseDateUnit(captures[3]);
  var week = parseDateUnit(captures[4]);
  var dayOfWeek = parseDateUnit(captures[5]) - 1;
  if (isWeekDate) {
    if (!validateWeekDate(year, week, dayOfWeek)) {
      return new Date(NaN);
    }
    return dayOfISOWeekYear(year, week, dayOfWeek);
  } else {
    var date = new Date(0);
    if (!validateDate(year, month, day) || !validateDayOfYearDate(year, dayOfYear)) {
      return new Date(NaN);
    }
    date.setUTCFullYear(year, month, Math.max(dayOfYear, day));
    return date;
  }
}
function parseDateUnit(value) {
  return value ? parseInt(value) : 1;
}
function parseTime(timeString) {
  var captures = timeString.match(timeRegex);
  if (!captures)
    return NaN;
  var hours = parseTimeUnit(captures[1]);
  var minutes = parseTimeUnit(captures[2]);
  var seconds = parseTimeUnit(captures[3]);
  if (!validateTime(hours, minutes, seconds)) {
    return NaN;
  }
  return hours * millisecondsInHour + minutes * millisecondsInMinute + seconds * 1e3;
}
function parseTimeUnit(value) {
  return value && parseFloat(value.replace(",", ".")) || 0;
}
function parseTimezone(timezoneString) {
  if (timezoneString === "Z")
    return 0;
  var captures = timezoneString.match(timezoneRegex);
  if (!captures)
    return 0;
  var sign = captures[1] === "+" ? -1 : 1;
  var hours = parseInt(captures[2]);
  var minutes = captures[3] && parseInt(captures[3]) || 0;
  if (!validateTimezone(hours, minutes)) {
    return NaN;
  }
  return sign * (hours * millisecondsInHour + minutes * millisecondsInMinute);
}
function dayOfISOWeekYear(isoWeekYear, week, day) {
  var date = new Date(0);
  date.setUTCFullYear(isoWeekYear, 0, 4);
  var fourthOfJanuaryDay = date.getUTCDay() || 7;
  var diff = (week - 1) * 7 + day + 1 - fourthOfJanuaryDay;
  date.setUTCDate(date.getUTCDate() + diff);
  return date;
}
var daysInMonths = [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
function isLeapYearIndex(year) {
  return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
}
function validateDate(year, month, date) {
  return month >= 0 && month <= 11 && date >= 1 && date <= (daysInMonths[month] || (isLeapYearIndex(year) ? 29 : 28));
}
function validateDayOfYearDate(year, dayOfYear) {
  return dayOfYear >= 1 && dayOfYear <= (isLeapYearIndex(year) ? 366 : 365);
}
function validateWeekDate(_year, week, day) {
  return week >= 1 && week <= 53 && day >= 0 && day <= 6;
}
function validateTime(hours, minutes, seconds) {
  if (hours === 24) {
    return minutes === 0 && seconds === 0;
  }
  return seconds >= 0 && seconds < 60 && minutes >= 0 && minutes < 60 && hours >= 0 && hours < 25;
}
function validateTimezone(_hours, minutes) {
  return minutes >= 0 && minutes <= 59;
}
function setMonth(dirtyDate, dirtyMonth) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var month = toInteger(dirtyMonth);
  var year = date.getFullYear();
  var day = date.getDate();
  var dateWithDesiredMonth = new Date(0);
  dateWithDesiredMonth.setFullYear(year, month, 15);
  dateWithDesiredMonth.setHours(0, 0, 0, 0);
  var daysInMonth = getDaysInMonth(dateWithDesiredMonth);
  date.setMonth(month, Math.min(day, daysInMonth));
  return date;
}
function _typeof$1(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$1 = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$1 = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$1(obj);
}
function set(dirtyDate, values) {
  requiredArgs(2, arguments);
  if (_typeof$1(values) !== "object" || values === null) {
    throw new RangeError("values parameter must be an object");
  }
  var date = toDate(dirtyDate);
  if (isNaN(date.getTime())) {
    return new Date(NaN);
  }
  if (values.year != null) {
    date.setFullYear(values.year);
  }
  if (values.month != null) {
    date = setMonth(date, values.month);
  }
  if (values.date != null) {
    date.setDate(toInteger(values.date));
  }
  if (values.hours != null) {
    date.setHours(toInteger(values.hours));
  }
  if (values.minutes != null) {
    date.setMinutes(toInteger(values.minutes));
  }
  if (values.seconds != null) {
    date.setSeconds(toInteger(values.seconds));
  }
  if (values.milliseconds != null) {
    date.setMilliseconds(toInteger(values.milliseconds));
  }
  return date;
}
function setHours(dirtyDate, dirtyHours) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var hours = toInteger(dirtyHours);
  date.setHours(hours);
  return date;
}
function setMilliseconds(dirtyDate, dirtyMilliseconds) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var milliseconds = toInteger(dirtyMilliseconds);
  date.setMilliseconds(milliseconds);
  return date;
}
function setMinutes(dirtyDate, dirtyMinutes) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var minutes = toInteger(dirtyMinutes);
  date.setMinutes(minutes);
  return date;
}
function setSeconds(dirtyDate, dirtySeconds) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var seconds = toInteger(dirtySeconds);
  date.setSeconds(seconds);
  return date;
}
function setYear(dirtyDate, dirtyYear) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var year = toInteger(dirtyYear);
  if (isNaN(date.getTime())) {
    return new Date(NaN);
  }
  date.setFullYear(year);
  return date;
}
function subMonths(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMonths(dirtyDate, -amount);
}
function _typeof(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof(obj);
}
function sub(date, duration) {
  requiredArgs(2, arguments);
  if (!duration || _typeof(duration) !== "object")
    return new Date(NaN);
  var years = duration.years ? toInteger(duration.years) : 0;
  var months = duration.months ? toInteger(duration.months) : 0;
  var weeks = duration.weeks ? toInteger(duration.weeks) : 0;
  var days = duration.days ? toInteger(duration.days) : 0;
  var hours = duration.hours ? toInteger(duration.hours) : 0;
  var minutes = duration.minutes ? toInteger(duration.minutes) : 0;
  var seconds = duration.seconds ? toInteger(duration.seconds) : 0;
  var dateWithoutMonths = subMonths(date, months + years * 12);
  var dateWithoutDays = subDays(dateWithoutMonths, days + weeks * 7);
  var minutestoSub = minutes + hours * 60;
  var secondstoSub = seconds + minutestoSub * 60;
  var mstoSub = secondstoSub * 1e3;
  var finalDate = new Date(dateWithoutDays.getTime() - mstoSub);
  return finalDate;
}
function subYears(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addYears(dirtyDate, -amount);
}
const ct = (e3, n2) => {
  const a3 = e3.__vccOpts || e3;
  for (const [t3, o2] of n2)
    a3[t3] = o2;
  return a3;
}, ca = {}, da = {
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32",
  viewBox: "0 0 32 32",
  class: "dp__icon"
}, fa = /* @__PURE__ */ createBaseVNode("path", { d: "M29.333 8c0-2.208-1.792-4-4-4h-18.667c-2.208 0-4 1.792-4 4v18.667c0 2.208 1.792 4 4 4h18.667c2.208 0 4-1.792 4-4v-18.667zM26.667 8v18.667c0 0.736-0.597 1.333-1.333 1.333 0 0-18.667 0-18.667 0-0.736 0-1.333-0.597-1.333-1.333 0 0 0-18.667 0-18.667 0-0.736 0.597-1.333 1.333-1.333 0 0 18.667 0 18.667 0 0.736 0 1.333 0.597 1.333 1.333z" }, null, -1), va = /* @__PURE__ */ createBaseVNode("path", { d: "M20 2.667v5.333c0 0.736 0.597 1.333 1.333 1.333s1.333-0.597 1.333-1.333v-5.333c0-0.736-0.597-1.333-1.333-1.333s-1.333 0.597-1.333 1.333z" }, null, -1), ma = /* @__PURE__ */ createBaseVNode("path", { d: "M9.333 2.667v5.333c0 0.736 0.597 1.333 1.333 1.333s1.333-0.597 1.333-1.333v-5.333c0-0.736-0.597-1.333-1.333-1.333s-1.333 0.597-1.333 1.333z" }, null, -1), ya = /* @__PURE__ */ createBaseVNode("path", { d: "M4 14.667h24c0.736 0 1.333-0.597 1.333-1.333s-0.597-1.333-1.333-1.333h-24c-0.736 0-1.333 0.597-1.333 1.333s0.597 1.333 1.333 1.333z" }, null, -1), ha = [
  fa,
  va,
  ma,
  ya
];
function ga(e3, n2) {
  return openBlock(), createElementBlock("svg", da, ha);
}
const Lt = /* @__PURE__ */ ct(ca, [["render", ga]]), pa = {}, ka = {
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32",
  viewBox: "0 0 32 32",
  class: "dp__icon"
}, wa = /* @__PURE__ */ createBaseVNode("path", { d: "M23.057 7.057l-16 16c-0.52 0.52-0.52 1.365 0 1.885s1.365 0.52 1.885 0l16-16c0.52-0.52 0.52-1.365 0-1.885s-1.365-0.52-1.885 0z" }, null, -1), ba = /* @__PURE__ */ createBaseVNode("path", { d: "M7.057 8.943l16 16c0.52 0.52 1.365 0.52 1.885 0s0.52-1.365 0-1.885l-16-16c-0.52-0.52-1.365-0.52-1.885 0s-0.52 1.365 0 1.885z" }, null, -1), $a = [
  wa,
  ba
];
function Da(e3, n2) {
  return openBlock(), createElementBlock("svg", ka, $a);
}
const Ma = /* @__PURE__ */ ct(pa, [["render", Da]]), _a = {}, Ta = {
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32",
  viewBox: "0 0 32 32",
  class: "dp__icon"
}, Aa = /* @__PURE__ */ createBaseVNode("path", { d: "M20.943 23.057l-7.057-7.057c0 0 7.057-7.057 7.057-7.057 0.52-0.52 0.52-1.365 0-1.885s-1.365-0.52-1.885 0l-8 8c-0.521 0.521-0.521 1.365 0 1.885l8 8c0.52 0.52 1.365 0.52 1.885 0s0.52-1.365 0-1.885z" }, null, -1), Sa = [
  Aa
];
function Ca(e3, n2) {
  return openBlock(), createElementBlock("svg", Ta, Sa);
}
const kn = /* @__PURE__ */ ct(_a, [["render", Ca]]), Pa = {}, Na = {
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32",
  viewBox: "0 0 32 32",
  class: "dp__icon"
}, Ra = /* @__PURE__ */ createBaseVNode("path", { d: "M12.943 24.943l8-8c0.521-0.521 0.521-1.365 0-1.885l-8-8c-0.52-0.52-1.365-0.52-1.885 0s-0.52 1.365 0 1.885l7.057 7.057c0 0-7.057 7.057-7.057 7.057-0.52 0.52-0.52 1.365 0 1.885s1.365 0.52 1.885 0z" }, null, -1), Ia = [
  Ra
];
function Oa(e3, n2) {
  return openBlock(), createElementBlock("svg", Na, Ia);
}
const wn = /* @__PURE__ */ ct(Pa, [["render", Oa]]), Ba = {}, Ya = {
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32",
  viewBox: "0 0 32 32",
  class: "dp__icon"
}, Va = /* @__PURE__ */ createBaseVNode("path", { d: "M16 1.333c-8.095 0-14.667 6.572-14.667 14.667s6.572 14.667 14.667 14.667c8.095 0 14.667-6.572 14.667-14.667s-6.572-14.667-14.667-14.667zM16 4c6.623 0 12 5.377 12 12s-5.377 12-12 12c-6.623 0-12-5.377-12-12s5.377-12 12-12z" }, null, -1), Ea = /* @__PURE__ */ createBaseVNode("path", { d: "M14.667 8v8c0 0.505 0.285 0.967 0.737 1.193l5.333 2.667c0.658 0.329 1.46 0.062 1.789-0.596s0.062-1.46-0.596-1.789l-4.596-2.298c0 0 0-7.176 0-7.176 0-0.736-0.597-1.333-1.333-1.333s-1.333 0.597-1.333 1.333z" }, null, -1), La = [
  Va,
  Ea
];
function Fa(e3, n2) {
  return openBlock(), createElementBlock("svg", Ya, La);
}
const Fn = /* @__PURE__ */ ct(Ba, [["render", Fa]]), Ua = {}, Ha = {
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32",
  viewBox: "0 0 32 32",
  class: "dp__icon"
}, Wa = /* @__PURE__ */ createBaseVNode("path", { d: "M24.943 19.057l-8-8c-0.521-0.521-1.365-0.521-1.885 0l-8 8c-0.52 0.52-0.52 1.365 0 1.885s1.365 0.52 1.885 0l7.057-7.057c0 0 7.057 7.057 7.057 7.057 0.52 0.52 1.365 0.52 1.885 0s0.52-1.365 0-1.885z" }, null, -1), za = [
  Wa
];
function xa(e3, n2) {
  return openBlock(), createElementBlock("svg", Ha, za);
}
const Un = /* @__PURE__ */ ct(Ua, [["render", xa]]), Ka = {}, ja = {
  version: "1.1",
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32",
  viewBox: "0 0 32 32",
  class: "dp__icon"
}, Ga = /* @__PURE__ */ createBaseVNode("path", { d: "M7.057 12.943l8 8c0.521 0.521 1.365 0.521 1.885 0l8-8c0.52-0.52 0.52-1.365 0-1.885s-1.365-0.52-1.885 0l-7.057 7.057c0 0-7.057-7.057-7.057-7.057-0.52-0.52-1.365-0.52-1.885 0s-0.52 1.365 0 1.885z" }, null, -1), Za = [
  Ga
];
function Xa(e3, n2) {
  return openBlock(), createElementBlock("svg", ja, Za);
}
const Hn = /* @__PURE__ */ ct(Ka, [["render", Xa]]), bn = (e3, n2) => {
  const a3 = parse(e3, n2.slice(0, e3.length), new Date());
  return isValid(a3) && isDate(a3) ? a3 : null;
}, qa = (e3, n2) => {
  if (typeof n2 == "string")
    return bn(e3, n2);
  if (Array.isArray(n2)) {
    let a3 = null;
    for (const t3 of n2)
      if (a3 = bn(e3, t3), a3)
        break;
    return a3;
  }
  return typeof n2 == "function" ? n2(e3) : null;
}, b2 = (e3) => e3 ? new Date(e3) : new Date(), Ja = (e3, n2) => {
  if (n2) {
    const t3 = (e3.getMonth() + 1).toString().padStart(2, "0"), o2 = e3.getDate().toString().padStart(2, "0"), d3 = e3.getHours().toString().padStart(2, "0"), p2 = e3.getMinutes().toString().padStart(2, "0");
    return `${e3.getFullYear()}-${t3}-${o2}T${d3}:${p2}:00.000Z`;
  }
  const a3 = Date.UTC(
    e3.getUTCFullYear(),
    e3.getUTCMonth(),
    e3.getUTCDate(),
    e3.getUTCHours(),
    e3.getUTCMinutes(),
    e3.getUTCSeconds()
  );
  return new Date(a3).toISOString();
}, Ke = (e3) => {
  let n2 = b2(JSON.parse(JSON.stringify(e3)));
  return n2 = setHours(n2, 0), n2 = setMinutes(n2, 0), n2 = setSeconds(n2, 0), n2 = setMilliseconds(n2, 0), n2;
}, Ee = (e3, n2, a3, t3) => {
  let o2 = e3 ? b2(e3) : b2();
  return (n2 || n2 === 0) && (o2 = setHours(o2, +n2)), (a3 || a3 === 0) && (o2 = setMinutes(o2, +a3)), (t3 || t3 === 0) && (o2 = setSeconds(o2, +t3)), setMilliseconds(o2, 0);
}, Pe = (e3, n2) => !e3 || !n2 ? false : isBefore(Ke(e3), Ke(n2)), pe = (e3, n2) => !e3 || !n2 ? false : isEqual(Ke(e3), Ke(n2)), Oe = (e3, n2) => !e3 || !n2 ? false : isAfter(Ke(e3), Ke(n2)), Wn = (e3, n2, a3) => e3 && e3[0] && e3[1] ? Oe(a3, e3[0]) && Pe(a3, e3[1]) : e3 && e3[0] && n2 ? Oe(a3, e3[0]) && Pe(a3, n2) || Pe(a3, e3[0]) && Oe(a3, n2) : false, kt = reactive({
  menuFocused: false,
  shiftKeyInMenu: false
}), zn = () => {
  const e3 = (t3) => {
    kt.menuFocused = t3;
  }, n2 = (t3) => {
    kt.shiftKeyInMenu !== t3 && (kt.shiftKeyInMenu = t3);
  };
  return {
    control: computed(() => ({ shiftKeyInMenu: kt.shiftKeyInMenu, menuFocused: kt.menuFocused })),
    setMenuFocused: e3,
    setShiftKey: n2
  };
};
function fn(e3) {
  return e3 && e3.__esModule && Object.prototype.hasOwnProperty.call(e3, "default") ? e3.default : e3;
}
var Ot = {}, Qa = {
  get exports() {
    return Ot;
  },
  set exports(e3) {
    Ot = e3;
  }
};
(function(e3, n2) {
  Object.defineProperty(n2, "__esModule", {
    value: true
  }), n2.default = a3;
  function a3(t3) {
    if (t3 === null || t3 === true || t3 === false)
      return NaN;
    var o2 = Number(t3);
    return isNaN(o2) ? o2 : o2 < 0 ? Math.ceil(o2) : Math.floor(o2);
  }
  e3.exports = n2.default;
})(Qa, Ot);
const er = /* @__PURE__ */ fn(Ot);
var Bt = {}, tr = {
  get exports() {
    return Bt;
  },
  set exports(e3) {
    Bt = e3;
  }
};
(function(e3, n2) {
  Object.defineProperty(n2, "__esModule", {
    value: true
  }), n2.default = a3;
  function a3(t3) {
    var o2 = new Date(Date.UTC(t3.getFullYear(), t3.getMonth(), t3.getDate(), t3.getHours(), t3.getMinutes(), t3.getSeconds(), t3.getMilliseconds()));
    return o2.setUTCFullYear(t3.getFullYear()), t3.getTime() - o2.getTime();
  }
  e3.exports = n2.default;
})(tr, Bt);
const $n = /* @__PURE__ */ fn(Bt);
function nr(e3, n2) {
  var a3 = or(n2);
  return a3.formatToParts ? rr(a3, e3) : lr(a3, e3);
}
var ar = {
  year: 0,
  month: 1,
  day: 2,
  hour: 3,
  minute: 4,
  second: 5
};
function rr(e3, n2) {
  try {
    for (var a3 = e3.formatToParts(n2), t3 = [], o2 = 0; o2 < a3.length; o2++) {
      var d3 = ar[a3[o2].type];
      d3 >= 0 && (t3[d3] = parseInt(a3[o2].value, 10));
    }
    return t3;
  } catch (p2) {
    if (p2 instanceof RangeError)
      return [NaN];
    throw p2;
  }
}
function lr(e3, n2) {
  var a3 = e3.format(n2).replace(/\u200E/g, ""), t3 = /(\d+)\/(\d+)\/(\d+),? (\d+):(\d+):(\d+)/.exec(a3);
  return [t3[3], t3[1], t3[2], t3[4], t3[5], t3[6]];
}
var jt = {};
function or(e3) {
  if (!jt[e3]) {
    var n2 = new Intl.DateTimeFormat("en-US", {
      hour12: false,
      timeZone: "America/New_York",
      year: "numeric",
      month: "numeric",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit"
    }).format(new Date("2014-06-25T04:00:00.123Z")), a3 = n2 === "06/25/2014, 00:00:00" || n2 === "\u200E06\u200E/\u200E25\u200E/\u200E2014\u200E \u200E00\u200E:\u200E00\u200E:\u200E00";
    jt[e3] = a3 ? new Intl.DateTimeFormat("en-US", {
      hour12: false,
      timeZone: e3,
      year: "numeric",
      month: "numeric",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit"
    }) : new Intl.DateTimeFormat("en-US", {
      hourCycle: "h23",
      timeZone: e3,
      year: "numeric",
      month: "numeric",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit"
    });
  }
  return jt[e3];
}
function vn(e3, n2, a3, t3, o2, d3, p2) {
  var $ = new Date(0);
  return $.setUTCFullYear(e3, n2, a3), $.setUTCHours(t3, o2, d3, p2), $;
}
var Dn = 36e5, sr = 6e4, Gt = {
  timezone: /([Z+-].*)$/,
  timezoneZ: /^(Z)$/,
  timezoneHH: /^([+-]\d{2})$/,
  timezoneHHMM: /^([+-]\d{2}):?(\d{2})$/
};
function mn(e3, n2, a3) {
  var t3, o2;
  if (!e3 || (t3 = Gt.timezoneZ.exec(e3), t3))
    return 0;
  var d3;
  if (t3 = Gt.timezoneHH.exec(e3), t3)
    return d3 = parseInt(t3[1], 10), Mn(d3) ? -(d3 * Dn) : NaN;
  if (t3 = Gt.timezoneHHMM.exec(e3), t3) {
    d3 = parseInt(t3[1], 10);
    var p2 = parseInt(t3[2], 10);
    return Mn(d3, p2) ? (o2 = Math.abs(d3) * Dn + p2 * sr, d3 > 0 ? -o2 : o2) : NaN;
  }
  if (cr(e3)) {
    n2 = new Date(n2 || Date.now());
    var $ = a3 ? n2 : ir(n2), O2 = rn($, e3), R2 = a3 ? O2 : ur(n2, O2, e3);
    return -R2;
  }
  return NaN;
}
function ir(e3) {
  return vn(
    e3.getFullYear(),
    e3.getMonth(),
    e3.getDate(),
    e3.getHours(),
    e3.getMinutes(),
    e3.getSeconds(),
    e3.getMilliseconds()
  );
}
function rn(e3, n2) {
  var a3 = nr(e3, n2), t3 = vn(
    a3[0],
    a3[1] - 1,
    a3[2],
    a3[3] % 24,
    a3[4],
    a3[5],
    0
  ).getTime(), o2 = e3.getTime(), d3 = o2 % 1e3;
  return o2 -= d3 >= 0 ? d3 : 1e3 + d3, t3 - o2;
}
function ur(e3, n2, a3) {
  var t3 = e3.getTime(), o2 = t3 - n2, d3 = rn(new Date(o2), a3);
  if (n2 === d3)
    return n2;
  o2 -= d3 - n2;
  var p2 = rn(new Date(o2), a3);
  return d3 === p2 ? d3 : Math.max(d3, p2);
}
function Mn(e3, n2) {
  return -23 <= e3 && e3 <= 23 && (n2 == null || 0 <= n2 && n2 <= 59);
}
var _n = {};
function cr(e3) {
  if (_n[e3])
    return true;
  try {
    return new Intl.DateTimeFormat(void 0, { timeZone: e3 }), _n[e3] = true, true;
  } catch {
    return false;
  }
}
var dr = /(Z|[+-]\d{2}(?::?\d{2})?| UTC| [a-zA-Z]+\/[a-zA-Z_]+(?:\/[a-zA-Z_]+)?)$/;
const xn = dr;
var Zt = 36e5, Tn = 6e4, fr = 2, Ie = {
  dateTimePattern: /^([0-9W+-]+)(T| )(.*)/,
  datePattern: /^([0-9W+-]+)(.*)/,
  plainTime: /:/,
  YY: /^(\d{2})$/,
  YYY: [
    /^([+-]\d{2})$/,
    /^([+-]\d{3})$/,
    /^([+-]\d{4})$/
  ],
  YYYY: /^(\d{4})/,
  YYYYY: [
    /^([+-]\d{4})/,
    /^([+-]\d{5})/,
    /^([+-]\d{6})/
  ],
  MM: /^-(\d{2})$/,
  DDD: /^-?(\d{3})$/,
  MMDD: /^-?(\d{2})-?(\d{2})$/,
  Www: /^-?W(\d{2})$/,
  WwwD: /^-?W(\d{2})-?(\d{1})$/,
  HH: /^(\d{2}([.,]\d*)?)$/,
  HHMM: /^(\d{2}):?(\d{2}([.,]\d*)?)$/,
  HHMMSS: /^(\d{2}):?(\d{2}):?(\d{2}([.,]\d*)?)$/,
  timeZone: xn
};
function ln(e3, n2) {
  if (arguments.length < 1)
    throw new TypeError("1 argument required, but only " + arguments.length + " present");
  if (e3 === null)
    return new Date(NaN);
  var a3 = n2 || {}, t3 = a3.additionalDigits == null ? fr : er(a3.additionalDigits);
  if (t3 !== 2 && t3 !== 1 && t3 !== 0)
    throw new RangeError("additionalDigits must be 0, 1 or 2");
  if (e3 instanceof Date || typeof e3 == "object" && Object.prototype.toString.call(e3) === "[object Date]")
    return new Date(e3.getTime());
  if (typeof e3 == "number" || Object.prototype.toString.call(e3) === "[object Number]")
    return new Date(e3);
  if (!(typeof e3 == "string" || Object.prototype.toString.call(e3) === "[object String]"))
    return new Date(NaN);
  var o2 = vr(e3), d3 = mr(o2.date, t3), p2 = d3.year, $ = d3.restDateString, O2 = yr($, p2);
  if (isNaN(O2))
    return new Date(NaN);
  if (O2) {
    var R2 = O2.getTime(), F = 0, A;
    if (o2.time && (F = hr(o2.time), isNaN(F)))
      return new Date(NaN);
    if (o2.timeZone || a3.timeZone) {
      if (A = mn(o2.timeZone || a3.timeZone, new Date(R2 + F)), isNaN(A))
        return new Date(NaN);
    } else
      A = $n(new Date(R2 + F)), A = $n(new Date(R2 + F + A));
    return new Date(R2 + F + A);
  } else
    return new Date(NaN);
}
function vr(e3) {
  var n2 = {}, a3 = Ie.dateTimePattern.exec(e3), t3;
  if (a3 ? (n2.date = a3[1], t3 = a3[3]) : (a3 = Ie.datePattern.exec(e3), a3 ? (n2.date = a3[1], t3 = a3[2]) : (n2.date = null, t3 = e3)), t3) {
    var o2 = Ie.timeZone.exec(t3);
    o2 ? (n2.time = t3.replace(o2[1], ""), n2.timeZone = o2[1].trim()) : n2.time = t3;
  }
  return n2;
}
function mr(e3, n2) {
  var a3 = Ie.YYY[n2], t3 = Ie.YYYYY[n2], o2;
  if (o2 = Ie.YYYY.exec(e3) || t3.exec(e3), o2) {
    var d3 = o2[1];
    return {
      year: parseInt(d3, 10),
      restDateString: e3.slice(d3.length)
    };
  }
  if (o2 = Ie.YY.exec(e3) || a3.exec(e3), o2) {
    var p2 = o2[1];
    return {
      year: parseInt(p2, 10) * 100,
      restDateString: e3.slice(p2.length)
    };
  }
  return {
    year: null
  };
}
function yr(e3, n2) {
  if (n2 === null)
    return null;
  var a3, t3, o2, d3;
  if (e3.length === 0)
    return t3 = new Date(0), t3.setUTCFullYear(n2), t3;
  if (a3 = Ie.MM.exec(e3), a3)
    return t3 = new Date(0), o2 = parseInt(a3[1], 10) - 1, Sn(n2, o2) ? (t3.setUTCFullYear(n2, o2), t3) : new Date(NaN);
  if (a3 = Ie.DDD.exec(e3), a3) {
    t3 = new Date(0);
    var p2 = parseInt(a3[1], 10);
    return kr(n2, p2) ? (t3.setUTCFullYear(n2, 0, p2), t3) : new Date(NaN);
  }
  if (a3 = Ie.MMDD.exec(e3), a3) {
    t3 = new Date(0), o2 = parseInt(a3[1], 10) - 1;
    var $ = parseInt(a3[2], 10);
    return Sn(n2, o2, $) ? (t3.setUTCFullYear(n2, o2, $), t3) : new Date(NaN);
  }
  if (a3 = Ie.Www.exec(e3), a3)
    return d3 = parseInt(a3[1], 10) - 1, Cn(n2, d3) ? An(n2, d3) : new Date(NaN);
  if (a3 = Ie.WwwD.exec(e3), a3) {
    d3 = parseInt(a3[1], 10) - 1;
    var O2 = parseInt(a3[2], 10) - 1;
    return Cn(n2, d3, O2) ? An(n2, d3, O2) : new Date(NaN);
  }
  return null;
}
function hr(e3) {
  var n2, a3, t3;
  if (n2 = Ie.HH.exec(e3), n2)
    return a3 = parseFloat(n2[1].replace(",", ".")), Xt(a3) ? a3 % 24 * Zt : NaN;
  if (n2 = Ie.HHMM.exec(e3), n2)
    return a3 = parseInt(n2[1], 10), t3 = parseFloat(n2[2].replace(",", ".")), Xt(a3, t3) ? a3 % 24 * Zt + t3 * Tn : NaN;
  if (n2 = Ie.HHMMSS.exec(e3), n2) {
    a3 = parseInt(n2[1], 10), t3 = parseInt(n2[2], 10);
    var o2 = parseFloat(n2[3].replace(",", "."));
    return Xt(a3, t3, o2) ? a3 % 24 * Zt + t3 * Tn + o2 * 1e3 : NaN;
  }
  return null;
}
function An(e3, n2, a3) {
  n2 = n2 || 0, a3 = a3 || 0;
  var t3 = new Date(0);
  t3.setUTCFullYear(e3, 0, 4);
  var o2 = t3.getUTCDay() || 7, d3 = n2 * 7 + a3 + 1 - o2;
  return t3.setUTCDate(t3.getUTCDate() + d3), t3;
}
var gr = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], pr = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
function Kn(e3) {
  return e3 % 400 === 0 || e3 % 4 === 0 && e3 % 100 !== 0;
}
function Sn(e3, n2, a3) {
  if (n2 < 0 || n2 > 11)
    return false;
  if (a3 != null) {
    if (a3 < 1)
      return false;
    var t3 = Kn(e3);
    if (t3 && a3 > pr[n2] || !t3 && a3 > gr[n2])
      return false;
  }
  return true;
}
function kr(e3, n2) {
  if (n2 < 1)
    return false;
  var a3 = Kn(e3);
  return !(a3 && n2 > 366 || !a3 && n2 > 365);
}
function Cn(e3, n2, a3) {
  return !(n2 < 0 || n2 > 52 || a3 != null && (a3 < 0 || a3 > 6));
}
function Xt(e3, n2, a3) {
  return !(e3 != null && (e3 < 0 || e3 >= 25) || n2 != null && (n2 < 0 || n2 >= 60) || a3 != null && (a3 < 0 || a3 >= 60));
}
var Yt = {}, wr = {
  get exports() {
    return Yt;
  },
  set exports(e3) {
    Yt = e3;
  }
}, Vt = {}, br = {
  get exports() {
    return Vt;
  },
  set exports(e3) {
    Vt = e3;
  }
};
(function(e3, n2) {
  Object.defineProperty(n2, "__esModule", {
    value: true
  }), n2.default = a3;
  function a3(t3, o2) {
    if (t3 == null)
      throw new TypeError("assign requires that input parameter not be null or undefined");
    for (var d3 in o2)
      Object.prototype.hasOwnProperty.call(o2, d3) && (t3[d3] = o2[d3]);
    return t3;
  }
  e3.exports = n2.default;
})(br, Vt);
(function(e3, n2) {
  Object.defineProperty(n2, "__esModule", {
    value: true
  }), n2.default = o2;
  var a3 = t3(Vt);
  function t3(d3) {
    return d3 && d3.__esModule ? d3 : { default: d3 };
  }
  function o2(d3) {
    return (0, a3.default)({}, d3);
  }
  e3.exports = n2.default;
})(wr, Yt);
const $r = /* @__PURE__ */ fn(Yt);
function Dr(e3, n2, a3) {
  var t3 = ln(e3, a3), o2 = mn(n2, t3, true), d3 = new Date(t3.getTime() - o2), p2 = new Date(0);
  return p2.setFullYear(d3.getUTCFullYear(), d3.getUTCMonth(), d3.getUTCDate()), p2.setHours(d3.getUTCHours(), d3.getUTCMinutes(), d3.getUTCSeconds(), d3.getUTCMilliseconds()), p2;
}
function Mr(e3, n2, a3) {
  if (typeof e3 == "string" && !e3.match(xn)) {
    var t3 = $r(a3);
    return t3.timeZone = n2, ln(e3, t3);
  }
  var o2 = ln(e3, a3), d3 = vn(
    o2.getFullYear(),
    o2.getMonth(),
    o2.getDate(),
    o2.getHours(),
    o2.getMinutes(),
    o2.getSeconds(),
    o2.getMilliseconds()
  ).getTime(), p2 = mn(n2, new Date(d3));
  return new Date(d3 + p2);
}
const _r = (e3, n2 = 3) => {
  const a3 = [];
  for (let t3 = 0; t3 < e3.length; t3 += n2)
    a3.push([e3[t3], e3[t3 + 1], e3[t3 + 2]]);
  return a3;
}, Tr = (e3, n2) => {
  const a3 = [1, 2, 3, 4, 5, 6, 7].map((d3) => new Intl.DateTimeFormat(e3, { weekday: "short", timeZone: "UTC" }).format(new Date(`2017-01-0${d3}T00:00:00+00:00`)).slice(0, 2)), t3 = a3.slice(0, n2), o2 = a3.slice(n2 + 1, a3.length);
  return [a3[n2]].concat(...o2).concat(...t3);
}, Ar = (e3) => {
  const n2 = [];
  for (let a3 = +e3[0]; a3 <= +e3[1]; a3++)
    n2.push({ value: +a3, text: `${a3}` });
  return n2;
}, Sr = (e3, n2) => {
  const a3 = new Intl.DateTimeFormat(e3, { month: n2, timeZone: "UTC" });
  return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12].map((o2) => {
    const d3 = o2 < 10 ? `0${o2}` : o2;
    return new Date(`2017-${d3}-01T00:00:00+00:00`);
  }).map((o2, d3) => ({
    text: a3.format(o2),
    value: d3
  }));
}, Cr = (e3) => [12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11][e3], Me = (e3) => {
  const n2 = unref(e3);
  return n2 != null && n2.$el ? n2 == null ? void 0 : n2.$el : n2;
}, Pr = (e3) => Object.assign({ type: "dot" }, e3), jn = (e3) => Array.isArray(e3) ? !!e3[0] && !!e3[1] : false, Et = {
  prop: (e3) => `"${e3}" prop must be enabled!`,
  dateArr: (e3) => `You need to use array as "model-value" binding in order to support "${e3}"`
}, _e = (e3) => e3, Pn = (e3) => e3 === 0 ? e3 : !e3 || isNaN(+e3) ? null : +e3, Nn = (e3) => Object.assign(
  {
    menuAppear: "dp-menu-appear",
    open: "dp-slide-down",
    close: "dp-slide-up",
    next: "calendar-next",
    previous: "calendar-prev",
    vNext: "dp-slide-up",
    vPrevious: "dp-slide-down"
  },
  e3
), Nr = (e3) => Object.assign(
  {
    toggleOverlay: "Toggle overlay",
    menu: "Datepicker menu",
    input: "Datepicker input",
    calendarWrap: "Calendar wrapper",
    calendarDays: "Calendar days",
    openTimePicker: "Open time picker",
    closeTimePicker: "Close time Picker",
    incrementValue: (n2) => `Increment ${n2}`,
    decrementValue: (n2) => `Decrement ${n2}`,
    openTpOverlay: (n2) => `Open ${n2} overlay`,
    amPmButton: "Switch AM/PM mode",
    openYearsOverlay: "Open years overlay",
    openMonthsOverlay: "Open months overlay",
    nextMonth: "Next month",
    prevMonth: "Previous month",
    day: () => ""
  },
  e3
), Rr = (e3) => e3 === null ? 0 : typeof e3 == "boolean" ? e3 ? 2 : 0 : +e3 >= 2 ? +e3 : 2, Ir = (e3, n2, a3) => e3 || (typeof a3 == "string" ? a3 : n2), Or = (e3) => typeof e3 == "boolean" ? e3 ? Nn({}) : false : Nn(e3), Br = () => ({
  enterSubmit: true,
  tabSubmit: true,
  openMenu: true,
  rangeSeparator: " - "
}), Yr = (e3) => Object.assign({ months: [], years: [], times: { hours: [], minutes: [], seconds: [] } }, e3), Ve = (e3) => {
  const n2 = () => {
    if (e3.partialRange)
      return null;
    throw new Error(Et.prop("partial-range"));
  }, a3 = computed(() => ({
    ariaLabels: Nr(e3.ariaLabels),
    textInputOptions: Object.assign(Br(), e3.textInputOptions),
    multiCalendars: Rr(e3.multiCalendars),
    previewFormat: Ir(e3.previewFormat, e3.format, d3()),
    filters: Yr(e3.filters),
    transitions: Or(e3.transitions),
    startTime: c2()
  })), t3 = (r2) => {
    if (e3.range)
      return r2();
    throw new Error(Et.prop("range"));
  }, o2 = () => {
    const r2 = e3.enableSeconds ? ":ss" : "";
    return e3.is24 ? `HH:mm${r2}` : `hh:mm${r2} aa`;
  }, d3 = () => e3.format ? e3.format : e3.monthPicker ? "MM/yyyy" : e3.timePicker ? o2() : e3.weekPicker ? "MM/dd/yyyy" : e3.yearPicker ? "yyyy" : e3.enableTimePicker ? `MM/dd/yyyy, ${o2()}` : "MM/dd/yyyy", p2 = (r2, m3) => {
    if (typeof e3.format == "function")
      return e3.format(r2);
    const y3 = m3 || d3(), k2 = e3.formatLocale ? { locale: e3.formatLocale } : void 0;
    return Array.isArray(r2) ? `${format(r2[0], y3, k2)} ${e3.modelAuto && !r2[1] ? "" : a3.value.textInputOptions.rangeSeparator || "-"} ${r2[1] ? format(r2[1], y3, k2) : ""}` : format(r2, y3, k2);
  }, $ = (r2) => e3.timezone ? Dr(r2, e3.timezone) : r2, O2 = (r2) => e3.timezone ? Mr(r2, e3.timezone) : r2, R2 = computed(() => (r2) => {
    var m3;
    return (m3 = e3.hideNavigation) == null ? void 0 : m3.includes(r2);
  }), F = (r2) => {
    const m3 = e3.maxDate ? Oe($(r2), $(b2(e3.maxDate))) : false, y3 = e3.minDate ? Pe($(r2), $(b2(e3.minDate))) : false, k2 = B2(r2, e3.disabledDates), G2 = a3.value.filters.months.map((we) => +we).includes(getMonth(r2)), de = e3.disabledWeekDays.length ? e3.disabledWeekDays.some((we) => +we === getDay(r2)) : false, f = e3.allowedDates.length ? !e3.allowedDates.some((we) => pe($(b2(we)), $(r2))) : false, l = getYear(r2), Q2 = l < +e3.yearRange[0] || l > +e3.yearRange[1];
    return !(m3 || y3 || k2 || G2 || Q2 || de || f);
  }, A = (r2) => {
    const m3 = {
      hours: getHours(b2()),
      minutes: getMinutes(b2()),
      seconds: getSeconds(b2())
    };
    return Object.assign(m3, r2);
  }, c2 = () => e3.range ? e3.startTime && Array.isArray(e3.startTime) ? [A(e3.startTime[0]), A(e3.startTime[1])] : null : e3.startTime && !Array.isArray(e3.startTime) ? A(e3.startTime) : null, M3 = (r2) => !F(r2), W = (r2) => Array.isArray(r2) ? isValid(r2[0]) && (r2[1] ? isValid(r2[1]) : true) : r2 ? isValid(r2) : false, Y2 = (r2) => r2 instanceof Date ? r2 : parseISO(r2), ee = (r2) => {
    const m3 = startOfWeek($(r2), { weekStartsOn: +e3.weekStart }), y3 = endOfWeek($(r2), { weekStartsOn: +e3.weekStart });
    return [m3, y3];
  }, B2 = (r2, m3) => Array.isArray(m3) ? m3.some((y3) => pe($(b2(y3)), $(r2))) : m3(r2), E2 = (r2, m3, y3) => {
    let k2 = r2 ? b2(r2) : b2();
    return (m3 || m3 === 0) && (k2 = setMonth(k2, m3)), y3 && (k2 = setYear(k2, y3)), k2;
  }, N = (r2) => set(b2(), { hours: getHours(r2), minutes: getMinutes(r2), seconds: getSeconds(r2) }), j = (r2) => set(b2(), {
    hours: +r2.hours || 0,
    minutes: +r2.minutes || 0,
    seconds: +r2.seconds || 0
  }), ae = (r2, m3, y3, k2) => {
    if (!r2)
      return true;
    if (k2) {
      const x2 = y3 === "max" ? isBefore(r2, m3) : isAfter(r2, m3), G2 = { seconds: 0, milliseconds: 0 };
      return x2 || isEqual(set(r2, G2), set(m3, G2));
    }
    return y3 === "max" ? r2.getTime() <= m3.getTime() : r2.getTime() >= m3.getTime();
  }, le = () => !e3.enableTimePicker || e3.monthPicker || e3.yearPicker || e3.ignoreTimeValidation, ce = (r2) => Array.isArray(r2) ? [r2[0] ? N(r2[0]) : null, r2[1] ? N(r2[1]) : null] : N(r2), v = (r2) => {
    const m3 = e3.maxTime ? j(e3.maxTime) : b2(e3.maxDate);
    return Array.isArray(r2) ? ae(r2[0], m3, "max", !!e3.maxDate) && ae(r2[1], m3, "max", !!e3.maxDate) : ae(r2, m3, "max", !!e3.maxDate);
  }, S3 = (r2, m3) => {
    const y3 = e3.minTime ? j(e3.minTime) : b2(e3.minDate);
    return Array.isArray(r2) ? ae(r2[0], y3, "min", !!e3.minDate) && ae(r2[1], y3, "min", !!e3.minDate) && m3 : ae(r2, y3, "min", !!e3.minDate) && m3;
  }, I2 = (r2) => {
    let m3 = true;
    if (!r2 || le())
      return true;
    const y3 = !e3.minDate && !e3.maxDate ? ce(r2) : r2;
    return (e3.maxTime || e3.maxDate) && (m3 = v(_e(y3))), (e3.minTime || e3.minDate) && (m3 = S3(_e(y3), m3)), m3;
  }, T2 = (r2, m3) => {
    const y3 = b2(JSON.parse(JSON.stringify(r2))), k2 = [];
    for (let x2 = 0; x2 < 7; x2++) {
      const G2 = addDays(y3, x2), de = getMonth(G2) !== m3;
      k2.push({
        text: e3.hideOffsetDates && de ? "" : G2.getDate(),
        value: G2,
        current: !de,
        classData: {}
      });
    }
    return k2;
  }, L2 = (r2, m3) => {
    const y3 = [], k2 = b2($(new Date(m3, r2))), x2 = b2($(new Date(m3, r2 + 1, 0))), G2 = startOfWeek(k2, { weekStartsOn: e3.weekStart }), de = (f) => {
      const l = T2(f, r2);
      if (y3.push({ days: l }), !y3[y3.length - 1].days.some(
        (Q2) => pe(Ke(Q2.value), Ke(x2))
      )) {
        const Q2 = addDays(f, 7);
        de(Q2);
      }
    };
    if (de(G2), e3.sixWeeks && y3.length < 6) {
      const f = 6 - y3.length;
      for (let l = 1; l <= f; l++) {
        const Q2 = y3[y3.length - 1], we = Q2.days[Q2.days.length - 1], be = T2(addDays(we.value, 1), getMonth(k2));
        y3.push({ days: be });
      }
    }
    return y3;
  }, Z = (r2, m3, y3) => [set(b2(r2), { date: 1 }), set(b2(), { month: m3, year: y3, date: 1 })], J = (r2, m3) => Pe(...Z(e3.minDate, r2, m3)) || pe(...Z(e3.minDate, r2, m3)), _2 = (r2, m3) => Oe(...Z(e3.maxDate, r2, m3)) || pe(...Z(e3.maxDate, r2, m3)), C = (r2, m3, y3) => {
    let k2 = false;
    return e3.maxDate && y3 && _2(r2, m3) && (k2 = true), e3.minDate && !y3 && J(r2, m3) && (k2 = true), k2;
  };
  return {
    checkPartialRangeValue: n2,
    checkRangeEnabled: t3,
    getZonedDate: $,
    getZonedToUtc: O2,
    formatDate: p2,
    getDefaultPattern: d3,
    validateDate: F,
    getDefaultStartTime: c2,
    isDisabled: M3,
    isValidDate: W,
    sanitizeDate: Y2,
    getWeekFromDate: ee,
    matchDate: B2,
    setDateMonthOrYear: E2,
    isValidTime: I2,
    getCalendarDays: L2,
    validateMonthYearInRange: (r2, m3, y3, k2) => {
      let x2 = false;
      return k2 ? e3.minDate && e3.maxDate ? x2 = C(r2, m3, y3) : (e3.minDate && J(r2, m3) || e3.maxDate && _2(r2, m3)) && (x2 = true) : x2 = true, x2;
    },
    validateMaxDate: _2,
    validateMinDate: J,
    defaults: a3,
    hideNavigationButtons: R2
  };
}, ye = reactive({
  monthYear: [],
  calendar: [],
  time: [],
  actionRow: [],
  selectionGrid: [],
  timePicker: {
    0: [],
    1: []
  },
  monthPicker: []
}), qt = ref(null), At = ref(false), Jt = ref(false), Qt = ref(false), en = ref(false), Ne = ref(0), Ae = ref(0), et = () => {
  const e3 = computed(() => At.value ? [...ye.selectionGrid, ye.actionRow].filter((B2) => B2.length) : Jt.value ? [
    ...ye.timePicker[0],
    ...ye.timePicker[1],
    en.value ? [] : [qt.value],
    ye.actionRow
  ].filter((B2) => B2.length) : Qt.value ? [...ye.monthPicker, ye.actionRow] : [ye.monthYear, ...ye.calendar, ye.time, ye.actionRow].filter((B2) => B2.length)), n2 = (B2) => {
    Ne.value = B2 ? Ne.value + 1 : Ne.value - 1;
    let E2 = null;
    e3.value[Ae.value] && (E2 = e3.value[Ae.value][Ne.value]), E2 || (Ne.value = B2 ? Ne.value - 1 : Ne.value + 1);
  }, a3 = (B2) => {
    if (Ae.value === 0 && !B2 || Ae.value === e3.value.length && B2)
      return;
    Ae.value = B2 ? Ae.value + 1 : Ae.value - 1, e3.value[Ae.value] ? e3.value[Ae.value] && !e3.value[Ae.value][Ne.value] && Ne.value !== 0 && (Ne.value = e3.value[Ae.value].length - 1) : Ae.value = B2 ? Ae.value - 1 : Ae.value + 1;
  }, t3 = (B2) => {
    let E2 = null;
    e3.value[Ae.value] && (E2 = e3.value[Ae.value][Ne.value]), E2 ? E2.focus({ preventScroll: !At.value }) : Ne.value = B2 ? Ne.value - 1 : Ne.value + 1;
  }, o2 = () => {
    n2(true), t3(true);
  }, d3 = () => {
    n2(false), t3(false);
  }, p2 = () => {
    a3(false), t3(true);
  }, $ = () => {
    a3(true), t3(true);
  }, O2 = (B2, E2) => {
    ye[E2] = B2;
  }, R2 = (B2, E2) => {
    ye[E2] = B2;
  }, F = () => {
    Ne.value = 0, Ae.value = 0;
  };
  return {
    buildMatrix: O2,
    buildMultiLevelMatrix: R2,
    setTimePickerBackRef: (B2) => {
      qt.value = B2;
    },
    setSelectionGrid: (B2) => {
      At.value = B2, F(), B2 || (ye.selectionGrid = []);
    },
    setTimePicker: (B2, E2 = false) => {
      Jt.value = B2, en.value = E2, F(), B2 || (ye.timePicker[0] = [], ye.timePicker[1] = []);
    },
    setTimePickerElements: (B2, E2 = 0) => {
      ye.timePicker[E2] = B2;
    },
    arrowRight: o2,
    arrowLeft: d3,
    arrowUp: p2,
    arrowDown: $,
    clearArrowNav: () => {
      ye.monthYear = [], ye.calendar = [], ye.time = [], ye.actionRow = [], ye.selectionGrid = [], ye.timePicker[0] = [], ye.timePicker[1] = [], At.value = false, Jt.value = false, en.value = false, Qt.value = false, F(), qt.value = null;
    },
    setMonthPicker: (B2) => {
      Qt.value = B2, F();
    },
    refSets: ye
  };
}, Rn = (e3) => Array.isArray(e3), at = (e3) => Array.isArray(e3), In = (e3) => Array.isArray(e3) && e3.length === 2, Vr = (e3, n2, a3, t3, o2) => {
  const {
    getDefaultStartTime: d3,
    isDisabled: p2,
    sanitizeDate: $,
    getWeekFromDate: O2,
    setDateMonthOrYear: R2,
    validateMonthYearInRange: F,
    defaults: A
  } = Ve(e3), c2 = computed({
    get: () => e3.internalModelValue,
    set: (s3) => {
      !e3.readonly && !e3.disabled && n2("update:internal-model-value", s3);
    }
  }), M3 = ref([]);
  watch(c2, () => {
    e3.multiCalendars || ae();
  });
  const W = ref([{ month: getMonth(b2()), year: getYear(b2()) }]), Y2 = reactive({
    hours: e3.range ? [getHours(b2()), getHours(b2())] : getHours(b2()),
    minutes: e3.range ? [getMinutes(b2()), getMinutes(b2())] : getMinutes(b2()),
    seconds: e3.range ? [0, 0] : 0
  }), ee = computed(
    () => (s3) => W.value[s3] ? W.value[s3].month : 0
  ), B2 = computed(
    () => (s3) => W.value[s3] ? W.value[s3].year : 0
  ), E2 = computed(() => e3.flow && e3.flow.length ? o2.value === e3.flow.length : true), N = (s3, w2, K2) => {
    var te, h4;
    W.value[s3] || (W.value[s3] = { month: 0, year: 0 }), W.value[s3].month = w2 === null ? (te = W.value[s3]) == null ? void 0 : te.month : w2, W.value[s3].year = K2 === null ? (h4 = W.value[s3]) == null ? void 0 : h4.year : K2;
  }, j = (s3, w2) => {
    Y2[s3] = w2;
  };
  onMounted(() => {
    c2.value || (e3.startDate && (N(0, getMonth(b2(e3.startDate)), getYear(b2(e3.startDate))), A.value.multiCalendars && nt(0)), A.value.startTime && _2()), ae(true);
  });
  const ae = (s3 = false) => {
    if (c2.value)
      return Array.isArray(c2.value) ? (M3.value = c2.value, I2(s3)) : ce(c2.value);
    if (e3.timePicker)
      return T2();
    if (e3.monthPicker && !e3.range)
      return L2();
    if (e3.yearPicker && !e3.range)
      return Z();
    if (A.value.multiCalendars && s3 && !e3.startDate)
      return le(b2(), s3);
  }, le = (s3, w2 = false) => {
    if ((!A.value.multiCalendars || !e3.multiStatic || w2) && N(0, getMonth(s3), getYear(s3)), A.value.multiCalendars)
      for (let K2 = 1; K2 < A.value.multiCalendars; K2++) {
        const te = set(b2(), { month: ee.value(K2 - 1), year: B2.value(K2 - 1) }), h4 = add(te, { months: 1 });
        W.value[K2] = { month: getMonth(h4), year: getYear(h4) };
      }
  }, ce = (s3) => {
    le(s3), j("hours", getHours(s3)), j("minutes", getMinutes(s3)), j("seconds", getSeconds(s3));
  }, v = (s3, w2) => {
    le(s3[0], w2);
    const K2 = (te, h4) => [
      te(s3[0]),
      s3[1] ? te(s3[1]) : Y2[h4][1]
    ];
    j("hours", K2(getHours, "hours")), j("minutes", K2(getMinutes, "minutes")), j("seconds", K2(getSeconds, "seconds"));
  }, S3 = (s3, w2) => {
    if ((e3.range || e3.weekPicker) && !e3.multiDates)
      return v(s3, w2);
    if (e3.multiDates) {
      const K2 = s3[s3.length - 1];
      return ce(K2);
    }
  }, I2 = (s3) => {
    const w2 = c2.value;
    S3(w2, s3), A.value.multiCalendars && e3.multiCalendarsSolo && u2();
  }, T2 = () => {
    if (_2(), !e3.range)
      c2.value = Ee(b2(), Y2.hours, Y2.minutes, J());
    else {
      const s3 = Y2.hours, w2 = Y2.minutes;
      c2.value = [
        Ee(b2(), s3[0], w2[0], J()),
        Ee(b2(), s3[1], w2[1], J(false))
      ];
    }
  }, L2 = () => {
    c2.value = R2(b2(), ee.value(0), B2.value(0));
  }, Z = () => {
    c2.value = b2();
  }, J = (s3 = true) => e3.enableSeconds ? Array.isArray(Y2.seconds) ? s3 ? Y2.seconds[0] : Y2.seconds[1] : Y2.seconds : 0, _2 = () => {
    const s3 = d3();
    if (s3) {
      const w2 = Array.isArray(s3), K2 = w2 ? [+s3[0].hours, +s3[1].hours] : +s3.hours, te = w2 ? [+s3[0].minutes, +s3[1].minutes] : +s3.minutes, h4 = w2 ? [+s3[0].seconds, +s3[1].seconds] : +s3.seconds;
      j("hours", K2), j("minutes", te), e3.enableSeconds && j("seconds", h4);
    }
  }, C = () => Array.isArray(c2.value) && c2.value.length ? c2.value[c2.value.length - 1] : null, u2 = () => {
    if (Array.isArray(c2.value) && c2.value.length === 2) {
      const s3 = b2(
        b2(c2.value[1] ? c2.value[1] : addMonths(c2.value[0], 1))
      ), [w2, K2] = [getMonth(c2.value[0]), getYear(c2.value[0])], [te, h4] = [getMonth(c2.value[1]), getYear(c2.value[1])];
      (w2 !== te || w2 === te && K2 !== h4) && e3.multiCalendarsSolo && N(1, getMonth(s3), getYear(s3));
    }
  }, r2 = (s3) => {
    const w2 = addMonths(s3, 1);
    return { month: getMonth(w2), year: getYear(w2) };
  }, m3 = (s3) => {
    const w2 = getMonth(b2(s3)), K2 = getYear(b2(s3));
    if (N(0, w2, K2), A.value.multiCalendars > 0)
      for (let te = 1; te < A.value.multiCalendars; te++) {
        const h4 = r2(
          set(b2(s3), { year: ee.value(te - 1), month: B2.value(te - 1) })
        );
        N(te, h4.month, h4.year);
      }
  }, y3 = (s3) => {
    if (c2.value && Array.isArray(c2.value))
      if (c2.value.some((w2) => pe(s3, w2))) {
        const w2 = c2.value.filter((K2) => !pe(K2, s3));
        c2.value = w2.length ? w2 : null;
      } else
        (e3.multiDatesLimit && +e3.multiDatesLimit > c2.value.length || !e3.multiDatesLimit) && c2.value.push(s3);
    else
      c2.value = [s3];
  }, k2 = (s3, w2) => {
    const K2 = Oe(s3, w2) ? w2 : s3, te = Oe(w2, s3) ? w2 : s3;
    return eachDayOfInterval({ start: K2, end: te });
  }, x2 = (s3) => {
    if (Array.isArray(c2.value) && c2.value[0]) {
      const w2 = differenceInCalendarDays(s3, c2.value[0]), K2 = k2(c2.value[0], s3), te = K2.length === 1 ? 0 : K2.filter((z2) => p2(z2)).length, h4 = Math.abs(w2) - te;
      if (e3.minRange && e3.maxRange)
        return h4 >= +e3.minRange && h4 <= +e3.maxRange;
      if (e3.minRange)
        return h4 >= +e3.minRange;
      if (e3.maxRange)
        return h4 <= +e3.maxRange;
    }
    return true;
  }, G2 = (s3) => Array.isArray(c2.value) && c2.value.length === 2 ? e3.fixedStart && (Oe(s3, c2.value[0]) || pe(s3, c2.value[0])) ? [c2.value[0], s3] : e3.fixedEnd && (Pe(s3, c2.value[1]) || pe(s3, c2.value[1])) ? [s3, c2.value[1]] : (n2("invalid-fixed-range", s3), c2.value) : [], de = () => {
    e3.autoApply && E2.value && n2("auto-apply");
  }, f = () => {
    e3.autoApply && n2("select-date");
  }, l = (s3) => !eachDayOfInterval({ start: s3[0], end: s3[1] }).some((K2) => p2(K2)), Q2 = (s3) => (c2.value = O2(b2(s3.value)), de()), we = (s3) => {
    const w2 = Ee(b2(s3.value), Y2.hours, Y2.minutes, J());
    e3.multiDates ? y3(w2) : c2.value = w2, a3(), de();
  }, be = () => {
    M3.value = c2.value ? c2.value.slice() : [], M3.value.length === 2 && !(e3.fixedStart || e3.fixedEnd) && (M3.value = []);
  }, We = (s3, w2) => {
    const K2 = [b2(s3.value), addDays(b2(s3.value), +e3.autoRange)];
    l(K2) && (w2 && m3(s3.value), M3.value = K2);
  }, je = (s3) => {
    re(s3.value) || (M3.value = G2(b2(s3.value)));
  }, re = (s3) => e3.noDisabledRange ? k2(M3.value[0], s3).some((K2) => p2(K2)) : false, Je = (s3, w2) => {
    if (be(), e3.autoRange)
      return We(s3, w2);
    if (e3.fixedStart || e3.fixedEnd)
      return je(s3);
    M3.value[0] ? x2(b2(s3.value)) && !re(s3.value) && (Pe(b2(s3.value), b2(M3.value[0])) ? M3.value.unshift(b2(s3.value)) : M3.value[1] = b2(s3.value)) : M3.value[0] = b2(s3.value);
  }, ze = (s3) => {
    M3.value[s3] = Ee(
      M3.value[s3],
      Y2.hours[s3],
      Y2.minutes[s3],
      J(s3 !== 1)
    );
  }, X2 = () => {
    M3.value.length && (M3.value[0] && !M3.value[1] ? ze(0) : (ze(0), ze(1), a3()), c2.value = M3.value.slice(), M3.value[0] && M3.value[1] && e3.autoApply && n2("auto-apply"), M3.value[0] && !M3.value[1] && e3.modelAuto && e3.autoApply && n2("auto-apply"));
  }, ke = (s3, w2 = false) => {
    if (!(p2(s3.value) || !s3.current && e3.hideOffsetDates)) {
      if (e3.weekPicker)
        return Q2(s3);
      if (!e3.range)
        return we(s3);
      at(Y2.hours) && at(Y2.minutes) && !e3.multiDates && (Je(s3, w2), X2());
    }
  }, me = (s3) => {
    const w2 = s3[0];
    return e3.weekNumbers === "local" ? getWeek(w2.value, { weekStartsOn: +e3.weekStart }) : e3.weekNumbers === "iso" ? getISOWeek(w2.value) : typeof e3.weekNumbers == "function" ? e3.weekNumbers(w2.value) : "";
  }, nt = (s3) => {
    for (let w2 = s3 - 1; w2 >= 0; w2--) {
      const K2 = subMonths(set(b2(), { month: ee.value(w2 + 1), year: B2.value(w2 + 1) }), 1);
      N(w2, getMonth(K2), getYear(K2));
    }
    for (let w2 = s3 + 1; w2 <= A.value.multiCalendars - 1; w2++) {
      const K2 = addMonths(set(b2(), { month: ee.value(w2 - 1), year: B2.value(w2 - 1) }), 1);
      N(w2, getMonth(K2), getYear(K2));
    }
  }, Le = (s3) => R2(b2(), ee.value(s3), B2.value(s3)), gt = (s3) => Ee(s3, Y2.hours, Y2.minutes, J()), Ut = (s3, w2) => {
    const K2 = e3.monthPicker ? ee.value(s3) !== w2.month || !w2.fromNav : B2.value(s3) !== w2.year;
    if (N(s3, w2.month, w2.year), A.value.multiCalendars && !e3.multiCalendarsSolo && nt(s3), e3.monthPicker || e3.yearPicker)
      if (e3.range) {
        if (K2) {
          let te = c2.value ? c2.value.slice() : [];
          te.length === 2 && te[1] !== null && (te = []), te.length ? Pe(Le(s3), te[0]) ? te.unshift(Le(s3)) : te[1] = Le(s3) : te = [Le(s3)], c2.value = te;
        }
      } else
        c2.value = Le(s3);
    n2("update-month-year", { instance: s3, month: w2.month, year: w2.year }), t3(e3.multiCalendarsSolo ? s3 : void 0);
  }, Ht = async (s3 = false) => {
    if (e3.autoApply && (e3.monthPicker || e3.yearPicker)) {
      await nextTick();
      const w2 = e3.monthPicker ? s3 : false;
      e3.range ? n2("auto-apply", w2 || !c2.value || c2.value.length === 1) : n2("auto-apply", w2);
    }
    a3();
  }, Mt = (s3, w2) => {
    const K2 = set(b2(), { month: ee.value(w2), year: B2.value(w2) }), te = s3 < 0 ? addMonths(K2, 1) : subMonths(K2, 1);
    F(getMonth(te), getYear(te), s3 < 0, e3.preventMinMaxNavigation) && (N(w2, getMonth(te), getYear(te)), A.value.multiCalendars && !e3.multiCalendarsSolo && nt(w2), n2("update-month-year", { instance: w2, month: getMonth(te), year: getYear(te) }), t3());
  }, pt = (s3) => {
    Rn(s3) && Rn(c2.value) && at(Y2.hours) && at(Y2.minutes) ? (s3[0] && c2.value[0] && (c2.value[0] = Ee(s3[0], Y2.hours[0], Y2.minutes[0], J())), s3[1] && c2.value[1] && (c2.value[1] = Ee(s3[1], Y2.hours[1], Y2.minutes[1], J(false)))) : e3.multiDates && Array.isArray(c2.value) ? c2.value[c2.value.length - 1] = gt(s3) : !e3.range && !In(s3) && (c2.value = gt(s3)), n2("time-update");
  }, Wt = (s3, w2 = true, K2 = false) => {
    const te = w2 ? s3 : Y2.hours, h4 = !w2 && !K2 ? s3 : Y2.minutes, z2 = K2 ? s3 : Y2.seconds;
    if (e3.range && In(c2.value) && at(te) && at(h4) && at(z2) && !e3.disableTimeRangeValidation) {
      const $e = (Fe) => Ee(c2.value[Fe], te[Fe], h4[Fe], z2[Fe]), Te = (Fe) => setMilliseconds(c2.value[Fe], 0);
      if (pe(c2.value[0], c2.value[1]) && (isAfter($e(0), Te(1)) || isBefore($e(1), Te(0))))
        return;
    }
    if (j("hours", te), j("minutes", h4), j("seconds", z2), c2.value)
      if (e3.multiDates) {
        const $e = C();
        $e && pt($e);
      } else
        pt(c2.value);
    else
      e3.timePicker && pt(e3.range ? [b2(), b2()] : b2());
    a3();
  }, zt = (s3, w2) => {
    e3.monthChangeOnScroll && Mt(e3.monthChangeOnScroll !== "inverse" ? -s3.deltaY : s3.deltaY, w2);
  }, xt = (s3, w2, K2 = false) => {
    e3.monthChangeOnArrows && e3.vertical === K2 && _t(s3, w2);
  }, _t = (s3, w2) => {
    Mt(s3 === "right" ? -1 : 1, w2);
  };
  return {
    time: Y2,
    month: ee,
    year: B2,
    modelValue: c2,
    calendars: W,
    monthYearSelect: Ht,
    isDisabled: p2,
    updateTime: Wt,
    getWeekNum: me,
    selectDate: ke,
    updateMonthYear: Ut,
    handleScroll: zt,
    getMarker: (s3) => e3.markers.find((w2) => pe($(s3.value), $(w2.date))),
    handleArrow: xt,
    handleSwipe: _t,
    selectCurrentDate: () => {
      e3.range ? c2.value && Array.isArray(c2.value) && c2.value[0] ? c2.value = Pe(b2(), c2.value[0]) ? [b2(), c2.value[0]] : [c2.value[0], b2()] : c2.value = [b2()] : c2.value = b2(), f();
    },
    presetDateRange: (s3, w2) => {
      w2 || s3.length && s3.length <= 2 && e3.range && (c2.value = s3.map((K2) => b2(K2)), f(), e3.multiCalendars && nextTick().then(() => ae(true)));
    }
  };
}, Er = (e3, n2, a3) => {
  const t3 = ref(), {
    getZonedToUtc: o2,
    getZonedDate: d3,
    formatDate: p2,
    getDefaultPattern: $,
    checkRangeEnabled: O2,
    checkPartialRangeValue: R2,
    isValidDate: F,
    setDateMonthOrYear: A,
    defaults: c2
  } = Ve(n2), M3 = ref(""), W = toRef(n2, "format");
  watch(t3, () => {
    e3("internal-model-change", t3.value);
  }), watch(W, () => {
    r2();
  });
  const Y2 = (l) => {
    const Q2 = l || b2();
    return n2.modelType ? y3(Q2) : {
      hours: getHours(Q2),
      minutes: getMinutes(Q2),
      seconds: n2.enableSeconds ? getSeconds(Q2) : 0
    };
  }, ee = (l) => n2.modelType ? y3(l) : { month: getMonth(l), year: getYear(l) }, B2 = (l) => Array.isArray(l) ? O2(() => [
    setYear(b2(), l[0]),
    l[1] ? setYear(b2(), l[1]) : R2()
  ]) : setYear(b2(), +l), E2 = (l, Q2) => (typeof l == "string" || typeof l == "number") && n2.modelType ? m3(l) : Q2, N = (l) => Array.isArray(l) ? [
    E2(
      l[0],
      Ee(null, +l[0].hours, +l[0].minutes, l[0].seconds)
    ),
    E2(
      l[1],
      Ee(null, +l[1].hours, +l[1].minutes, l[1].seconds)
    )
  ] : E2(l, Ee(null, l.hours, l.minutes, l.seconds)), j = (l) => Array.isArray(l) ? O2(() => [
    E2(l[0], A(null, +l[0].month, +l[0].year)),
    E2(
      l[1],
      l[1] ? A(null, +l[1].month, +l[1].year) : R2()
    )
  ]) : E2(l, A(null, +l.month, +l.year)), ae = (l) => {
    if (Array.isArray(l))
      return l.map((Q2) => m3(Q2));
    throw new Error(Et.dateArr("multi-dates"));
  }, le = (l) => {
    if (Array.isArray(l))
      return [b2(l[0]), b2(l[1])];
    throw new Error(Et.dateArr("week-picker"));
  }, ce = (l) => n2.modelAuto ? Array.isArray(l) ? [m3(l[0]), m3(l[1])] : n2.autoApply ? [m3(l)] : [m3(l), null] : Array.isArray(l) ? O2(() => [
    m3(l[0]),
    l[1] ? m3(l[1]) : R2()
  ]) : m3(l), v = () => {
    Array.isArray(t3.value) && n2.range && t3.value.length === 1 && t3.value.push(R2());
  }, S3 = () => {
    const l = t3.value;
    return [
      y3(l[0]),
      l[1] ? y3(l[1]) : R2()
    ];
  }, I2 = () => t3.value[1] ? S3() : y3(_e(t3.value[0])), T2 = () => (t3.value || []).map((l) => y3(l)), L2 = () => (v(), n2.modelAuto ? I2() : n2.multiDates ? T2() : Array.isArray(t3.value) ? O2(() => S3()) : y3(_e(t3.value))), Z = (l) => l ? n2.timePicker ? N(_e(l)) : n2.monthPicker ? j(_e(l)) : n2.yearPicker ? B2(_e(l)) : n2.multiDates ? ae(_e(l)) : n2.weekPicker ? le(_e(l)) : ce(_e(l)) : null, J = (l) => {
    const Q2 = Z(l);
    F(_e(Q2)) ? (t3.value = _e(Q2), r2()) : (t3.value = null, M3.value = "");
  }, _2 = () => {
    var Q2;
    const l = (we) => {
      var be;
      return format(we, (be = c2.value.textInputOptions) == null ? void 0 : be.format);
    };
    return `${l(t3.value[0])} ${(Q2 = c2.value.textInputOptions) == null ? void 0 : Q2.rangeSeparator} ${t3.value[1] ? l(t3.value[1]) : ""}`;
  }, C = () => {
    var l;
    return a3.value && t3.value ? Array.isArray(t3.value) ? _2() : format(t3.value, (l = c2.value.textInputOptions) == null ? void 0 : l.format) : p2(t3.value);
  }, u2 = () => {
    var l;
    return t3.value ? n2.multiDates ? t3.value.map((Q2) => p2(Q2)).join("; ") : n2.textInput && typeof ((l = c2.value.textInputOptions) == null ? void 0 : l.format) == "string" ? C() : p2(t3.value) : "";
  }, r2 = () => {
    !n2.format || typeof n2.format == "string" ? M3.value = u2() : M3.value = n2.format(t3.value);
  }, m3 = (l) => {
    if (n2.utc) {
      const Q2 = new Date(l);
      return n2.utc === "preserve" ? new Date(Q2.getTime() + Q2.getTimezoneOffset() * 6e4) : Q2;
    }
    return n2.modelType ? n2.modelType === "date" || n2.modelType === "timestamp" ? d3(new Date(l)) : n2.modelType === "format" && (typeof n2.format == "string" || !n2.format) ? parse(l, $(), new Date()) : d3(parse(l, n2.modelType, new Date())) : d3(new Date(l));
  }, y3 = (l) => n2.utc ? Ja(l, n2.utc === "preserve") : n2.modelType ? n2.modelType === "timestamp" ? +o2(l) : n2.modelType === "format" && (typeof n2.format == "string" || !n2.format) ? p2(o2(l)) : p2(o2(l), n2.modelType) : o2(l), k2 = (l) => {
    e3("update:model-value", l);
  }, x2 = (l) => Array.isArray(t3.value) ? [
    l(t3.value[0]),
    t3.value[1] ? l(t3.value[1]) : R2()
  ] : l(_e(t3.value)), G2 = (l) => k2(_e(x2(l)));
  return {
    inputValue: M3,
    internalModelValue: t3,
    checkBeforeEmit: () => t3.value ? n2.range ? n2.partialRange ? t3.value.length >= 1 : t3.value.length === 2 : !!t3.value : false,
    parseExternalModelValue: J,
    formatInputValue: r2,
    emitModelValue: () => (r2(), n2.monthPicker ? G2(ee) : n2.timePicker ? G2(Y2) : n2.yearPicker ? G2(getYear) : n2.weekPicker ? k2(t3.value) : k2(L2()))
  };
}, Lr = (e3, n2) => {
  const { validateMonthYearInRange: a3, validateMaxDate: t3, validateMinDate: o2, defaults: d3 } = Ve(e3), p2 = (A, c2) => {
    let M3 = A;
    return d3.value.filters.months.includes(getMonth(M3)) ? (M3 = c2 ? addMonths(A, 1) : subMonths(A, 1), p2(M3, c2)) : M3;
  }, $ = (A, c2) => {
    let M3 = A;
    return d3.value.filters.years.includes(getYear(M3)) ? (M3 = c2 ? addYears(A, 1) : subYears(A, 1), $(M3, c2)) : M3;
  }, O2 = (A) => {
    const c2 = set(new Date(), { month: e3.month, year: e3.year });
    let M3 = A ? addMonths(c2, 1) : subMonths(c2, 1), W = getMonth(M3), Y2 = getYear(M3);
    d3.value.filters.months.includes(W) && (M3 = p2(M3, A), W = getMonth(M3), Y2 = getYear(M3)), d3.value.filters.years.includes(Y2) && (M3 = $(M3, A), Y2 = getYear(M3)), a3(W, Y2, A, e3.preventMinMaxNavigation) && R2(W, Y2);
  }, R2 = (A, c2) => {
    n2("update-month-year", { month: A, year: c2 });
  }, F = computed(() => (A) => {
    if (!e3.preventMinMaxNavigation || A && !e3.maxDate || !A && !e3.minDate)
      return false;
    const c2 = set(new Date(), { month: e3.month, year: e3.year }), M3 = A ? addMonths(c2, 1) : subMonths(c2, 1), W = [getMonth(M3), getYear(M3)];
    return A ? !t3(...W) : !o2(...W);
  });
  return { handleMonthYearChange: O2, isDisabled: F, updateMonthYear: R2 };
};
var Rt = /* @__PURE__ */ ((e3) => (e3.center = "center", e3.left = "left", e3.right = "right", e3))(Rt || {});
const Fr = (e3, n2, a3, t3) => {
  const o2 = ref({
    top: "0",
    left: "0",
    transform: "none"
  }), d3 = ref(false), p2 = toRef(t3, "teleportCenter");
  watch(p2, () => {
    Y2();
  });
  const $ = () => ({ top: 0, left: 0 }), O2 = (v, S3) => {
    o2.value.left = `${v + S3}px`, o2.value.transform = "translateX(-100%)";
  }, R2 = (v) => {
    o2.value.left = `${v}px`, o2.value.transform = "translateX(0)";
  }, F = (v, S3, I2 = false) => {
    t3.position === Rt.left && R2(v), t3.position === Rt.right && O2(v, S3), t3.position === Rt.center && (o2.value.left = `${v + S3 / 2}px`, o2.value.transform = I2 ? "translate(-50%, -50%)" : "translateX(-50%)");
  }, A = (v) => {
    const { width: S3, height: I2 } = v.getBoundingClientRect(), { top: T2, left: L2 } = t3.altPosition ? t3.altPosition(v) : $();
    return { top: +T2, left: +L2, width: S3, height: I2 };
  }, c2 = () => {
    const v = Me(n2);
    if (v) {
      const { top: S3, left: I2, width: T2, height: L2 } = A(v);
      o2.value.top = `${S3 + L2 / 2}px`, o2.value.transform = "translateY(-50%)", F(I2, T2, true);
    }
  }, M3 = () => {
    o2.value.left = "50%", o2.value.top = "50%", o2.value.transform = "translate(-50%, -50%)", o2.value.position = "fixed";
  }, W = () => {
    const v = Me(n2), { top: S3, left: I2, transform: T2 } = t3.altPosition(v);
    o2.value = { top: `${S3}px`, left: `${I2}px`, transform: T2 || "" };
  }, Y2 = (v = true) => {
    if (!t3.inline)
      return p2.value ? M3() : t3.altPosition !== null ? W() : (v && a3("recalculate-position"), ae());
  }, ee = ({
    inputEl: v,
    menuEl: S3,
    left: I2,
    width: T2
  }) => {
    window.screen.width > 768 && F(I2, T2), N(v, S3);
  }, B2 = (v, S3) => {
    const { top: I2, left: T2, height: L2, width: Z } = A(v);
    o2.value.top = `${L2 + I2 + +t3.offset}px`, ee({ inputEl: v, menuEl: S3, left: T2, width: Z }), d3.value = false;
  }, E2 = (v, S3) => {
    const { top: I2, left: T2, width: L2 } = A(v), { height: Z } = S3.getBoundingClientRect();
    o2.value.top = `${I2 - Z - +t3.offset}px`, ee({ inputEl: v, menuEl: S3, left: T2, width: L2 }), d3.value = true;
  }, N = (v, S3) => {
    if (t3.autoPosition) {
      const { left: I2, width: T2 } = A(v), { left: L2, right: Z } = S3.getBoundingClientRect();
      return L2 <= 0 || L2 <= I2 ? R2(I2) : Z >= document.documentElement.clientWidth ? O2(I2, T2) : F(I2, T2);
    }
  }, j = (v, S3) => {
    const { height: I2 } = S3.getBoundingClientRect(), { top: T2, height: L2 } = v.getBoundingClientRect(), J = window.innerHeight - T2 - L2, _2 = T2;
    return I2 <= J ? B2(v, S3) : I2 > J && I2 <= _2 ? E2(v, S3) : J >= _2 ? B2(v, S3) : E2(v, S3);
  }, ae = () => {
    const v = Me(n2), S3 = Me(e3);
    if (v && S3)
      return t3.autoPosition ? j(v, S3) : B2(v, S3);
  }, le = function(v) {
    if (v) {
      const S3 = v.scrollHeight > v.clientHeight, T2 = window.getComputedStyle(v).overflowY.indexOf("hidden") !== -1;
      return S3 && !T2;
    }
    return true;
  }, ce = function(v) {
    return !v || v === document.body ? window : le(v) ? v : ce(v.parentNode);
  };
  return { openOnTop: d3, menuPosition: o2, setMenuPosition: Y2, setInitialPosition: c2, getScrollableParent: ce };
}, ft = [
  { name: "clock-icon", use: ["time", "calendar"] },
  { name: "arrow-left", use: ["month-year", "calendar"] },
  { name: "arrow-right", use: ["month-year", "calendar"] },
  { name: "arrow-up", use: ["time", "calendar"] },
  { name: "arrow-down", use: ["time", "calendar"] },
  { name: "calendar-icon", use: ["month-year", "time", "calendar"] },
  { name: "day", use: ["calendar"] },
  { name: "month-overlay-value", use: ["calendar", "month-year"] },
  { name: "year-overlay-value", use: ["calendar", "month-year"] },
  { name: "year-overlay", use: ["month-year"] },
  { name: "month-overlay", use: ["month-year"] },
  { name: "month-overlay-header", use: ["month-year"] },
  { name: "year-overlay-header", use: ["month-year"] },
  { name: "hours-overlay-value", use: ["calendar", "time"] },
  { name: "minutes-overlay-value", use: ["calendar", "time"] },
  { name: "seconds-overlay-value", use: ["calendar", "time"] },
  { name: "hours", use: ["calendar", "time"] },
  { name: "minutes", use: ["calendar", "time"] },
  { name: "month", use: ["calendar", "month-year"] },
  { name: "year", use: ["calendar", "month-year"] },
  { name: "action-select", use: ["action"] },
  { name: "action-preview", use: ["action"] },
  { name: "calendar-header", use: ["calendar"] },
  { name: "marker-tooltip", use: ["calendar"] },
  { name: "now-button", use: [] },
  { name: "time-picker-overlay", use: ["calendar", "time"] },
  { name: "am-pm-button", use: ["calendar", "time"] },
  { name: "left-sidebar", use: ["menu"] },
  { name: "right-sidebar", use: ["menu"] },
  { name: "month-year", use: ["month-year"] },
  { name: "time-picker", use: ["menu"] },
  { name: "action-row", use: ["action"] }
], Ur = [{ name: "trigger" }, { name: "input-icon" }, { name: "clear-icon" }, { name: "dp-input" }], Hr = {
  all: () => ft,
  monthYear: () => ft.filter((e3) => e3.use.includes("month-year")),
  input: () => Ur,
  timePicker: () => ft.filter((e3) => e3.use.includes("time")),
  action: () => ft.filter((e3) => e3.use.includes("action")),
  calendar: () => ft.filter((e3) => e3.use.includes("calendar")),
  menu: () => ft.filter((e3) => e3.use.includes("menu"))
}, st = (e3, n2, a3) => {
  const t3 = [];
  return Hr[n2]().forEach((o2) => {
    e3[o2.name] && t3.push(o2.name);
  }), a3 && a3.length && a3.forEach((o2) => {
    o2.slot && t3.push(o2.slot);
  }), t3;
}, Ft = (e3) => ({ transitionName: computed(() => (a3) => e3 && typeof e3 != "boolean" ? a3 ? e3.open : e3.close : ""), showTransition: !!e3 }), tt = {
  multiCalendars: { type: [Boolean, Number, String], default: null },
  modelValue: { type: [String, Date, Array, Object, Number], default: null },
  modelType: { type: String, default: null },
  position: { type: String, default: "center" },
  dark: { type: Boolean, default: false },
  format: {
    type: [String, Function],
    default: () => null
  },
  closeOnScroll: { type: Boolean, default: false },
  autoPosition: { type: Boolean, default: true },
  closeOnAutoApply: { type: Boolean, default: true },
  altPosition: { type: Function, default: null },
  transitions: { type: [Boolean, Object], default: true },
  formatLocale: { type: Object, default: null },
  utc: { type: [Boolean, String], default: false },
  ariaLabels: { type: Object, default: () => ({}) },
  offset: { type: [Number, String], default: 10 },
  hideNavigation: { type: Array, default: () => [] },
  timezone: { type: String, default: null },
  vertical: { type: Boolean, default: false },
  disableMonthYearSelect: { type: Boolean, default: false },
  menuClassName: { type: String, default: null },
  dayClass: { type: Function, default: null },
  yearRange: { type: Array, default: () => [1900, 2100] },
  multiCalendarsSolo: { type: Boolean, default: false },
  calendarCellClassName: { type: String, default: null },
  enableTimePicker: { type: Boolean, default: true },
  autoApply: { type: Boolean, default: false },
  disabledDates: { type: [Array, Function], default: () => [] },
  monthNameFormat: { type: String, default: "short" },
  startDate: { type: [Date, String], default: null },
  startTime: { type: [Object, Array], default: null },
  hideOffsetDates: { type: Boolean, default: false },
  autoRange: { type: [Number, String], default: null },
  noToday: { type: Boolean, default: false },
  disabledWeekDays: { type: Array, default: () => [] },
  allowedDates: { type: Array, default: () => [] },
  showNowButton: { type: Boolean, default: false },
  nowButtonLabel: { type: String, default: "Now" },
  markers: { type: Array, default: () => [] },
  modeHeight: { type: [Number, String], default: 255 },
  escClose: { type: Boolean, default: true },
  spaceConfirm: { type: Boolean, default: true },
  monthChangeOnArrows: { type: Boolean, default: true },
  presetRanges: { type: Array, default: () => [] },
  flow: { type: Array, default: () => [] },
  preventMinMaxNavigation: { type: Boolean, default: false },
  minRange: { type: [Number, String], default: null },
  maxRange: { type: [Number, String], default: null },
  multiDatesLimit: { type: [Number, String], default: null },
  reverseYears: { type: Boolean, default: false },
  keepActionRow: { type: Boolean, default: false },
  weekPicker: { type: Boolean, default: false },
  filters: { type: Object, default: () => ({}) },
  arrowNavigation: { type: Boolean, default: false },
  multiStatic: { type: Boolean, default: true },
  disableTimeRangeValidation: { type: Boolean, default: false },
  highlight: {
    type: [Array, Function],
    default: null
  },
  highlightWeekDays: {
    type: Array,
    default: null
  },
  highlightDisabledDays: { type: Boolean, default: false },
  teleportCenter: { type: Boolean, default: false },
  locale: { type: String, default: "en-Us" },
  weekNumName: { type: String, default: "W" },
  weekStart: { type: [Number, String], default: 1 },
  weekNumbers: {
    type: [String, Function],
    default: null
  },
  calendarClassName: { type: String, default: null },
  noSwipe: { type: Boolean, default: false },
  monthChangeOnScroll: { type: [Boolean, String], default: true },
  dayNames: {
    type: [Function, Array],
    default: null
  },
  monthPicker: { type: Boolean, default: false },
  customProps: { type: Object, default: null },
  yearPicker: { type: Boolean, default: false },
  modelAuto: { type: Boolean, default: false },
  selectText: { type: String, default: "Select" },
  cancelText: { type: String, default: "Cancel" },
  previewFormat: {
    type: [String, Function],
    default: () => ""
  },
  multiDates: { type: Boolean, default: false },
  partialRange: { type: Boolean, default: true },
  ignoreTimeValidation: { type: Boolean, default: false },
  minDate: { type: [Date, String], default: null },
  maxDate: { type: [Date, String], default: null },
  minTime: { type: Object, default: null },
  maxTime: { type: Object, default: null },
  name: { type: String, default: null },
  placeholder: { type: String, default: "" },
  hideInputIcon: { type: Boolean, default: false },
  clearable: { type: Boolean, default: true },
  state: { type: Boolean, default: null },
  required: { type: Boolean, default: false },
  autocomplete: { type: String, default: "off" },
  inputClassName: { type: String, default: null },
  inlineWithInput: { type: Boolean, default: false },
  textInputOptions: { type: Object, default: () => null },
  fixedStart: { type: Boolean, default: false },
  fixedEnd: { type: Boolean, default: false },
  timePicker: { type: Boolean, default: false },
  enableSeconds: { type: Boolean, default: false },
  is24: { type: Boolean, default: true },
  noHoursOverlay: { type: Boolean, default: false },
  noMinutesOverlay: { type: Boolean, default: false },
  noSecondsOverlay: { type: Boolean, default: false },
  hoursGridIncrement: { type: [String, Number], default: 1 },
  minutesGridIncrement: { type: [String, Number], default: 5 },
  secondsGridIncrement: { type: [String, Number], default: 5 },
  hoursIncrement: { type: [Number, String], default: 1 },
  minutesIncrement: { type: [Number, String], default: 1 },
  secondsIncrement: { type: [Number, String], default: 1 },
  range: { type: Boolean, default: false },
  uid: { type: String, default: null },
  disabled: { type: Boolean, default: false },
  readonly: { type: Boolean, default: false },
  inline: { type: Boolean, default: false },
  textInput: { type: Boolean, default: false },
  onClickOutside: { type: Function, default: null },
  noDisabledRange: { type: Boolean, default: false },
  sixWeeks: { type: Boolean, default: false }
}, Wr = ["aria-label", "aria-disabled", "aria-readonly"], zr = {
  key: 1,
  class: "dp__input_wrap"
}, xr = ["id", "name", "inputmode", "placeholder", "disabled", "readonly", "required", "value", "autocomplete", "onKeydown"], Kr = {
  key: 2,
  class: "dp__input_icon"
}, jr = {
  key: 4,
  class: "dp__clear_icon"
}, Gr = /* @__PURE__ */ defineComponent$1({
  __name: "DatepickerInput",
  props: {
    isMenuOpen: { type: Boolean, default: false },
    inputValue: { type: String, default: "" },
    ...tt
  },
  emits: [
    "clear",
    "open",
    "update:input-value",
    "set-input-date",
    "close",
    "select-date",
    "set-empty-date",
    "toggle",
    "focus-prev",
    "focus",
    "blur"
  ],
  setup(e3, { expose: n2, emit: a3 }) {
    const t3 = e3, { getDefaultPattern: o2, isValidDate: d3, defaults: p2 } = Ve(t3), $ = ref(), O2 = ref(null), R2 = ref(false), F = computed(
      () => ({
        dp__pointer: !t3.disabled && !t3.readonly && !t3.textInput,
        dp__disabled: t3.disabled,
        dp__input_readonly: !t3.textInput,
        dp__input: true,
        dp__input_icon_pad: !t3.hideInputIcon,
        dp__input_valid: t3.state,
        dp__input_invalid: t3.state === false,
        dp__input_focus: R2.value || t3.isMenuOpen,
        dp__input_reg: !t3.textInput,
        [t3.inputClassName]: !!t3.inputClassName
      })
    ), A = () => {
      a3("set-input-date", null), t3.autoApply && (a3("set-empty-date"), $.value = null);
    }, c2 = (v) => {
      var S3;
      return qa(v, ((S3 = p2.value.textInputOptions) == null ? void 0 : S3.format) || o2());
    }, M3 = (v) => {
      const { rangeSeparator: S3 } = p2.value.textInputOptions, [I2, T2] = v.split(`${S3}`);
      if (I2) {
        const L2 = c2(I2.trim()), Z = T2 ? c2(T2.trim()) : null, J = L2 && Z ? [L2, Z] : [L2];
        $.value = L2 ? J : null;
      }
    }, W = (v) => {
      if (t3.range)
        M3(v);
      else if (t3.multiDates) {
        const S3 = v.split(";");
        $.value = S3.map((I2) => c2(I2.trim())).filter((I2) => I2);
      } else
        $.value = c2(v);
    }, Y2 = (v) => {
      var I2;
      const { value: S3 } = v.target;
      S3 !== "" ? ((I2 = p2.value.textInputOptions) != null && I2.openMenu && !t3.isMenuOpen && a3("open"), W(S3), a3("set-input-date", $.value)) : A(), a3("update:input-value", S3);
    }, ee = () => {
      var v, S3;
      (v = p2.value.textInputOptions) != null && v.enterSubmit && d3($.value) && t3.inputValue !== "" ? (a3("set-input-date", $.value, true), $.value = null) : (S3 = p2.value.textInputOptions) != null && S3.enterSubmit && t3.inputValue === "" && ($.value = null, a3("clear"));
    }, B2 = () => {
      var v, S3;
      (v = p2.value.textInputOptions) != null && v.tabSubmit && d3($.value) && t3.inputValue !== "" ? (a3("set-input-date", $.value, true), $.value = null) : (S3 = p2.value.textInputOptions) != null && S3.tabSubmit && t3.inputValue === "" && ($.value = null, a3("clear"));
    }, E2 = () => {
      R2.value = true, a3("focus");
    }, N = (v) => {
      var S3;
      v.preventDefault(), v.stopImmediatePropagation(), v.stopPropagation(), t3.textInput && ((S3 = p2.value.textInputOptions) != null && S3.openMenu) && !t3.inlineWithInput ? t3.isMenuOpen ? p2.value.textInputOptions.enterSubmit && a3("select-date") : a3("open") : t3.textInput || a3("toggle");
    }, j = () => {
      R2.value = false, t3.isMenuOpen || a3("blur"), t3.autoApply && t3.textInput && $.value && (a3("set-input-date", $.value), a3("select-date"), $.value = null);
    }, ae = () => {
      a3("clear");
    }, le = (v) => {
      t3.textInput || v.preventDefault();
    };
    return n2({
      focusInput: () => {
        O2.value && O2.value.focus({ preventScroll: true });
      }
    }), (v, S3) => {
      var I2;
      return openBlock(), createElementBlock("div", {
        onClick: N,
        "aria-label": (I2 = unref(p2).ariaLabels) == null ? void 0 : I2.input,
        role: "textbox",
        "aria-multiline": "false",
        "aria-disabled": v.disabled,
        "aria-readonly": v.readonly
      }, [
        v.$slots.trigger && !v.$slots["dp-input"] && !v.inline ? renderSlot(v.$slots, "trigger", { key: 0 }) : createCommentVNode("", true),
        !v.$slots.trigger && (!v.inline || v.inlineWithInput) ? (openBlock(), createElementBlock("div", zr, [
          v.$slots["dp-input"] && !v.$slots.trigger && !v.inline ? renderSlot(v.$slots, "dp-input", {
            key: 0,
            value: e3.inputValue,
            onInput: Y2,
            onEnter: ee,
            onTab: B2,
            onClear: ae
          }) : createCommentVNode("", true),
          v.$slots["dp-input"] ? createCommentVNode("", true) : (openBlock(), createElementBlock("input", {
            key: 1,
            ref_key: "inputRef",
            ref: O2,
            id: v.uid ? `dp-input-${v.uid}` : void 0,
            name: v.name,
            class: normalizeClass(unref(F)),
            inputmode: v.textInput ? "text" : "none",
            placeholder: v.placeholder,
            disabled: v.disabled,
            readonly: v.readonly,
            required: v.required,
            value: e3.inputValue,
            autocomplete: v.autocomplete,
            onInput: Y2,
            onKeydown: [
              withKeys(N, ["enter"]),
              withKeys(B2, ["tab"])
            ],
            onBlur: j,
            onFocus: E2,
            onKeypress: le
          }, null, 42, xr)),
          v.$slots["input-icon"] && !v.hideInputIcon ? (openBlock(), createElementBlock("span", Kr, [
            renderSlot(v.$slots, "input-icon")
          ])) : createCommentVNode("", true),
          !v.$slots["input-icon"] && !v.hideInputIcon && !v.$slots["dp-input"] ? (openBlock(), createBlock(unref(Lt), {
            key: 3,
            class: "dp__input_icon dp__input_icons"
          })) : createCommentVNode("", true),
          v.$slots["clear-icon"] && e3.inputValue && v.clearable && !v.disabled && !v.readonly ? (openBlock(), createElementBlock("span", jr, [
            renderSlot(v.$slots, "clear-icon", { clear: ae })
          ])) : createCommentVNode("", true),
          v.clearable && !v.$slots["clear-icon"] && e3.inputValue && !v.disabled && !v.readonly ? (openBlock(), createBlock(unref(Ma), {
            key: 5,
            class: "dp__clear_icon dp__input_icons",
            "data-test": "clear-icon",
            onClick: withModifiers(ae, ["stop", "prevent"])
          }, null, 8, ["onClick"])) : createCommentVNode("", true)
        ])) : createCommentVNode("", true)
      ], 8, Wr);
    };
  }
}), Zr = { class: "dp__selection_preview" }, Xr = { class: "dp__action_buttons" }, qr = ["onKeydown"], Jr = /* @__PURE__ */ defineComponent$1({
  __name: "ActionRow",
  props: {
    calendarWidth: { type: Number, default: 0 },
    menuMount: { type: Boolean, default: false },
    internalModelValue: { type: [Date, Array], default: null },
    ...tt
  },
  emits: ["close-picker", "select-date", "invalid-select"],
  setup(e3, { emit: n2 }) {
    const a3 = e3, { formatDate: t3, isValidTime: o2, defaults: d3 } = Ve(a3), { buildMatrix: p2 } = et(), $ = ref(null), O2 = ref(null);
    onMounted(() => {
      a3.arrowNavigation && p2([Me($), Me(O2)], "actionRow");
    });
    const R2 = computed(() => a3.range && !a3.partialRange && a3.internalModelValue ? a3.internalModelValue.length === 2 : true), F = computed(() => !c2.value || !M3.value || !R2.value), A = computed(() => ({
      dp__action: true,
      dp__select: true,
      dp__action_disabled: F.value
    })), c2 = computed(() => !a3.enableTimePicker || a3.ignoreTimeValidation ? true : o2(a3.internalModelValue)), M3 = computed(() => a3.monthPicker ? B2(a3.internalModelValue) : true), W = () => {
      const N = d3.value.previewFormat;
      return a3.timePicker || a3.monthPicker, N(_e(a3.internalModelValue));
    }, Y2 = () => {
      const N = a3.internalModelValue;
      return d3.value.multiCalendars > 0 ? `${t3(N[0])} - ${t3(N[1])}` : [t3(N[0]), t3(N[1])];
    }, ee = computed(() => !a3.internalModelValue || !a3.menuMount ? "" : typeof d3.value.previewFormat == "string" ? Array.isArray(a3.internalModelValue) ? a3.internalModelValue.length === 2 && a3.internalModelValue[1] ? Y2() : a3.multiDates ? a3.internalModelValue.map((N) => `${t3(N)}`) : a3.modelAuto ? `${t3(a3.internalModelValue[0])}` : `${t3(a3.internalModelValue[0])} -` : t3(a3.internalModelValue) : W()), B2 = (N) => {
      if (!a3.monthPicker)
        return true;
      let j = true;
      return a3.minDate && a3.maxDate ? Oe(b2(N), b2(a3.minDate)) && Pe(b2(N), b2(a3.maxDate)) : (a3.minDate && (j = Oe(b2(N), b2(a3.minDate))), a3.maxDate && (j = Pe(b2(N), b2(a3.maxDate))), j);
    }, E2 = () => {
      c2.value && M3.value && R2.value ? n2("select-date") : n2("invalid-select");
    };
    return (N, j) => (openBlock(), createElementBlock("div", {
      class: "dp__action_row",
      style: normalizeStyle(e3.calendarWidth ? { width: `${e3.calendarWidth}px` } : {})
    }, [
      N.$slots["action-row"] ? renderSlot(N.$slots, "action-row", normalizeProps(mergeProps({ key: 0 }, {
        internalModelValue: e3.internalModelValue,
        disabled: unref(F),
        selectDate: () => N.$emit("select-date"),
        closePicker: () => N.$emit("close-picker")
      }))) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
        createBaseVNode("div", Zr, [
          N.$slots["action-preview"] ? renderSlot(N.$slots, "action-preview", {
            key: 0,
            value: e3.internalModelValue
          }) : createCommentVNode("", true),
          N.$slots["action-preview"] ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
            Array.isArray(unref(ee)) ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              createTextVNode(toDisplayString(unref(ee)), 1)
            ], 64)),
            Array.isArray(unref(ee)) ? (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList(unref(ee), (ae, le) => (openBlock(), createElementBlock("div", { key: le }, toDisplayString(ae), 1))), 128)) : createCommentVNode("", true)
          ], 64))
        ]),
        createBaseVNode("div", Xr, [
          N.$slots["action-select"] ? renderSlot(N.$slots, "action-select", {
            key: 0,
            value: e3.internalModelValue
          }) : createCommentVNode("", true),
          N.$slots["action-select"] ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
            N.inline ? createCommentVNode("", true) : (openBlock(), createElementBlock("span", {
              key: 0,
              class: "dp__action dp__cancel",
              ref_key: "cancelButtonRef",
              ref: $,
              tabindex: "0",
              onClick: j[0] || (j[0] = (ae) => N.$emit("close-picker")),
              onKeydown: [
                j[1] || (j[1] = withKeys((ae) => N.$emit("close-picker"), ["enter"])),
                j[2] || (j[2] = withKeys((ae) => N.$emit("close-picker"), ["space"]))
              ]
            }, toDisplayString(N.cancelText), 545)),
            createBaseVNode("span", {
              class: normalizeClass(unref(A)),
              tabindex: "0",
              onKeydown: [
                withKeys(E2, ["enter"]),
                withKeys(E2, ["space"])
              ],
              onClick: E2,
              "data-test": "select-button",
              ref_key: "selectButtonRef",
              ref: O2
            }, toDisplayString(N.selectText), 43, qr)
          ], 64))
        ])
      ], 64))
    ], 4));
  }
}), Qr = ["aria-label"], el = {
  class: "dp__calendar_header",
  role: "row"
}, tl = {
  key: 0,
  class: "dp__calendar_header_item",
  role: "gridcell"
}, nl = /* @__PURE__ */ createBaseVNode("div", { class: "dp__calendar_header_separator" }, null, -1), al = ["aria-label"], rl = {
  key: 0,
  role: "gridcell",
  class: "dp__calendar_item dp__week_num"
}, ll = { class: "dp__cell_inner" }, ol = ["aria-selected", "aria-disabled", "aria-label", "data-test", "onClick", "onKeydown", "onMouseenter", "onMouseleave"], sl = /* @__PURE__ */ createBaseVNode("div", { class: "dp__arrow_bottom_tp" }, null, -1), il = /* @__PURE__ */ defineComponent$1({
  __name: "Calendar",
  props: {
    mappedDates: { type: Array, default: () => [] },
    getWeekNum: {
      type: Function,
      default: () => ""
    },
    specificMode: { type: Boolean, default: false },
    instance: { type: Number, default: 0 },
    month: { type: Number, default: 0 },
    year: { type: Number, default: 0 },
    ...tt
  },
  emits: [
    "select-date",
    "set-hover-date",
    "handle-scroll",
    "mount",
    "handle-swipe",
    "handle-space",
    "tooltip-open",
    "tooltip-close"
  ],
  setup(e3, { expose: n2, emit: a3 }) {
    const t3 = e3, { buildMultiLevelMatrix: o2 } = et(), { setDateMonthOrYear: d3, defaults: p2 } = Ve(t3), $ = ref(null), O2 = ref({ bottom: "", left: "", transform: "" }), R2 = ref([]), F = ref(null), A = ref(true), c2 = ref(""), M3 = ref({ startX: 0, endX: 0, startY: 0, endY: 0 }), W = computed(() => t3.dayNames ? Array.isArray(t3.dayNames) ? t3.dayNames : t3.dayNames(t3.locale, +t3.weekStart) : Tr(t3.locale, +t3.weekStart));
    onMounted(() => {
      a3("mount", { cmp: "calendar", refs: R2 }), t3.noSwipe || F.value && (F.value.addEventListener("touchstart", S3, { passive: false }), F.value.addEventListener("touchend", I2, { passive: false }), F.value.addEventListener("touchmove", T2, { passive: false })), t3.monthChangeOnScroll && F.value && F.value.addEventListener("wheel", J, { passive: false });
    });
    const Y2 = (_2) => _2 ? t3.vertical ? "vNext" : "next" : t3.vertical ? "vPrevious" : "previous", ee = (_2, C) => {
      if (t3.transitions) {
        const u2 = Ke(d3(b2(), t3.month, t3.year));
        c2.value = Oe(Ke(d3(b2(), _2, C)), u2) ? p2.value.transitions[Y2(true)] : p2.value.transitions[Y2(false)], A.value = false, nextTick(() => {
          A.value = true;
        });
      }
    }, B2 = computed(
      () => ({
        dp__calendar_wrap: true,
        [t3.calendarClassName]: !!t3.calendarClassName
      })
    ), E2 = computed(() => (_2) => {
      const C = Pr(_2);
      return {
        dp__marker_dot: C.type === "dot",
        dp__marker_line: C.type === "line"
      };
    }), N = computed(() => (_2) => pe(_2, $.value)), j = computed(() => ({
      dp__calendar: true,
      dp__calendar_next: p2.value.multiCalendars > 0 && t3.instance !== 0
    })), ae = computed(() => (_2) => t3.hideOffsetDates ? _2.current : true), le = computed(() => t3.specificMode ? { height: `${t3.modeHeight}px` } : void 0), ce = (_2, C, u2) => {
      var r2, m3;
      if (a3("set-hover-date", _2), (m3 = (r2 = _2.marker) == null ? void 0 : r2.tooltip) != null && m3.length) {
        const y3 = Me(R2.value[C][u2]);
        if (y3) {
          const { width: k2, height: x2 } = y3.getBoundingClientRect();
          O2.value = {
            bottom: `${x2}px`,
            left: `${k2 / 2}px`,
            transform: "translateX(-50%)"
          }, $.value = _2.value, a3("tooltip-open", _2.marker);
        }
      }
    }, v = (_2) => {
      $.value && ($.value = null, a3("tooltip-close", _2.marker));
    }, S3 = (_2) => {
      M3.value.startX = _2.changedTouches[0].screenX, M3.value.startY = _2.changedTouches[0].screenY;
    }, I2 = (_2) => {
      M3.value.endX = _2.changedTouches[0].screenX, M3.value.endY = _2.changedTouches[0].screenY, L2();
    }, T2 = (_2) => {
      t3.vertical && !t3.inline && _2.preventDefault();
    }, L2 = () => {
      const _2 = t3.vertical ? "Y" : "X";
      Math.abs(M3.value[`start${_2}`] - M3.value[`end${_2}`]) > 10 && a3("handle-swipe", M3.value[`start${_2}`] > M3.value[`end${_2}`] ? "right" : "left");
    }, Z = (_2, C, u2) => {
      _2 && (Array.isArray(R2.value[C]) ? R2.value[C][u2] = _2 : R2.value[C] = [_2]), t3.arrowNavigation && o2(R2.value, "calendar");
    }, J = (_2) => {
      t3.monthChangeOnScroll && (_2.preventDefault(), a3("handle-scroll", _2));
    };
    return n2({ triggerTransition: ee }), (_2, C) => {
      var u2;
      return openBlock(), createElementBlock("div", {
        class: normalizeClass(unref(j))
      }, [
        createBaseVNode("div", {
          style: normalizeStyle(unref(le))
        }, [
          e3.specificMode ? createCommentVNode("", true) : (openBlock(), createElementBlock("div", {
            key: 0,
            ref_key: "calendarWrapRef",
            ref: F,
            class: normalizeClass(unref(B2)),
            role: "grid",
            "aria-label": (u2 = unref(p2).ariaLabels) == null ? void 0 : u2.calendarWrap
          }, [
            createBaseVNode("div", el, [
              _2.weekNumbers ? (openBlock(), createElementBlock("div", tl, toDisplayString(_2.weekNumName), 1)) : createCommentVNode("", true),
              (openBlock(true), createElementBlock(Fragment, null, renderList(unref(W), (r2, m3) => (openBlock(), createElementBlock("div", {
                class: "dp__calendar_header_item",
                role: "gridcell",
                key: m3,
                "data-test": "calendar-header"
              }, [
                _2.$slots["calendar-header"] ? renderSlot(_2.$slots, "calendar-header", {
                  key: 0,
                  day: r2,
                  index: m3
                }) : createCommentVNode("", true),
                _2.$slots["calendar-header"] ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                  createTextVNode(toDisplayString(r2), 1)
                ], 64))
              ]))), 128))
            ]),
            nl,
            createVNode(Transition, {
              name: c2.value,
              css: !!_2.transitions
            }, {
              default: withCtx(() => {
                var r2;
                return [
                  A.value ? (openBlock(), createElementBlock("div", {
                    key: 0,
                    class: "dp__calendar",
                    role: "grid",
                    "aria-label": (r2 = unref(p2).ariaLabels) == null ? void 0 : r2.calendarDays
                  }, [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(e3.mappedDates, (m3, y3) => (openBlock(), createElementBlock("div", {
                      class: "dp__calendar_row",
                      role: "row",
                      key: y3
                    }, [
                      _2.weekNumbers ? (openBlock(), createElementBlock("div", rl, [
                        createBaseVNode("div", ll, toDisplayString(e3.getWeekNum(m3.days)), 1)
                      ])) : createCommentVNode("", true),
                      (openBlock(true), createElementBlock(Fragment, null, renderList(m3.days, (k2, x2) => {
                        var G2, de, f;
                        return openBlock(), createElementBlock("div", {
                          role: "gridcell",
                          class: "dp__calendar_item",
                          ref_for: true,
                          ref: (l) => Z(l, y3, x2),
                          key: x2 + y3,
                          "aria-selected": k2.classData.dp__active_date || k2.classData.dp__range_start || k2.classData.dp__range_start,
                          "aria-disabled": k2.classData.dp__cell_disabled,
                          "aria-label": (de = (G2 = unref(p2).ariaLabels) == null ? void 0 : G2.day) == null ? void 0 : de.call(G2, k2),
                          tabindex: "0",
                          "data-test": k2.value,
                          onClick: withModifiers((l) => _2.$emit("select-date", k2), ["stop", "prevent"]),
                          onKeydown: [
                            withKeys((l) => _2.$emit("select-date", k2), ["enter"]),
                            withKeys((l) => _2.$emit("handle-space", k2), ["space"])
                          ],
                          onMouseenter: (l) => ce(k2, y3, x2),
                          onMouseleave: (l) => v(k2)
                        }, [
                          createBaseVNode("div", {
                            class: normalizeClass(["dp__cell_inner", k2.classData])
                          }, [
                            _2.$slots.day && unref(ae)(k2) ? renderSlot(_2.$slots, "day", {
                              key: 0,
                              day: +k2.text,
                              date: k2.value
                            }) : createCommentVNode("", true),
                            _2.$slots.day ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                              createTextVNode(toDisplayString(k2.text), 1)
                            ], 64)),
                            k2.marker && unref(ae)(k2) ? (openBlock(), createElementBlock("div", {
                              key: 2,
                              class: normalizeClass(unref(E2)(k2.marker)),
                              style: normalizeStyle(k2.marker.color ? { backgroundColor: k2.marker.color } : {})
                            }, null, 6)) : createCommentVNode("", true),
                            unref(N)(k2.value) ? (openBlock(), createElementBlock("div", {
                              key: 3,
                              class: "dp__marker_tooltip",
                              style: normalizeStyle(O2.value)
                            }, [
                              (f = k2.marker) != null && f.tooltip ? (openBlock(), createElementBlock("div", {
                                key: 0,
                                class: "dp__tooltip_content",
                                onClick: C[0] || (C[0] = withModifiers(() => {
                                }, ["stop"]))
                              }, [
                                (openBlock(true), createElementBlock(Fragment, null, renderList(k2.marker.tooltip, (l, Q2) => (openBlock(), createElementBlock("div", {
                                  key: Q2,
                                  class: "dp__tooltip_text"
                                }, [
                                  _2.$slots["marker-tooltip"] ? renderSlot(_2.$slots, "marker-tooltip", {
                                    key: 0,
                                    tooltip: l,
                                    day: k2.value
                                  }) : createCommentVNode("", true),
                                  _2.$slots["marker-tooltip"] ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                                    createBaseVNode("div", {
                                      class: "dp__tooltip_mark",
                                      style: normalizeStyle(l.color ? { backgroundColor: l.color } : {})
                                    }, null, 4),
                                    createBaseVNode("div", null, toDisplayString(l.text), 1)
                                  ], 64))
                                ]))), 128)),
                                sl
                              ])) : createCommentVNode("", true)
                            ], 4)) : createCommentVNode("", true)
                          ], 2)
                        ], 40, ol);
                      }), 128))
                    ]))), 128))
                  ], 8, al)) : createCommentVNode("", true)
                ];
              }),
              _: 3
            }, 8, ["name", "css"])
          ], 10, Qr))
        ], 4)
      ], 2);
    };
  }
}), ul = ["aria-label", "aria-disabled"], tn = /* @__PURE__ */ defineComponent$1({
  __name: "ActionIcon",
  props: {
    ariaLabel: { type: String, default: "" },
    disabled: { type: Boolean, default: false }
  },
  emits: ["activate", "set-ref"],
  setup(e3, { emit: n2 }) {
    const a3 = ref(null);
    return onMounted(() => n2("set-ref", a3)), (t3, o2) => (openBlock(), createElementBlock("div", {
      class: "dp__month_year_col_nav",
      onClick: o2[0] || (o2[0] = (d3) => t3.$emit("activate")),
      onKeydown: [
        o2[1] || (o2[1] = withKeys((d3) => t3.$emit("activate"), ["enter"])),
        o2[2] || (o2[2] = withKeys((d3) => t3.$emit("activate"), ["space"]))
      ],
      tabindex: "0",
      role: "button",
      "aria-label": e3.ariaLabel,
      "aria-disabled": e3.disabled,
      ref_key: "elRef",
      ref: a3
    }, [
      createBaseVNode("div", {
        class: normalizeClass(["dp__inner_nav", { dp__inner_nav_disabled: e3.disabled }])
      }, [
        renderSlot(t3.$slots, "default")
      ], 2)
    ], 40, ul));
  }
}), cl = ["onKeydown"], dl = { class: "dp__selection_grid_header" }, fl = ["aria-selected", "aria-disabled", "data-test", "onClick", "onKeydown", "onMouseover"], vl = ["aria-label", "onKeydown"], $t = /* @__PURE__ */ defineComponent$1({
  __name: "SelectionGrid",
  props: {
    items: { type: Array, default: () => [] },
    modelValue: { type: [String, Number], default: null },
    multiModelValue: { type: Array, default: () => [] },
    disabledValues: { type: Array, default: () => [] },
    minValue: { type: [Number, String], default: null },
    maxValue: { type: [Number, String], default: null },
    year: { type: Number, default: 0 },
    skipActive: { type: Boolean, default: false },
    headerRefs: { type: Array, default: () => [] },
    skipButtonRef: { type: Boolean, default: false },
    monthPicker: { type: Boolean, default: false },
    yearPicker: { type: Boolean, default: false },
    escClose: { type: Boolean, default: true },
    type: { type: String, default: null },
    arrowNavigation: { type: Boolean, default: false },
    autoApply: { type: Boolean, default: false },
    textInput: { type: Boolean, default: false },
    ariaLabels: { type: Object, default: () => ({}) },
    hideNavigation: { type: Array, default: () => [] }
  },
  emits: ["update:model-value", "selected", "toggle", "reset-flow"],
  setup(e3, { expose: n2, emit: a3 }) {
    const t3 = e3, { setSelectionGrid: o2, buildMultiLevelMatrix: d3, setMonthPicker: p2 } = et(), { hideNavigationButtons: $ } = Ve(t3), O2 = ref(false), R2 = ref(null), F = ref(null), A = ref([]), c2 = ref(), M3 = ref(null), W = ref(0), Y2 = ref(null);
    onBeforeUpdate(() => {
      R2.value = null;
    }), onMounted(() => {
      nextTick().then(() => S3()), B2(), ee(true);
    }), onUnmounted(() => ee(false));
    const ee = (C) => {
      var u2;
      t3.arrowNavigation && ((u2 = t3.headerRefs) != null && u2.length ? p2(C) : o2(C));
    }, B2 = () => {
      const C = Me(F);
      C && (t3.textInput || C.focus({ preventScroll: true }), O2.value = C.clientHeight < C.scrollHeight);
    }, E2 = computed(
      () => ({
        dp__overlay: true
      })
    ), N = computed(() => ({
      dp__overlay_col: true
    })), j = (C) => t3.skipActive ? false : C.value === t3.modelValue, ae = computed(() => t3.items.map((C) => C.filter((u2) => u2).map((u2) => {
      var y3, k2, x2;
      const r2 = t3.disabledValues.some((G2) => G2 === u2.value) || v(u2.value), m3 = (y3 = t3.multiModelValue) != null && y3.length ? (k2 = t3.multiModelValue) == null ? void 0 : k2.some(
        (G2) => pe(
          G2,
          setYear(
            t3.monthPicker ? setMonth(new Date(), u2.value) : new Date(),
            t3.monthPicker ? t3.year : u2.value
          )
        )
      ) : j(u2);
      return {
        ...u2,
        className: {
          dp__overlay_cell_active: m3,
          dp__overlay_cell: !m3,
          dp__overlay_cell_disabled: r2,
          dp__overlay_cell_active_disabled: r2 && m3,
          dp__overlay_cell_pad: true,
          dp__cell_in_between: (x2 = t3.multiModelValue) != null && x2.length ? T2(u2.value) : false
        }
      };
    }))), le = computed(
      () => ({
        dp__button: true,
        dp__overlay_action: true,
        dp__over_action_scroll: O2.value,
        dp__button_bottom: t3.autoApply
      })
    ), ce = computed(() => {
      var C, u2;
      return {
        dp__overlay_container: true,
        dp__container_flex: ((C = t3.items) == null ? void 0 : C.length) <= 6,
        dp__container_block: ((u2 = t3.items) == null ? void 0 : u2.length) > 6
      };
    }), v = (C) => {
      const u2 = t3.maxValue || t3.maxValue === 0, r2 = t3.minValue || t3.minValue === 0;
      return !u2 && !r2 ? false : u2 && r2 ? +C > +t3.maxValue || +C < +t3.minValue : u2 ? +C > +t3.maxValue : r2 ? +C < +t3.minValue : false;
    }, S3 = () => {
      const C = Me(R2), u2 = Me(F), r2 = Me(M3), m3 = Me(Y2), y3 = r2 ? r2.getBoundingClientRect().height : 0;
      u2 && (W.value = u2.getBoundingClientRect().height - y3), C && m3 && (m3.scrollTop = C.offsetTop - m3.offsetTop - (W.value / 2 - C.getBoundingClientRect().height) - y3);
    }, I2 = (C) => {
      !t3.disabledValues.some((u2) => u2 === C) && !v(C) && (a3("update:model-value", C), a3("selected"));
    }, T2 = (C) => {
      const u2 = t3.monthPicker ? t3.year : C;
      return Wn(
        t3.multiModelValue,
        setYear(
          t3.monthPicker ? setMonth(new Date(), c2.value || 0) : new Date(),
          t3.monthPicker ? u2 : c2.value || u2
        ),
        setYear(t3.monthPicker ? setMonth(new Date(), C) : new Date(), u2)
      );
    }, L2 = () => {
      a3("toggle"), a3("reset-flow");
    }, Z = () => {
      t3.escClose && L2();
    }, J = (C, u2, r2, m3) => {
      C && (u2.value === +t3.modelValue && !t3.disabledValues.includes(u2.value) && (R2.value = C), t3.arrowNavigation && (Array.isArray(A.value[r2]) ? A.value[r2][m3] = C : A.value[r2] = [C], _2()));
    }, _2 = () => {
      var u2, r2;
      const C = (u2 = t3.headerRefs) != null && u2.length ? [t3.headerRefs].concat(A.value) : A.value.concat([t3.skipButtonRef ? [] : [M3.value]]);
      d3(_e(C), (r2 = t3.headerRefs) != null && r2.length ? "monthPicker" : "selectionGrid");
    };
    return n2({ focusGrid: B2 }), (C, u2) => {
      var r2;
      return openBlock(), createElementBlock("div", {
        ref_key: "gridWrapRef",
        ref: F,
        class: normalizeClass(unref(E2)),
        role: "dialog",
        tabindex: "0",
        onKeydown: withKeys(Z, ["esc"])
      }, [
        createBaseVNode("div", {
          class: normalizeClass(unref(ce)),
          ref_key: "containerRef",
          ref: Y2,
          role: "grid",
          style: normalizeStyle({ height: `${W.value}px` })
        }, [
          createBaseVNode("div", dl, [
            renderSlot(C.$slots, "header")
          ]),
          C.$slots.overlay ? renderSlot(C.$slots, "overlay", { key: 0 }) : (openBlock(true), createElementBlock(Fragment, { key: 1 }, renderList(unref(ae), (m3, y3) => (openBlock(), createElementBlock("div", {
            class: "dp__overlay_row",
            key: y3,
            role: "row"
          }, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(m3, (k2, x2) => (openBlock(), createElementBlock("div", {
              role: "gridcell",
              class: normalizeClass(unref(N)),
              key: k2.value,
              "aria-selected": k2.value === e3.modelValue && !e3.disabledValues.includes(k2.value),
              "aria-disabled": k2.className.dp__overlay_cell_disabled,
              ref_for: true,
              ref: (G2) => J(G2, k2, y3, x2),
              tabindex: "0",
              "data-test": k2.text,
              onClick: (G2) => I2(k2.value),
              onKeydown: [
                withKeys((G2) => I2(k2.value), ["enter"]),
                withKeys((G2) => I2(k2.value), ["space"])
              ],
              onMouseover: (G2) => c2.value = k2.value
            }, [
              createBaseVNode("div", {
                class: normalizeClass(k2.className)
              }, [
                C.$slots.item ? renderSlot(C.$slots, "item", {
                  key: 0,
                  item: k2
                }) : createCommentVNode("", true),
                C.$slots.item ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                  createTextVNode(toDisplayString(k2.text), 1)
                ], 64))
              ], 2)
            ], 42, fl))), 128))
          ]))), 128))
        ], 6),
        C.$slots["button-icon"] ? withDirectives((openBlock(), createElementBlock("div", {
          key: 0,
          role: "button",
          "aria-label": (r2 = e3.ariaLabels) == null ? void 0 : r2.toggleOverlay,
          class: normalizeClass(unref(le)),
          tabindex: "0",
          ref_key: "toggleButton",
          ref: M3,
          onClick: L2,
          onKeydown: withKeys(L2, ["enter"])
        }, [
          renderSlot(C.$slots, "button-icon")
        ], 42, vl)), [
          [vShow, !unref($)(e3.type)]
        ]) : createCommentVNode("", true)
      ], 42, cl);
    };
  }
}), ml = ["aria-label"], On = /* @__PURE__ */ defineComponent$1({
  __name: "RegularPicker",
  props: {
    ariaLabel: { type: String, default: "" },
    showSelectionGrid: { type: Boolean, default: false },
    modelValue: { type: Number, default: null },
    items: { type: Array, default: () => [] },
    disabledValues: { type: Array, default: () => [] },
    minValue: { type: Number, default: null },
    maxValue: { type: Number, default: null },
    slotName: { type: String, default: "" },
    overlaySlot: { type: String, default: "" },
    headerRefs: { type: Array, default: () => [] },
    escClose: { type: Boolean, default: true },
    type: { type: String, default: null },
    transitions: { type: [Object, Boolean], default: false },
    arrowNavigation: { type: Boolean, default: false },
    autoApply: { type: Boolean, default: false },
    textInput: { type: Boolean, default: false },
    ariaLabels: { type: Object, default: () => ({}) },
    hideNavigation: { type: Array, default: () => [] }
  },
  emits: ["update:model-value", "toggle", "set-ref"],
  setup(e3, { emit: n2 }) {
    const a3 = e3, { transitionName: t3, showTransition: o2 } = Ft(a3.transitions), d3 = ref(null);
    return onMounted(() => n2("set-ref", d3)), (p2, $) => (openBlock(), createElementBlock(Fragment, null, [
      createBaseVNode("div", {
        class: "dp__month_year_select",
        onClick: $[0] || ($[0] = (O2) => p2.$emit("toggle")),
        onKeydown: [
          $[1] || ($[1] = withKeys((O2) => p2.$emit("toggle"), ["enter"])),
          $[2] || ($[2] = withKeys((O2) => p2.$emit("toggle"), ["space"]))
        ],
        role: "button",
        "aria-label": e3.ariaLabel,
        tabindex: "0",
        ref_key: "elRef",
        ref: d3
      }, [
        renderSlot(p2.$slots, "default")
      ], 40, ml),
      createVNode(Transition, {
        name: unref(t3)(e3.showSelectionGrid),
        css: unref(o2)
      }, {
        default: withCtx(() => [
          e3.showSelectionGrid ? (openBlock(), createBlock($t, mergeProps({ key: 0 }, {
            modelValue: e3.modelValue,
            items: e3.items,
            disabledValues: e3.disabledValues,
            minValue: e3.minValue,
            maxValue: e3.maxValue,
            escClose: e3.escClose,
            type: e3.type,
            arrowNavigation: e3.arrowNavigation,
            textInput: e3.textInput,
            autoApply: e3.autoApply,
            ariaLabels: e3.ariaLabels,
            hideNavigation: e3.hideNavigation
          }, {
            "header-refs": [],
            "onUpdate:modelValue": $[3] || ($[3] = (O2) => p2.$emit("update:model-value", O2)),
            onToggle: $[4] || ($[4] = (O2) => p2.$emit("toggle"))
          }), createSlots({
            "button-icon": withCtx(() => [
              p2.$slots["calendar-icon"] ? renderSlot(p2.$slots, "calendar-icon", { key: 0 }) : createCommentVNode("", true),
              p2.$slots["calendar-icon"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(Lt), { key: 1 }))
            ]),
            _: 2
          }, [
            p2.$slots[e3.slotName] ? {
              name: "item",
              fn: withCtx(({ item: O2 }) => [
                renderSlot(p2.$slots, e3.slotName, { item: O2 })
              ]),
              key: "0"
            } : void 0,
            p2.$slots[e3.overlaySlot] ? {
              name: "overlay",
              fn: withCtx(() => [
                renderSlot(p2.$slots, e3.overlaySlot)
              ]),
              key: "1"
            } : void 0,
            p2.$slots[`${e3.overlaySlot}-header`] ? {
              name: "header",
              fn: withCtx(() => [
                renderSlot(p2.$slots, `${e3.overlaySlot}-header`)
              ]),
              key: "2"
            } : void 0
          ]), 1040)) : createCommentVNode("", true)
        ]),
        _: 3
      }, 8, ["name", "css"])
    ], 64));
  }
}), yl = { class: "dp__month_year_row" }, hl = { class: "dp__month_year_wrap" }, gl = { class: "dp__month_picker_header" }, pl = ["aria-label"], kl = ["aria-label"], wl = ["aria-label"], bl = /* @__PURE__ */ defineComponent$1({
  __name: "MonthYearPicker",
  props: {
    month: { type: Number, default: 0 },
    year: { type: Number, default: 0 },
    instance: { type: Number, default: 0 },
    years: { type: Array, default: () => [] },
    months: { type: Array, default: () => [] },
    internalModelValue: { type: [Date, Array], default: null },
    ...tt
  },
  emits: ["update-month-year", "month-year-select", "mount", "reset-flow", "overlay-closed"],
  setup(e3, { expose: n2, emit: a3 }) {
    const t3 = e3, { defaults: o2 } = Ve(t3), { transitionName: d3, showTransition: p2 } = Ft(o2.value.transitions), { buildMatrix: $ } = et(), { handleMonthYearChange: O2, isDisabled: R2, updateMonthYear: F } = Lr(t3, a3), A = ref(false), c2 = ref(false), M3 = ref([null, null, null, null]), W = ref(null), Y2 = ref(null), ee = ref(null);
    onMounted(() => {
      a3("mount");
    });
    const B2 = (f) => ({
      get: () => t3[f],
      set: (l) => {
        const Q2 = f === "month" ? "year" : "month";
        a3("update-month-year", { [f]: l, [Q2]: t3[Q2] }), a3("month-year-select", f === "year"), f === "month" ? y3(true) : k2(true);
      }
    }), E2 = computed(B2("month")), N = computed(B2("year")), j = (f) => {
      const l = getYear(b2(f));
      return t3.year === l;
    }, ae = computed(() => t3.monthPicker ? Array.isArray(t3.disabledDates) ? t3.disabledDates.map((f) => b2(f)).filter((f) => j(f)).map((f) => getMonth(f)) : [] : []), le = computed(() => (f) => {
      const l = f === "month";
      return {
        showSelectionGrid: (l ? A : c2).value,
        items: (l ? C : u2).value,
        disabledValues: o2.value.filters[l ? "months" : "years"].concat(ae.value),
        minValue: (l ? I2 : v).value,
        maxValue: (l ? T2 : S3).value,
        headerRefs: l && t3.monthPicker ? [W.value, Y2.value, ee.value] : [],
        escClose: t3.escClose,
        transitions: o2.value.transitions,
        ariaLabels: o2.value.ariaLabels,
        textInput: t3.textInput,
        autoApply: t3.autoApply,
        arrowNavigation: t3.arrowNavigation,
        hideNavigation: t3.hideNavigation
      };
    }), ce = computed(() => (f) => ({
      month: t3.month,
      year: t3.year,
      items: f === "month" ? t3.months : t3.years,
      instance: t3.instance,
      updateMonthYear: F,
      toggle: f === "month" ? y3 : k2
    })), v = computed(() => t3.minDate ? getYear(b2(t3.minDate)) : null), S3 = computed(() => t3.maxDate ? getYear(b2(t3.maxDate)) : null), I2 = computed(() => {
      if (t3.minDate && v.value) {
        if (v.value > t3.year)
          return 12;
        if (v.value === t3.year)
          return getMonth(b2(t3.minDate));
      }
      return null;
    }), T2 = computed(() => t3.maxDate && S3.value ? S3.value < t3.year ? -1 : S3.value === t3.year ? getMonth(b2(t3.maxDate)) : null : null), L2 = computed(() => t3.range && t3.internalModelValue && (t3.monthPicker || t3.yearPicker) ? t3.internalModelValue : []), Z = (f) => f.reverse(), J = (f, l = false) => {
      const Q2 = [], we = (be) => l ? Z(be) : be;
      for (let be = 0; be < f.length; be += 3) {
        const We = [f[be], f[be + 1], f[be + 2]];
        Q2.push(we(We));
      }
      return l ? Q2.reverse() : Q2;
    }, _2 = computed(() => {
      const f = t3.months.find((l) => l.value === t3.month);
      return f || { text: "", value: 0 };
    }), C = computed(() => J(t3.months)), u2 = computed(() => J(t3.years, t3.reverseYears)), r2 = computed(() => o2.value.multiCalendars ? t3.multiCalendarsSolo ? true : t3.instance === 0 : true), m3 = computed(() => o2.value.multiCalendars ? t3.multiCalendarsSolo ? true : t3.instance === o2.value.multiCalendars - 1 : true), y3 = (f = false) => {
      x2(f), A.value = !A.value, A.value || a3("overlay-closed");
    }, k2 = (f = false) => {
      x2(f), c2.value = !c2.value, c2.value || a3("overlay-closed");
    }, x2 = (f) => {
      f || a3("reset-flow");
    }, G2 = (f = false) => {
      R2.value(f) || a3("update-month-year", {
        year: f ? t3.year + 1 : t3.year - 1,
        month: t3.month,
        fromNav: true
      });
    }, de = (f, l) => {
      t3.arrowNavigation && (M3.value[l] = Me(f), $(M3.value, "monthYear"));
    };
    return n2({
      toggleMonthPicker: y3,
      toggleYearPicker: k2
    }), (f, l) => {
      var Q2, we, be, We, je;
      return openBlock(), createElementBlock("div", yl, [
        f.$slots["month-year"] ? renderSlot(f.$slots, "month-year", normalizeProps(mergeProps({ key: 0 }, { month: e3.month, year: e3.year, months: e3.months, years: e3.years, updateMonthYear: unref(F), handleMonthYearChange: unref(O2), instance: e3.instance }))) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
          !f.monthPicker && !f.yearPicker ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
            unref(r2) && !f.vertical ? (openBlock(), createBlock(tn, {
              key: 0,
              "aria-label": (Q2 = unref(o2).ariaLabels) == null ? void 0 : Q2.prevMonth,
              disabled: unref(R2)(false),
              onActivate: l[0] || (l[0] = (re) => unref(O2)(false)),
              onSetRef: l[1] || (l[1] = (re) => de(re, 0))
            }, {
              default: withCtx(() => [
                f.$slots["arrow-left"] ? renderSlot(f.$slots, "arrow-left", { key: 0 }) : createCommentVNode("", true),
                f.$slots["arrow-left"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(kn), { key: 1 }))
              ]),
              _: 3
            }, 8, ["aria-label", "disabled"])) : createCommentVNode("", true),
            createBaseVNode("div", hl, [
              createVNode(On, mergeProps({
                type: "month",
                "slot-name": "month-overlay-val",
                "overlay-slot": "overlay-month",
                "aria-label": (we = unref(o2).ariaLabels) == null ? void 0 : we.openMonthsOverlay,
                modelValue: unref(E2),
                "onUpdate:modelValue": l[2] || (l[2] = (re) => isRef(E2) ? E2.value = re : null)
              }, unref(le)("month"), {
                onToggle: y3,
                onSetRef: l[3] || (l[3] = (re) => de(re, 1))
              }), createSlots({
                default: withCtx(() => [
                  f.$slots.month ? renderSlot(f.$slots, "month", normalizeProps(mergeProps({ key: 0 }, unref(_2)))) : createCommentVNode("", true),
                  f.$slots.month ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                    createTextVNode(toDisplayString(unref(_2).text), 1)
                  ], 64))
                ]),
                _: 2
              }, [
                f.$slots["calendar-icon"] ? {
                  name: "calendar-icon",
                  fn: withCtx(() => [
                    renderSlot(f.$slots, "calendar-icon")
                  ]),
                  key: "0"
                } : void 0,
                f.$slots["month-overlay-value"] ? {
                  name: "month-overlay-val",
                  fn: withCtx(({ item: re }) => [
                    renderSlot(f.$slots, "month-overlay-value", {
                      text: re.text,
                      value: re.value
                    })
                  ]),
                  key: "1"
                } : void 0,
                f.$slots["month-overlay"] ? {
                  name: "overlay-month",
                  fn: withCtx(() => [
                    renderSlot(f.$slots, "month-overlay", normalizeProps(guardReactiveProps(unref(ce)("month"))))
                  ]),
                  key: "2"
                } : void 0,
                f.$slots["month-overlay-header"] ? {
                  name: "overlay-month-header",
                  fn: withCtx(() => [
                    renderSlot(f.$slots, "month-overlay-header", { toggle: y3 })
                  ]),
                  key: "3"
                } : void 0
              ]), 1040, ["aria-label", "modelValue"]),
              createVNode(On, mergeProps({
                type: "year",
                "slot-name": "year-overlay-val",
                "overlay-slot": "overlay-year",
                "aria-label": (be = unref(o2).ariaLabels) == null ? void 0 : be.openYearsOverlay,
                modelValue: unref(N),
                "onUpdate:modelValue": l[4] || (l[4] = (re) => isRef(N) ? N.value = re : null)
              }, unref(le)("year"), {
                onToggle: k2,
                onSetRef: l[5] || (l[5] = (re) => de(re, 2))
              }), createSlots({
                default: withCtx(() => [
                  f.$slots.year ? renderSlot(f.$slots, "year", {
                    key: 0,
                    year: e3.year
                  }) : createCommentVNode("", true),
                  f.$slots.year ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                    createTextVNode(toDisplayString(e3.year), 1)
                  ], 64))
                ]),
                _: 2
              }, [
                f.$slots["calendar-icon"] ? {
                  name: "calendar-icon",
                  fn: withCtx(() => [
                    renderSlot(f.$slots, "calendar-icon")
                  ]),
                  key: "0"
                } : void 0,
                f.$slots["year-overlay-value"] ? {
                  name: "year-overlay-val",
                  fn: withCtx(({ item: re }) => [
                    renderSlot(f.$slots, "year-overlay-value", {
                      text: re.text,
                      value: re.value
                    })
                  ]),
                  key: "1"
                } : void 0,
                f.$slots["year-overlay"] ? {
                  name: "overlay-year",
                  fn: withCtx(() => [
                    renderSlot(f.$slots, "year-overlay", normalizeProps(guardReactiveProps(unref(ce)("year"))))
                  ]),
                  key: "2"
                } : void 0,
                f.$slots["year-overlay-header"] ? {
                  name: "overlay-year-header",
                  fn: withCtx(() => [
                    renderSlot(f.$slots, "year-overlay-header", { toggle: k2 })
                  ]),
                  key: "3"
                } : void 0
              ]), 1040, ["aria-label", "modelValue"])
            ]),
            unref(r2) && f.vertical ? (openBlock(), createBlock(tn, {
              key: 1,
              "aria-label": (We = unref(o2).ariaLabels) == null ? void 0 : We.prevMonth,
              disabled: unref(R2)(false),
              onActivate: l[6] || (l[6] = (re) => unref(O2)(false))
            }, {
              default: withCtx(() => [
                f.$slots["arrow-up"] ? renderSlot(f.$slots, "arrow-up", { key: 0 }) : createCommentVNode("", true),
                f.$slots["arrow-up"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(Un), { key: 1 }))
              ]),
              _: 3
            }, 8, ["aria-label", "disabled"])) : createCommentVNode("", true),
            unref(m3) ? (openBlock(), createBlock(tn, {
              key: 2,
              ref: "rightIcon",
              disabled: unref(R2)(true),
              "aria-label": (je = unref(o2).ariaLabels) == null ? void 0 : je.nextMonth,
              onActivate: l[7] || (l[7] = (re) => unref(O2)(true)),
              onSetRef: l[8] || (l[8] = (re) => de(re, 3))
            }, {
              default: withCtx(() => [
                f.$slots[f.vertical ? "arrow-down" : "arrow-right"] ? renderSlot(f.$slots, f.vertical ? "arrow-down" : "arrow-right", { key: 0 }) : createCommentVNode("", true),
                f.$slots[f.vertical ? "arrow-down" : "arrow-right"] ? createCommentVNode("", true) : (openBlock(), createBlock(resolveDynamicComponent(f.vertical ? unref(Hn) : unref(wn)), { key: 1 }))
              ]),
              _: 3
            }, 8, ["disabled", "aria-label"])) : createCommentVNode("", true)
          ], 64)) : createCommentVNode("", true),
          f.monthPicker ? (openBlock(), createBlock($t, mergeProps({ key: 1 }, unref(le)("month"), {
            "skip-active": f.range,
            year: e3.year,
            "multi-model-value": unref(L2),
            "month-picker": "",
            modelValue: unref(E2),
            "onUpdate:modelValue": l[17] || (l[17] = (re) => isRef(E2) ? E2.value = re : null),
            onToggle: y3,
            onSelected: l[18] || (l[18] = (re) => f.$emit("overlay-closed"))
          }), createSlots({
            header: withCtx(() => {
              var re, Je, ze;
              return [
                createBaseVNode("div", gl, [
                  createBaseVNode("div", {
                    class: "dp__month_year_col_nav",
                    tabindex: "0",
                    ref_key: "mpPrevIconRef",
                    ref: W,
                    onClick: l[9] || (l[9] = (X2) => G2(false)),
                    onKeydown: l[10] || (l[10] = withKeys((X2) => G2(false), ["enter"]))
                  }, [
                    createBaseVNode("div", {
                      class: normalizeClass(["dp__inner_nav", { dp__inner_nav_disabled: unref(R2)(false) }]),
                      role: "button",
                      "aria-label": (re = unref(o2).ariaLabels) == null ? void 0 : re.prevMonth
                    }, [
                      f.$slots["arrow-left"] ? renderSlot(f.$slots, "arrow-left", { key: 0 }) : createCommentVNode("", true),
                      f.$slots["arrow-left"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(kn), { key: 1 }))
                    ], 10, pl)
                  ], 544),
                  createBaseVNode("div", {
                    class: "dp__pointer",
                    role: "button",
                    ref_key: "mpYearButtonRef",
                    ref: Y2,
                    "aria-label": (Je = unref(o2).ariaLabels) == null ? void 0 : Je.openYearsOverlay,
                    tabindex: "0",
                    onClick: l[11] || (l[11] = () => k2(false)),
                    onKeydown: l[12] || (l[12] = withKeys(() => k2(false), ["enter"]))
                  }, [
                    f.$slots.year ? renderSlot(f.$slots, "year", {
                      key: 0,
                      year: e3.year
                    }) : createCommentVNode("", true),
                    f.$slots.year ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                      createTextVNode(toDisplayString(e3.year), 1)
                    ], 64))
                  ], 40, kl),
                  createBaseVNode("div", {
                    class: "dp__month_year_col_nav",
                    tabindex: "0",
                    ref_key: "mpNextIconRef",
                    ref: ee,
                    onClick: l[13] || (l[13] = (X2) => G2(true)),
                    onKeydown: l[14] || (l[14] = withKeys((X2) => G2(true), ["enter"]))
                  }, [
                    createBaseVNode("div", {
                      class: normalizeClass(["dp__inner_nav", { dp__inner_nav_disabled: unref(R2)(true) }]),
                      role: "button",
                      "aria-label": (ze = unref(o2).ariaLabels) == null ? void 0 : ze.nextMonth
                    }, [
                      f.$slots["arrow-right"] ? renderSlot(f.$slots, "arrow-right", { key: 0 }) : createCommentVNode("", true),
                      f.$slots["arrow-right"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(wn), { key: 1 }))
                    ], 10, wl)
                  ], 544)
                ]),
                createVNode(Transition, {
                  name: unref(d3)(c2.value),
                  css: unref(p2)
                }, {
                  default: withCtx(() => [
                    c2.value ? (openBlock(), createBlock($t, mergeProps({ key: 0 }, unref(le)("year"), {
                      modelValue: unref(N),
                      "onUpdate:modelValue": l[15] || (l[15] = (X2) => isRef(N) ? N.value = X2 : null),
                      onToggle: k2,
                      onSelected: l[16] || (l[16] = (X2) => f.$emit("overlay-closed"))
                    }), createSlots({
                      "button-icon": withCtx(() => [
                        f.$slots["calendar-icon"] ? renderSlot(f.$slots, "calendar-icon", { key: 0 }) : createCommentVNode("", true),
                        f.$slots["calendar-icon"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(Lt), { key: 1 }))
                      ]),
                      _: 2
                    }, [
                      f.$slots["year-overlay-value"] ? {
                        name: "item",
                        fn: withCtx(({ item: X2 }) => [
                          renderSlot(f.$slots, "year-overlay-value", {
                            text: X2.text,
                            value: X2.value
                          })
                        ]),
                        key: "0"
                      } : void 0
                    ]), 1040, ["modelValue"])) : createCommentVNode("", true)
                  ]),
                  _: 3
                }, 8, ["name", "css"])
              ];
            }),
            _: 2
          }, [
            f.$slots["month-overlay-value"] ? {
              name: "item",
              fn: withCtx(({ item: re }) => [
                renderSlot(f.$slots, "month-overlay-value", {
                  text: re.text,
                  value: re.value
                })
              ]),
              key: "0"
            } : void 0
          ]), 1040, ["skip-active", "year", "multi-model-value", "modelValue"])) : createCommentVNode("", true),
          f.yearPicker ? (openBlock(), createBlock($t, mergeProps({ key: 2 }, unref(le)("year"), {
            modelValue: unref(N),
            "onUpdate:modelValue": l[19] || (l[19] = (re) => isRef(N) ? N.value = re : null),
            "multi-model-value": unref(L2),
            "skip-active": f.range,
            "skip-button-ref": "",
            "year-picker": "",
            onToggle: k2,
            onSelected: l[20] || (l[20] = (re) => f.$emit("overlay-closed"))
          }), createSlots({ _: 2 }, [
            f.$slots["year-overlay-value"] ? {
              name: "item",
              fn: withCtx(({ item: re }) => [
                renderSlot(f.$slots, "year-overlay-value", {
                  text: re.text,
                  value: re.value
                })
              ]),
              key: "0"
            } : void 0
          ]), 1040, ["modelValue", "multi-model-value", "skip-active"])) : createCommentVNode("", true)
        ], 64))
      ]);
    };
  }
}), $l = {
  key: 0,
  class: "dp__time_input"
}, Dl = ["aria-label", "onKeydown", "onClick"], Ml = ["aria-label", "data-test", "onKeydown", "onClick"], _l = ["aria-label", "onKeydown", "onClick"], Tl = { key: 0 }, Al = ["aria-label", "onKeydown"], Sl = /* @__PURE__ */ defineComponent$1({
  __name: "TimeInput",
  props: {
    hours: { type: Number, default: 0 },
    minutes: { type: Number, default: 0 },
    seconds: { type: Number, default: 0 },
    closeTimePickerBtn: { type: Object, default: null },
    order: { type: Number, default: 0 },
    ...tt
  },
  emits: [
    "set-hours",
    "set-minutes",
    "update:hours",
    "update:minutes",
    "update:seconds",
    "reset-flow",
    "mounted",
    "overlay-closed"
  ],
  setup(e3, { expose: n2, emit: a3 }) {
    const t3 = e3, { setTimePickerElements: o2, setTimePickerBackRef: d3 } = et(), { defaults: p2 } = Ve(t3), { transitionName: $, showTransition: O2 } = Ft(p2.value.transitions), R2 = reactive({
      hours: false,
      minutes: false,
      seconds: false
    }), F = ref("AM"), A = ref(null), c2 = ref([]);
    onMounted(() => {
      a3("mounted");
    });
    const M3 = computed(() => (u2) => !!(t3.maxTime && t3.maxTime[u2] && t3.maxTime[u2] < t3[u2] + +t3[`${u2}Increment`])), W = computed(() => (u2) => !!(t3.minTime && t3.minTime[u2] && t3.minTime[u2] > t3[u2] - +t3[`${u2}Increment`])), Y2 = (u2, r2) => add(set(b2(), u2), r2), ee = (u2, r2) => sub(set(b2(), u2), r2), B2 = computed(
      () => ({
        dp__time_col: true,
        dp__time_col_reg: !t3.enableSeconds && t3.is24,
        dp__time_col_reg_with_button: !t3.enableSeconds && !t3.is24,
        dp__time_col_sec: t3.enableSeconds && t3.is24,
        dp__time_col_sec_with_button: t3.enableSeconds && !t3.is24
      })
    ), E2 = computed(() => {
      const u2 = [{ type: "hours" }, { type: "", separator: true }, { type: "minutes" }];
      return t3.enableSeconds ? u2.concat([{ type: "", separator: true }, { type: "seconds" }]) : u2;
    }), N = computed(() => E2.value.filter((u2) => !u2.separator)), j = computed(() => (u2) => {
      if (u2 === "hours") {
        const r2 = L2(t3.hours);
        return { text: r2 < 10 ? `0${r2}` : `${r2}`, value: r2 };
      }
      return { text: t3[u2] < 10 ? `0${t3[u2]}` : `${t3[u2]}`, value: t3[u2] };
    }), ae = (u2) => {
      const r2 = t3.is24 ? 24 : 12, m3 = u2 === "hours" ? r2 : 60, y3 = +t3[`${u2}GridIncrement`], k2 = u2 === "hours" && !t3.is24 ? y3 : 0, x2 = [];
      for (let G2 = k2; G2 < m3; G2 += y3)
        x2.push({ value: G2, text: G2 < 10 ? `0${G2}` : `${G2}` });
      return u2 === "hours" && !t3.is24 && x2.push({ value: 0, text: "12" }), _r(x2);
    }, le = (u2, r2) => {
      const m3 = t3.minTime && t3.minTime[r2], y3 = t3.maxTime && t3.maxTime[r2];
      return m3 && y3 ? u2 < m3 || u2 > y3 : m3 ? u2 < m3 : y3 ? u2 > y3 : false;
    }, ce = computed(() => (u2) => ae(u2).flat().map((m3) => m3.value).filter((m3) => le(m3, u2))), v = (u2) => t3[`no${u2[0].toUpperCase() + u2.slice(1)}Overlay`], S3 = (u2) => {
      v(u2) || (R2[u2] = !R2[u2], R2[u2] || a3("overlay-closed"));
    }, I2 = (u2) => u2 === "hours" ? getHours : u2 === "minutes" ? getMinutes : getSeconds, T2 = (u2, r2 = true) => {
      const m3 = r2 ? Y2 : ee;
      (r2 ? M3.value(u2) : W.value(u2)) || a3(
        `update:${u2}`,
        I2(u2)(m3({ [u2]: +t3[u2] }, { [u2]: +t3[`${u2}Increment`] }))
      );
    }, L2 = (u2) => t3.is24 ? u2 : (u2 >= 12 ? F.value = "PM" : F.value = "AM", Cr(u2)), Z = () => {
      F.value === "PM" ? (F.value = "AM", a3("update:hours", t3.hours - 12)) : (F.value = "PM", a3("update:hours", t3.hours + 12));
    }, J = (u2) => {
      R2[u2] = true;
    }, _2 = (u2, r2, m3) => {
      if (u2 && t3.arrowNavigation) {
        Array.isArray(c2.value[r2]) ? c2.value[r2][m3] = u2 : c2.value[r2] = [u2];
        const y3 = c2.value.reduce(
          (k2, x2) => x2.map((G2, de) => [...k2[de] || [], x2[de]]),
          []
        );
        d3(t3.closeTimePickerBtn), A.value && (y3[1] = y3[1].concat(A.value)), o2(y3, t3.order);
      }
    }, C = (u2, r2) => u2 === "hours" && !t3.is24 ? a3(`update:${u2}`, F.value === "PM" ? r2 + 12 : r2) : a3(`update:${u2}`, r2);
    return n2({ openChildCmp: J }), (u2, r2) => {
      var m3;
      return u2.disabled ? createCommentVNode("", true) : (openBlock(), createElementBlock("div", $l, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(unref(E2), (y3, k2) => {
          var x2, G2, de;
          return openBlock(), createElementBlock("div", {
            key: k2,
            class: normalizeClass(unref(B2))
          }, [
            y3.separator ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
              createTextVNode(" : ")
            ], 64)) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
              createBaseVNode("div", {
                class: normalizeClass({
                  dp__inc_dec_button: true,
                  dp__inc_dec_button_disabled: unref(M3)(y3.type)
                }),
                role: "button",
                "data-test": "time-inc-btn",
                "aria-label": (x2 = unref(p2).ariaLabels) == null ? void 0 : x2.incrementValue(y3.type),
                tabindex: "0",
                onKeydown: [
                  withKeys((f) => T2(y3.type), ["enter"]),
                  withKeys((f) => T2(y3.type), ["space"])
                ],
                onClick: (f) => T2(y3.type),
                ref_for: true,
                ref: (f) => _2(f, k2, 0)
              }, [
                u2.$slots["arrow-up"] ? renderSlot(u2.$slots, "arrow-up", { key: 0 }) : createCommentVNode("", true),
                u2.$slots["arrow-up"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(Un), { key: 1 }))
              ], 42, Dl),
              createBaseVNode("div", {
                role: "button",
                "aria-label": (G2 = unref(p2).ariaLabels) == null ? void 0 : G2.openTpOverlay(y3.type),
                class: normalizeClass(v(y3.type) ? "" : "dp__time_display"),
                tabindex: "0",
                "data-test": `${y3.type}-toggle-overlay-btn`,
                onKeydown: [
                  withKeys((f) => S3(y3.type), ["enter"]),
                  withKeys((f) => S3(y3.type), ["space"])
                ],
                onClick: (f) => S3(y3.type),
                ref_for: true,
                ref: (f) => _2(f, k2, 1)
              }, [
                u2.$slots[y3.type] ? renderSlot(u2.$slots, y3.type, {
                  key: 0,
                  text: unref(j)(y3.type).text,
                  value: unref(j)(y3.type).value
                }) : createCommentVNode("", true),
                u2.$slots[y3.type] ? createCommentVNode("", true) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                  createTextVNode(toDisplayString(unref(j)(y3.type).text), 1)
                ], 64))
              ], 42, Ml),
              createBaseVNode("div", {
                class: normalizeClass({
                  dp__inc_dec_button: true,
                  dp__inc_dec_button_disabled: unref(W)(y3.type)
                }),
                role: "button",
                "data-test": "time-dec-btn",
                "aria-label": (de = unref(p2).ariaLabels) == null ? void 0 : de.decrementValue(y3.type),
                tabindex: "0",
                onKeydown: [
                  withKeys((f) => T2(y3.type, false), ["enter"]),
                  withKeys((f) => T2(y3.type, false), ["space"])
                ],
                onClick: (f) => T2(y3.type, false),
                ref_for: true,
                ref: (f) => _2(f, k2, 2)
              }, [
                u2.$slots["arrow-down"] ? renderSlot(u2.$slots, "arrow-down", { key: 0 }) : createCommentVNode("", true),
                u2.$slots["arrow-down"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(Hn), { key: 1 }))
              ], 42, _l)
            ], 64))
          ], 2);
        }), 128)),
        u2.is24 ? createCommentVNode("", true) : (openBlock(), createElementBlock("div", Tl, [
          u2.$slots["am-pm-button"] ? renderSlot(u2.$slots, "am-pm-button", {
            key: 0,
            toggle: Z,
            value: F.value
          }) : createCommentVNode("", true),
          u2.$slots["am-pm-button"] ? createCommentVNode("", true) : (openBlock(), createElementBlock("button", {
            key: 1,
            ref_key: "amPmButton",
            ref: A,
            type: "button",
            class: "dp__pm_am_button",
            role: "button",
            "aria-label": (m3 = unref(p2).ariaLabels) == null ? void 0 : m3.amPmButton,
            tabindex: "0",
            onClick: Z,
            onKeydown: [
              withKeys(withModifiers(Z, ["prevent"]), ["enter"]),
              withKeys(withModifiers(Z, ["prevent"]), ["space"])
            ]
          }, toDisplayString(F.value), 41, Al))
        ])),
        (openBlock(true), createElementBlock(Fragment, null, renderList(unref(N), (y3, k2) => (openBlock(), createBlock(Transition, {
          key: k2,
          name: unref($)(R2[y3.type]),
          css: unref(O2)
        }, {
          default: withCtx(() => [
            R2[y3.type] ? (openBlock(), createBlock($t, {
              key: 0,
              items: ae(y3.type),
              "disabled-values": unref(p2).filters.times[y3.type].concat(unref(ce)(y3.type)),
              "esc-close": u2.escClose,
              "aria-labels": unref(p2).ariaLabels,
              "hide-navigation": u2.hideNavigation,
              "onUpdate:modelValue": (x2) => C(y3.type, x2),
              onSelected: (x2) => S3(y3.type),
              onToggle: (x2) => S3(y3.type),
              onResetFlow: r2[0] || (r2[0] = (x2) => u2.$emit("reset-flow")),
              type: y3.type
            }, createSlots({
              "button-icon": withCtx(() => [
                u2.$slots["clock-icon"] ? renderSlot(u2.$slots, "clock-icon", { key: 0 }) : createCommentVNode("", true),
                u2.$slots["clock-icon"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(Fn), { key: 1 }))
              ]),
              _: 2
            }, [
              u2.$slots[`${y3.type}-overlay-value`] ? {
                name: "item",
                fn: withCtx(({ item: x2 }) => [
                  renderSlot(u2.$slots, `${y3.type}-overlay-value`, {
                    text: x2.text,
                    value: x2.value
                  })
                ]),
                key: "0"
              } : void 0
            ]), 1032, ["items", "disabled-values", "esc-close", "aria-labels", "hide-navigation", "onUpdate:modelValue", "onSelected", "onToggle", "type"])) : createCommentVNode("", true)
          ]),
          _: 2
        }, 1032, ["name", "css"]))), 128))
      ]));
    };
  }
}), Cl = ["aria-label"], Pl = { class: "dp__overlay_container dp__container_flex dp__time_picker_overlay_container" }, Nl = {
  key: 1,
  class: "dp__overlay_row"
}, Rl = ["aria-label"], Il = /* @__PURE__ */ defineComponent$1({
  __name: "TimePicker",
  props: {
    hours: { type: [Number, Array], default: 0 },
    minutes: { type: [Number, Array], default: 0 },
    seconds: { type: [Number, Array], default: 0 },
    internalModelValue: { type: [Date, Array], default: null },
    ...tt
  },
  emits: [
    "update:hours",
    "update:minutes",
    "update:seconds",
    "mount",
    "reset-flow",
    "overlay-closed"
  ],
  setup(e3, { expose: n2, emit: a3 }) {
    const t3 = e3, { buildMatrix: o2, setTimePicker: d3 } = et(), p2 = useSlots(), { hideNavigationButtons: $, defaults: O2 } = Ve(t3), { transitionName: R2, showTransition: F } = Ft(O2.value.transitions), A = ref(null), c2 = ref(null), M3 = ref([]), W = ref(null);
    onMounted(() => {
      a3("mount"), !t3.timePicker && t3.arrowNavigation ? o2([Me(A.value)], "time") : d3(true, t3.timePicker);
    });
    const Y2 = computed(() => t3.range && t3.modelAuto ? jn(t3.internalModelValue) : true), ee = ref(false), B2 = (T2) => ({
      hours: Array.isArray(t3.hours) ? t3.hours[T2] : t3.hours,
      minutes: Array.isArray(t3.minutes) ? t3.minutes[T2] : t3.minutes,
      seconds: Array.isArray(t3.seconds) ? t3.seconds[T2] : t3.seconds
    }), E2 = computed(() => {
      const T2 = [];
      if (t3.range)
        for (let L2 = 0; L2 < 2; L2++)
          T2.push(B2(L2));
      else
        T2.push(B2(0));
      return T2;
    }), N = (T2, L2 = false, Z = "") => {
      L2 || a3("reset-flow"), ee.value = T2, t3.arrowNavigation && (d3(T2), T2 || a3("overlay-closed")), nextTick(() => {
        Z !== "" && M3.value[0] && M3.value[0].openChildCmp(Z);
      });
    }, j = computed(() => ({
      dp__button: true,
      dp__button_bottom: t3.autoApply
    })), ae = st(p2, "timePicker"), le = (T2, L2, Z) => t3.range ? L2 === 0 ? [T2, E2.value[1][Z]] : [E2.value[0][Z], T2] : T2, ce = (T2) => {
      a3("update:hours", T2);
    }, v = (T2) => {
      a3("update:minutes", T2);
    }, S3 = (T2) => {
      a3("update:seconds", T2);
    }, I2 = () => {
      W.value && t3.arrowNavigation && W.value.focus({ preventScroll: true });
    };
    return n2({ toggleTimePicker: N }), (T2, L2) => {
      var Z;
      return openBlock(), createElementBlock("div", null, [
        T2.timePicker ? createCommentVNode("", true) : withDirectives((openBlock(), createElementBlock("div", {
          key: 0,
          class: normalizeClass(unref(j)),
          role: "button",
          "aria-label": (Z = unref(O2).ariaLabels) == null ? void 0 : Z.openTimePicker,
          tabindex: "0",
          "data-test": "open-time-picker-btn",
          ref_key: "openTimePickerBtn",
          ref: A,
          onKeydown: [
            L2[0] || (L2[0] = withKeys((J) => N(true), ["enter"])),
            L2[1] || (L2[1] = withKeys((J) => N(true), ["space"]))
          ],
          onClick: L2[2] || (L2[2] = (J) => N(true))
        }, [
          T2.$slots["clock-icon"] ? renderSlot(T2.$slots, "clock-icon", { key: 0 }) : createCommentVNode("", true),
          T2.$slots["clock-icon"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(Fn), { key: 1 }))
        ], 42, Cl)), [
          [vShow, !unref($)("time")]
        ]),
        createVNode(Transition, {
          name: unref(R2)(ee.value),
          css: unref(F)
        }, {
          default: withCtx(() => {
            var J;
            return [
              ee.value || T2.timePicker ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: "dp__overlay",
                ref_key: "overlayRef",
                ref: W,
                tabindex: "0"
              }, [
                createBaseVNode("div", Pl, [
                  T2.$slots["time-picker-overlay"] ? renderSlot(T2.$slots, "time-picker-overlay", {
                    key: 0,
                    hours: e3.hours,
                    minutes: e3.minutes,
                    seconds: e3.seconds,
                    setHours: ce,
                    setMinutes: v,
                    setSeconds: S3
                  }) : createCommentVNode("", true),
                  T2.$slots["time-picker-overlay"] ? createCommentVNode("", true) : (openBlock(), createElementBlock("div", Nl, [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(unref(E2), (_2, C) => withDirectives((openBlock(), createBlock(Sl, mergeProps({ key: C }, {
                      ...T2.$props,
                      order: C,
                      hours: _2.hours,
                      minutes: _2.minutes,
                      seconds: _2.seconds,
                      closeTimePickerBtn: c2.value,
                      disabled: C === 0 ? T2.fixedStart : T2.fixedEnd
                    }, {
                      ref_for: true,
                      ref_key: "timeInputRefs",
                      ref: M3,
                      "onUpdate:hours": (u2) => ce(le(u2, C, "hours")),
                      "onUpdate:minutes": (u2) => v(le(u2, C, "minutes")),
                      "onUpdate:seconds": (u2) => S3(le(u2, C, "seconds")),
                      onMounted: I2,
                      onOverlayClosed: I2
                    }), createSlots({ _: 2 }, [
                      renderList(unref(ae), (u2, r2) => ({
                        name: u2,
                        fn: withCtx((m3) => [
                          renderSlot(T2.$slots, u2, normalizeProps(guardReactiveProps(m3)))
                        ])
                      }))
                    ]), 1040, ["onUpdate:hours", "onUpdate:minutes", "onUpdate:seconds"])), [
                      [vShow, C === 0 ? true : unref(Y2)]
                    ])), 128))
                  ])),
                  T2.timePicker ? createCommentVNode("", true) : withDirectives((openBlock(), createElementBlock("div", {
                    key: 2,
                    ref_key: "closeTimePickerBtn",
                    ref: c2,
                    class: normalizeClass(unref(j)),
                    role: "button",
                    "aria-label": (J = unref(O2).ariaLabels) == null ? void 0 : J.closeTimePicker,
                    tabindex: "0",
                    onKeydown: [
                      L2[3] || (L2[3] = withKeys((_2) => N(false), ["enter"])),
                      L2[4] || (L2[4] = withKeys((_2) => N(false), ["space"]))
                    ],
                    onClick: L2[5] || (L2[5] = (_2) => N(false))
                  }, [
                    T2.$slots["calendar-icon"] ? renderSlot(T2.$slots, "calendar-icon", { key: 0 }) : createCommentVNode("", true),
                    T2.$slots["calendar-icon"] ? createCommentVNode("", true) : (openBlock(), createBlock(unref(Lt), { key: 1 }))
                  ], 42, Rl)), [
                    [vShow, !unref($)("time")]
                  ])
                ])
              ], 512)) : createCommentVNode("", true)
            ];
          }),
          _: 3
        }, 8, ["name", "css"])
      ]);
    };
  }
}), Ol = (e3, n2) => {
  const { isDisabled: a3, matchDate: t3, getWeekFromDate: o2 } = Ve(n2), d3 = ref(null), p2 = ref(b2()), $ = (r2) => {
    !r2.current && n2.hideOffsetDates || (d3.value = r2.value);
  }, O2 = () => {
    d3.value = null;
  }, R2 = (r2) => Array.isArray(e3.value) && n2.range && e3.value[0] && d3.value ? r2 ? Oe(d3.value, e3.value[0]) : Pe(d3.value, e3.value[0]) : true, F = (r2, m3) => {
    const y3 = () => e3.value ? m3 ? e3.value[0] || null : e3.value[1] : null, k2 = e3.value && Array.isArray(e3.value) ? y3() : null;
    return pe(b2(r2.value), k2);
  }, A = (r2) => {
    const m3 = Array.isArray(e3.value) ? e3.value[0] : null;
    return r2 ? !Pe(d3.value || null, m3) : true;
  }, c2 = (r2, m3 = true) => (n2.range || n2.weekPicker) && Array.isArray(e3.value) ? n2.hideOffsetDates && !r2.current ? false : pe(b2(r2.value), e3.value[m3 ? 0 : 1]) : n2.range ? F(r2, m3) && A(m3) || pe(r2.value, Array.isArray(e3.value) ? e3.value[0] : null) && R2(m3) : false, M3 = (r2, m3, y3) => Array.isArray(e3.value) && e3.value[0] && e3.value.length === 1 ? r2 ? false : y3 ? Oe(e3.value[0], m3.value) : Pe(e3.value[0], m3.value) : false, W = (r2) => !e3.value || n2.hideOffsetDates && !r2.current ? false : n2.range ? n2.modelAuto && Array.isArray(e3.value) ? pe(r2.value, e3.value[0] ? e3.value[0] : p2.value) : false : n2.multiDates && Array.isArray(e3.value) ? e3.value.some((m3) => pe(m3, r2.value)) : pe(r2.value, e3.value ? e3.value : p2.value), Y2 = (r2) => {
    if (n2.autoRange || n2.weekPicker) {
      if (d3.value) {
        if (n2.hideOffsetDates && !r2.current)
          return false;
        const m3 = addDays(d3.value, +n2.autoRange), y3 = o2(b2(d3.value));
        return n2.weekPicker ? pe(y3[1], b2(r2.value)) : pe(m3, b2(r2.value));
      }
      return false;
    }
    return false;
  }, ee = (r2) => {
    if (n2.autoRange || n2.weekPicker) {
      if (d3.value) {
        const m3 = addDays(d3.value, +n2.autoRange);
        if (n2.hideOffsetDates && !r2.current)
          return false;
        const y3 = o2(b2(d3.value));
        return n2.weekPicker ? Oe(r2.value, y3[0]) && Pe(r2.value, y3[1]) : Oe(r2.value, d3.value) && Pe(r2.value, m3);
      }
      return false;
    }
    return false;
  }, B2 = (r2) => {
    if (n2.autoRange || n2.weekPicker) {
      if (d3.value) {
        if (n2.hideOffsetDates && !r2.current)
          return false;
        const m3 = o2(b2(d3.value));
        return n2.weekPicker ? pe(m3[0], r2.value) : pe(d3.value, r2.value);
      }
      return false;
    }
    return false;
  }, E2 = (r2) => Wn(e3.value, d3.value, r2.value), N = () => n2.modelAuto && Array.isArray(n2.internalModelValue) ? !!n2.internalModelValue[0] : false, j = () => n2.modelAuto ? jn(n2.internalModelValue) : true, ae = (r2) => {
    if (Array.isArray(e3.value) && e3.value.length || n2.weekPicker)
      return false;
    const m3 = n2.range ? !c2(r2) && !c2(r2, false) : true;
    return !a3(r2.value) && !W(r2) && !(!r2.current && n2.hideOffsetDates) && m3;
  }, le = (r2) => n2.range ? n2.modelAuto ? N() && W(r2) : false : W(r2), ce = (r2) => n2.highlight ? t3(r2.value, n2.highlight) : false, v = (r2) => a3(r2.value) && n2.highlightDisabledDays === false, S3 = (r2) => n2.highlightWeekDays && n2.highlightWeekDays.includes(r2.value.getDay()), I2 = (r2) => (n2.range || n2.weekPicker) && (!(n2.multiCalendars > 0) || r2.current) && j() && !(!r2.current && n2.hideOffsetDates) && !W(r2) ? E2(r2) : false, T2 = (r2) => ({
    dp__cell_offset: !r2.current,
    dp__pointer: !n2.disabled && !(!r2.current && n2.hideOffsetDates) && !a3(r2.value),
    dp__cell_disabled: a3(r2.value),
    dp__cell_highlight: !v(r2) && (ce(r2) || S3(r2)) && !le(r2),
    dp__cell_highlight_active: !v(r2) && (ce(r2) || S3(r2)) && le(r2),
    dp__today: !n2.noToday && pe(r2.value, p2.value) && r2.current
  }), L2 = (r2) => ({
    dp__active_date: le(r2),
    dp__date_hover: ae(r2)
  }), Z = (r2) => ({
    ...J(r2),
    ..._2(r2),
    dp__range_between_week: I2(r2) && n2.weekPicker
  }), J = (r2) => ({
    dp__range_start: n2.multiCalendars > 0 ? r2.current && c2(r2) && j() : c2(r2) && j(),
    dp__range_end: n2.multiCalendars > 0 ? r2.current && c2(r2, false) && j() : c2(r2, false) && j(),
    dp__range_between: I2(r2) && !n2.weekPicker,
    dp__date_hover_start: M3(ae(r2), r2, true),
    dp__date_hover_end: M3(ae(r2), r2, false)
  }), _2 = (r2) => ({
    ...J(r2),
    dp__cell_auto_range: ee(r2),
    dp__cell_auto_range_start: B2(r2),
    dp__cell_auto_range_end: Y2(r2)
  }), C = (r2) => n2.range ? n2.autoRange ? _2(r2) : n2.modelAuto ? { ...L2(r2), ...J(r2) } : J(r2) : n2.weekPicker ? Z(r2) : L2(r2);
  return {
    setHoverDate: $,
    clearHoverDate: O2,
    getDayClassData: (r2) => ({
      ...T2(r2),
      ...C(r2),
      [n2.dayClass ? n2.dayClass(r2.value) : ""]: true,
      [n2.calendarCellClassName]: !!n2.calendarCellClassName
    })
  };
}, Bl = ["id", "onKeydown"], Yl = {
  key: 0,
  class: "dp__sidebar_left"
}, Vl = {
  key: 1,
  class: "dp__preset_ranges"
}, El = ["onClick"], Ll = {
  key: 2,
  class: "dp__sidebar_right"
}, Fl = {
  key: 3,
  class: "dp__now_wrap"
}, Ul = /* @__PURE__ */ defineComponent$1({
  __name: "DatepickerMenu",
  props: {
    openOnTop: { type: Boolean, default: false },
    internalModelValue: { type: [Date, Array], default: null },
    ...tt
  },
  emits: [
    "close-picker",
    "select-date",
    "auto-apply",
    "time-update",
    "flow-step",
    "update-month-year",
    "invalid-select",
    "update:internal-model-value",
    "recalculate-position",
    "invalid-fixed-range",
    "tooltip-open",
    "tooltip-close"
  ],
  setup(e3, { expose: n2, emit: a3 }) {
    const t3 = e3, { setMenuFocused: o2, setShiftKey: d3, control: p2 } = zn(), { getCalendarDays: $, defaults: O2 } = Ve(t3), R2 = useSlots(), F = ref(null), A = reactive({
      timePicker: !!(!t3.enableTimePicker || t3.timePicker || t3.monthPicker),
      monthYearInput: !!t3.timePicker,
      calendar: false
    }), c2 = ref([]), M3 = ref([]), W = ref(null), Y2 = ref(null), ee = ref(0), B2 = ref(false), E2 = ref(0);
    onMounted(() => {
      var z2;
      B2.value = true, !((z2 = t3.presetRanges) != null && z2.length) && !R2["left-sidebar"] && !R2["right-sidebar"] && me();
      const h4 = Me(Y2);
      if (h4 && !t3.textInput && !t3.inline && (o2(true), v()), h4) {
        const $e = (Te) => {
          Object.keys(R2).length || Te.preventDefault(), Te.stopImmediatePropagation(), Te.stopPropagation();
        };
        h4.addEventListener("pointerdown", $e), h4.addEventListener("mousedown", $e);
      }
      window.addEventListener("resize", me);
    }), onUnmounted(() => {
      window.removeEventListener("resize", me);
    });
    const { arrowRight: N, arrowLeft: j, arrowDown: ae, arrowUp: le } = et(), ce = (h4) => {
      h4 || h4 === 0 ? M3.value[h4].triggerTransition(
        Z.value(h4),
        J.value(h4)
      ) : M3.value.forEach(
        (z2, $e) => z2.triggerTransition(Z.value($e), J.value($e))
      );
    }, v = () => {
      const h4 = Me(Y2);
      h4 && h4.focus({ preventScroll: true });
    }, S3 = () => {
      var h4;
      (h4 = t3.flow) != null && h4.length && E2.value !== -1 && (E2.value += 1, a3("flow-step", E2.value), w2());
    }, I2 = () => {
      E2.value = -1;
    }, {
      calendars: T2,
      modelValue: L2,
      month: Z,
      year: J,
      time: _2,
      updateTime: C,
      updateMonthYear: u2,
      selectDate: r2,
      getWeekNum: m3,
      monthYearSelect: y3,
      handleScroll: k2,
      handleArrow: x2,
      handleSwipe: G2,
      getMarker: de,
      selectCurrentDate: f,
      presetDateRange: l
    } = Vr(t3, a3, S3, ce, E2), { setHoverDate: Q2, clearHoverDate: we, getDayClassData: be } = Ol(L2, t3);
    watch(
      T2,
      () => {
        t3.openOnTop && setTimeout(() => {
          a3("recalculate-position");
        }, 0);
      },
      { deep: true }
    );
    const We = st(R2, "calendar"), je = st(R2, "action"), re = st(R2, "timePicker"), Je = st(R2, "monthYear"), ze = computed(() => t3.openOnTop ? "dp__arrow_bottom" : "dp__arrow_top"), X2 = computed(() => Ar(t3.yearRange)), ke = computed(() => Sr(t3.locale, t3.monthNameFormat)), me = () => {
      const h4 = Me(F);
      h4 && (ee.value = h4.getBoundingClientRect().width);
    }, nt = computed(() => (h4) => $(Z.value(h4), J.value(h4))), Le = computed(
      () => O2.value.multiCalendars > 0 && t3.range ? [...Array(O2.value.multiCalendars).keys()] : [0]
    ), gt = computed(
      () => (h4) => h4 === 1
    ), Ut = computed(() => t3.monthPicker || t3.timePicker || t3.yearPicker), Ht = computed(
      () => ({
        dp__flex_display: O2.value.multiCalendars > 0
      })
    ), Mt = computed(() => ({
      dp__instance_calendar: O2.value.multiCalendars > 0
    })), pt = computed(() => ({
      dp__menu_disabled: t3.disabled,
      dp__menu_readonly: t3.readonly
    })), Wt = computed(
      () => (h4) => xt(nt, h4)
    ), zt = computed(
      () => ({
        dp__menu: true,
        dp__menu_index: !t3.inline,
        dp__relative: t3.inline,
        [t3.menuClassName]: !!t3.menuClassName
      })
    ), xt = (h4, z2) => h4.value(z2).map(($e) => ({
      ...$e,
      days: $e.days.map((Te) => (Te.marker = de(Te), Te.classData = be(Te), Te))
    })), _t = (h4) => {
      h4.stopPropagation(), h4.stopImmediatePropagation();
    }, yn = () => {
      t3.escClose && a3("close-picker");
    }, hn = (h4, z2 = false) => {
      r2(h4, z2), t3.spaceConfirm && a3("select-date");
    }, Tt = (h4) => {
      var z2;
      (z2 = t3.flow) != null && z2.length && (A[h4] = true, Object.keys(A).filter(($e) => !A[$e]).length || w2());
    }, s3 = (h4, z2, $e, Te, ...Fe) => {
      if (t3.flow[E2.value] === h4) {
        const q2 = Te ? z2.value[0] : z2.value;
        q2 && q2[$e](...Fe);
      }
    }, w2 = () => {
      s3("month", c2, "toggleMonthPicker", true, true), s3("year", c2, "toggleYearPicker", true, true), s3("calendar", W, "toggleTimePicker", false, false, true), s3("time", W, "toggleTimePicker", false, true, true);
      const h4 = t3.flow[E2.value];
      (h4 === "hours" || h4 === "minutes" || h4 === "seconds") && s3(h4, W, "toggleTimePicker", false, true, true, h4);
    }, K2 = (h4) => {
      if (t3.arrowNavigation) {
        if (h4 === "up")
          return le();
        if (h4 === "down")
          return ae();
        if (h4 === "left")
          return j();
        if (h4 === "right")
          return N();
      } else
        h4 === "left" || h4 === "up" ? x2("left", 0, h4 === "up") : x2("right", 0, h4 === "down");
    }, te = (h4) => {
      d3(h4.shiftKey), !t3.disableMonthYearSelect && h4.code === "Tab" && h4.target.classList.contains("dp__menu") && p2.value.shiftKeyInMenu && (h4.preventDefault(), h4.stopImmediatePropagation(), a3("close-picker"));
    };
    return n2({
      updateMonthYear: u2
    }), (h4, z2) => {
      var $e;
      return openBlock(), createBlock(Transition, {
        appear: "",
        name: ($e = unref(O2).transitions) == null ? void 0 : $e.menuAppear,
        mode: "out-in",
        css: !!h4.transitions
      }, {
        default: withCtx(() => {
          var Te, Fe;
          return [
            createBaseVNode("div", {
              id: h4.uid ? `dp-menu-${h4.uid}` : void 0,
              tabindex: "0",
              ref_key: "dpMenuRef",
              ref: Y2,
              role: "dialog",
              class: normalizeClass(unref(zt)),
              onMouseleave: z2[14] || (z2[14] = (...q2) => unref(we) && unref(we)(...q2)),
              onClick: _t,
              onKeydown: [
                withKeys(yn, ["esc"]),
                z2[15] || (z2[15] = withKeys(withModifiers((q2) => K2("left"), ["prevent"]), ["left"])),
                z2[16] || (z2[16] = withKeys(withModifiers((q2) => K2("up"), ["prevent"]), ["up"])),
                z2[17] || (z2[17] = withKeys(withModifiers((q2) => K2("down"), ["prevent"]), ["down"])),
                z2[18] || (z2[18] = withKeys(withModifiers((q2) => K2("right"), ["prevent"]), ["right"])),
                te
              ]
            }, [
              (h4.disabled || h4.readonly) && h4.inline ? (openBlock(), createElementBlock("div", {
                key: 0,
                class: normalizeClass(unref(pt))
              }, null, 2)) : createCommentVNode("", true),
              !h4.inline && !h4.teleportCenter ? (openBlock(), createElementBlock("div", {
                key: 1,
                class: normalizeClass(unref(ze))
              }, null, 2)) : createCommentVNode("", true),
              createBaseVNode("div", {
                class: normalizeClass({
                  dp__menu_content_wrapper: ((Te = h4.presetRanges) == null ? void 0 : Te.length) || !!h4.$slots["left-sidebar"] || !!h4.$slots["right-sidebar"]
                })
              }, [
                h4.$slots["left-sidebar"] ? (openBlock(), createElementBlock("div", Yl, [
                  renderSlot(h4.$slots, "left-sidebar")
                ])) : createCommentVNode("", true),
                (Fe = h4.presetRanges) != null && Fe.length ? (openBlock(), createElementBlock("div", Vl, [
                  (openBlock(true), createElementBlock(Fragment, null, renderList(h4.presetRanges, (q2, dt) => (openBlock(), createElementBlock("div", {
                    key: dt,
                    style: normalizeStyle(q2.style || {}),
                    class: "dp__preset_range",
                    onClick: (se) => unref(l)(q2.range, !!q2.slot)
                  }, [
                    q2.slot ? renderSlot(h4.$slots, q2.slot, {
                      key: 0,
                      presetDateRange: unref(l),
                      label: q2.label,
                      range: q2.range
                    }) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                      createTextVNode(toDisplayString(q2.label), 1)
                    ], 64))
                  ], 12, El))), 128))
                ])) : createCommentVNode("", true),
                createBaseVNode("div", {
                  class: "dp__instance_calendar",
                  ref_key: "calendarWrapperRef",
                  ref: F,
                  role: "document"
                }, [
                  createBaseVNode("div", {
                    class: normalizeClass(unref(Ht))
                  }, [
                    (openBlock(true), createElementBlock(Fragment, null, renderList(unref(Le), (q2, dt) => (openBlock(), createElementBlock("div", {
                      key: q2,
                      class: normalizeClass(unref(Mt))
                    }, [
                      !h4.disableMonthYearSelect && !h4.timePicker ? (openBlock(), createBlock(bl, mergeProps({
                        key: 0,
                        ref_for: true,
                        ref: (se) => {
                          se && (c2.value[dt] = se);
                        },
                        months: unref(ke),
                        years: unref(X2),
                        month: unref(Z)(q2),
                        year: unref(J)(q2),
                        instance: q2,
                        "internal-model-value": e3.internalModelValue
                      }, h4.$props, {
                        onMount: z2[0] || (z2[0] = (se) => Tt("monthYearInput")),
                        onResetFlow: I2,
                        onUpdateMonthYear: (se) => unref(u2)(q2, se),
                        onMonthYearSelect: unref(y3),
                        onOverlayClosed: v
                      }), createSlots({ _: 2 }, [
                        renderList(unref(Je), (se, Zn) => ({
                          name: se,
                          fn: withCtx((Kt) => [
                            renderSlot(h4.$slots, se, normalizeProps(guardReactiveProps(Kt)))
                          ])
                        }))
                      ]), 1040, ["months", "years", "month", "year", "instance", "internal-model-value", "onUpdateMonthYear", "onMonthYearSelect"])) : createCommentVNode("", true),
                      createVNode(il, mergeProps({
                        ref_for: true,
                        ref: (se) => {
                          se && (M3.value[dt] = se);
                        },
                        "specific-mode": unref(Ut),
                        "get-week-num": unref(m3),
                        instance: q2,
                        "mapped-dates": unref(Wt)(q2),
                        month: unref(Z)(q2),
                        year: unref(J)(q2)
                      }, h4.$props, {
                        "flow-step": E2.value,
                        "onUpdate:flowStep": z2[1] || (z2[1] = (se) => E2.value = se),
                        onSelectDate: (se) => unref(r2)(se, !unref(gt)(q2)),
                        onHandleSpace: (se) => hn(se, !unref(gt)(q2)),
                        onSetHoverDate: z2[2] || (z2[2] = (se) => unref(Q2)(se)),
                        onHandleScroll: (se) => unref(k2)(se, q2),
                        onHandleSwipe: (se) => unref(G2)(se, q2),
                        onMount: z2[3] || (z2[3] = (se) => Tt("calendar")),
                        onResetFlow: I2,
                        onTooltipOpen: z2[4] || (z2[4] = (se) => h4.$emit("tooltip-open", se)),
                        onTooltipClose: z2[5] || (z2[5] = (se) => h4.$emit("tooltip-close", se))
                      }), createSlots({ _: 2 }, [
                        renderList(unref(We), (se, Zn) => ({
                          name: se,
                          fn: withCtx((Kt) => [
                            renderSlot(h4.$slots, se, normalizeProps(guardReactiveProps({ ...Kt })))
                          ])
                        }))
                      ]), 1040, ["specific-mode", "get-week-num", "instance", "mapped-dates", "month", "year", "flow-step", "onSelectDate", "onHandleSpace", "onHandleScroll", "onHandleSwipe"])
                    ], 2))), 128))
                  ], 2),
                  createBaseVNode("div", null, [
                    h4.$slots["time-picker"] ? renderSlot(h4.$slots, "time-picker", normalizeProps(mergeProps({ key: 0 }, { time: unref(_2), updateTime: unref(C) }))) : (openBlock(), createElementBlock(Fragment, { key: 1 }, [
                      h4.enableTimePicker && !h4.monthPicker && !h4.weekPicker ? (openBlock(), createBlock(Il, mergeProps({
                        key: 0,
                        ref_key: "timePickerRef",
                        ref: W,
                        hours: unref(_2).hours,
                        minutes: unref(_2).minutes,
                        seconds: unref(_2).seconds,
                        "internal-model-value": e3.internalModelValue
                      }, h4.$props, {
                        onMount: z2[6] || (z2[6] = (q2) => Tt("timePicker")),
                        "onUpdate:hours": z2[7] || (z2[7] = (q2) => unref(C)(q2)),
                        "onUpdate:minutes": z2[8] || (z2[8] = (q2) => unref(C)(q2, false)),
                        "onUpdate:seconds": z2[9] || (z2[9] = (q2) => unref(C)(q2, false, true)),
                        onResetFlow: I2,
                        onOverlayClosed: v
                      }), createSlots({ _: 2 }, [
                        renderList(unref(re), (q2, dt) => ({
                          name: q2,
                          fn: withCtx((se) => [
                            renderSlot(h4.$slots, q2, normalizeProps(guardReactiveProps(se)))
                          ])
                        }))
                      ]), 1040, ["hours", "minutes", "seconds", "internal-model-value"])) : createCommentVNode("", true)
                    ], 64))
                  ])
                ], 512),
                h4.$slots["right-sidebar"] ? (openBlock(), createElementBlock("div", Ll, [
                  renderSlot(h4.$slots, "right-sidebar")
                ])) : createCommentVNode("", true),
                h4.showNowButton ? (openBlock(), createElementBlock("div", Fl, [
                  h4.$slots["now-button"] ? renderSlot(h4.$slots, "now-button", {
                    key: 0,
                    selectCurrentDate: unref(f)
                  }) : createCommentVNode("", true),
                  h4.$slots["now-button"] ? createCommentVNode("", true) : (openBlock(), createElementBlock("button", {
                    key: 1,
                    type: "button",
                    role: "button",
                    class: "dp__now_button",
                    onClick: z2[10] || (z2[10] = (...q2) => unref(f) && unref(f)(...q2))
                  }, toDisplayString(h4.nowButtonLabel), 1))
                ])) : createCommentVNode("", true)
              ], 2),
              !h4.autoApply || h4.keepActionRow ? (openBlock(), createBlock(Jr, mergeProps({
                key: 2,
                "menu-mount": B2.value,
                "calendar-width": ee.value,
                "internal-model-value": e3.internalModelValue
              }, h4.$props, {
                onClosePicker: z2[11] || (z2[11] = (q2) => h4.$emit("close-picker")),
                onSelectDate: z2[12] || (z2[12] = (q2) => h4.$emit("select-date")),
                onInvalidSelect: z2[13] || (z2[13] = (q2) => h4.$emit("invalid-select"))
              }), createSlots({ _: 2 }, [
                renderList(unref(je), (q2, dt) => ({
                  name: q2,
                  fn: withCtx((se) => [
                    renderSlot(h4.$slots, q2, normalizeProps(guardReactiveProps({ ...se })))
                  ])
                }))
              ]), 1040, ["menu-mount", "calendar-width", "internal-model-value"])) : createCommentVNode("", true)
            ], 42, Bl)
          ];
        }),
        _: 3
      }, 8, ["name", "css"]);
    };
  }
}), Hl = typeof window < "u" ? window : void 0, nn = () => {
}, Wl = (e3) => getCurrentScope() ? (onScopeDispose(e3), true) : false, zl = (e3, n2, a3, t3) => {
  if (!e3)
    return nn;
  let o2 = nn;
  const d3 = watch(
    () => unref(e3),
    ($) => {
      o2(), $ && ($.addEventListener(n2, a3, t3), o2 = () => {
        $.removeEventListener(n2, a3, t3), o2 = nn;
      });
    },
    { immediate: true, flush: "post" }
  ), p2 = () => {
    d3(), o2();
  };
  return Wl(p2), p2;
}, xl = (e3, n2, a3, t3 = {}) => {
  const { window: o2 = Hl, event: d3 = "pointerdown" } = t3;
  return o2 ? zl(o2, d3, ($) => {
    const O2 = Me(e3), R2 = Me(n2);
    !O2 || !R2 || O2 === $.target || $.composedPath().includes(O2) || $.composedPath().includes(R2) || a3($);
  }, { passive: true }) : void 0;
}, Kl = /* @__PURE__ */ defineComponent$1({
  __name: "VueDatePicker",
  props: {
    ...tt
  },
  emits: [
    "update:model-value",
    "text-submit",
    "closed",
    "cleared",
    "open",
    "focus",
    "blur",
    "internal-model-change",
    "recalculate-position",
    "flow-step",
    "update-month-year",
    "invalid-select",
    "invalid-fixed-range",
    "tooltip-open",
    "tooltip-close"
  ],
  setup(e3, { expose: n2, emit: a3 }) {
    const t3 = e3, o2 = useSlots(), d3 = ref(false), p2 = toRef(t3, "modelValue"), $ = toRef(t3, "timezone"), O2 = ref(null), R2 = ref(null), F = ref(false), A = ref(null), { setMenuFocused: c2, setShiftKey: M3 } = zn(), { clearArrowNav: W } = et(), { validateDate: Y2, isValidTime: ee, defaults: B2 } = Ve(t3);
    onMounted(() => {
      T2(t3.modelValue), t3.inline || (v(A.value).addEventListener("scroll", u2), window.addEventListener("resize", r2)), t3.inline && (d3.value = true);
    }), onUnmounted(() => {
      if (!t3.inline) {
        const X2 = v(A.value);
        X2 && X2.removeEventListener("scroll", u2), window.removeEventListener("resize", r2);
      }
    });
    const E2 = st(o2, "all", t3.presetRanges), N = st(o2, "input");
    watch(
      [p2, $],
      () => {
        T2(p2.value);
      },
      { deep: true }
    );
    const { openOnTop: j, menuPosition: ae, setMenuPosition: le, setInitialPosition: ce, getScrollableParent: v } = Fr(
      O2,
      R2,
      a3,
      t3
    ), {
      inputValue: S3,
      internalModelValue: I2,
      parseExternalModelValue: T2,
      emitModelValue: L2,
      formatInputValue: Z,
      checkBeforeEmit: J
    } = Er(a3, t3, F), _2 = computed(
      () => ({
        dp__main: true,
        dp__theme_dark: t3.dark,
        dp__theme_light: !t3.dark,
        dp__flex_display: t3.inline,
        dp__flex_display_with_input: t3.inlineWithInput
      })
    ), C = computed(() => t3.dark ? "dp__theme_dark" : "dp__theme_light"), u2 = () => {
      d3.value && (t3.closeOnScroll ? l() : le());
    }, r2 = () => {
      d3.value && le();
    }, m3 = () => {
      !t3.disabled && !t3.readonly && (ce(), d3.value = true, nextTick().then(() => {
        le(), d3.value && a3("open");
      }), d3.value || f(), T2(t3.modelValue));
    }, y3 = () => {
      S3.value = "", f(), a3("update:model-value", null), a3("cleared"), l();
    }, k2 = () => {
      const X2 = I2.value;
      return !X2 || !Array.isArray(X2) && Y2(X2) ? true : Array.isArray(X2) ? X2.length === 2 && Y2(X2[0]) && Y2(X2[1]) ? true : Y2(X2[0]) : false;
    }, x2 = () => {
      J() && k2() ? (L2(), l()) : a3("invalid-select", I2.value);
    }, G2 = (X2) => {
      L2(), t3.closeOnAutoApply && !X2 && l();
    }, de = (X2 = false) => {
      t3.autoApply && ee(I2.value) && k2() && (t3.range && Array.isArray(I2.value) ? (t3.partialRange || I2.value.length === 2) && G2(X2) : G2(X2));
    }, f = () => {
      t3.textInput || (I2.value = null);
    }, l = () => {
      t3.inline || (d3.value && (d3.value = false, c2(false), M3(false), W(), a3("closed"), ce(), S3.value && T2(p2.value)), f(), R2.value && R2.value.focusInput());
    }, Q2 = (X2, ke) => {
      if (!X2) {
        I2.value = null;
        return;
      }
      I2.value = X2, ke && (x2(), a3("text-submit"));
    }, we = () => {
      t3.autoApply && ee(I2.value) && L2();
    }, be = () => d3.value ? l() : m3(), We = (X2) => {
      I2.value = X2;
    }, je = computed(() => t3.textInput && B2.value.textInputOptions.format), re = () => {
      je.value && (F.value = true, Z()), a3("focus");
    }, Je = () => {
      je.value && (F.value = false, Z()), a3("blur");
    }, ze = (X2) => {
      O2.value && O2.value.updateMonthYear(0, {
        month: Pn(X2.month),
        year: Pn(X2.year)
      });
    };
    return xl(
      O2,
      R2,
      t3.onClickOutside ? () => t3.onClickOutside(k2) : l
    ), n2({
      closeMenu: l,
      selectDate: x2,
      clearValue: y3,
      openMenu: m3,
      onScroll: u2,
      formatInputValue: Z,
      updateInternalModelValue: We,
      setMonthYear: ze
    }), (X2, ke) => (openBlock(), createElementBlock("div", {
      class: normalizeClass(unref(_2)),
      ref_key: "pickerWrapperRef",
      ref: A
    }, [
      createVNode(Gr, mergeProps({
        ref_key: "inputRef",
        ref: R2,
        "is-menu-open": d3.value,
        "input-value": unref(S3),
        "onUpdate:inputValue": ke[0] || (ke[0] = (me) => isRef(S3) ? S3.value = me : null)
      }, X2.$props, {
        onClear: y3,
        onOpen: m3,
        onSetInputDate: Q2,
        onSetEmptyDate: unref(L2),
        onSelectDate: x2,
        onToggle: be,
        onClose: l,
        onFocus: re,
        onBlur: Je
      }), createSlots({ _: 2 }, [
        renderList(unref(N), (me, nt) => ({
          name: me,
          fn: withCtx((Le) => [
            renderSlot(X2.$slots, me, normalizeProps(guardReactiveProps(Le)))
          ])
        }))
      ]), 1040, ["is-menu-open", "input-value", "onSetEmptyDate"]),
      d3.value ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
        d3.value ? (openBlock(), createBlock(Ul, mergeProps({
          key: 0,
          ref_key: "dpMenuRef",
          ref: O2,
          class: unref(C),
          style: unref(ae),
          "open-on-top": unref(j)
        }, X2.$props, {
          "internal-model-value": unref(I2),
          "onUpdate:internalModelValue": ke[1] || (ke[1] = (me) => isRef(I2) ? I2.value = me : null),
          onClosePicker: l,
          onSelectDate: x2,
          onAutoApply: de,
          onTimeUpdate: we,
          onFlowStep: ke[2] || (ke[2] = (me) => X2.$emit("flow-step", me)),
          onUpdateMonthYear: ke[3] || (ke[3] = (me) => X2.$emit("update-month-year", me)),
          onInvalidSelect: ke[4] || (ke[4] = (me) => X2.$emit("invalid-select", unref(I2))),
          onInvalidFixedRange: ke[5] || (ke[5] = (me) => X2.$emit("invalid-fixed-range", me)),
          onRecalculatePosition: unref(le),
          onTooltipOpen: ke[6] || (ke[6] = (me) => X2.$emit("tooltip-open", me)),
          onTooltipClose: ke[7] || (ke[7] = (me) => X2.$emit("tooltip-close", me))
        }), createSlots({ _: 2 }, [
          renderList(unref(E2), (me, nt) => ({
            name: me,
            fn: withCtx((Le) => [
              renderSlot(X2.$slots, me, normalizeProps(guardReactiveProps({ ...Le })))
            ])
          }))
        ]), 1040, ["class", "style", "open-on-top", "internal-model-value", "onRecalculatePosition"])) : createCommentVNode("", true)
      ], 64)) : createCommentVNode("", true)
    ], 2));
  }
}), Gn = /* @__PURE__ */ (() => {
  const e3 = Kl;
  return e3.install = (n2) => {
    n2.component("Vue3DatePicker", e3);
  }, e3;
})(), jl = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: Gn
}, Symbol.toStringTag, { value: "Module" }));
Object.entries(jl).forEach(([e3, n2]) => {
  e3 !== "default" && (Gn[e3] = n2);
});
const main$1 = "";
const scriptRel = "modulepreload";
const assetsURL = function(dep) {
  return "/" + dep;
};
const seen = {};
const __vitePreload = function preload(baseModule, deps, importerUrl) {
  if (!deps || deps.length === 0) {
    return baseModule();
  }
  const links = document.getElementsByTagName("link");
  return Promise.all(deps.map((dep) => {
    dep = assetsURL(dep);
    if (dep in seen)
      return;
    seen[dep] = true;
    const isCss = dep.endsWith(".css");
    const cssSelector = isCss ? '[rel="stylesheet"]' : "";
    const isBaseRelative = !!importerUrl;
    if (isBaseRelative) {
      for (let i2 = links.length - 1; i2 >= 0; i2--) {
        const link2 = links[i2];
        if (link2.href === dep && (!isCss || link2.rel === "stylesheet")) {
          return;
        }
      }
    } else if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
      return;
    }
    const link = document.createElement("link");
    link.rel = isCss ? "stylesheet" : scriptRel;
    if (!isCss) {
      link.as = "script";
      link.crossOrigin = "";
    }
    link.href = dep;
    document.head.appendChild(link);
    if (isCss) {
      return new Promise((res, rej) => {
        link.addEventListener("load", res);
        link.addEventListener("error", () => rej(new Error(`Unable to preload CSS for ${dep}`)));
      });
    }
  })).then(() => baseModule());
};
async function loadFonts() {
  const webFontLoader = await __vitePreload(() => import(
    /* webpackChunkName: "webfontloader" */
    "../webfontloader.b777d690.js"
  ).then((n2) => n2.w), true ? [] : void 0);
  webFontLoader.load({
    google: {
      families: ["Roboto:100,300,400,500,700,900&display=swap"]
    }
  });
}
const materialdesignicons = "";
const main = "";
const DisplaySymbol = Symbol.for("vuetify:display");
const defaultDisplayOptions = {
  mobileBreakpoint: "lg",
  thresholds: {
    xs: 0,
    sm: 600,
    md: 960,
    lg: 1280,
    xl: 1920,
    xxl: 2560
  }
};
const parseDisplayOptions = function() {
  let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : defaultDisplayOptions;
  return mergeDeep(defaultDisplayOptions, options);
};
function getClientWidth(isHydrate) {
  return IN_BROWSER && !isHydrate ? window.innerWidth : 0;
}
function getClientHeight(isHydrate) {
  return IN_BROWSER && !isHydrate ? window.innerHeight : 0;
}
function getPlatform() {
  const userAgent2 = IN_BROWSER ? window.navigator.userAgent : "ssr";
  function match2(regexp) {
    return Boolean(userAgent2.match(regexp));
  }
  const android = match2(/android/i);
  const ios = match2(/iphone|ipad|ipod/i);
  const cordova = match2(/cordova/i);
  const electron = match2(/electron/i);
  const chrome = match2(/chrome/i);
  const edge = match2(/edge/i);
  const firefox = match2(/firefox/i);
  const opera = match2(/opera/i);
  const win = match2(/win/i);
  const mac = match2(/mac/i);
  const linux = match2(/linux/i);
  const ssr = match2(/ssr/i);
  return {
    android,
    ios,
    cordova,
    electron,
    chrome,
    edge,
    firefox,
    opera,
    win,
    mac,
    linux,
    touch: SUPPORTS_TOUCH,
    ssr
  };
}
function createDisplay(options, ssr) {
  const {
    thresholds,
    mobileBreakpoint
  } = parseDisplayOptions(options);
  const height = ref(getClientHeight(ssr));
  const platform2 = getPlatform();
  const state = reactive({});
  const width = ref(getClientWidth(ssr));
  function update() {
    height.value = getClientHeight();
    width.value = getClientWidth();
  }
  watchEffect(() => {
    const xs = width.value < thresholds.sm;
    const sm = width.value < thresholds.md && !xs;
    const md = width.value < thresholds.lg && !(sm || xs);
    const lg = width.value < thresholds.xl && !(md || sm || xs);
    const xl2 = width.value < thresholds.xxl && !(lg || md || sm || xs);
    const xxl = width.value >= thresholds.xxl;
    const name2 = xs ? "xs" : sm ? "sm" : md ? "md" : lg ? "lg" : xl2 ? "xl" : "xxl";
    const breakpointValue = typeof mobileBreakpoint === "number" ? mobileBreakpoint : thresholds[mobileBreakpoint];
    const mobile = !platform2.ssr ? width.value < breakpointValue : platform2.android || platform2.ios || platform2.opera;
    state.xs = xs;
    state.sm = sm;
    state.md = md;
    state.lg = lg;
    state.xl = xl2;
    state.xxl = xxl;
    state.smAndUp = !xs;
    state.mdAndUp = !(xs || sm);
    state.lgAndUp = !(xs || sm || md);
    state.xlAndUp = !(xs || sm || md || lg);
    state.smAndDown = !(md || lg || xl2 || xxl);
    state.mdAndDown = !(lg || xl2 || xxl);
    state.lgAndDown = !(xl2 || xxl);
    state.xlAndDown = !xxl;
    state.name = name2;
    state.height = height.value;
    state.width = width.value;
    state.mobile = mobile;
    state.mobileBreakpoint = mobileBreakpoint;
    state.platform = platform2;
    state.thresholds = thresholds;
  });
  if (IN_BROWSER) {
    window.addEventListener("resize", update, {
      passive: true
    });
  }
  return {
    ...toRefs(state),
    update,
    ssr: !!ssr
  };
}
function useDisplay() {
  const display = inject$1(DisplaySymbol);
  if (!display)
    throw new Error("Could not find Vuetify display injection");
  return display;
}
const aliases = {
  collapse: "mdi-chevron-up",
  complete: "mdi-check",
  cancel: "mdi-close-circle",
  close: "mdi-close",
  delete: "mdi-close-circle",
  clear: "mdi-close-circle",
  success: "mdi-check-circle",
  info: "mdi-information",
  warning: "mdi-alert-circle",
  error: "mdi-close-circle",
  prev: "mdi-chevron-left",
  next: "mdi-chevron-right",
  checkboxOn: "mdi-checkbox-marked",
  checkboxOff: "mdi-checkbox-blank-outline",
  checkboxIndeterminate: "mdi-minus-box",
  delimiter: "mdi-circle",
  sortAsc: "mdi-arrow-up",
  sortDesc: "mdi-arrow-down",
  expand: "mdi-chevron-down",
  menu: "mdi-menu",
  subgroup: "mdi-menu-down",
  dropdown: "mdi-menu-down",
  radioOn: "mdi-radiobox-marked",
  radioOff: "mdi-radiobox-blank",
  edit: "mdi-pencil",
  ratingEmpty: "mdi-star-outline",
  ratingFull: "mdi-star",
  ratingHalf: "mdi-star-half-full",
  loading: "mdi-cached",
  first: "mdi-page-first",
  last: "mdi-page-last",
  unfold: "mdi-unfold-more-horizontal",
  file: "mdi-paperclip",
  plus: "mdi-plus",
  minus: "mdi-minus"
};
const mdi = {
  component: (props) => h(VClassIcon, {
    ...props,
    class: "mdi"
  })
};
const IconValue = [String, Function, Object];
const IconSymbol = Symbol.for("vuetify:icons");
const makeIconProps = propsFactory({
  icon: {
    type: IconValue
  },
  tag: {
    type: String,
    required: true
  }
}, "icon");
const VComponentIcon = defineComponent({
  name: "VComponentIcon",
  props: makeIconProps(),
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    return () => {
      var _slots$default;
      return createVNode(props.tag, null, {
        default: () => [props.icon ? createVNode(props.icon, null, null) : (_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots)]
      });
    };
  }
});
const VSvgIcon = defineComponent({
  name: "VSvgIcon",
  inheritAttrs: false,
  props: makeIconProps(),
  setup(props, _ref2) {
    let {
      attrs
    } = _ref2;
    return () => {
      return createVNode(props.tag, mergeProps(attrs, {
        "style": null
      }), {
        default: () => [createVNode("svg", {
          "class": "v-icon__svg",
          "xmlns": "http://www.w3.org/2000/svg",
          "viewBox": "0 0 24 24",
          "role": "img",
          "aria-hidden": "true"
        }, [createVNode("path", {
          "d": props.icon
        }, null)])]
      });
    };
  }
});
defineComponent({
  name: "VLigatureIcon",
  props: makeIconProps(),
  setup(props) {
    return () => {
      return createVNode(props.tag, null, {
        default: () => [props.icon]
      });
    };
  }
});
const VClassIcon = defineComponent({
  name: "VClassIcon",
  props: makeIconProps(),
  setup(props) {
    return () => {
      return createVNode(props.tag, {
        "class": props.icon
      }, null);
    };
  }
});
const defaultSets = {
  svg: {
    component: VSvgIcon
  },
  class: {
    component: VClassIcon
  }
};
function createIcons(options) {
  return mergeDeep({
    defaultSet: "mdi",
    sets: {
      ...defaultSets,
      mdi
    },
    aliases
  }, options);
}
const useIcon = (props) => {
  const icons = inject$1(IconSymbol);
  if (!icons)
    throw new Error("Missing Vuetify Icons provide!");
  const iconData = computed(() => {
    const iconAlias = isRef(props) ? props.value : props.icon;
    if (!iconAlias)
      return {
        component: VComponentIcon
      };
    let icon = iconAlias;
    if (typeof icon === "string") {
      icon = icon.trim();
      if (icon.startsWith("$")) {
        var _icons$aliases;
        icon = (_icons$aliases = icons.aliases) == null ? void 0 : _icons$aliases[icon.slice(1)];
      }
    }
    if (!icon)
      throw new Error(`Could not find aliased icon "${iconAlias}"`);
    if (typeof icon !== "string") {
      return {
        component: VComponentIcon,
        icon
      };
    }
    const iconSetName = Object.keys(icons.sets).find((setName) => typeof icon === "string" && icon.startsWith(`${setName}:`));
    const iconName = iconSetName ? icon.slice(iconSetName.length + 1) : icon;
    const iconSet = icons.sets[iconSetName != null ? iconSetName : icons.defaultSet];
    return {
      component: iconSet.component,
      icon: iconName
    };
  });
  return {
    iconData
  };
};
function createVuetify() {
  let vuetify2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  const {
    blueprint,
    ...rest
  } = vuetify2;
  const options = mergeDeep(blueprint, rest);
  const {
    aliases: aliases2 = {},
    components = {},
    directives = {}
  } = options;
  const defaults2 = createDefaults(options.defaults);
  const display = createDisplay(options.display, options.ssr);
  const theme = createTheme(options.theme);
  const icons = createIcons(options.icons);
  const locale2 = createLocale(options.locale);
  const install2 = (app2) => {
    for (const key in directives) {
      app2.directive(key, directives[key]);
    }
    for (const key in components) {
      app2.component(key, components[key]);
    }
    for (const key in aliases2) {
      app2.component(key, defineComponent({
        ...aliases2[key],
        name: key,
        aliasName: aliases2[key].name
      }));
    }
    theme.install(app2);
    app2.provide(DefaultsSymbol, defaults2);
    app2.provide(DisplaySymbol, display);
    app2.provide(ThemeSymbol, theme);
    app2.provide(IconSymbol, icons);
    app2.provide(LocaleSymbol, locale2);
    if (IN_BROWSER && options.ssr) {
      if (app2.$nuxt) {
        app2.$nuxt.hook("app:suspense:resolve", () => {
          display.update();
        });
      } else {
        const {
          mount
        } = app2;
        app2.mount = function() {
          const vm = mount(...arguments);
          nextTick(() => display.update());
          app2.mount = mount;
          return vm;
        };
      }
    }
    getUid.reset();
    {
      app2.mixin({
        computed: {
          $vuetify() {
            return reactive({
              defaults: inject.call(this, DefaultsSymbol),
              display: inject.call(this, DisplaySymbol),
              theme: inject.call(this, ThemeSymbol),
              icons: inject.call(this, IconSymbol),
              locale: inject.call(this, LocaleSymbol)
            });
          }
        }
      });
    }
  };
  return {
    install: install2,
    defaults: defaults2,
    display,
    theme,
    icons,
    locale: locale2
  };
}
const version = "3.1.4";
createVuetify.version = version;
function inject(key) {
  var _a2;
  var _vm$parent, _vm$vnode$appContext;
  const vm = this.$;
  const provides = (_a2 = (_vm$parent = vm.parent) == null ? void 0 : _vm$parent.provides) != null ? _a2 : (_vm$vnode$appContext = vm.vnode.appContext) == null ? void 0 : _vm$vnode$appContext.provides;
  if (provides && key in provides) {
    return provides[key];
  }
}
const vuetify = createVuetify({
  theme: {
    themes: {
      light: {
        colors: {
          primary: "#1867C0",
          secondary: "#5CBBF6"
        }
      }
    }
  }
});
function registerPlugins(app2) {
  loadFonts();
  app2.use(vuetify);
}
const MONTH_INDEX_MAP = {
  Jan: 0,
  Feb: 1,
  Mar: 2,
  Apr: 3,
  May: 4,
  Jun: 5,
  Jul: 6,
  Aug: 7,
  Sep: 8,
  Oct: 9,
  Nov: 10,
  Dec: 11
};
const getPeriodStartDate = (period, format$1 = "yyyy-MM-dd") => {
  const [month, yearShortForm] = period.split("-")[0].trim().split(" ");
  const numericYear = _.toNumber(`20${yearShortForm}`);
  const monthIndex = MONTH_INDEX_MAP[month];
  return format(new Date(numericYear, monthIndex), format$1);
};
const getPeriodEndDate = (period, format$1 = "yyyy-MM-dd") => {
  const [month, yearShortForm] = period.split("-")[1].trim().split(" ");
  const numericYear = _.toNumber(`20${yearShortForm}`);
  const monthIndex = MONTH_INDEX_MAP[month];
  return format(new Date(numericYear, monthIndex), format$1);
};
const getQuarterLabel = (period) => {
  const periodStartDate = getPeriodStartDate(period);
  const parsedDate = parse(periodStartDate, "yyyy-MM-dd", new Date());
  const year = getYear(parsedDate);
  const quarterNumber = getQuarter(parsedDate);
  return `${year}-Q${quarterNumber}`;
};
const FORECAST_PERIOD_TYPES = {
  R3M_VIEW: "r3m",
  QUARTERLY_VIEW: "fixed"
};
const ACTION_STATUS_LABELS = {
  PENDING_ACTION: "Pending Action",
  REVIEWED_AND_ACTION_TAKEN: "Reviewed and Action has been taken",
  REVIEWED_AND_ACTION_NOT_TAKEN: "Reviewed and Action has not been taken"
};
const { R3M_VIEW: R3M_VIEW$1 } = FORECAST_PERIOD_TYPES;
const formatPeriodLabel = (period) => {
  const periodStartDate = format(
    parse(period.split("-")[0].trim(), "MMM yy", new Date()),
    "MMM \u2018yy"
  );
  const periodEndDate = format(
    parse(period.split("-")[1].trim(), "MMM yy", new Date()),
    "MMM \u2018yy"
  );
  return `${periodStartDate}-${periodEndDate}`;
};
const getPeriodDataLabel = (period, forecastPeriodType) => {
  const formattedPeriod = formatPeriodLabel(period);
  if (forecastPeriodType === R3M_VIEW$1)
    return formattedPeriod;
  const quarterLabel = getQuarterLabel(period);
  return `${quarterLabel}, ${formattedPeriod}`;
};
const getConcisePeriodLabel = (period, forecastPeriodType) => {
  const formattedPeriod = formatPeriodLabel(period);
  if (forecastPeriodType === R3M_VIEW$1)
    return formattedPeriod;
  return getQuarterLabel(period);
};
const EyeIcon = "/assets/eye-icon.8b8006c4.svg";
const EyeOffIcon = "/assets/eye-off-icon.a6dda03f.svg";
function commonjsRequire(path) {
  throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var object_hash = { exports: {} };
(function(module2, exports) {
  !function(e3) {
    module2.exports = e3();
  }(function() {
    return function r2(o2, i2, u2) {
      function s3(n2, e4) {
        if (!i2[n2]) {
          if (!o2[n2]) {
            var t3 = "function" == typeof commonjsRequire && commonjsRequire;
            if (!e4 && t3)
              return t3(n2, true);
            if (a3)
              return a3(n2, true);
            throw new Error("Cannot find module '" + n2 + "'");
          }
          e4 = i2[n2] = { exports: {} };
          o2[n2][0].call(e4.exports, function(e5) {
            var t4 = o2[n2][1][e5];
            return s3(t4 || e5);
          }, e4, e4.exports, r2, o2, i2, u2);
        }
        return i2[n2].exports;
      }
      for (var a3 = "function" == typeof commonjsRequire && commonjsRequire, e3 = 0; e3 < u2.length; e3++)
        s3(u2[e3]);
      return s3;
    }({ 1: [function(w2, b3, m3) {
      !function(e3, n2, s3, c2, d3, h4, p2, g, y3) {
        var r2 = w2("crypto");
        function t3(e4, t4) {
          t4 = u2(e4, t4);
          var n3;
          return void 0 === (n3 = "passthrough" !== t4.algorithm ? r2.createHash(t4.algorithm) : new l()).write && (n3.write = n3.update, n3.end = n3.update), f(t4, n3).dispatch(e4), n3.update || n3.end(""), n3.digest ? n3.digest("buffer" === t4.encoding ? void 0 : t4.encoding) : (e4 = n3.read(), "buffer" !== t4.encoding ? e4.toString(t4.encoding) : e4);
        }
        (m3 = b3.exports = t3).sha1 = function(e4) {
          return t3(e4);
        }, m3.keys = function(e4) {
          return t3(e4, { excludeValues: true, algorithm: "sha1", encoding: "hex" });
        }, m3.MD5 = function(e4) {
          return t3(e4, { algorithm: "md5", encoding: "hex" });
        }, m3.keysMD5 = function(e4) {
          return t3(e4, { algorithm: "md5", encoding: "hex", excludeValues: true });
        };
        var o2 = r2.getHashes ? r2.getHashes().slice() : ["sha1", "md5"], i2 = (o2.push("passthrough"), ["buffer", "hex", "binary", "base64"]);
        function u2(e4, t4) {
          var n3 = {};
          if (n3.algorithm = (t4 = t4 || {}).algorithm || "sha1", n3.encoding = t4.encoding || "hex", n3.excludeValues = !!t4.excludeValues, n3.algorithm = n3.algorithm.toLowerCase(), n3.encoding = n3.encoding.toLowerCase(), n3.ignoreUnknown = true === t4.ignoreUnknown, n3.respectType = false !== t4.respectType, n3.respectFunctionNames = false !== t4.respectFunctionNames, n3.respectFunctionProperties = false !== t4.respectFunctionProperties, n3.unorderedArrays = true === t4.unorderedArrays, n3.unorderedSets = false !== t4.unorderedSets, n3.unorderedObjects = false !== t4.unorderedObjects, n3.replacer = t4.replacer || void 0, n3.excludeKeys = t4.excludeKeys || void 0, void 0 === e4)
            throw new Error("Object argument required.");
          for (var r3 = 0; r3 < o2.length; ++r3)
            o2[r3].toLowerCase() === n3.algorithm.toLowerCase() && (n3.algorithm = o2[r3]);
          if (-1 === o2.indexOf(n3.algorithm))
            throw new Error('Algorithm "' + n3.algorithm + '"  not supported. supported values: ' + o2.join(", "));
          if (-1 === i2.indexOf(n3.encoding) && "passthrough" !== n3.algorithm)
            throw new Error('Encoding "' + n3.encoding + '"  not supported. supported values: ' + i2.join(", "));
          return n3;
        }
        function a3(e4) {
          if ("function" == typeof e4)
            return null != /^function\s+\w*\s*\(\s*\)\s*{\s+\[native code\]\s+}$/i.exec(Function.prototype.toString.call(e4));
        }
        function f(o3, t4, i3) {
          i3 = i3 || [];
          function u3(e4) {
            return t4.update ? t4.update(e4, "utf8") : t4.write(e4, "utf8");
          }
          return { dispatch: function(e4) {
            return this["_" + (null === (e4 = o3.replacer ? o3.replacer(e4) : e4) ? "null" : typeof e4)](e4);
          }, _object: function(t5) {
            var n3, e4 = Object.prototype.toString.call(t5), r3 = /\[object (.*)\]/i.exec(e4);
            r3 = (r3 = r3 ? r3[1] : "unknown:[" + e4 + "]").toLowerCase();
            if (0 <= (e4 = i3.indexOf(t5)))
              return this.dispatch("[CIRCULAR:" + e4 + "]");
            if (i3.push(t5), void 0 !== s3 && s3.isBuffer && s3.isBuffer(t5))
              return u3("buffer:"), u3(t5);
            if ("object" === r3 || "function" === r3 || "asyncfunction" === r3)
              return e4 = Object.keys(t5), o3.unorderedObjects && (e4 = e4.sort()), false === o3.respectType || a3(t5) || e4.splice(0, 0, "prototype", "__proto__", "constructor"), o3.excludeKeys && (e4 = e4.filter(function(e5) {
                return !o3.excludeKeys(e5);
              })), u3("object:" + e4.length + ":"), n3 = this, e4.forEach(function(e5) {
                n3.dispatch(e5), u3(":"), o3.excludeValues || n3.dispatch(t5[e5]), u3(",");
              });
            if (!this["_" + r3]) {
              if (o3.ignoreUnknown)
                return u3("[" + r3 + "]");
              throw new Error('Unknown object type "' + r3 + '"');
            }
            this["_" + r3](t5);
          }, _array: function(e4, t5) {
            t5 = void 0 !== t5 ? t5 : false !== o3.unorderedArrays;
            var n3 = this;
            if (u3("array:" + e4.length + ":"), !t5 || e4.length <= 1)
              return e4.forEach(function(e5) {
                return n3.dispatch(e5);
              });
            var r3 = [], t5 = e4.map(function(e5) {
              var t6 = new l(), n4 = i3.slice();
              return f(o3, t6, n4).dispatch(e5), r3 = r3.concat(n4.slice(i3.length)), t6.read().toString();
            });
            return i3 = i3.concat(r3), t5.sort(), this._array(t5, false);
          }, _date: function(e4) {
            return u3("date:" + e4.toJSON());
          }, _symbol: function(e4) {
            return u3("symbol:" + e4.toString());
          }, _error: function(e4) {
            return u3("error:" + e4.toString());
          }, _boolean: function(e4) {
            return u3("bool:" + e4.toString());
          }, _string: function(e4) {
            u3("string:" + e4.length + ":"), u3(e4.toString());
          }, _function: function(e4) {
            u3("fn:"), a3(e4) ? this.dispatch("[native]") : this.dispatch(e4.toString()), false !== o3.respectFunctionNames && this.dispatch("function-name:" + String(e4.name)), o3.respectFunctionProperties && this._object(e4);
          }, _number: function(e4) {
            return u3("number:" + e4.toString());
          }, _xml: function(e4) {
            return u3("xml:" + e4.toString());
          }, _null: function() {
            return u3("Null");
          }, _undefined: function() {
            return u3("Undefined");
          }, _regexp: function(e4) {
            return u3("regex:" + e4.toString());
          }, _uint8array: function(e4) {
            return u3("uint8array:"), this.dispatch(Array.prototype.slice.call(e4));
          }, _uint8clampedarray: function(e4) {
            return u3("uint8clampedarray:"), this.dispatch(Array.prototype.slice.call(e4));
          }, _int8array: function(e4) {
            return u3("int8array:"), this.dispatch(Array.prototype.slice.call(e4));
          }, _uint16array: function(e4) {
            return u3("uint16array:"), this.dispatch(Array.prototype.slice.call(e4));
          }, _int16array: function(e4) {
            return u3("int16array:"), this.dispatch(Array.prototype.slice.call(e4));
          }, _uint32array: function(e4) {
            return u3("uint32array:"), this.dispatch(Array.prototype.slice.call(e4));
          }, _int32array: function(e4) {
            return u3("int32array:"), this.dispatch(Array.prototype.slice.call(e4));
          }, _float32array: function(e4) {
            return u3("float32array:"), this.dispatch(Array.prototype.slice.call(e4));
          }, _float64array: function(e4) {
            return u3("float64array:"), this.dispatch(Array.prototype.slice.call(e4));
          }, _arraybuffer: function(e4) {
            return u3("arraybuffer:"), this.dispatch(new Uint8Array(e4));
          }, _url: function(e4) {
            return u3("url:" + e4.toString());
          }, _map: function(e4) {
            u3("map:");
            e4 = Array.from(e4);
            return this._array(e4, false !== o3.unorderedSets);
          }, _set: function(e4) {
            u3("set:");
            e4 = Array.from(e4);
            return this._array(e4, false !== o3.unorderedSets);
          }, _file: function(e4) {
            return u3("file:"), this.dispatch([e4.name, e4.size, e4.type, e4.lastModfied]);
          }, _blob: function() {
            if (o3.ignoreUnknown)
              return u3("[blob]");
            throw Error('Hashing Blob objects is currently not supported\n(see https://github.com/puleos/object-hash/issues/26)\nUse "options.replacer" or "options.ignoreUnknown"\n');
          }, _domwindow: function() {
            return u3("domwindow");
          }, _bigint: function(e4) {
            return u3("bigint:" + e4.toString());
          }, _process: function() {
            return u3("process");
          }, _timer: function() {
            return u3("timer");
          }, _pipe: function() {
            return u3("pipe");
          }, _tcp: function() {
            return u3("tcp");
          }, _udp: function() {
            return u3("udp");
          }, _tty: function() {
            return u3("tty");
          }, _statwatcher: function() {
            return u3("statwatcher");
          }, _securecontext: function() {
            return u3("securecontext");
          }, _connection: function() {
            return u3("connection");
          }, _zlib: function() {
            return u3("zlib");
          }, _context: function() {
            return u3("context");
          }, _nodescript: function() {
            return u3("nodescript");
          }, _httpparser: function() {
            return u3("httpparser");
          }, _dataview: function() {
            return u3("dataview");
          }, _signal: function() {
            return u3("signal");
          }, _fsevent: function() {
            return u3("fsevent");
          }, _tlswrap: function() {
            return u3("tlswrap");
          } };
        }
        function l() {
          return { buf: "", write: function(e4) {
            this.buf += e4;
          }, end: function(e4) {
            this.buf += e4;
          }, read: function() {
            return this.buf;
          } };
        }
        m3.writeToStream = function(e4, t4, n3) {
          return void 0 === n3 && (n3 = t4, t4 = {}), f(t4 = u2(e4, t4), n3).dispatch(e4);
        };
      }.call(this, w2("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, w2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/fake_9a5aa49d.js", "/");
    }, { buffer: 3, crypto: 5, lYpoI2: 11 }], 2: [function(e3, t3, f) {
      !function(e4, t4, n2, r2, o2, i2, u2, s3, a3) {
        !function(e5) {
          var a4 = "undefined" != typeof Uint8Array ? Uint8Array : Array, t5 = "+".charCodeAt(0), n3 = "/".charCodeAt(0), r3 = "0".charCodeAt(0), o3 = "a".charCodeAt(0), i3 = "A".charCodeAt(0), u3 = "-".charCodeAt(0), s4 = "_".charCodeAt(0);
          function f2(e6) {
            e6 = e6.charCodeAt(0);
            return e6 === t5 || e6 === u3 ? 62 : e6 === n3 || e6 === s4 ? 63 : e6 < r3 ? -1 : e6 < r3 + 10 ? e6 - r3 + 26 + 26 : e6 < i3 + 26 ? e6 - i3 : e6 < o3 + 26 ? e6 - o3 + 26 : void 0;
          }
          e5.toByteArray = function(e6) {
            var t6, n4;
            if (0 < e6.length % 4)
              throw new Error("Invalid string. Length must be a multiple of 4");
            var r4 = e6.length, r4 = "=" === e6.charAt(r4 - 2) ? 2 : "=" === e6.charAt(r4 - 1) ? 1 : 0, o4 = new a4(3 * e6.length / 4 - r4), i4 = 0 < r4 ? e6.length - 4 : e6.length, u4 = 0;
            function s5(e7) {
              o4[u4++] = e7;
            }
            for (t6 = 0; t6 < i4; t6 += 4, 0)
              s5((16711680 & (n4 = f2(e6.charAt(t6)) << 18 | f2(e6.charAt(t6 + 1)) << 12 | f2(e6.charAt(t6 + 2)) << 6 | f2(e6.charAt(t6 + 3)))) >> 16), s5((65280 & n4) >> 8), s5(255 & n4);
            return 2 == r4 ? s5(255 & (n4 = f2(e6.charAt(t6)) << 2 | f2(e6.charAt(t6 + 1)) >> 4)) : 1 == r4 && (s5((n4 = f2(e6.charAt(t6)) << 10 | f2(e6.charAt(t6 + 1)) << 4 | f2(e6.charAt(t6 + 2)) >> 2) >> 8 & 255), s5(255 & n4)), o4;
          }, e5.fromByteArray = function(e6) {
            var t6, n4, r4, o4, i4 = e6.length % 3, u4 = "";
            function s5(e7) {
              return "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charAt(e7);
            }
            for (t6 = 0, r4 = e6.length - i4; t6 < r4; t6 += 3)
              n4 = (e6[t6] << 16) + (e6[t6 + 1] << 8) + e6[t6 + 2], u4 += s5((o4 = n4) >> 18 & 63) + s5(o4 >> 12 & 63) + s5(o4 >> 6 & 63) + s5(63 & o4);
            switch (i4) {
              case 1:
                u4 = (u4 += s5((n4 = e6[e6.length - 1]) >> 2)) + s5(n4 << 4 & 63) + "==";
                break;
              case 2:
                u4 = (u4 = (u4 += s5((n4 = (e6[e6.length - 2] << 8) + e6[e6.length - 1]) >> 10)) + s5(n4 >> 4 & 63)) + s5(n4 << 2 & 63) + "=";
            }
            return u4;
          };
        }(void 0 === f ? this.base64js = {} : f);
      }.call(this, e3("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e3("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/base64-js/lib/b64.js", "/node_modules/gulp-browserify/node_modules/base64-js/lib");
    }, { buffer: 3, lYpoI2: 11 }], 3: [function(O2, e3, H3) {
      !function(e4, n2, f, r2, h4, p2, g, y3, w2) {
        var a3 = O2("base64-js"), i2 = O2("ieee754");
        function f(e5, t4, n3) {
          if (!(this instanceof f))
            return new f(e5, t4, n3);
          var r3, o3, i3, u3, s4 = typeof e5;
          if ("base64" === t4 && "string" == s4)
            for (e5 = (u3 = e5).trim ? u3.trim() : u3.replace(/^\s+|\s+$/g, ""); e5.length % 4 != 0; )
              e5 += "=";
          if ("number" == s4)
            r3 = j(e5);
          else if ("string" == s4)
            r3 = f.byteLength(e5, t4);
          else {
            if ("object" != s4)
              throw new Error("First argument needs to be a number, array or string.");
            r3 = j(e5.length);
          }
          if (f._useTypedArrays ? o3 = f._augment(new Uint8Array(r3)) : ((o3 = this).length = r3, o3._isBuffer = true), f._useTypedArrays && "number" == typeof e5.byteLength)
            o3._set(e5);
          else if (C(u3 = e5) || f.isBuffer(u3) || u3 && "object" == typeof u3 && "number" == typeof u3.length)
            for (i3 = 0; i3 < r3; i3++)
              f.isBuffer(e5) ? o3[i3] = e5.readUInt8(i3) : o3[i3] = e5[i3];
          else if ("string" == s4)
            o3.write(e5, 0, t4);
          else if ("number" == s4 && !f._useTypedArrays && !n3)
            for (i3 = 0; i3 < r3; i3++)
              o3[i3] = 0;
          return o3;
        }
        function b3(e5, t4, n3, r3) {
          return f._charsWritten = c2(function(e6) {
            for (var t5 = [], n4 = 0; n4 < e6.length; n4++)
              t5.push(255 & e6.charCodeAt(n4));
            return t5;
          }(t4), e5, n3, r3);
        }
        function m3(e5, t4, n3, r3) {
          return f._charsWritten = c2(function(e6) {
            for (var t5, n4, r4 = [], o3 = 0; o3 < e6.length; o3++)
              n4 = e6.charCodeAt(o3), t5 = n4 >> 8, n4 = n4 % 256, r4.push(n4), r4.push(t5);
            return r4;
          }(t4), e5, n3, r3);
        }
        function v(e5, t4, n3) {
          var r3 = "";
          n3 = Math.min(e5.length, n3);
          for (var o3 = t4; o3 < n3; o3++)
            r3 += String.fromCharCode(e5[o3]);
          return r3;
        }
        function o2(e5, t4, n3, r3) {
          r3 || (d3("boolean" == typeof n3, "missing or invalid endian"), d3(null != t4, "missing offset"), d3(t4 + 1 < e5.length, "Trying to read beyond buffer length"));
          var o3, r3 = e5.length;
          if (!(r3 <= t4))
            return n3 ? (o3 = e5[t4], t4 + 1 < r3 && (o3 |= e5[t4 + 1] << 8)) : (o3 = e5[t4] << 8, t4 + 1 < r3 && (o3 |= e5[t4 + 1])), o3;
        }
        function u2(e5, t4, n3, r3) {
          r3 || (d3("boolean" == typeof n3, "missing or invalid endian"), d3(null != t4, "missing offset"), d3(t4 + 3 < e5.length, "Trying to read beyond buffer length"));
          var o3, r3 = e5.length;
          if (!(r3 <= t4))
            return n3 ? (t4 + 2 < r3 && (o3 = e5[t4 + 2] << 16), t4 + 1 < r3 && (o3 |= e5[t4 + 1] << 8), o3 |= e5[t4], t4 + 3 < r3 && (o3 += e5[t4 + 3] << 24 >>> 0)) : (t4 + 1 < r3 && (o3 = e5[t4 + 1] << 16), t4 + 2 < r3 && (o3 |= e5[t4 + 2] << 8), t4 + 3 < r3 && (o3 |= e5[t4 + 3]), o3 += e5[t4] << 24 >>> 0), o3;
        }
        function _2(e5, t4, n3, r3) {
          if (r3 || (d3("boolean" == typeof n3, "missing or invalid endian"), d3(null != t4, "missing offset"), d3(t4 + 1 < e5.length, "Trying to read beyond buffer length")), !(e5.length <= t4))
            return r3 = o2(e5, t4, n3, true), 32768 & r3 ? -1 * (65535 - r3 + 1) : r3;
        }
        function E2(e5, t4, n3, r3) {
          if (r3 || (d3("boolean" == typeof n3, "missing or invalid endian"), d3(null != t4, "missing offset"), d3(t4 + 3 < e5.length, "Trying to read beyond buffer length")), !(e5.length <= t4))
            return r3 = u2(e5, t4, n3, true), 2147483648 & r3 ? -1 * (4294967295 - r3 + 1) : r3;
        }
        function I2(e5, t4, n3, r3) {
          return r3 || (d3("boolean" == typeof n3, "missing or invalid endian"), d3(t4 + 3 < e5.length, "Trying to read beyond buffer length")), i2.read(e5, t4, n3, 23, 4);
        }
        function A(e5, t4, n3, r3) {
          return r3 || (d3("boolean" == typeof n3, "missing or invalid endian"), d3(t4 + 7 < e5.length, "Trying to read beyond buffer length")), i2.read(e5, t4, n3, 52, 8);
        }
        function s3(e5, t4, n3, r3, o3) {
          o3 || (d3(null != t4, "missing value"), d3("boolean" == typeof r3, "missing or invalid endian"), d3(null != n3, "missing offset"), d3(n3 + 1 < e5.length, "trying to write beyond buffer length"), Y2(t4, 65535));
          o3 = e5.length;
          if (!(o3 <= n3))
            for (var i3 = 0, u3 = Math.min(o3 - n3, 2); i3 < u3; i3++)
              e5[n3 + i3] = (t4 & 255 << 8 * (r3 ? i3 : 1 - i3)) >>> 8 * (r3 ? i3 : 1 - i3);
        }
        function l(e5, t4, n3, r3, o3) {
          o3 || (d3(null != t4, "missing value"), d3("boolean" == typeof r3, "missing or invalid endian"), d3(null != n3, "missing offset"), d3(n3 + 3 < e5.length, "trying to write beyond buffer length"), Y2(t4, 4294967295));
          o3 = e5.length;
          if (!(o3 <= n3))
            for (var i3 = 0, u3 = Math.min(o3 - n3, 4); i3 < u3; i3++)
              e5[n3 + i3] = t4 >>> 8 * (r3 ? i3 : 3 - i3) & 255;
        }
        function B2(e5, t4, n3, r3, o3) {
          o3 || (d3(null != t4, "missing value"), d3("boolean" == typeof r3, "missing or invalid endian"), d3(null != n3, "missing offset"), d3(n3 + 1 < e5.length, "Trying to write beyond buffer length"), F(t4, 32767, -32768)), e5.length <= n3 || s3(e5, 0 <= t4 ? t4 : 65535 + t4 + 1, n3, r3, o3);
        }
        function L2(e5, t4, n3, r3, o3) {
          o3 || (d3(null != t4, "missing value"), d3("boolean" == typeof r3, "missing or invalid endian"), d3(null != n3, "missing offset"), d3(n3 + 3 < e5.length, "Trying to write beyond buffer length"), F(t4, 2147483647, -2147483648)), e5.length <= n3 || l(e5, 0 <= t4 ? t4 : 4294967295 + t4 + 1, n3, r3, o3);
        }
        function U(e5, t4, n3, r3, o3) {
          o3 || (d3(null != t4, "missing value"), d3("boolean" == typeof r3, "missing or invalid endian"), d3(null != n3, "missing offset"), d3(n3 + 3 < e5.length, "Trying to write beyond buffer length"), D2(t4, 34028234663852886e22, -34028234663852886e22)), e5.length <= n3 || i2.write(e5, t4, n3, r3, 23, 4);
        }
        function x2(e5, t4, n3, r3, o3) {
          o3 || (d3(null != t4, "missing value"), d3("boolean" == typeof r3, "missing or invalid endian"), d3(null != n3, "missing offset"), d3(n3 + 7 < e5.length, "Trying to write beyond buffer length"), D2(t4, 17976931348623157e292, -17976931348623157e292)), e5.length <= n3 || i2.write(e5, t4, n3, r3, 52, 8);
        }
        H3.Buffer = f, H3.SlowBuffer = f, H3.INSPECT_MAX_BYTES = 50, f.poolSize = 8192, f._useTypedArrays = function() {
          try {
            var e5 = new ArrayBuffer(0), t4 = new Uint8Array(e5);
            return t4.foo = function() {
              return 42;
            }, 42 === t4.foo() && "function" == typeof t4.subarray;
          } catch (e6) {
            return false;
          }
        }(), f.isEncoding = function(e5) {
          switch (String(e5).toLowerCase()) {
            case "hex":
            case "utf8":
            case "utf-8":
            case "ascii":
            case "binary":
            case "base64":
            case "raw":
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              return true;
            default:
              return false;
          }
        }, f.isBuffer = function(e5) {
          return !(null == e5 || !e5._isBuffer);
        }, f.byteLength = function(e5, t4) {
          var n3;
          switch (e5 += "", t4 || "utf8") {
            case "hex":
              n3 = e5.length / 2;
              break;
            case "utf8":
            case "utf-8":
              n3 = T2(e5).length;
              break;
            case "ascii":
            case "binary":
            case "raw":
              n3 = e5.length;
              break;
            case "base64":
              n3 = M3(e5).length;
              break;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              n3 = 2 * e5.length;
              break;
            default:
              throw new Error("Unknown encoding");
          }
          return n3;
        }, f.concat = function(e5, t4) {
          if (d3(C(e5), "Usage: Buffer.concat(list, [totalLength])\nlist should be an Array."), 0 === e5.length)
            return new f(0);
          if (1 === e5.length)
            return e5[0];
          if ("number" != typeof t4)
            for (o3 = t4 = 0; o3 < e5.length; o3++)
              t4 += e5[o3].length;
          for (var n3 = new f(t4), r3 = 0, o3 = 0; o3 < e5.length; o3++) {
            var i3 = e5[o3];
            i3.copy(n3, r3), r3 += i3.length;
          }
          return n3;
        }, f.prototype.write = function(e5, t4, n3, r3) {
          isFinite(t4) ? isFinite(n3) || (r3 = n3, n3 = void 0) : (a4 = r3, r3 = t4, t4 = n3, n3 = a4), t4 = Number(t4) || 0;
          var o3, i3, u3, s4, a4 = this.length - t4;
          switch ((!n3 || a4 < (n3 = Number(n3))) && (n3 = a4), r3 = String(r3 || "utf8").toLowerCase()) {
            case "hex":
              o3 = function(e6, t5, n4, r4) {
                n4 = Number(n4) || 0;
                var o4 = e6.length - n4;
                (!r4 || o4 < (r4 = Number(r4))) && (r4 = o4), d3((o4 = t5.length) % 2 == 0, "Invalid hex string"), o4 / 2 < r4 && (r4 = o4 / 2);
                for (var i4 = 0; i4 < r4; i4++) {
                  var u4 = parseInt(t5.substr(2 * i4, 2), 16);
                  d3(!isNaN(u4), "Invalid hex string"), e6[n4 + i4] = u4;
                }
                return f._charsWritten = 2 * i4, i4;
              }(this, e5, t4, n3);
              break;
            case "utf8":
            case "utf-8":
              i3 = this, u3 = t4, s4 = n3, o3 = f._charsWritten = c2(T2(e5), i3, u3, s4);
              break;
            case "ascii":
            case "binary":
              o3 = b3(this, e5, t4, n3);
              break;
            case "base64":
              i3 = this, u3 = t4, s4 = n3, o3 = f._charsWritten = c2(M3(e5), i3, u3, s4);
              break;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              o3 = m3(this, e5, t4, n3);
              break;
            default:
              throw new Error("Unknown encoding");
          }
          return o3;
        }, f.prototype.toString = function(e5, t4, n3) {
          var r3, o3, i3, u3, s4 = this;
          if (e5 = String(e5 || "utf8").toLowerCase(), t4 = Number(t4) || 0, (n3 = void 0 !== n3 ? Number(n3) : s4.length) === t4)
            return "";
          switch (e5) {
            case "hex":
              r3 = function(e6, t5, n4) {
                var r4 = e6.length;
                (!t5 || t5 < 0) && (t5 = 0);
                (!n4 || n4 < 0 || r4 < n4) && (n4 = r4);
                for (var o4 = "", i4 = t5; i4 < n4; i4++)
                  o4 += k2(e6[i4]);
                return o4;
              }(s4, t4, n3);
              break;
            case "utf8":
            case "utf-8":
              r3 = function(e6, t5, n4) {
                var r4 = "", o4 = "";
                n4 = Math.min(e6.length, n4);
                for (var i4 = t5; i4 < n4; i4++)
                  e6[i4] <= 127 ? (r4 += N(o4) + String.fromCharCode(e6[i4]), o4 = "") : o4 += "%" + e6[i4].toString(16);
                return r4 + N(o4);
              }(s4, t4, n3);
              break;
            case "ascii":
            case "binary":
              r3 = v(s4, t4, n3);
              break;
            case "base64":
              o3 = s4, u3 = n3, r3 = 0 === (i3 = t4) && u3 === o3.length ? a3.fromByteArray(o3) : a3.fromByteArray(o3.slice(i3, u3));
              break;
            case "ucs2":
            case "ucs-2":
            case "utf16le":
            case "utf-16le":
              r3 = function(e6, t5, n4) {
                for (var r4 = e6.slice(t5, n4), o4 = "", i4 = 0; i4 < r4.length; i4 += 2)
                  o4 += String.fromCharCode(r4[i4] + 256 * r4[i4 + 1]);
                return o4;
              }(s4, t4, n3);
              break;
            default:
              throw new Error("Unknown encoding");
          }
          return r3;
        }, f.prototype.toJSON = function() {
          return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
        }, f.prototype.copy = function(e5, t4, n3, r3) {
          if (t4 = t4 || 0, (r3 = r3 || 0 === r3 ? r3 : this.length) !== (n3 = n3 || 0) && 0 !== e5.length && 0 !== this.length) {
            d3(n3 <= r3, "sourceEnd < sourceStart"), d3(0 <= t4 && t4 < e5.length, "targetStart out of bounds"), d3(0 <= n3 && n3 < this.length, "sourceStart out of bounds"), d3(0 <= r3 && r3 <= this.length, "sourceEnd out of bounds"), r3 > this.length && (r3 = this.length);
            var o3 = (r3 = e5.length - t4 < r3 - n3 ? e5.length - t4 + n3 : r3) - n3;
            if (o3 < 100 || !f._useTypedArrays)
              for (var i3 = 0; i3 < o3; i3++)
                e5[i3 + t4] = this[i3 + n3];
            else
              e5._set(this.subarray(n3, n3 + o3), t4);
          }
        }, f.prototype.slice = function(e5, t4) {
          var n3 = this.length;
          if (e5 = S3(e5, n3, 0), t4 = S3(t4, n3, n3), f._useTypedArrays)
            return f._augment(this.subarray(e5, t4));
          for (var r3 = t4 - e5, o3 = new f(r3, void 0, true), i3 = 0; i3 < r3; i3++)
            o3[i3] = this[i3 + e5];
          return o3;
        }, f.prototype.get = function(e5) {
          return console.log(".get() is deprecated. Access using array indexes instead."), this.readUInt8(e5);
        }, f.prototype.set = function(e5, t4) {
          return console.log(".set() is deprecated. Access using array indexes instead."), this.writeUInt8(e5, t4);
        }, f.prototype.readUInt8 = function(e5, t4) {
          if (t4 || (d3(null != e5, "missing offset"), d3(e5 < this.length, "Trying to read beyond buffer length")), !(e5 >= this.length))
            return this[e5];
        }, f.prototype.readUInt16LE = function(e5, t4) {
          return o2(this, e5, true, t4);
        }, f.prototype.readUInt16BE = function(e5, t4) {
          return o2(this, e5, false, t4);
        }, f.prototype.readUInt32LE = function(e5, t4) {
          return u2(this, e5, true, t4);
        }, f.prototype.readUInt32BE = function(e5, t4) {
          return u2(this, e5, false, t4);
        }, f.prototype.readInt8 = function(e5, t4) {
          if (t4 || (d3(null != e5, "missing offset"), d3(e5 < this.length, "Trying to read beyond buffer length")), !(e5 >= this.length))
            return 128 & this[e5] ? -1 * (255 - this[e5] + 1) : this[e5];
        }, f.prototype.readInt16LE = function(e5, t4) {
          return _2(this, e5, true, t4);
        }, f.prototype.readInt16BE = function(e5, t4) {
          return _2(this, e5, false, t4);
        }, f.prototype.readInt32LE = function(e5, t4) {
          return E2(this, e5, true, t4);
        }, f.prototype.readInt32BE = function(e5, t4) {
          return E2(this, e5, false, t4);
        }, f.prototype.readFloatLE = function(e5, t4) {
          return I2(this, e5, true, t4);
        }, f.prototype.readFloatBE = function(e5, t4) {
          return I2(this, e5, false, t4);
        }, f.prototype.readDoubleLE = function(e5, t4) {
          return A(this, e5, true, t4);
        }, f.prototype.readDoubleBE = function(e5, t4) {
          return A(this, e5, false, t4);
        }, f.prototype.writeUInt8 = function(e5, t4, n3) {
          n3 || (d3(null != e5, "missing value"), d3(null != t4, "missing offset"), d3(t4 < this.length, "trying to write beyond buffer length"), Y2(e5, 255)), t4 >= this.length || (this[t4] = e5);
        }, f.prototype.writeUInt16LE = function(e5, t4, n3) {
          s3(this, e5, t4, true, n3);
        }, f.prototype.writeUInt16BE = function(e5, t4, n3) {
          s3(this, e5, t4, false, n3);
        }, f.prototype.writeUInt32LE = function(e5, t4, n3) {
          l(this, e5, t4, true, n3);
        }, f.prototype.writeUInt32BE = function(e5, t4, n3) {
          l(this, e5, t4, false, n3);
        }, f.prototype.writeInt8 = function(e5, t4, n3) {
          n3 || (d3(null != e5, "missing value"), d3(null != t4, "missing offset"), d3(t4 < this.length, "Trying to write beyond buffer length"), F(e5, 127, -128)), t4 >= this.length || (0 <= e5 ? this.writeUInt8(e5, t4, n3) : this.writeUInt8(255 + e5 + 1, t4, n3));
        }, f.prototype.writeInt16LE = function(e5, t4, n3) {
          B2(this, e5, t4, true, n3);
        }, f.prototype.writeInt16BE = function(e5, t4, n3) {
          B2(this, e5, t4, false, n3);
        }, f.prototype.writeInt32LE = function(e5, t4, n3) {
          L2(this, e5, t4, true, n3);
        }, f.prototype.writeInt32BE = function(e5, t4, n3) {
          L2(this, e5, t4, false, n3);
        }, f.prototype.writeFloatLE = function(e5, t4, n3) {
          U(this, e5, t4, true, n3);
        }, f.prototype.writeFloatBE = function(e5, t4, n3) {
          U(this, e5, t4, false, n3);
        }, f.prototype.writeDoubleLE = function(e5, t4, n3) {
          x2(this, e5, t4, true, n3);
        }, f.prototype.writeDoubleBE = function(e5, t4, n3) {
          x2(this, e5, t4, false, n3);
        }, f.prototype.fill = function(e5, t4, n3) {
          if (t4 = t4 || 0, n3 = n3 || this.length, d3("number" == typeof (e5 = "string" == typeof (e5 = e5 || 0) ? e5.charCodeAt(0) : e5) && !isNaN(e5), "value is not a number"), d3(t4 <= n3, "end < start"), n3 !== t4 && 0 !== this.length) {
            d3(0 <= t4 && t4 < this.length, "start out of bounds"), d3(0 <= n3 && n3 <= this.length, "end out of bounds");
            for (var r3 = t4; r3 < n3; r3++)
              this[r3] = e5;
          }
        }, f.prototype.inspect = function() {
          for (var e5 = [], t4 = this.length, n3 = 0; n3 < t4; n3++)
            if (e5[n3] = k2(this[n3]), n3 === H3.INSPECT_MAX_BYTES) {
              e5[n3 + 1] = "...";
              break;
            }
          return "<Buffer " + e5.join(" ") + ">";
        }, f.prototype.toArrayBuffer = function() {
          if ("undefined" == typeof Uint8Array)
            throw new Error("Buffer.toArrayBuffer not supported in this browser");
          if (f._useTypedArrays)
            return new f(this).buffer;
          for (var e5 = new Uint8Array(this.length), t4 = 0, n3 = e5.length; t4 < n3; t4 += 1)
            e5[t4] = this[t4];
          return e5.buffer;
        };
        var t3 = f.prototype;
        function S3(e5, t4, n3) {
          return "number" != typeof e5 ? n3 : t4 <= (e5 = ~~e5) ? t4 : 0 <= e5 || 0 <= (e5 += t4) ? e5 : 0;
        }
        function j(e5) {
          return (e5 = ~~Math.ceil(+e5)) < 0 ? 0 : e5;
        }
        function C(e5) {
          return (Array.isArray || function(e6) {
            return "[object Array]" === Object.prototype.toString.call(e6);
          })(e5);
        }
        function k2(e5) {
          return e5 < 16 ? "0" + e5.toString(16) : e5.toString(16);
        }
        function T2(e5) {
          for (var t4 = [], n3 = 0; n3 < e5.length; n3++) {
            var r3 = e5.charCodeAt(n3);
            if (r3 <= 127)
              t4.push(e5.charCodeAt(n3));
            else
              for (var o3 = n3, i3 = (55296 <= r3 && r3 <= 57343 && n3++, encodeURIComponent(e5.slice(o3, n3 + 1)).substr(1).split("%")), u3 = 0; u3 < i3.length; u3++)
                t4.push(parseInt(i3[u3], 16));
          }
          return t4;
        }
        function M3(e5) {
          return a3.toByteArray(e5);
        }
        function c2(e5, t4, n3, r3) {
          for (var o3 = 0; o3 < r3 && !(o3 + n3 >= t4.length || o3 >= e5.length); o3++)
            t4[o3 + n3] = e5[o3];
          return o3;
        }
        function N(e5) {
          try {
            return decodeURIComponent(e5);
          } catch (e6) {
            return String.fromCharCode(65533);
          }
        }
        function Y2(e5, t4) {
          d3("number" == typeof e5, "cannot write a non-number as a number"), d3(0 <= e5, "specified a negative value for writing an unsigned value"), d3(e5 <= t4, "value is larger than maximum value for type"), d3(Math.floor(e5) === e5, "value has a fractional component");
        }
        function F(e5, t4, n3) {
          d3("number" == typeof e5, "cannot write a non-number as a number"), d3(e5 <= t4, "value larger than maximum allowed value"), d3(n3 <= e5, "value smaller than minimum allowed value"), d3(Math.floor(e5) === e5, "value has a fractional component");
        }
        function D2(e5, t4, n3) {
          d3("number" == typeof e5, "cannot write a non-number as a number"), d3(e5 <= t4, "value larger than maximum allowed value"), d3(n3 <= e5, "value smaller than minimum allowed value");
        }
        function d3(e5, t4) {
          if (!e5)
            throw new Error(t4 || "Failed assertion");
        }
        f._augment = function(e5) {
          return e5._isBuffer = true, e5._get = e5.get, e5._set = e5.set, e5.get = t3.get, e5.set = t3.set, e5.write = t3.write, e5.toString = t3.toString, e5.toLocaleString = t3.toString, e5.toJSON = t3.toJSON, e5.copy = t3.copy, e5.slice = t3.slice, e5.readUInt8 = t3.readUInt8, e5.readUInt16LE = t3.readUInt16LE, e5.readUInt16BE = t3.readUInt16BE, e5.readUInt32LE = t3.readUInt32LE, e5.readUInt32BE = t3.readUInt32BE, e5.readInt8 = t3.readInt8, e5.readInt16LE = t3.readInt16LE, e5.readInt16BE = t3.readInt16BE, e5.readInt32LE = t3.readInt32LE, e5.readInt32BE = t3.readInt32BE, e5.readFloatLE = t3.readFloatLE, e5.readFloatBE = t3.readFloatBE, e5.readDoubleLE = t3.readDoubleLE, e5.readDoubleBE = t3.readDoubleBE, e5.writeUInt8 = t3.writeUInt8, e5.writeUInt16LE = t3.writeUInt16LE, e5.writeUInt16BE = t3.writeUInt16BE, e5.writeUInt32LE = t3.writeUInt32LE, e5.writeUInt32BE = t3.writeUInt32BE, e5.writeInt8 = t3.writeInt8, e5.writeInt16LE = t3.writeInt16LE, e5.writeInt16BE = t3.writeInt16BE, e5.writeInt32LE = t3.writeInt32LE, e5.writeInt32BE = t3.writeInt32BE, e5.writeFloatLE = t3.writeFloatLE, e5.writeFloatBE = t3.writeFloatBE, e5.writeDoubleLE = t3.writeDoubleLE, e5.writeDoubleBE = t3.writeDoubleBE, e5.fill = t3.fill, e5.inspect = t3.inspect, e5.toArrayBuffer = t3.toArrayBuffer, e5;
        };
      }.call(this, O2("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, O2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/buffer/index.js", "/node_modules/gulp-browserify/node_modules/buffer");
    }, { "base64-js": 2, buffer: 3, ieee754: 10, lYpoI2: 11 }], 4: [function(c2, d3, e3) {
      !function(e4, t3, a3, n2, r2, o2, i2, u2, s3) {
        var a3 = c2("buffer").Buffer, f = 4, l = new a3(f);
        l.fill(0);
        d3.exports = { hash: function(e5, t4, n3, r3) {
          for (var o3 = t4(function(e6, t5) {
            e6.length % f != 0 && (n4 = e6.length + (f - e6.length % f), e6 = a3.concat([e6, l], n4));
            for (var n4, r4 = [], o4 = t5 ? e6.readInt32BE : e6.readInt32LE, i4 = 0; i4 < e6.length; i4 += f)
              r4.push(o4.call(e6, i4));
            return r4;
          }(e5 = a3.isBuffer(e5) ? e5 : new a3(e5), r3), 8 * e5.length), t4 = r3, i3 = new a3(n3), u3 = t4 ? i3.writeInt32BE : i3.writeInt32LE, s4 = 0; s4 < o3.length; s4++)
            u3.call(i3, o3[s4], 4 * s4, true);
          return i3;
        } };
      }.call(this, c2("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, c2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/helpers.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
    }, { buffer: 3, lYpoI2: 11 }], 5: [function(v, e3, _2) {
      !function(l, c2, u2, d3, h4, p2, g, y3, w2) {
        var u2 = v("buffer").Buffer, e4 = v("./sha"), t3 = v("./sha256"), n2 = v("./rng"), b3 = { sha1: e4, sha256: t3, md5: v("./md5") }, s3 = 64, a3 = new u2(s3);
        function r2(e5, n3) {
          var r3 = b3[e5 = e5 || "sha1"], o3 = [];
          return r3 || i2("algorithm:", e5, "is not yet supported"), { update: function(e6) {
            return u2.isBuffer(e6) || (e6 = new u2(e6)), o3.push(e6), e6.length, this;
          }, digest: function(e6) {
            var t4 = u2.concat(o3), t4 = n3 ? function(e7, t5, n4) {
              u2.isBuffer(t5) || (t5 = new u2(t5)), u2.isBuffer(n4) || (n4 = new u2(n4)), t5.length > s3 ? t5 = e7(t5) : t5.length < s3 && (t5 = u2.concat([t5, a3], s3));
              for (var r4 = new u2(s3), o4 = new u2(s3), i3 = 0; i3 < s3; i3++)
                r4[i3] = 54 ^ t5[i3], o4[i3] = 92 ^ t5[i3];
              return n4 = e7(u2.concat([r4, n4])), e7(u2.concat([o4, n4]));
            }(r3, n3, t4) : r3(t4);
            return o3 = null, e6 ? t4.toString(e6) : t4;
          } };
        }
        function i2() {
          var e5 = [].slice.call(arguments).join(" ");
          throw new Error([e5, "we accept pull requests", "http://github.com/dominictarr/crypto-browserify"].join("\n"));
        }
        a3.fill(0), _2.createHash = function(e5) {
          return r2(e5);
        }, _2.createHmac = r2, _2.randomBytes = function(e5, t4) {
          if (!t4 || !t4.call)
            return new u2(n2(e5));
          try {
            t4.call(this, void 0, new u2(n2(e5)));
          } catch (e6) {
            t4(e6);
          }
        };
        var o2, f = ["createCredentials", "createCipher", "createCipheriv", "createDecipher", "createDecipheriv", "createSign", "createVerify", "createDiffieHellman", "pbkdf2"], m3 = function(e5) {
          _2[e5] = function() {
            i2("sorry,", e5, "is not implemented yet");
          };
        };
        for (o2 in f)
          m3(f[o2]);
      }.call(this, v("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, v("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/index.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
    }, { "./md5": 6, "./rng": 7, "./sha": 8, "./sha256": 9, buffer: 3, lYpoI2: 11 }], 6: [function(w2, b3, e3) {
      !function(e4, r2, o2, i2, u2, a3, f, l, y3) {
        var t3 = w2("./helpers");
        function n2(e5, t4) {
          e5[t4 >> 5] |= 128 << t4 % 32, e5[14 + (t4 + 64 >>> 9 << 4)] = t4;
          for (var n3 = 1732584193, r3 = -271733879, o3 = -1732584194, i3 = 271733878, u3 = 0; u3 < e5.length; u3 += 16) {
            var s4 = n3, a4 = r3, f2 = o3, l2 = i3, n3 = c2(n3, r3, o3, i3, e5[u3 + 0], 7, -680876936), i3 = c2(i3, n3, r3, o3, e5[u3 + 1], 12, -389564586), o3 = c2(o3, i3, n3, r3, e5[u3 + 2], 17, 606105819), r3 = c2(r3, o3, i3, n3, e5[u3 + 3], 22, -1044525330);
            n3 = c2(n3, r3, o3, i3, e5[u3 + 4], 7, -176418897), i3 = c2(i3, n3, r3, o3, e5[u3 + 5], 12, 1200080426), o3 = c2(o3, i3, n3, r3, e5[u3 + 6], 17, -1473231341), r3 = c2(r3, o3, i3, n3, e5[u3 + 7], 22, -45705983), n3 = c2(n3, r3, o3, i3, e5[u3 + 8], 7, 1770035416), i3 = c2(i3, n3, r3, o3, e5[u3 + 9], 12, -1958414417), o3 = c2(o3, i3, n3, r3, e5[u3 + 10], 17, -42063), r3 = c2(r3, o3, i3, n3, e5[u3 + 11], 22, -1990404162), n3 = c2(n3, r3, o3, i3, e5[u3 + 12], 7, 1804603682), i3 = c2(i3, n3, r3, o3, e5[u3 + 13], 12, -40341101), o3 = c2(o3, i3, n3, r3, e5[u3 + 14], 17, -1502002290), n3 = d3(n3, r3 = c2(r3, o3, i3, n3, e5[u3 + 15], 22, 1236535329), o3, i3, e5[u3 + 1], 5, -165796510), i3 = d3(i3, n3, r3, o3, e5[u3 + 6], 9, -1069501632), o3 = d3(o3, i3, n3, r3, e5[u3 + 11], 14, 643717713), r3 = d3(r3, o3, i3, n3, e5[u3 + 0], 20, -373897302), n3 = d3(n3, r3, o3, i3, e5[u3 + 5], 5, -701558691), i3 = d3(i3, n3, r3, o3, e5[u3 + 10], 9, 38016083), o3 = d3(o3, i3, n3, r3, e5[u3 + 15], 14, -660478335), r3 = d3(r3, o3, i3, n3, e5[u3 + 4], 20, -405537848), n3 = d3(n3, r3, o3, i3, e5[u3 + 9], 5, 568446438), i3 = d3(i3, n3, r3, o3, e5[u3 + 14], 9, -1019803690), o3 = d3(o3, i3, n3, r3, e5[u3 + 3], 14, -187363961), r3 = d3(r3, o3, i3, n3, e5[u3 + 8], 20, 1163531501), n3 = d3(n3, r3, o3, i3, e5[u3 + 13], 5, -1444681467), i3 = d3(i3, n3, r3, o3, e5[u3 + 2], 9, -51403784), o3 = d3(o3, i3, n3, r3, e5[u3 + 7], 14, 1735328473), n3 = h4(n3, r3 = d3(r3, o3, i3, n3, e5[u3 + 12], 20, -1926607734), o3, i3, e5[u3 + 5], 4, -378558), i3 = h4(i3, n3, r3, o3, e5[u3 + 8], 11, -2022574463), o3 = h4(o3, i3, n3, r3, e5[u3 + 11], 16, 1839030562), r3 = h4(r3, o3, i3, n3, e5[u3 + 14], 23, -35309556), n3 = h4(n3, r3, o3, i3, e5[u3 + 1], 4, -1530992060), i3 = h4(i3, n3, r3, o3, e5[u3 + 4], 11, 1272893353), o3 = h4(o3, i3, n3, r3, e5[u3 + 7], 16, -155497632), r3 = h4(r3, o3, i3, n3, e5[u3 + 10], 23, -1094730640), n3 = h4(n3, r3, o3, i3, e5[u3 + 13], 4, 681279174), i3 = h4(i3, n3, r3, o3, e5[u3 + 0], 11, -358537222), o3 = h4(o3, i3, n3, r3, e5[u3 + 3], 16, -722521979), r3 = h4(r3, o3, i3, n3, e5[u3 + 6], 23, 76029189), n3 = h4(n3, r3, o3, i3, e5[u3 + 9], 4, -640364487), i3 = h4(i3, n3, r3, o3, e5[u3 + 12], 11, -421815835), o3 = h4(o3, i3, n3, r3, e5[u3 + 15], 16, 530742520), n3 = p2(n3, r3 = h4(r3, o3, i3, n3, e5[u3 + 2], 23, -995338651), o3, i3, e5[u3 + 0], 6, -198630844), i3 = p2(i3, n3, r3, o3, e5[u3 + 7], 10, 1126891415), o3 = p2(o3, i3, n3, r3, e5[u3 + 14], 15, -1416354905), r3 = p2(r3, o3, i3, n3, e5[u3 + 5], 21, -57434055), n3 = p2(n3, r3, o3, i3, e5[u3 + 12], 6, 1700485571), i3 = p2(i3, n3, r3, o3, e5[u3 + 3], 10, -1894986606), o3 = p2(o3, i3, n3, r3, e5[u3 + 10], 15, -1051523), r3 = p2(r3, o3, i3, n3, e5[u3 + 1], 21, -2054922799), n3 = p2(n3, r3, o3, i3, e5[u3 + 8], 6, 1873313359), i3 = p2(i3, n3, r3, o3, e5[u3 + 15], 10, -30611744), o3 = p2(o3, i3, n3, r3, e5[u3 + 6], 15, -1560198380), r3 = p2(r3, o3, i3, n3, e5[u3 + 13], 21, 1309151649), n3 = p2(n3, r3, o3, i3, e5[u3 + 4], 6, -145523070), i3 = p2(i3, n3, r3, o3, e5[u3 + 11], 10, -1120210379), o3 = p2(o3, i3, n3, r3, e5[u3 + 2], 15, 718787259), r3 = p2(r3, o3, i3, n3, e5[u3 + 9], 21, -343485551), n3 = g(n3, s4), r3 = g(r3, a4), o3 = g(o3, f2), i3 = g(i3, l2);
          }
          return Array(n3, r3, o3, i3);
        }
        function s3(e5, t4, n3, r3, o3, i3) {
          return g((t4 = g(g(t4, e5), g(r3, i3))) << o3 | t4 >>> 32 - o3, n3);
        }
        function c2(e5, t4, n3, r3, o3, i3, u3) {
          return s3(t4 & n3 | ~t4 & r3, e5, t4, o3, i3, u3);
        }
        function d3(e5, t4, n3, r3, o3, i3, u3) {
          return s3(t4 & r3 | n3 & ~r3, e5, t4, o3, i3, u3);
        }
        function h4(e5, t4, n3, r3, o3, i3, u3) {
          return s3(t4 ^ n3 ^ r3, e5, t4, o3, i3, u3);
        }
        function p2(e5, t4, n3, r3, o3, i3, u3) {
          return s3(n3 ^ (t4 | ~r3), e5, t4, o3, i3, u3);
        }
        function g(e5, t4) {
          var n3 = (65535 & e5) + (65535 & t4);
          return (e5 >> 16) + (t4 >> 16) + (n3 >> 16) << 16 | 65535 & n3;
        }
        b3.exports = function(e5) {
          return t3.hash(e5, n2, 16);
        };
      }.call(this, w2("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, w2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/md5.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
    }, { "./helpers": 4, buffer: 3, lYpoI2: 11 }], 7: [function(e3, l, t3) {
      !function(e4, t4, n2, r2, o2, i2, u2, s3, f) {
        l.exports = function(e5) {
          for (var t5, n3 = new Array(e5), r3 = 0; r3 < e5; r3++)
            0 == (3 & r3) && (t5 = 4294967296 * Math.random()), n3[r3] = t5 >>> ((3 & r3) << 3) & 255;
          return n3;
        };
      }.call(this, e3("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e3("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/rng.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
    }, { buffer: 3, lYpoI2: 11 }], 8: [function(c2, d3, e3) {
      !function(e4, t3, n2, r2, o2, s3, a3, f, l) {
        var i2 = c2("./helpers");
        function u2(l2, c3) {
          l2[c3 >> 5] |= 128 << 24 - c3 % 32, l2[15 + (c3 + 64 >> 9 << 4)] = c3;
          for (var e5, t4, n3, r3 = Array(80), o3 = 1732584193, i3 = -271733879, u3 = -1732584194, s4 = 271733878, d4 = -1009589776, h4 = 0; h4 < l2.length; h4 += 16) {
            for (var p2 = o3, g = i3, y3 = u3, w2 = s4, b3 = d4, a4 = 0; a4 < 80; a4++) {
              r3[a4] = a4 < 16 ? l2[h4 + a4] : v(r3[a4 - 3] ^ r3[a4 - 8] ^ r3[a4 - 14] ^ r3[a4 - 16], 1);
              var f2 = m3(m3(v(o3, 5), (f2 = i3, t4 = u3, n3 = s4, (e5 = a4) < 20 ? f2 & t4 | ~f2 & n3 : !(e5 < 40) && e5 < 60 ? f2 & t4 | f2 & n3 | t4 & n3 : f2 ^ t4 ^ n3)), m3(m3(d4, r3[a4]), (e5 = a4) < 20 ? 1518500249 : e5 < 40 ? 1859775393 : e5 < 60 ? -1894007588 : -899497514)), d4 = s4, s4 = u3, u3 = v(i3, 30), i3 = o3, o3 = f2;
            }
            o3 = m3(o3, p2), i3 = m3(i3, g), u3 = m3(u3, y3), s4 = m3(s4, w2), d4 = m3(d4, b3);
          }
          return Array(o3, i3, u3, s4, d4);
        }
        function m3(e5, t4) {
          var n3 = (65535 & e5) + (65535 & t4);
          return (e5 >> 16) + (t4 >> 16) + (n3 >> 16) << 16 | 65535 & n3;
        }
        function v(e5, t4) {
          return e5 << t4 | e5 >>> 32 - t4;
        }
        d3.exports = function(e5) {
          return i2.hash(e5, u2, 20, true);
        };
      }.call(this, c2("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, c2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/sha.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
    }, { "./helpers": 4, buffer: 3, lYpoI2: 11 }], 9: [function(c2, d3, e3) {
      !function(e4, t3, n2, r2, u2, s3, a3, f, l) {
        function b3(e5, t4) {
          var n3 = (65535 & e5) + (65535 & t4);
          return (e5 >> 16) + (t4 >> 16) + (n3 >> 16) << 16 | 65535 & n3;
        }
        function o2(e5, l2) {
          var c3, d4 = new Array(1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298), t4 = new Array(1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225), n3 = new Array(64);
          e5[l2 >> 5] |= 128 << 24 - l2 % 32, e5[15 + (l2 + 64 >> 9 << 4)] = l2;
          for (var r3, o3, h4 = 0; h4 < e5.length; h4 += 16) {
            for (var i3 = t4[0], u3 = t4[1], s4 = t4[2], p2 = t4[3], a4 = t4[4], g = t4[5], y3 = t4[6], w2 = t4[7], f2 = 0; f2 < 64; f2++)
              n3[f2] = f2 < 16 ? e5[f2 + h4] : b3(b3(b3((o3 = n3[f2 - 2], m3(o3, 17) ^ m3(o3, 19) ^ v(o3, 10)), n3[f2 - 7]), (o3 = n3[f2 - 15], m3(o3, 7) ^ m3(o3, 18) ^ v(o3, 3))), n3[f2 - 16]), c3 = b3(b3(b3(b3(w2, m3(o3 = a4, 6) ^ m3(o3, 11) ^ m3(o3, 25)), a4 & g ^ ~a4 & y3), d4[f2]), n3[f2]), r3 = b3(m3(r3 = i3, 2) ^ m3(r3, 13) ^ m3(r3, 22), i3 & u3 ^ i3 & s4 ^ u3 & s4), w2 = y3, y3 = g, g = a4, a4 = b3(p2, c3), p2 = s4, s4 = u3, u3 = i3, i3 = b3(c3, r3);
            t4[0] = b3(i3, t4[0]), t4[1] = b3(u3, t4[1]), t4[2] = b3(s4, t4[2]), t4[3] = b3(p2, t4[3]), t4[4] = b3(a4, t4[4]), t4[5] = b3(g, t4[5]), t4[6] = b3(y3, t4[6]), t4[7] = b3(w2, t4[7]);
          }
          return t4;
        }
        var i2 = c2("./helpers"), m3 = function(e5, t4) {
          return e5 >>> t4 | e5 << 32 - t4;
        }, v = function(e5, t4) {
          return e5 >>> t4;
        };
        d3.exports = function(e5) {
          return i2.hash(e5, o2, 32, true);
        };
      }.call(this, c2("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, c2("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/crypto-browserify/sha256.js", "/node_modules/gulp-browserify/node_modules/crypto-browserify");
    }, { "./helpers": 4, buffer: 3, lYpoI2: 11 }], 10: [function(e3, t3, f) {
      !function(e4, t4, n2, r2, o2, i2, u2, s3, a3) {
        f.read = function(e5, t5, n3, r3, o3) {
          var i3, u3, l = 8 * o3 - r3 - 1, c2 = (1 << l) - 1, d3 = c2 >> 1, s4 = -7, a4 = n3 ? o3 - 1 : 0, f2 = n3 ? -1 : 1, o3 = e5[t5 + a4];
          for (a4 += f2, i3 = o3 & (1 << -s4) - 1, o3 >>= -s4, s4 += l; 0 < s4; i3 = 256 * i3 + e5[t5 + a4], a4 += f2, s4 -= 8)
            ;
          for (u3 = i3 & (1 << -s4) - 1, i3 >>= -s4, s4 += r3; 0 < s4; u3 = 256 * u3 + e5[t5 + a4], a4 += f2, s4 -= 8)
            ;
          if (0 === i3)
            i3 = 1 - d3;
          else {
            if (i3 === c2)
              return u3 ? NaN : 1 / 0 * (o3 ? -1 : 1);
            u3 += Math.pow(2, r3), i3 -= d3;
          }
          return (o3 ? -1 : 1) * u3 * Math.pow(2, i3 - r3);
        }, f.write = function(e5, t5, l, n3, r3, c2) {
          var o3, i3, u3 = 8 * c2 - r3 - 1, s4 = (1 << u3) - 1, a4 = s4 >> 1, d3 = 23 === r3 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f2 = n3 ? 0 : c2 - 1, h4 = n3 ? 1 : -1, c2 = t5 < 0 || 0 === t5 && 1 / t5 < 0 ? 1 : 0;
          for (t5 = Math.abs(t5), isNaN(t5) || t5 === 1 / 0 ? (i3 = isNaN(t5) ? 1 : 0, o3 = s4) : (o3 = Math.floor(Math.log(t5) / Math.LN2), t5 * (n3 = Math.pow(2, -o3)) < 1 && (o3--, n3 *= 2), 2 <= (t5 += 1 <= o3 + a4 ? d3 / n3 : d3 * Math.pow(2, 1 - a4)) * n3 && (o3++, n3 /= 2), s4 <= o3 + a4 ? (i3 = 0, o3 = s4) : 1 <= o3 + a4 ? (i3 = (t5 * n3 - 1) * Math.pow(2, r3), o3 += a4) : (i3 = t5 * Math.pow(2, a4 - 1) * Math.pow(2, r3), o3 = 0)); 8 <= r3; e5[l + f2] = 255 & i3, f2 += h4, i3 /= 256, r3 -= 8)
            ;
          for (o3 = o3 << r3 | i3, u3 += r3; 0 < u3; e5[l + f2] = 255 & o3, f2 += h4, o3 /= 256, u3 -= 8)
            ;
          e5[l + f2 - h4] |= 128 * c2;
        };
      }.call(this, e3("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e3("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/ieee754/index.js", "/node_modules/gulp-browserify/node_modules/ieee754");
    }, { buffer: 3, lYpoI2: 11 }], 11: [function(e3, h4, t3) {
      !function(e4, t4, n2, r2, o2, f, l, c2, d3) {
        var i2, u2, s3;
        function a3() {
        }
        (e4 = h4.exports = {}).nextTick = (u2 = "undefined" != typeof window && window.setImmediate, s3 = "undefined" != typeof window && window.postMessage && window.addEventListener, u2 ? function(e5) {
          return window.setImmediate(e5);
        } : s3 ? (i2 = [], window.addEventListener("message", function(e5) {
          var t5 = e5.source;
          t5 !== window && null !== t5 || "process-tick" !== e5.data || (e5.stopPropagation(), 0 < i2.length && i2.shift()());
        }, true), function(e5) {
          i2.push(e5), window.postMessage("process-tick", "*");
        }) : function(e5) {
          setTimeout(e5, 0);
        }), e4.title = "browser", e4.browser = true, e4.env = {}, e4.argv = [], e4.on = a3, e4.addListener = a3, e4.once = a3, e4.off = a3, e4.removeListener = a3, e4.removeAllListeners = a3, e4.emit = a3, e4.binding = function(e5) {
          throw new Error("process.binding is not supported");
        }, e4.cwd = function() {
          return "/";
        }, e4.chdir = function(e5) {
          throw new Error("process.chdir is not supported");
        };
      }.call(this, e3("lYpoI2"), "undefined" != typeof self ? self : "undefined" != typeof window ? window : {}, e3("buffer").Buffer, arguments[3], arguments[4], arguments[5], arguments[6], "/node_modules/gulp-browserify/node_modules/process/browser.js", "/node_modules/gulp-browserify/node_modules/process");
    }, { buffer: 3, lYpoI2: 11 }] }, {}, [1])(1);
  });
})(object_hash);
const hash = object_hash.exports;
let cachedData = {};
async function apiBase(enpoint, payload) {
  const cacheKeyHash = hash({ enpoint, payload });
  if (cachedData[`cacheKeyHash`]) {
    return cachedData[cacheKeyHash];
  }
  const data = await invokeGetApi(enpoint, payload);
  cachedData[cacheKeyHash] = data;
  return data;
}
async function fetchR3MData({
  marketSensingRefreshDate,
  categories,
  customers,
  valueORvolume
}) {
  const data = await apiBase("maindashboard", {
    marketSensingRefreshDate,
    categories,
    customers,
    valueORvolume
  });
  let dataForUi = _.get(data, "result", {});
  _.forEach(dataForUi, (v) => {
    const periodData = _.get(_.values(v), "[0]");
    periodData.modelAccuracy = _.toNumber(periodData.modelAccuracy);
    const metricsObj = _.get(periodData, "metrics");
    _.forOwn(metricsObj, (v2, k2) => {
      if (!(k2 === "historical" || k2 === "keyDemandDrivers")) {
        metricsObj[k2] = v2 === null ? "NA" : _.round(_.toNumber(v2), 0);
      }
    });
  });
  return dataForUi;
}
async function fetchQuarterlyData({
  marketSensingRefreshDate,
  categories,
  customers,
  valueORvolume
}) {
  const data = await apiBase("maindashboard", {
    marketSensingRefreshDate: format(
      startOfMonth(
        add(
          startOfQuarter(
            parse(marketSensingRefreshDate, "yyyy-MM-dd", new Date())
          ),
          {
            days: -1
          }
        )
      ),
      "yyyy-MM-dd"
    ),
    categories,
    customers,
    valueORvolume,
    isFixed: true
  });
  let dataForUi = _.get(data, "result", {});
  _.forEach(dataForUi, (v) => {
    const periodData = _.get(_.values(v), "[0]");
    periodData.modelAccuracy = _.toNumber(periodData.modelAccuracy);
    const metricsObj = _.get(periodData, "metrics");
    _.forOwn(metricsObj, (v2, k2) => {
      if (!(k2 === "historical" || k2 === "keyDemandDrivers")) {
        metricsObj[k2] = v2 === null ? "NA" : _.round(_.toNumber(v2), 0);
      }
    });
  });
  return dataForUi;
}
async function fetchDashboardOptions() {
  const dataForUi = await apiBase("dashboard_filters");
  return dataForUi;
}
const FiltersSection_vue_vue_type_style_index_0_lang$1 = "";
const VIcon$1 = "";
const predefinedSizes = ["x-small", "small", "default", "large", "x-large"];
const makeSizeProps = propsFactory({
  size: {
    type: [String, Number],
    default: "default"
  }
}, "size");
function useSize(props) {
  let name2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
  return destructComputed(() => {
    let sizeClasses;
    let sizeStyles;
    if (includes(predefinedSizes, props.size)) {
      sizeClasses = `${name2}--size-${props.size}`;
    } else if (props.size) {
      sizeStyles = {
        width: convertToUnit(props.size),
        height: convertToUnit(props.size)
      };
    }
    return {
      sizeClasses,
      sizeStyles
    };
  });
}
const makeTagProps = propsFactory({
  tag: {
    type: String,
    default: "div"
  }
}, "tag");
function useColor(colors) {
  return destructComputed(() => {
    const classes = [];
    const styles = {};
    if (colors.value.background) {
      if (isCssColor(colors.value.background)) {
        styles.backgroundColor = colors.value.background;
      } else {
        classes.push(`bg-${colors.value.background}`);
      }
    }
    if (colors.value.text) {
      if (isCssColor(colors.value.text)) {
        styles.color = colors.value.text;
        styles.caretColor = colors.value.text;
      } else {
        classes.push(`text-${colors.value.text}`);
      }
    }
    return {
      colorClasses: classes,
      colorStyles: styles
    };
  });
}
function useTextColor(props, name2) {
  const colors = computed(() => ({
    text: isRef(props) ? props.value : name2 ? props[name2] : null
  }));
  const {
    colorClasses: textColorClasses,
    colorStyles: textColorStyles
  } = useColor(colors);
  return {
    textColorClasses,
    textColorStyles
  };
}
function useBackgroundColor(props, name2) {
  const colors = computed(() => ({
    background: isRef(props) ? props.value : name2 ? props[name2] : null
  }));
  const {
    colorClasses: backgroundColorClasses,
    colorStyles: backgroundColorStyles
  } = useColor(colors);
  return {
    backgroundColorClasses,
    backgroundColorStyles
  };
}
const makeVIconProps = propsFactory({
  color: String,
  start: Boolean,
  end: Boolean,
  icon: IconValue,
  ...makeSizeProps(),
  ...makeTagProps({
    tag: "i"
  }),
  ...makeThemeProps()
}, "v-icon");
const VIcon = defineComponent({
  name: "VIcon",
  props: makeVIconProps(),
  setup(props, _ref) {
    let {
      attrs,
      slots
    } = _ref;
    let slotIcon;
    if (slots.default) {
      slotIcon = computed(() => {
        var _slots$default, _slot$filter$;
        const slot = (_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots);
        if (!slot)
          return;
        return (_slot$filter$ = slot.filter((node) => node.type === Text && node.children && typeof node.children === "string")[0]) == null ? void 0 : _slot$filter$.children;
      });
    }
    const {
      themeClasses
    } = provideTheme(props);
    const {
      iconData
    } = useIcon(slotIcon || props);
    const {
      sizeClasses
    } = useSize(props);
    const {
      textColorClasses,
      textColorStyles
    } = useTextColor(toRef(props, "color"));
    useRender(() => {
      var _slots$default2;
      return createVNode(iconData.value.component, {
        "tag": props.tag,
        "icon": iconData.value.icon,
        "class": ["v-icon", "notranslate", themeClasses.value, sizeClasses.value, textColorClasses.value, {
          "v-icon--clickable": !!attrs.onClick,
          "v-icon--start": props.start,
          "v-icon--end": props.end
        }],
        "style": [!sizeClasses.value ? {
          fontSize: convertToUnit(props.size),
          height: convertToUnit(props.size),
          width: convertToUnit(props.size)
        } : void 0, textColorStyles.value],
        "role": attrs.onClick ? "button" : void 0,
        "aria-hidden": !attrs.onClick
      }, {
        default: () => [(_slots$default2 = slots.default) == null ? void 0 : _slots$default2.call(slots)]
      });
    });
    return {};
  }
});
const VSelect$1 = "";
const VTextField$1 = "";
const VField$1 = "";
function createCssTransition(name2) {
  let origin = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "top center 0";
  let mode = arguments.length > 2 ? arguments[2] : void 0;
  return defineComponent({
    name: name2,
    props: {
      group: Boolean,
      hideOnLeave: Boolean,
      leaveAbsolute: Boolean,
      mode: {
        type: String,
        default: mode
      },
      origin: {
        type: String,
        default: origin
      }
    },
    setup(props, _ref) {
      let {
        slots
      } = _ref;
      return () => {
        const tag = props.group ? TransitionGroup : Transition;
        return h(tag, {
          name: name2,
          mode: props.mode,
          onBeforeEnter(el2) {
            el2.style.transformOrigin = props.origin;
          },
          onLeave(el2) {
            if (props.leaveAbsolute) {
              const {
                offsetTop,
                offsetLeft,
                offsetWidth,
                offsetHeight
              } = el2;
              el2._transitionInitialStyles = {
                position: el2.style.position,
                top: el2.style.top,
                left: el2.style.left,
                width: el2.style.width,
                height: el2.style.height
              };
              el2.style.position = "absolute";
              el2.style.top = `${offsetTop}px`;
              el2.style.left = `${offsetLeft}px`;
              el2.style.width = `${offsetWidth}px`;
              el2.style.height = `${offsetHeight}px`;
            }
            if (props.hideOnLeave) {
              el2.style.setProperty("display", "none", "important");
            }
          },
          onAfterLeave(el2) {
            if (props.leaveAbsolute && el2 != null && el2._transitionInitialStyles) {
              const {
                position,
                top,
                left,
                width,
                height
              } = el2._transitionInitialStyles;
              delete el2._transitionInitialStyles;
              el2.style.position = position || "";
              el2.style.top = top || "";
              el2.style.left = left || "";
              el2.style.width = width || "";
              el2.style.height = height || "";
            }
          }
        }, slots.default);
      };
    }
  });
}
function createJavascriptTransition(name2, functions) {
  let mode = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "in-out";
  return defineComponent({
    name: name2,
    props: {
      mode: {
        type: String,
        default: mode
      }
    },
    setup(props, _ref2) {
      let {
        slots
      } = _ref2;
      return () => {
        return h(Transition, {
          name: name2,
          ...functions
        }, slots.default);
      };
    }
  });
}
function ExpandTransitionGenerator() {
  let expandedParentClass = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
  let x2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  const sizeProperty = x2 ? "width" : "height";
  const offsetProperty = camelize(`offset-${sizeProperty}`);
  return {
    onBeforeEnter(el2) {
      el2._parent = el2.parentNode;
      el2._initialStyle = {
        transition: el2.style.transition,
        overflow: el2.style.overflow,
        [sizeProperty]: el2.style[sizeProperty]
      };
    },
    onEnter(el2) {
      const initialStyle = el2._initialStyle;
      el2.style.setProperty("transition", "none", "important");
      el2.style.overflow = "hidden";
      const offset = `${el2[offsetProperty]}px`;
      el2.style[sizeProperty] = "0";
      void el2.offsetHeight;
      el2.style.transition = initialStyle.transition;
      if (expandedParentClass && el2._parent) {
        el2._parent.classList.add(expandedParentClass);
      }
      requestAnimationFrame(() => {
        el2.style[sizeProperty] = offset;
      });
    },
    onAfterEnter: resetStyles,
    onEnterCancelled: resetStyles,
    onLeave(el2) {
      el2._initialStyle = {
        transition: "",
        overflow: el2.style.overflow,
        [sizeProperty]: el2.style[sizeProperty]
      };
      el2.style.overflow = "hidden";
      el2.style[sizeProperty] = `${el2[offsetProperty]}px`;
      void el2.offsetHeight;
      requestAnimationFrame(() => el2.style[sizeProperty] = "0");
    },
    onAfterLeave,
    onLeaveCancelled: onAfterLeave
  };
  function onAfterLeave(el2) {
    if (expandedParentClass && el2._parent) {
      el2._parent.classList.remove(expandedParentClass);
    }
    resetStyles(el2);
  }
  function resetStyles(el2) {
    const size2 = el2._initialStyle[sizeProperty];
    el2.style.overflow = el2._initialStyle.overflow;
    if (size2 != null)
      el2.style[sizeProperty] = size2;
    delete el2._initialStyle;
  }
}
const VDialogTransition = defineComponent({
  name: "VDialogTransition",
  props: {
    target: Object
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const functions = {
      onBeforeEnter(el2) {
        el2.style.pointerEvents = "none";
        el2.style.visibility = "hidden";
      },
      async onEnter(el2, done) {
        var _getChildren;
        await new Promise((resolve2) => requestAnimationFrame(resolve2));
        await new Promise((resolve2) => requestAnimationFrame(resolve2));
        el2.style.visibility = "";
        const {
          x: x2,
          y: y3,
          sx,
          sy,
          speed
        } = getDimensions(props.target, el2);
        const animation = animate(el2, [{
          transform: `translate(${x2}px, ${y3}px) scale(${sx}, ${sy})`,
          opacity: 0
        }, {}], {
          duration: 225 * speed,
          easing: deceleratedEasing
        });
        (_getChildren = getChildren(el2)) == null ? void 0 : _getChildren.forEach((el3) => {
          animate(el3, [{
            opacity: 0
          }, {
            opacity: 0,
            offset: 0.33
          }, {}], {
            duration: 225 * 2 * speed,
            easing: standardEasing
          });
        });
        animation.finished.then(() => done());
      },
      onAfterEnter(el2) {
        el2.style.removeProperty("pointer-events");
      },
      onBeforeLeave(el2) {
        el2.style.pointerEvents = "none";
      },
      async onLeave(el2, done) {
        var _getChildren2;
        await new Promise((resolve2) => requestAnimationFrame(resolve2));
        const {
          x: x2,
          y: y3,
          sx,
          sy,
          speed
        } = getDimensions(props.target, el2);
        const animation = animate(el2, [{}, {
          transform: `translate(${x2}px, ${y3}px) scale(${sx}, ${sy})`,
          opacity: 0
        }], {
          duration: 125 * speed,
          easing: acceleratedEasing
        });
        animation.finished.then(() => done());
        (_getChildren2 = getChildren(el2)) == null ? void 0 : _getChildren2.forEach((el3) => {
          animate(el3, [{}, {
            opacity: 0,
            offset: 0.2
          }, {
            opacity: 0
          }], {
            duration: 125 * 2 * speed,
            easing: standardEasing
          });
        });
      },
      onAfterLeave(el2) {
        el2.style.removeProperty("pointer-events");
      }
    };
    return () => {
      return props.target ? createVNode(Transition, mergeProps({
        "name": "dialog-transition"
      }, functions, {
        "css": false
      }), slots) : createVNode(Transition, {
        "name": "dialog-transition"
      }, slots);
    };
  }
});
function getChildren(el2) {
  var _el$querySelector;
  const els = (_el$querySelector = el2.querySelector(":scope > .v-card, :scope > .v-sheet, :scope > .v-list")) == null ? void 0 : _el$querySelector.children;
  return els && [...els];
}
function getDimensions(target, el2) {
  const targetBox = target.getBoundingClientRect();
  const elBox = nullifyTransforms(el2);
  const [originX, originY] = getComputedStyle(el2).transformOrigin.split(" ").map((v) => parseFloat(v));
  const [anchorSide, anchorOffset] = getComputedStyle(el2).getPropertyValue("--v-overlay-anchor-origin").split(" ");
  let offsetX = targetBox.left + targetBox.width / 2;
  if (anchorSide === "left" || anchorOffset === "left") {
    offsetX -= targetBox.width / 2;
  } else if (anchorSide === "right" || anchorOffset === "right") {
    offsetX += targetBox.width / 2;
  }
  let offsetY = targetBox.top + targetBox.height / 2;
  if (anchorSide === "top" || anchorOffset === "top") {
    offsetY -= targetBox.height / 2;
  } else if (anchorSide === "bottom" || anchorOffset === "bottom") {
    offsetY += targetBox.height / 2;
  }
  const tsx = targetBox.width / elBox.width;
  const tsy = targetBox.height / elBox.height;
  const maxs = Math.max(1, tsx, tsy);
  const sx = tsx / maxs || 0;
  const sy = tsy / maxs || 0;
  const asa = elBox.width * elBox.height / (window.innerWidth * window.innerHeight);
  const speed = asa > 0.12 ? Math.min(1.5, (asa - 0.12) * 10 + 1) : 1;
  return {
    x: offsetX - (originX + elBox.left),
    y: offsetY - (originY + elBox.top),
    sx,
    sy,
    speed
  };
}
createCssTransition("fab-transition", "center center", "out-in");
createCssTransition("dialog-bottom-transition");
createCssTransition("dialog-top-transition");
createCssTransition("fade-transition");
createCssTransition("scale-transition");
createCssTransition("scroll-x-transition");
createCssTransition("scroll-x-reverse-transition");
createCssTransition("scroll-y-transition");
createCssTransition("scroll-y-reverse-transition");
createCssTransition("slide-x-transition");
createCssTransition("slide-x-reverse-transition");
const VSlideYTransition = createCssTransition("slide-y-transition");
createCssTransition("slide-y-reverse-transition");
const VExpandTransition = createJavascriptTransition("expand-transition", ExpandTransitionGenerator());
const VExpandXTransition = createJavascriptTransition("expand-x-transition", ExpandTransitionGenerator("", true));
function useInputIcon(props) {
  const {
    t: t3
  } = useLocale();
  function InputIcon(_ref) {
    var _a2;
    let {
      name: name2
    } = _ref;
    const localeKey = {
      prepend: "prependAction",
      prependInner: "prependAction",
      append: "appendAction",
      appendInner: "appendAction",
      clear: "clear"
    }[name2];
    const listener = props[`onClick:${name2}`];
    const label = listener && localeKey ? t3(`$vuetify.input.${localeKey}`, (_a2 = props.label) != null ? _a2 : "") : void 0;
    return createVNode(VIcon, {
      "icon": props[`${name2}Icon`],
      "aria-label": label,
      "onClick": listener
    }, null);
  }
  return {
    InputIcon
  };
}
const VLabel$1 = "";
const VLabel = defineComponent({
  name: "VLabel",
  props: {
    text: String,
    clickable: Boolean,
    ...makeThemeProps()
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    useRender(() => {
      var _slots$default;
      return createVNode("label", {
        "class": ["v-label", {
          "v-label--clickable": props.clickable
        }]
      }, [props.text, (_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots)]);
    });
    return {};
  }
});
const VFieldLabel = defineComponent({
  name: "VFieldLabel",
  props: {
    floating: Boolean
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    useRender(() => createVNode(VLabel, {
      "class": ["v-field-label", {
        "v-field-label--floating": props.floating
      }],
      "aria-hidden": props.floating || void 0
    }, slots));
    return {};
  }
});
const VProgressLinear$1 = "";
const makeRoundedProps = propsFactory({
  rounded: {
    type: [Boolean, Number, String],
    default: void 0
  }
}, "rounded");
function useRounded(props) {
  let name2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
  const roundedClasses = computed(() => {
    const rounded = isRef(props) ? props.value : props.rounded;
    const classes = [];
    if (rounded === true || rounded === "") {
      classes.push(`${name2}--rounded`);
    } else if (typeof rounded === "string" || rounded === 0) {
      for (const value of String(rounded).split(" ")) {
        classes.push(`rounded-${value}`);
      }
    }
    return classes;
  });
  return {
    roundedClasses
  };
}
const oppositeMap = {
  center: "center",
  top: "bottom",
  bottom: "top",
  left: "right",
  right: "left"
};
const makeLocationProps = propsFactory({
  location: String
}, "location");
function useLocation(props) {
  let opposite = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  let offset = arguments.length > 2 ? arguments[2] : void 0;
  const {
    isRtl
  } = useRtl();
  const locationStyles = computed(() => {
    if (!props.location)
      return {};
    const {
      side,
      align
    } = parseAnchor(props.location.split(" ").length > 1 ? props.location : `${props.location} center`, isRtl.value);
    function getOffset2(side2) {
      return offset ? offset(side2) : 0;
    }
    const styles = {};
    if (side !== "center") {
      if (opposite)
        styles[oppositeMap[side]] = `calc(100% - ${getOffset2(side)}px)`;
      else
        styles[side] = 0;
    }
    if (align !== "center") {
      if (opposite)
        styles[oppositeMap[align]] = `calc(100% - ${getOffset2(align)}px)`;
      else
        styles[align] = 0;
    } else {
      if (side === "center")
        styles.top = styles.left = "50%";
      else {
        styles[{
          top: "left",
          bottom: "left",
          left: "top",
          right: "top"
        }[side]] = "50%";
      }
      styles.transform = {
        top: "translateX(-50%)",
        bottom: "translateX(-50%)",
        left: "translateY(-50%)",
        right: "translateY(-50%)",
        center: "translate(-50%, -50%)"
      }[side];
    }
    return styles;
  });
  return {
    locationStyles
  };
}
function useIntersectionObserver(callback) {
  const intersectionRef = ref();
  const isIntersecting = ref(false);
  if (SUPPORTS_INTERSECTION) {
    const observer = new IntersectionObserver((entries) => {
      callback == null ? void 0 : callback(entries, observer);
      isIntersecting.value = !!entries.find((entry) => entry.isIntersecting);
    });
    onBeforeUnmount(() => {
      observer.disconnect();
    });
    watch(intersectionRef, (newValue, oldValue) => {
      if (oldValue) {
        observer.unobserve(oldValue);
        isIntersecting.value = false;
      }
      if (newValue)
        observer.observe(newValue);
    }, {
      flush: "post"
    });
  }
  return {
    intersectionRef,
    isIntersecting
  };
}
const VProgressLinear = defineComponent({
  name: "VProgressLinear",
  props: {
    absolute: Boolean,
    active: {
      type: Boolean,
      default: true
    },
    bgColor: String,
    bgOpacity: [Number, String],
    bufferValue: {
      type: [Number, String],
      default: 0
    },
    clickable: Boolean,
    color: String,
    height: {
      type: [Number, String],
      default: 4
    },
    indeterminate: Boolean,
    max: {
      type: [Number, String],
      default: 100
    },
    modelValue: {
      type: [Number, String],
      default: 0
    },
    reverse: Boolean,
    stream: Boolean,
    striped: Boolean,
    roundedBar: Boolean,
    ...makeLocationProps({
      location: "top"
    }),
    ...makeRoundedProps(),
    ...makeTagProps(),
    ...makeThemeProps()
  },
  emits: {
    "update:modelValue": (value) => true
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const progress = useProxiedModel(props, "modelValue");
    const {
      isRtl
    } = useRtl();
    const {
      themeClasses
    } = provideTheme(props);
    const {
      locationStyles
    } = useLocation(props);
    const {
      textColorClasses,
      textColorStyles
    } = useTextColor(props, "color");
    const {
      backgroundColorClasses,
      backgroundColorStyles
    } = useBackgroundColor(computed(() => props.bgColor || props.color));
    const {
      backgroundColorClasses: barColorClasses,
      backgroundColorStyles: barColorStyles
    } = useBackgroundColor(props, "color");
    const {
      roundedClasses
    } = useRounded(props);
    const {
      intersectionRef,
      isIntersecting
    } = useIntersectionObserver();
    const max = computed(() => parseInt(props.max, 10));
    const height = computed(() => parseInt(props.height, 10));
    const normalizedBuffer = computed(() => parseFloat(props.bufferValue) / max.value * 100);
    const normalizedValue = computed(() => parseFloat(progress.value) / max.value * 100);
    const isReversed = computed(() => isRtl.value !== props.reverse);
    const transition = computed(() => props.indeterminate ? "fade-transition" : "slide-x-transition");
    const opacity = computed(() => {
      return props.bgOpacity == null ? props.bgOpacity : parseFloat(props.bgOpacity);
    });
    function handleClick(e3) {
      if (!intersectionRef.value)
        return;
      const {
        left,
        right,
        width
      } = intersectionRef.value.getBoundingClientRect();
      const value = isReversed.value ? width - e3.clientX + (right - width) : e3.clientX - left;
      progress.value = Math.round(value / width * max.value);
    }
    useRender(() => createVNode(props.tag, {
      "ref": intersectionRef,
      "class": ["v-progress-linear", {
        "v-progress-linear--absolute": props.absolute,
        "v-progress-linear--active": props.active && isIntersecting.value,
        "v-progress-linear--reverse": isReversed.value,
        "v-progress-linear--rounded": props.rounded,
        "v-progress-linear--rounded-bar": props.roundedBar,
        "v-progress-linear--striped": props.striped
      }, roundedClasses.value, themeClasses.value],
      "style": {
        bottom: props.location === "bottom" ? 0 : void 0,
        top: props.location === "top" ? 0 : void 0,
        height: props.active ? convertToUnit(height.value) : 0,
        "--v-progress-linear-height": convertToUnit(height.value),
        ...locationStyles.value
      },
      "role": "progressbar",
      "aria-hidden": props.active ? "false" : "true",
      "aria-valuemin": "0",
      "aria-valuemax": props.max,
      "aria-valuenow": props.indeterminate ? void 0 : normalizedValue.value,
      "onClick": props.clickable && handleClick
    }, {
      default: () => [props.stream && createVNode("div", {
        "key": "stream",
        "class": ["v-progress-linear__stream", textColorClasses.value],
        "style": {
          ...textColorStyles.value,
          [isReversed.value ? "left" : "right"]: convertToUnit(-height.value),
          borderTop: `${convertToUnit(height.value / 2)} dotted`,
          opacity: opacity.value,
          top: `calc(50% - ${convertToUnit(height.value / 4)})`,
          width: convertToUnit(100 - normalizedBuffer.value, "%"),
          "--v-progress-linear-stream-to": convertToUnit(height.value * (isReversed.value ? 1 : -1))
        }
      }, null), createVNode("div", {
        "class": ["v-progress-linear__background", backgroundColorClasses.value],
        "style": [backgroundColorStyles.value, {
          opacity: opacity.value,
          width: convertToUnit(!props.stream ? 100 : normalizedBuffer.value, "%")
        }]
      }, null), createVNode(Transition, {
        "name": transition.value
      }, {
        default: () => [!props.indeterminate ? createVNode("div", {
          "class": ["v-progress-linear__determinate", barColorClasses.value],
          "style": [barColorStyles.value, {
            width: convertToUnit(normalizedValue.value, "%")
          }]
        }, null) : createVNode("div", {
          "class": "v-progress-linear__indeterminate"
        }, [["long", "short"].map((bar) => createVNode("div", {
          "key": bar,
          "class": ["v-progress-linear__indeterminate", bar, barColorClasses.value],
          "style": barColorStyles.value
        }, null))])]
      }), slots.default && createVNode("div", {
        "class": "v-progress-linear__content"
      }, [slots.default({
        value: normalizedValue.value,
        buffer: normalizedBuffer.value
      })])]
    }));
    return {};
  }
});
const makeLoaderProps = propsFactory({
  loading: [Boolean, String]
}, "loader");
function useLoader(props) {
  let name2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
  const loaderClasses = computed(() => ({
    [`${name2}--loading`]: props.loading
  }));
  return {
    loaderClasses
  };
}
function LoaderSlot(props, _ref) {
  var _slots$default;
  let {
    slots
  } = _ref;
  return createVNode("div", {
    "class": `${props.name}__loader`
  }, [((_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots, {
    color: props.color,
    isActive: props.active
  })) || createVNode(VProgressLinear, {
    "active": props.active,
    "color": props.color,
    "height": "2",
    "indeterminate": true
  }, null)]);
}
const makeFocusProps = propsFactory({
  focused: Boolean
}, "focus");
function useFocus(props) {
  let name2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
  const isFocused = useProxiedModel(props, "focused");
  const focusClasses = computed(() => {
    return {
      [`${name2}--focused`]: isFocused.value
    };
  });
  function focus() {
    isFocused.value = true;
  }
  function blur() {
    isFocused.value = false;
  }
  return {
    focusClasses,
    isFocused,
    focus,
    blur
  };
}
const allowedVariants$1 = ["underlined", "outlined", "filled", "solo", "plain"];
const makeVFieldProps = propsFactory({
  appendInnerIcon: IconValue,
  bgColor: String,
  clearable: Boolean,
  clearIcon: {
    type: IconValue,
    default: "$clear"
  },
  active: Boolean,
  color: String,
  dirty: Boolean,
  disabled: Boolean,
  error: Boolean,
  label: String,
  persistentClear: Boolean,
  prependInnerIcon: IconValue,
  reverse: Boolean,
  singleLine: Boolean,
  variant: {
    type: String,
    default: "filled",
    validator: (v) => allowedVariants$1.includes(v)
  },
  "onClick:clear": EventProp,
  "onClick:appendInner": EventProp,
  "onClick:prependInner": EventProp,
  ...makeThemeProps(),
  ...makeLoaderProps()
}, "v-field");
const VField = genericComponent()({
  name: "VField",
  inheritAttrs: false,
  props: {
    id: String,
    ...makeFocusProps(),
    ...makeVFieldProps()
  },
  emits: {
    "click:control": (e3) => true,
    "update:focused": (focused) => true,
    "update:modelValue": (val) => true
  },
  setup(props, _ref) {
    let {
      attrs,
      emit: emit2,
      slots
    } = _ref;
    const {
      themeClasses
    } = provideTheme(props);
    const {
      loaderClasses
    } = useLoader(props);
    const {
      focusClasses,
      isFocused,
      focus,
      blur
    } = useFocus(props);
    const {
      InputIcon
    } = useInputIcon(props);
    const isActive = computed(() => props.dirty || props.active);
    const hasLabel = computed(() => !props.singleLine && !!(props.label || slots.label));
    const uid2 = getUid();
    const id = computed(() => props.id || `input-${uid2}`);
    const messagesId = computed(() => `${id.value}-messages`);
    const labelRef = ref();
    const floatingLabelRef = ref();
    const controlRef = ref();
    const {
      backgroundColorClasses,
      backgroundColorStyles
    } = useBackgroundColor(toRef(props, "bgColor"));
    const {
      textColorClasses,
      textColorStyles
    } = useTextColor(computed(() => {
      return isActive.value && isFocused.value && !props.error && !props.disabled ? props.color : void 0;
    }));
    watch(isActive, (val) => {
      if (hasLabel.value) {
        const el2 = labelRef.value.$el;
        const targetEl = floatingLabelRef.value.$el;
        requestAnimationFrame(() => {
          const rect = nullifyTransforms(el2);
          const targetRect = targetEl.getBoundingClientRect();
          const x2 = targetRect.x - rect.x;
          const y3 = targetRect.y - rect.y - (rect.height / 2 - targetRect.height / 2);
          const targetWidth = targetRect.width / 0.75;
          const width = Math.abs(targetWidth - rect.width) > 1 ? {
            maxWidth: convertToUnit(targetWidth)
          } : void 0;
          const style = getComputedStyle(el2);
          const targetStyle = getComputedStyle(targetEl);
          const duration = parseFloat(style.transitionDuration) * 1e3 || 150;
          const scale = parseFloat(targetStyle.getPropertyValue("--v-field-label-scale"));
          const color = targetStyle.getPropertyValue("color");
          el2.style.visibility = "visible";
          targetEl.style.visibility = "hidden";
          animate(el2, {
            transform: `translate(${x2}px, ${y3}px) scale(${scale})`,
            color,
            ...width
          }, {
            duration,
            easing: standardEasing,
            direction: val ? "normal" : "reverse"
          }).finished.then(() => {
            el2.style.removeProperty("visibility");
            targetEl.style.removeProperty("visibility");
          });
        });
      }
    }, {
      flush: "post"
    });
    const slotProps = computed(() => ({
      isActive,
      isFocused,
      controlRef,
      blur,
      focus
    }));
    function onClick(e3) {
      if (e3.target !== document.activeElement) {
        e3.preventDefault();
      }
      emit2("click:control", e3);
    }
    useRender(() => {
      var _slots$prependInner, _slots$default, _slots$appendInner;
      const isOutlined = props.variant === "outlined";
      const hasPrepend = slots["prepend-inner"] || props.prependInnerIcon;
      const hasClear = !!(props.clearable || slots.clear);
      const hasAppend = !!(slots["append-inner"] || props.appendInnerIcon || hasClear);
      const label = slots.label ? slots.label({
        label: props.label,
        props: {
          for: id.value
        }
      }) : props.label;
      return createVNode("div", mergeProps({
        "class": ["v-field", {
          "v-field--active": isActive.value,
          "v-field--appended": hasAppend,
          "v-field--disabled": props.disabled,
          "v-field--dirty": props.dirty,
          "v-field--error": props.error,
          "v-field--has-background": !!props.bgColor,
          "v-field--persistent-clear": props.persistentClear,
          "v-field--prepended": hasPrepend,
          "v-field--reverse": props.reverse,
          "v-field--single-line": props.singleLine,
          "v-field--no-label": !label,
          [`v-field--variant-${props.variant}`]: true
        }, themeClasses.value, backgroundColorClasses.value, focusClasses.value, loaderClasses.value],
        "style": [backgroundColorStyles.value, textColorStyles.value],
        "onClick": onClick
      }, attrs), [createVNode("div", {
        "class": "v-field__overlay"
      }, null), createVNode(LoaderSlot, {
        "name": "v-field",
        "active": !!props.loading,
        "color": props.error ? "error" : props.color
      }, {
        default: slots.loader
      }), hasPrepend && createVNode("div", {
        "key": "prepend",
        "class": "v-field__prepend-inner"
      }, [props.prependInnerIcon && createVNode(InputIcon, {
        "key": "prepend-icon",
        "name": "prependInner"
      }, null), (_slots$prependInner = slots["prepend-inner"]) == null ? void 0 : _slots$prependInner.call(slots, slotProps.value)]), createVNode("div", {
        "class": "v-field__field",
        "data-no-activator": ""
      }, [["solo", "filled"].includes(props.variant) && hasLabel.value && createVNode(VFieldLabel, {
        "key": "floating-label",
        "ref": floatingLabelRef,
        "class": [textColorClasses.value],
        "floating": true,
        "for": id.value
      }, {
        default: () => [label]
      }), createVNode(VFieldLabel, {
        "ref": labelRef,
        "for": id.value
      }, {
        default: () => [label]
      }), (_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots, {
        ...slotProps.value,
        props: {
          id: id.value,
          class: "v-field__input",
          "aria-describedby": messagesId.value
        },
        focus,
        blur
      })]), hasClear && createVNode(VExpandXTransition, {
        "key": "clear"
      }, {
        default: () => [withDirectives(createVNode("div", {
          "class": "v-field__clearable"
        }, [slots.clear ? slots.clear() : createVNode(InputIcon, {
          "name": "clear"
        }, null)]), [[vShow, props.dirty]])]
      }), hasAppend && createVNode("div", {
        "key": "append",
        "class": "v-field__append-inner"
      }, [(_slots$appendInner = slots["append-inner"]) == null ? void 0 : _slots$appendInner.call(slots, slotProps.value), props.appendInnerIcon && createVNode(InputIcon, {
        "key": "append-icon",
        "name": "appendInner"
      }, null)]), createVNode("div", {
        "class": ["v-field__outline", textColorClasses.value]
      }, [isOutlined && createVNode(Fragment, null, [createVNode("div", {
        "class": "v-field__outline__start"
      }, null), hasLabel.value && createVNode("div", {
        "class": "v-field__outline__notch"
      }, [createVNode(VFieldLabel, {
        "ref": floatingLabelRef,
        "floating": true,
        "for": id.value
      }, {
        default: () => [label]
      })]), createVNode("div", {
        "class": "v-field__outline__end"
      }, null)]), ["plain", "underlined"].includes(props.variant) && hasLabel.value && createVNode(VFieldLabel, {
        "ref": floatingLabelRef,
        "floating": true,
        "for": id.value
      }, {
        default: () => [label]
      })])]);
    });
    return {
      controlRef
    };
  }
});
function filterFieldProps(attrs) {
  const keys = Object.keys(VField.props).filter((k2) => !isOn(k2));
  return pick(attrs, keys);
}
const VInput$1 = "";
const VMessages$1 = "";
const makeTransitionProps = propsFactory({
  transition: {
    type: [Boolean, String, Object],
    default: "fade-transition",
    validator: (val) => val !== true
  }
}, "transition");
const MaybeTransition = (props, _ref) => {
  let {
    slots
  } = _ref;
  const {
    transition,
    ...rest
  } = props;
  const {
    component = Transition,
    ...customProps
  } = typeof transition === "object" ? transition : {};
  return h(component, mergeProps(typeof transition === "string" ? {
    name: transition
  } : customProps, rest), slots);
};
const VMessages = defineComponent({
  name: "VMessages",
  props: {
    active: Boolean,
    color: String,
    messages: {
      type: [Array, String],
      default: () => []
    },
    ...makeTransitionProps({
      transition: {
        component: VSlideYTransition,
        leaveAbsolute: true,
        group: true
      }
    })
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const messages = computed(() => wrapInArray(props.messages));
    const {
      textColorClasses,
      textColorStyles
    } = useTextColor(computed(() => props.color));
    useRender(() => createVNode(MaybeTransition, {
      "transition": props.transition,
      "tag": "div",
      "class": ["v-messages", textColorClasses.value],
      "style": textColorStyles.value,
      "role": "alert",
      "aria-live": "polite"
    }, {
      default: () => [props.active && messages.value.map((message, i2) => createVNode("div", {
        "class": "v-messages__message",
        "key": `${i2}-${messages.value}`
      }, [slots.message ? slots.message({
        message
      }) : message]))]
    }));
    return {};
  }
});
const allowedDensities = [null, "default", "comfortable", "compact"];
const makeDensityProps = propsFactory({
  density: {
    type: String,
    default: "default",
    validator: (v) => allowedDensities.includes(v)
  }
}, "density");
function useDensity(props) {
  let name2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
  const densityClasses = computed(() => {
    return `${name2}--density-${props.density}`;
  });
  return {
    densityClasses
  };
}
const FormKey = Symbol.for("vuetify:form");
function useForm() {
  return inject$1(FormKey, null);
}
const makeValidationProps = propsFactory({
  disabled: Boolean,
  error: Boolean,
  errorMessages: {
    type: [Array, String],
    default: () => []
  },
  maxErrors: {
    type: [Number, String],
    default: 1
  },
  name: String,
  label: String,
  readonly: Boolean,
  rules: {
    type: Array,
    default: () => []
  },
  modelValue: null,
  validateOn: String,
  validationValue: null,
  ...makeFocusProps()
}, "validation");
function useValidation(props) {
  let name2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
  let id = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : getUid();
  const model = useProxiedModel(props, "modelValue");
  const validationModel = computed(() => props.validationValue === void 0 ? model.value : props.validationValue);
  const form = useForm();
  const internalErrorMessages = ref([]);
  const isPristine = ref(true);
  const isDirty = computed(() => !!(wrapInArray(model.value === "" ? null : model.value).length || wrapInArray(validationModel.value === "" ? null : validationModel.value).length));
  const isDisabled = computed(() => !!(props.disabled || form != null && form.isDisabled.value));
  const isReadonly2 = computed(() => !!(props.readonly || form != null && form.isReadonly.value));
  const errorMessages = computed(() => {
    return props.errorMessages.length ? wrapInArray(props.errorMessages).slice(0, Math.max(0, +props.maxErrors)) : internalErrorMessages.value;
  });
  const isValid2 = computed(() => {
    if (props.error || errorMessages.value.length)
      return false;
    if (!props.rules.length)
      return true;
    return isPristine.value ? null : true;
  });
  const isValidating = ref(false);
  const validationClasses = computed(() => {
    return {
      [`${name2}--error`]: isValid2.value === false,
      [`${name2}--dirty`]: isDirty.value,
      [`${name2}--disabled`]: isDisabled.value,
      [`${name2}--readonly`]: isReadonly2.value
    };
  });
  const uid2 = computed(() => {
    var _a2;
    return (_a2 = props.name) != null ? _a2 : unref(id);
  });
  onBeforeMount(() => {
    form == null ? void 0 : form.register({
      id: uid2.value,
      validate,
      reset,
      resetValidation
    });
  });
  onBeforeUnmount(() => {
    form == null ? void 0 : form.unregister(uid2.value);
  });
  const validateOn = computed(() => props.validateOn || (form == null ? void 0 : form.validateOn.value) || "input");
  onMounted(() => form == null ? void 0 : form.update(uid2.value, isValid2.value, errorMessages.value));
  useToggleScope(() => validateOn.value === "input", () => {
    watch(validationModel, () => {
      if (validationModel.value != null) {
        validate();
      } else if (props.focused) {
        const unwatch = watch(() => props.focused, (val) => {
          if (!val)
            validate();
          unwatch();
        });
      }
    });
  });
  useToggleScope(() => validateOn.value === "blur", () => {
    watch(() => props.focused, (val) => {
      if (!val)
        validate();
    });
  });
  watch(isValid2, () => {
    form == null ? void 0 : form.update(uid2.value, isValid2.value, errorMessages.value);
  });
  function reset() {
    resetValidation();
    model.value = null;
  }
  function resetValidation() {
    isPristine.value = true;
    internalErrorMessages.value = [];
  }
  async function validate() {
    var _a2;
    const results = [];
    isValidating.value = true;
    for (const rule of props.rules) {
      if (results.length >= ((_a2 = props.maxErrors) != null ? _a2 : 1)) {
        break;
      }
      const handler = typeof rule === "function" ? rule : () => rule;
      const result = await handler(validationModel.value);
      if (result === true)
        continue;
      if (typeof result !== "string") {
        console.warn(`${result} is not a valid value. Rule functions must return boolean true or a string.`);
        continue;
      }
      results.push(result);
    }
    internalErrorMessages.value = results;
    isValidating.value = false;
    isPristine.value = false;
    return internalErrorMessages.value;
  }
  return {
    errorMessages,
    isDirty,
    isDisabled,
    isReadonly: isReadonly2,
    isPristine,
    isValid: isValid2,
    isValidating,
    reset,
    resetValidation,
    validate,
    validationClasses
  };
}
const makeVInputProps = propsFactory({
  id: String,
  appendIcon: IconValue,
  prependIcon: IconValue,
  hideDetails: [Boolean, String],
  messages: {
    type: [Array, String],
    default: () => []
  },
  direction: {
    type: String,
    default: "horizontal",
    validator: (v) => ["horizontal", "vertical"].includes(v)
  },
  "onClick:prepend": EventProp,
  "onClick:append": EventProp,
  ...makeDensityProps(),
  ...makeValidationProps()
}, "v-input");
const VInput = genericComponent()({
  name: "VInput",
  props: {
    ...makeVInputProps()
  },
  emits: {
    "update:modelValue": (val) => true
  },
  setup(props, _ref) {
    let {
      attrs,
      slots,
      emit: emit2
    } = _ref;
    const {
      densityClasses
    } = useDensity(props);
    const {
      InputIcon
    } = useInputIcon(props);
    const uid2 = getUid();
    const id = computed(() => props.id || `input-${uid2}`);
    const messagesId = computed(() => `${id.value}-messages`);
    const {
      errorMessages,
      isDirty,
      isDisabled,
      isReadonly: isReadonly2,
      isPristine,
      isValid: isValid2,
      isValidating,
      reset,
      resetValidation,
      validate,
      validationClasses
    } = useValidation(props, "v-input", id);
    const slotProps = computed(() => ({
      id,
      messagesId,
      isDirty,
      isDisabled,
      isReadonly: isReadonly2,
      isPristine,
      isValid: isValid2,
      isValidating,
      reset,
      resetValidation,
      validate
    }));
    useRender(() => {
      var _props$messages, _slots$prepend, _slots$default, _slots$append, _slots$details;
      const hasPrepend = !!(slots.prepend || props.prependIcon);
      const hasAppend = !!(slots.append || props.appendIcon);
      const hasMessages = !!((_props$messages = props.messages) != null && _props$messages.length || errorMessages.value.length);
      const hasDetails = !props.hideDetails || props.hideDetails === "auto" && (hasMessages || !!slots.details);
      return createVNode("div", {
        "class": ["v-input", `v-input--${props.direction}`, densityClasses.value, validationClasses.value]
      }, [hasPrepend && createVNode("div", {
        "key": "prepend",
        "class": "v-input__prepend"
      }, [(_slots$prepend = slots.prepend) == null ? void 0 : _slots$prepend.call(slots, slotProps.value), props.prependIcon && createVNode(InputIcon, {
        "key": "prepend-icon",
        "name": "prepend"
      }, null)]), slots.default && createVNode("div", {
        "class": "v-input__control"
      }, [(_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots, slotProps.value)]), hasAppend && createVNode("div", {
        "key": "append",
        "class": "v-input__append"
      }, [props.appendIcon && createVNode(InputIcon, {
        "key": "append-icon",
        "name": "append"
      }, null), (_slots$append = slots.append) == null ? void 0 : _slots$append.call(slots, slotProps.value)]), hasDetails && createVNode("div", {
        "class": "v-input__details"
      }, [createVNode(VMessages, {
        "id": messagesId.value,
        "active": hasMessages,
        "messages": errorMessages.value.length > 0 ? errorMessages.value : props.messages
      }, {
        message: slots.message
      }), (_slots$details = slots.details) == null ? void 0 : _slots$details.call(slots, slotProps.value)])]);
    });
    return {
      reset,
      resetValidation,
      validate
    };
  }
});
function filterInputProps(props) {
  const keys = Object.keys(VInput.props).filter((k2) => !isOn(k2));
  return pick(props, keys);
}
const VCounter$1 = "";
const VCounter = defineComponent({
  name: "VCounter",
  functional: true,
  props: {
    active: Boolean,
    max: [Number, String],
    value: {
      type: [Number, String],
      default: 0
    },
    ...makeTransitionProps({
      transition: {
        component: VSlideYTransition
      }
    })
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const counter = computed(() => {
      return props.max ? `${props.value} / ${props.max}` : String(props.value);
    });
    useRender(() => createVNode(MaybeTransition, {
      "transition": props.transition
    }, {
      default: () => [withDirectives(createVNode("div", {
        "class": "v-counter"
      }, [slots.default ? slots.default({
        counter: counter.value,
        max: props.max,
        value: props.value
      }) : counter.value]), [[vShow, props.active]])]
    }));
    return {};
  }
});
function mounted$1(el2, binding) {
  if (!SUPPORTS_INTERSECTION)
    return;
  const modifiers = binding.modifiers || {};
  const value = binding.value;
  const {
    handler,
    options
  } = typeof value === "object" ? value : {
    handler: value,
    options: {}
  };
  const observer = new IntersectionObserver(function() {
    var _el$_observe;
    let entries = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    let observer2 = arguments.length > 1 ? arguments[1] : void 0;
    const _observe = (_el$_observe = el2._observe) == null ? void 0 : _el$_observe[binding.instance.$.uid];
    if (!_observe)
      return;
    const isIntersecting = entries.some((entry) => entry.isIntersecting);
    if (handler && (!modifiers.quiet || _observe.init) && (!modifiers.once || isIntersecting || _observe.init)) {
      handler(isIntersecting, entries, observer2);
    }
    if (isIntersecting && modifiers.once)
      unmounted$1(el2, binding);
    else
      _observe.init = true;
  }, options);
  el2._observe = Object(el2._observe);
  el2._observe[binding.instance.$.uid] = {
    init: false,
    observer
  };
  observer.observe(el2);
}
function unmounted$1(el2, binding) {
  var _el$_observe2;
  const observe = (_el$_observe2 = el2._observe) == null ? void 0 : _el$_observe2[binding.instance.$.uid];
  if (!observe)
    return;
  observe.observer.unobserve(el2);
  delete el2._observe[binding.instance.$.uid];
}
const Intersect = {
  mounted: mounted$1,
  unmounted: unmounted$1
};
const intersect = Intersect;
const Refs = Symbol("Forwarded refs");
function forwardRefs(target) {
  for (var _len = arguments.length, refs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    refs[_key - 1] = arguments[_key];
  }
  target[Refs] = refs;
  return new Proxy(target, {
    get(target2, key) {
      if (Reflect.has(target2, key)) {
        return Reflect.get(target2, key);
      }
      for (const ref2 of refs) {
        if (ref2.value && Reflect.has(ref2.value, key)) {
          const val = Reflect.get(ref2.value, key);
          return typeof val === "function" ? val.bind(ref2.value) : val;
        }
      }
    },
    getOwnPropertyDescriptor(target2, key) {
      const descriptor = Reflect.getOwnPropertyDescriptor(target2, key);
      if (descriptor)
        return descriptor;
      if (typeof key === "symbol" || key.startsWith("__"))
        return;
      for (const ref2 of refs) {
        if (!ref2.value)
          continue;
        const descriptor2 = Reflect.getOwnPropertyDescriptor(ref2.value, key);
        if (descriptor2)
          return descriptor2;
        if ("_" in ref2.value && "setupState" in ref2.value._) {
          const descriptor3 = Reflect.getOwnPropertyDescriptor(ref2.value._.setupState, key);
          if (descriptor3)
            return descriptor3;
        }
      }
      for (const ref2 of refs) {
        let obj = ref2.value && Object.getPrototypeOf(ref2.value);
        while (obj) {
          const descriptor2 = Reflect.getOwnPropertyDescriptor(obj, key);
          if (descriptor2)
            return descriptor2;
          obj = Object.getPrototypeOf(obj);
        }
      }
      for (const ref2 of refs) {
        const childRefs = ref2.value && ref2.value[Refs];
        if (!childRefs)
          continue;
        const queue2 = childRefs.slice();
        while (queue2.length) {
          const ref3 = queue2.shift();
          const descriptor2 = Reflect.getOwnPropertyDescriptor(ref3.value, key);
          if (descriptor2)
            return descriptor2;
          const childRefs2 = ref3.value && ref3.value[Refs];
          if (childRefs2)
            queue2.push(...childRefs2);
        }
      }
      return void 0;
    }
  });
}
const activeTypes = ["color", "file", "time", "date", "datetime-local", "week", "month"];
const makeVTextFieldProps = propsFactory({
  autofocus: Boolean,
  counter: [Boolean, Number, String],
  counterValue: Function,
  hint: String,
  persistentHint: Boolean,
  prefix: String,
  placeholder: String,
  persistentPlaceholder: Boolean,
  persistentCounter: Boolean,
  suffix: String,
  type: {
    type: String,
    default: "text"
  },
  ...makeVInputProps(),
  ...makeVFieldProps()
}, "v-text-field");
const VTextField = genericComponent()({
  name: "VTextField",
  directives: {
    Intersect: intersect
  },
  inheritAttrs: false,
  props: makeVTextFieldProps(),
  emits: {
    "click:control": (e3) => true,
    "click:input": (e3) => true,
    "update:focused": (focused) => true,
    "update:modelValue": (val) => true
  },
  setup(props, _ref) {
    let {
      attrs,
      emit: emit2,
      slots
    } = _ref;
    const model = useProxiedModel(props, "modelValue");
    const {
      isFocused,
      focus,
      blur
    } = useFocus(props);
    const counterValue = computed(() => {
      var _a2;
      return typeof props.counterValue === "function" ? props.counterValue(model.value) : ((_a2 = model.value) != null ? _a2 : "").toString().length;
    });
    const max = computed(() => {
      if (attrs.maxlength)
        return attrs.maxlength;
      if (!props.counter || typeof props.counter !== "number" && typeof props.counter !== "string")
        return void 0;
      return props.counter;
    });
    function onIntersect(isIntersecting, entries) {
      var _entries$0$target, _entries$0$target$foc;
      if (!props.autofocus || !isIntersecting)
        return;
      (_entries$0$target = entries[0].target) == null ? void 0 : (_entries$0$target$foc = _entries$0$target.focus) == null ? void 0 : _entries$0$target$foc.call(_entries$0$target);
    }
    const vInputRef = ref();
    const vFieldRef = ref();
    const inputRef = ref();
    const isActive = computed(() => activeTypes.includes(props.type) || props.persistentPlaceholder || isFocused.value);
    const messages = computed(() => {
      return props.messages.length ? props.messages : isFocused.value || props.persistentHint ? props.hint : "";
    });
    function onFocus() {
      if (inputRef.value !== document.activeElement) {
        var _inputRef$value;
        (_inputRef$value = inputRef.value) == null ? void 0 : _inputRef$value.focus();
      }
      if (!isFocused.value)
        focus();
    }
    function onControlClick(e3) {
      onFocus();
      emit2("click:control", e3);
    }
    function onClear(e3) {
      e3.stopPropagation();
      onFocus();
      nextTick(() => {
        model.value = null;
        callEvent(props["onClick:clear"], e3);
      });
    }
    function onInput(e3) {
      model.value = e3.target.value;
    }
    useRender(() => {
      const hasCounter = !!(slots.counter || props.counter || props.counterValue);
      const hasDetails = !!(hasCounter || slots.details);
      const [rootAttrs, inputAttrs] = filterInputAttrs(attrs);
      const [{
        modelValue: _2,
        ...inputProps
      }] = filterInputProps(props);
      const [fieldProps] = filterFieldProps(props);
      return createVNode(VInput, mergeProps({
        "ref": vInputRef,
        "modelValue": model.value,
        "onUpdate:modelValue": ($event) => model.value = $event,
        "class": ["v-text-field", {
          "v-text-field--prefixed": props.prefix,
          "v-text-field--suffixed": props.suffix,
          "v-text-field--flush-details": ["plain", "underlined"].includes(props.variant)
        }],
        "onClick:prepend": props["onClick:prepend"],
        "onClick:append": props["onClick:append"]
      }, rootAttrs, inputProps, {
        "focused": isFocused.value,
        "messages": messages.value
      }), {
        ...slots,
        default: (_ref2) => {
          let {
            id,
            isDisabled,
            isDirty,
            isReadonly: isReadonly2,
            isValid: isValid2
          } = _ref2;
          return createVNode(VField, mergeProps({
            "ref": vFieldRef,
            "onMousedown": (e3) => {
              if (e3.target === inputRef.value)
                return;
              e3.preventDefault();
            },
            "onClick:control": onControlClick,
            "onClick:clear": onClear,
            "onClick:prependInner": props["onClick:prependInner"],
            "onClick:appendInner": props["onClick:appendInner"],
            "role": "textbox"
          }, fieldProps, {
            "id": id.value,
            "active": isActive.value || isDirty.value,
            "dirty": isDirty.value || props.dirty,
            "focused": isFocused.value,
            "error": isValid2.value === false
          }), {
            ...slots,
            default: (_ref3) => {
              let {
                props: {
                  class: fieldClass,
                  ...slotProps
                }
              } = _ref3;
              const inputNode = withDirectives(createVNode("input", mergeProps({
                "ref": inputRef,
                "value": model.value,
                "onInput": onInput,
                "autofocus": props.autofocus,
                "readonly": isReadonly2.value,
                "disabled": isDisabled.value,
                "name": props.name,
                "placeholder": props.placeholder,
                "size": 1,
                "type": props.type,
                "onFocus": onFocus,
                "onBlur": blur
              }, slotProps, inputAttrs), null), [[resolveDirective("intersect"), {
                handler: onIntersect
              }, null, {
                once: true
              }]]);
              return createVNode(Fragment, null, [props.prefix && createVNode("span", {
                "class": "v-text-field__prefix"
              }, [props.prefix]), slots.default ? createVNode("div", {
                "class": fieldClass,
                "onClick": (e3) => emit2("click:input", e3),
                "data-no-activator": ""
              }, [slots.default(), inputNode]) : cloneVNode(inputNode, {
                class: fieldClass
              }), props.suffix && createVNode("span", {
                "class": "v-text-field__suffix"
              }, [props.suffix])]);
            }
          });
        },
        details: hasDetails ? (slotProps) => {
          var _slots$details;
          return createVNode(Fragment, null, [(_slots$details = slots.details) == null ? void 0 : _slots$details.call(slots, slotProps), hasCounter && createVNode(Fragment, null, [createVNode("span", null, null), createVNode(VCounter, {
            "active": props.persistentCounter || isFocused.value,
            "value": counterValue.value,
            "max": max.value
          }, slots.counter)])]);
        } : void 0
      });
    });
    return forwardRefs({}, vInputRef, vFieldRef, inputRef);
  }
});
function filterVTextFieldProps(props) {
  return pick(props, Object.keys(VTextField.props));
}
const VCheckbox$1 = "";
const VSelectionControl$1 = "";
const VSelectionControlGroup = "";
const VSelectionControlGroupSymbol = Symbol.for("vuetify:selection-control-group");
const makeSelectionControlGroupProps = propsFactory({
  color: String,
  disabled: Boolean,
  error: Boolean,
  id: String,
  inline: Boolean,
  falseIcon: IconValue,
  trueIcon: IconValue,
  ripple: {
    type: Boolean,
    default: true
  },
  multiple: {
    type: Boolean,
    default: null
  },
  name: String,
  readonly: Boolean,
  modelValue: null,
  type: String,
  valueComparator: {
    type: Function,
    default: deepEqual
  },
  ...makeThemeProps(),
  ...makeDensityProps()
}, "v-selection-control-group");
defineComponent({
  name: "VSelectionControlGroup",
  props: {
    defaultsTarget: {
      type: String,
      default: "VSelectionControl"
    },
    ...makeSelectionControlGroupProps()
  },
  emits: {
    "update:modelValue": (val) => true
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const modelValue = useProxiedModel(props, "modelValue");
    const uid2 = getUid();
    const id = computed(() => props.id || `v-selection-control-group-${uid2}`);
    const name2 = computed(() => props.name || id.value);
    const updateHandlers = /* @__PURE__ */ new Set();
    provide(VSelectionControlGroupSymbol, {
      modelValue,
      forceUpdate: () => {
        updateHandlers.forEach((fn2) => fn2());
      },
      onForceUpdate: (cb) => {
        updateHandlers.add(cb);
        onScopeDispose(() => {
          updateHandlers.delete(cb);
        });
      }
    });
    provideDefaults({
      [props.defaultsTarget]: {
        color: toRef(props, "color"),
        disabled: toRef(props, "disabled"),
        density: toRef(props, "density"),
        error: toRef(props, "error"),
        inline: toRef(props, "inline"),
        modelValue,
        multiple: computed(() => !!props.multiple || props.multiple == null && Array.isArray(modelValue.value)),
        name: name2,
        falseIcon: toRef(props, "falseIcon"),
        trueIcon: toRef(props, "trueIcon"),
        readonly: toRef(props, "readonly"),
        ripple: toRef(props, "ripple"),
        type: toRef(props, "type"),
        valueComparator: toRef(props, "valueComparator")
      }
    });
    useRender(() => {
      var _slots$default;
      return createVNode("div", {
        "class": ["v-selection-control-group", {
          "v-selection-control-group--inline": props.inline
        }],
        "role": props.type === "radio" ? "radiogroup" : void 0
      }, [(_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots)]);
    });
    return {};
  }
});
const VRipple = "";
const stopSymbol = Symbol("rippleStop");
const DELAY_RIPPLE = 80;
function transform(el2, value) {
  el2.style.transform = value;
  el2.style.webkitTransform = value;
}
function isTouchEvent(e3) {
  return e3.constructor.name === "TouchEvent";
}
function isKeyboardEvent(e3) {
  return e3.constructor.name === "KeyboardEvent";
}
const calculate = function(e3, el2) {
  var _el$_ripple;
  let value = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  let localX = 0;
  let localY = 0;
  if (!isKeyboardEvent(e3)) {
    const offset = el2.getBoundingClientRect();
    const target = isTouchEvent(e3) ? e3.touches[e3.touches.length - 1] : e3;
    localX = target.clientX - offset.left;
    localY = target.clientY - offset.top;
  }
  let radius = 0;
  let scale = 0.3;
  if ((_el$_ripple = el2._ripple) != null && _el$_ripple.circle) {
    scale = 0.15;
    radius = el2.clientWidth / 2;
    radius = value.center ? radius : radius + Math.sqrt((localX - radius) ** 2 + (localY - radius) ** 2) / 4;
  } else {
    radius = Math.sqrt(el2.clientWidth ** 2 + el2.clientHeight ** 2) / 2;
  }
  const centerX = `${(el2.clientWidth - radius * 2) / 2}px`;
  const centerY = `${(el2.clientHeight - radius * 2) / 2}px`;
  const x2 = value.center ? centerX : `${localX - radius}px`;
  const y3 = value.center ? centerY : `${localY - radius}px`;
  return {
    radius,
    scale,
    x: x2,
    y: y3,
    centerX,
    centerY
  };
};
const ripples = {
  show(e3, el2) {
    var _el$_ripple2;
    let value = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!(el2 != null && (_el$_ripple2 = el2._ripple) != null && _el$_ripple2.enabled)) {
      return;
    }
    const container = document.createElement("span");
    const animation = document.createElement("span");
    container.appendChild(animation);
    container.className = "v-ripple__container";
    if (value.class) {
      container.className += ` ${value.class}`;
    }
    const {
      radius,
      scale,
      x: x2,
      y: y3,
      centerX,
      centerY
    } = calculate(e3, el2, value);
    const size2 = `${radius * 2}px`;
    animation.className = "v-ripple__animation";
    animation.style.width = size2;
    animation.style.height = size2;
    el2.appendChild(container);
    const computed2 = window.getComputedStyle(el2);
    if (computed2 && computed2.position === "static") {
      el2.style.position = "relative";
      el2.dataset.previousPosition = "static";
    }
    animation.classList.add("v-ripple__animation--enter");
    animation.classList.add("v-ripple__animation--visible");
    transform(animation, `translate(${x2}, ${y3}) scale3d(${scale},${scale},${scale})`);
    animation.dataset.activated = String(performance.now());
    setTimeout(() => {
      animation.classList.remove("v-ripple__animation--enter");
      animation.classList.add("v-ripple__animation--in");
      transform(animation, `translate(${centerX}, ${centerY}) scale3d(1,1,1)`);
    }, 0);
  },
  hide(el2) {
    var _el$_ripple3;
    if (!(el2 != null && (_el$_ripple3 = el2._ripple) != null && _el$_ripple3.enabled))
      return;
    const ripples2 = el2.getElementsByClassName("v-ripple__animation");
    if (ripples2.length === 0)
      return;
    const animation = ripples2[ripples2.length - 1];
    if (animation.dataset.isHiding)
      return;
    else
      animation.dataset.isHiding = "true";
    const diff = performance.now() - Number(animation.dataset.activated);
    const delay = Math.max(250 - diff, 0);
    setTimeout(() => {
      animation.classList.remove("v-ripple__animation--in");
      animation.classList.add("v-ripple__animation--out");
      setTimeout(() => {
        var _animation$parentNode;
        const ripples3 = el2.getElementsByClassName("v-ripple__animation");
        if (ripples3.length === 1 && el2.dataset.previousPosition) {
          el2.style.position = el2.dataset.previousPosition;
          delete el2.dataset.previousPosition;
        }
        if (((_animation$parentNode = animation.parentNode) == null ? void 0 : _animation$parentNode.parentNode) === el2)
          el2.removeChild(animation.parentNode);
      }, 300);
    }, delay);
  }
};
function isRippleEnabled(value) {
  return typeof value === "undefined" || !!value;
}
function rippleShow(e3) {
  const value = {};
  const element = e3.currentTarget;
  if (!(element != null && element._ripple) || element._ripple.touched || e3[stopSymbol])
    return;
  e3[stopSymbol] = true;
  if (isTouchEvent(e3)) {
    element._ripple.touched = true;
    element._ripple.isTouch = true;
  } else {
    if (element._ripple.isTouch)
      return;
  }
  value.center = element._ripple.centered || isKeyboardEvent(e3);
  if (element._ripple.class) {
    value.class = element._ripple.class;
  }
  if (isTouchEvent(e3)) {
    if (element._ripple.showTimerCommit)
      return;
    element._ripple.showTimerCommit = () => {
      ripples.show(e3, element, value);
    };
    element._ripple.showTimer = window.setTimeout(() => {
      var _element$_ripple;
      if (element != null && (_element$_ripple = element._ripple) != null && _element$_ripple.showTimerCommit) {
        element._ripple.showTimerCommit();
        element._ripple.showTimerCommit = null;
      }
    }, DELAY_RIPPLE);
  } else {
    ripples.show(e3, element, value);
  }
}
function rippleStop(e3) {
  e3[stopSymbol] = true;
}
function rippleHide(e3) {
  const element = e3.currentTarget;
  if (!element || !element._ripple)
    return;
  window.clearTimeout(element._ripple.showTimer);
  if (e3.type === "touchend" && element._ripple.showTimerCommit) {
    element._ripple.showTimerCommit();
    element._ripple.showTimerCommit = null;
    element._ripple.showTimer = window.setTimeout(() => {
      rippleHide(e3);
    });
    return;
  }
  window.setTimeout(() => {
    if (element._ripple) {
      element._ripple.touched = false;
    }
  });
  ripples.hide(element);
}
function rippleCancelShow(e3) {
  const element = e3.currentTarget;
  if (!element || !element._ripple)
    return;
  if (element._ripple.showTimerCommit) {
    element._ripple.showTimerCommit = null;
  }
  window.clearTimeout(element._ripple.showTimer);
}
let keyboardRipple = false;
function keyboardRippleShow(e3) {
  if (!keyboardRipple && (e3.keyCode === keyCodes.enter || e3.keyCode === keyCodes.space)) {
    keyboardRipple = true;
    rippleShow(e3);
  }
}
function keyboardRippleHide(e3) {
  keyboardRipple = false;
  rippleHide(e3);
}
function focusRippleHide(e3) {
  if (keyboardRipple) {
    keyboardRipple = false;
    rippleHide(e3);
  }
}
function updateRipple(el2, binding, wasEnabled) {
  var _a2;
  const {
    value,
    modifiers
  } = binding;
  const enabled = isRippleEnabled(value);
  if (!enabled) {
    ripples.hide(el2);
  }
  el2._ripple = (_a2 = el2._ripple) != null ? _a2 : {};
  el2._ripple.enabled = enabled;
  el2._ripple.centered = modifiers.center;
  el2._ripple.circle = modifiers.circle;
  if (isObject(value) && value.class) {
    el2._ripple.class = value.class;
  }
  if (enabled && !wasEnabled) {
    if (modifiers.stop) {
      el2.addEventListener("touchstart", rippleStop, {
        passive: true
      });
      el2.addEventListener("mousedown", rippleStop);
      return;
    }
    el2.addEventListener("touchstart", rippleShow, {
      passive: true
    });
    el2.addEventListener("touchend", rippleHide, {
      passive: true
    });
    el2.addEventListener("touchmove", rippleCancelShow, {
      passive: true
    });
    el2.addEventListener("touchcancel", rippleHide);
    el2.addEventListener("mousedown", rippleShow);
    el2.addEventListener("mouseup", rippleHide);
    el2.addEventListener("mouseleave", rippleHide);
    el2.addEventListener("keydown", keyboardRippleShow);
    el2.addEventListener("keyup", keyboardRippleHide);
    el2.addEventListener("blur", focusRippleHide);
    el2.addEventListener("dragstart", rippleHide, {
      passive: true
    });
  } else if (!enabled && wasEnabled) {
    removeListeners(el2);
  }
}
function removeListeners(el2) {
  el2.removeEventListener("mousedown", rippleShow);
  el2.removeEventListener("touchstart", rippleShow);
  el2.removeEventListener("touchend", rippleHide);
  el2.removeEventListener("touchmove", rippleCancelShow);
  el2.removeEventListener("touchcancel", rippleHide);
  el2.removeEventListener("mouseup", rippleHide);
  el2.removeEventListener("mouseleave", rippleHide);
  el2.removeEventListener("keydown", keyboardRippleShow);
  el2.removeEventListener("keyup", keyboardRippleHide);
  el2.removeEventListener("dragstart", rippleHide);
  el2.removeEventListener("blur", focusRippleHide);
}
function mounted(el2, binding) {
  updateRipple(el2, binding, false);
}
function unmounted(el2) {
  delete el2._ripple;
  removeListeners(el2);
}
function updated(el2, binding) {
  if (binding.value === binding.oldValue) {
    return;
  }
  const wasEnabled = isRippleEnabled(binding.oldValue);
  updateRipple(el2, binding, wasEnabled);
}
const Ripple = {
  mounted,
  unmounted,
  updated
};
const makeSelectionControlProps = propsFactory({
  label: String,
  trueValue: null,
  falseValue: null,
  value: null,
  ...makeSelectionControlGroupProps()
}, "v-selection-control");
function useSelectionControl(props) {
  const group = inject$1(VSelectionControlGroupSymbol, void 0);
  const {
    densityClasses
  } = useDensity(props);
  const modelValue = useProxiedModel(props, "modelValue");
  const trueValue = computed(() => props.trueValue !== void 0 ? props.trueValue : props.value !== void 0 ? props.value : true);
  const falseValue = computed(() => props.falseValue !== void 0 ? props.falseValue : false);
  const isMultiple = computed(() => !!props.multiple || props.multiple == null && Array.isArray(modelValue.value));
  const model = computed({
    get() {
      const val = group ? group.modelValue.value : modelValue.value;
      return isMultiple.value ? val.some((v) => props.valueComparator(v, trueValue.value)) : props.valueComparator(val, trueValue.value);
    },
    set(val) {
      if (props.readonly)
        return;
      const currentValue = val ? trueValue.value : falseValue.value;
      let newVal = currentValue;
      if (isMultiple.value) {
        newVal = val ? [...wrapInArray(modelValue.value), currentValue] : wrapInArray(modelValue.value).filter((item) => !props.valueComparator(item, trueValue.value));
      }
      if (group) {
        group.modelValue.value = newVal;
      } else {
        modelValue.value = newVal;
      }
    }
  });
  const {
    textColorClasses,
    textColorStyles
  } = useTextColor(computed(() => {
    return model.value && !props.error && !props.disabled ? props.color : void 0;
  }));
  const icon = computed(() => model.value ? props.trueIcon : props.falseIcon);
  return {
    group,
    densityClasses,
    trueValue,
    falseValue,
    model,
    textColorClasses,
    textColorStyles,
    icon
  };
}
const VSelectionControl = genericComponent()({
  name: "VSelectionControl",
  directives: {
    Ripple
  },
  inheritAttrs: false,
  props: makeSelectionControlProps(),
  emits: {
    "update:modelValue": (val) => true
  },
  setup(props, _ref) {
    let {
      attrs,
      slots
    } = _ref;
    const {
      group,
      densityClasses,
      icon,
      model,
      textColorClasses,
      textColorStyles,
      trueValue
    } = useSelectionControl(props);
    const uid2 = getUid();
    const id = computed(() => props.id || `input-${uid2}`);
    const isFocused = ref(false);
    const isFocusVisible = ref(false);
    const input = ref();
    group == null ? void 0 : group.onForceUpdate(() => {
      if (input.value) {
        input.value.checked = model.value;
      }
    });
    function onFocus(e3) {
      isFocused.value = true;
      if (!SUPPORTS_FOCUS_VISIBLE || SUPPORTS_FOCUS_VISIBLE && e3.target.matches(":focus-visible")) {
        isFocusVisible.value = true;
      }
    }
    function onBlur() {
      isFocused.value = false;
      isFocusVisible.value = false;
    }
    function onInput(e3) {
      if (props.readonly && group) {
        nextTick(() => group.forceUpdate());
      }
      model.value = e3.target.checked;
    }
    useRender(() => {
      var _slots$default, _slots$input;
      const label = slots.label ? slots.label({
        label: props.label,
        props: {
          for: id.value
        }
      }) : props.label;
      const [rootAttrs, inputAttrs] = filterInputAttrs(attrs);
      return createVNode("div", mergeProps({
        "class": ["v-selection-control", {
          "v-selection-control--dirty": model.value,
          "v-selection-control--disabled": props.disabled,
          "v-selection-control--error": props.error,
          "v-selection-control--focused": isFocused.value,
          "v-selection-control--focus-visible": isFocusVisible.value,
          "v-selection-control--inline": props.inline
        }, densityClasses.value]
      }, rootAttrs), [createVNode("div", {
        "class": ["v-selection-control__wrapper", textColorClasses.value],
        "style": textColorStyles.value
      }, [(_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots), withDirectives(createVNode("div", {
        "class": ["v-selection-control__input"]
      }, [icon.value && createVNode(VIcon, {
        "key": "icon",
        "icon": icon.value
      }, null), createVNode("input", mergeProps({
        "ref": input,
        "checked": model.value,
        "disabled": props.disabled,
        "id": id.value,
        "onBlur": onBlur,
        "onFocus": onFocus,
        "onInput": onInput,
        "aria-disabled": props.readonly,
        "type": props.type,
        "value": trueValue.value,
        "name": props.name,
        "aria-checked": props.type === "checkbox" ? model.value : void 0
      }, inputAttrs), null), (_slots$input = slots.input) == null ? void 0 : _slots$input.call(slots, {
        model,
        textColorClasses,
        textColorStyles,
        props: {
          onFocus,
          onBlur,
          id: id.value
        }
      })]), [[resolveDirective("ripple"), props.ripple && [!props.disabled && !props.readonly, null, ["center", "circle"]]]])]), label && createVNode(VLabel, {
        "for": id.value,
        "clickable": true
      }, {
        default: () => [label]
      })]);
    });
    return {
      isFocused,
      input
    };
  }
});
function filterControlProps(props) {
  return pick(props, Object.keys(VSelectionControl.props));
}
const makeVCheckboxBtnProps = propsFactory({
  indeterminate: Boolean,
  indeterminateIcon: {
    type: IconValue,
    default: "$checkboxIndeterminate"
  },
  ...makeSelectionControlProps({
    falseIcon: "$checkboxOff",
    trueIcon: "$checkboxOn"
  })
}, "v-checkbox-btn");
const VCheckboxBtn = defineComponent({
  name: "VCheckboxBtn",
  props: makeVCheckboxBtnProps(),
  emits: {
    "update:modelValue": (value) => true,
    "update:indeterminate": (val) => true
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const indeterminate = useProxiedModel(props, "indeterminate");
    const model = useProxiedModel(props, "modelValue");
    function onChange(v) {
      if (indeterminate.value) {
        indeterminate.value = false;
      }
    }
    const falseIcon = computed(() => {
      return props.indeterminate ? props.indeterminateIcon : props.falseIcon;
    });
    const trueIcon = computed(() => {
      return props.indeterminate ? props.indeterminateIcon : props.trueIcon;
    });
    useRender(() => createVNode(VSelectionControl, mergeProps(props, {
      "modelValue": model.value,
      "onUpdate:modelValue": [($event) => model.value = $event, onChange],
      "class": "v-checkbox-btn",
      "type": "checkbox",
      "inline": true,
      "falseIcon": falseIcon.value,
      "trueIcon": trueIcon.value,
      "aria-checked": props.indeterminate ? "mixed" : void 0
    }), slots));
    return {};
  }
});
function filterCheckboxBtnProps(props) {
  return pick(props, Object.keys(VCheckboxBtn.props));
}
const VCheckbox = defineComponent({
  name: "VCheckbox",
  inheritAttrs: false,
  props: {
    ...makeVInputProps(),
    ...makeVCheckboxBtnProps()
  },
  emits: {
    "update:focused": (focused) => true
  },
  setup(props, _ref) {
    let {
      attrs,
      slots
    } = _ref;
    const {
      isFocused,
      focus,
      blur
    } = useFocus(props);
    const uid2 = getUid();
    const id = computed(() => props.id || `checkbox-${uid2}`);
    useRender(() => {
      const [inputAttrs, controlAttrs] = filterInputAttrs(attrs);
      const [inputProps, _1] = filterInputProps(props);
      const [checkboxProps, _2] = filterCheckboxBtnProps(props);
      return createVNode(VInput, mergeProps({
        "class": "v-checkbox"
      }, inputAttrs, inputProps, {
        "id": id.value,
        "focused": isFocused.value
      }), {
        ...slots,
        default: (_ref2) => {
          let {
            id: id2,
            messagesId,
            isDisabled,
            isReadonly: isReadonly2
          } = _ref2;
          return createVNode(VCheckboxBtn, mergeProps(checkboxProps, {
            "id": id2.value,
            "aria-describedby": messagesId.value,
            "disabled": isDisabled.value,
            "readonly": isReadonly2.value
          }, controlAttrs, {
            "onFocus": focus,
            "onBlur": blur
          }), slots);
        }
      });
    });
    return {};
  }
});
const VChip$1 = "";
const VAvatar$1 = "";
const VImg$1 = "";
const VResponsive$1 = "";
const makeDimensionProps = propsFactory({
  height: [Number, String],
  maxHeight: [Number, String],
  maxWidth: [Number, String],
  minHeight: [Number, String],
  minWidth: [Number, String],
  width: [Number, String]
}, "dimension");
function useDimension(props) {
  const dimensionStyles = computed(() => ({
    height: convertToUnit(props.height),
    maxHeight: convertToUnit(props.maxHeight),
    maxWidth: convertToUnit(props.maxWidth),
    minHeight: convertToUnit(props.minHeight),
    minWidth: convertToUnit(props.minWidth),
    width: convertToUnit(props.width)
  }));
  return {
    dimensionStyles
  };
}
function useAspectStyles(props) {
  return {
    aspectStyles: computed(() => {
      const ratio = Number(props.aspectRatio);
      return ratio ? {
        paddingBottom: String(1 / ratio * 100) + "%"
      } : void 0;
    })
  };
}
const VResponsive = defineComponent({
  name: "VResponsive",
  props: {
    aspectRatio: [String, Number],
    contentClass: String,
    ...makeDimensionProps()
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const {
      aspectStyles
    } = useAspectStyles(props);
    const {
      dimensionStyles
    } = useDimension(props);
    useRender(() => {
      var _slots$additional;
      return createVNode("div", {
        "class": "v-responsive",
        "style": dimensionStyles.value
      }, [createVNode("div", {
        "class": "v-responsive__sizer",
        "style": aspectStyles.value
      }, null), (_slots$additional = slots.additional) == null ? void 0 : _slots$additional.call(slots), slots.default && createVNode("div", {
        "class": ["v-responsive__content", props.contentClass]
      }, [slots.default()])]);
    });
    return {};
  }
});
const VImg = defineComponent({
  name: "VImg",
  directives: {
    intersect
  },
  props: {
    aspectRatio: [String, Number],
    alt: String,
    cover: Boolean,
    eager: Boolean,
    gradient: String,
    lazySrc: String,
    options: {
      type: Object,
      default: () => ({
        root: void 0,
        rootMargin: void 0,
        threshold: void 0
      })
    },
    sizes: String,
    src: {
      type: [String, Object],
      default: ""
    },
    srcset: String,
    width: [String, Number],
    ...makeTransitionProps()
  },
  emits: {
    loadstart: (event) => true,
    load: (event) => true,
    error: (event) => true
  },
  setup(props, _ref) {
    let {
      emit: emit2,
      slots
    } = _ref;
    const currentSrc = ref("");
    const image = ref();
    const state = ref(props.eager ? "loading" : "idle");
    const naturalWidth = ref();
    const naturalHeight = ref();
    const normalisedSrc = computed(() => {
      return props.src && typeof props.src === "object" ? {
        src: props.src.src,
        srcset: props.srcset || props.src.srcset,
        lazySrc: props.lazySrc || props.src.lazySrc,
        aspect: Number(props.aspectRatio || props.src.aspect || 0)
      } : {
        src: props.src,
        srcset: props.srcset,
        lazySrc: props.lazySrc,
        aspect: Number(props.aspectRatio || 0)
      };
    });
    const aspectRatio = computed(() => {
      return normalisedSrc.value.aspect || naturalWidth.value / naturalHeight.value || 0;
    });
    watch(() => props.src, () => {
      init(state.value !== "idle");
    });
    watch(aspectRatio, (val, oldVal) => {
      if (!val && oldVal && image.value) {
        pollForSize(image.value);
      }
    });
    onBeforeMount(() => init());
    function init(isIntersecting) {
      if (props.eager && isIntersecting)
        return;
      if (SUPPORTS_INTERSECTION && !isIntersecting && !props.eager)
        return;
      state.value = "loading";
      if (normalisedSrc.value.lazySrc) {
        const lazyImg = new Image();
        lazyImg.src = normalisedSrc.value.lazySrc;
        pollForSize(lazyImg, null);
      }
      if (!normalisedSrc.value.src)
        return;
      nextTick(() => {
        var _image$value, _image$value2;
        emit2("loadstart", ((_image$value = image.value) == null ? void 0 : _image$value.currentSrc) || normalisedSrc.value.src);
        if ((_image$value2 = image.value) != null && _image$value2.complete) {
          if (!image.value.naturalWidth) {
            onError();
          }
          if (state.value === "error")
            return;
          if (!aspectRatio.value)
            pollForSize(image.value, null);
          onLoad();
        } else {
          if (!aspectRatio.value)
            pollForSize(image.value);
          getSrc();
        }
      });
    }
    function onLoad() {
      var _image$value3;
      getSrc();
      state.value = "loaded";
      emit2("load", ((_image$value3 = image.value) == null ? void 0 : _image$value3.currentSrc) || normalisedSrc.value.src);
    }
    function onError() {
      var _image$value4;
      state.value = "error";
      emit2("error", ((_image$value4 = image.value) == null ? void 0 : _image$value4.currentSrc) || normalisedSrc.value.src);
    }
    function getSrc() {
      const img = image.value;
      if (img)
        currentSrc.value = img.currentSrc || img.src;
    }
    let timer = -1;
    function pollForSize(img) {
      let timeout = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 100;
      const poll = () => {
        clearTimeout(timer);
        const {
          naturalHeight: imgHeight,
          naturalWidth: imgWidth
        } = img;
        if (imgHeight || imgWidth) {
          naturalWidth.value = imgWidth;
          naturalHeight.value = imgHeight;
        } else if (!img.complete && state.value === "loading" && timeout != null) {
          timer = window.setTimeout(poll, timeout);
        } else if (img.currentSrc.endsWith(".svg") || img.currentSrc.startsWith("data:image/svg+xml")) {
          naturalWidth.value = 1;
          naturalHeight.value = 1;
        }
      };
      poll();
    }
    const containClasses = computed(() => ({
      "v-img__img--cover": props.cover,
      "v-img__img--contain": !props.cover
    }));
    const __image = () => {
      var _slots$sources;
      if (!normalisedSrc.value.src || state.value === "idle")
        return null;
      const img = createVNode("img", {
        "class": ["v-img__img", containClasses.value],
        "src": normalisedSrc.value.src,
        "srcset": normalisedSrc.value.srcset,
        "alt": "",
        "sizes": props.sizes,
        "ref": image,
        "onLoad": onLoad,
        "onError": onError
      }, null);
      const sources = (_slots$sources = slots.sources) == null ? void 0 : _slots$sources.call(slots);
      return createVNode(MaybeTransition, {
        "transition": props.transition,
        "appear": true
      }, {
        default: () => [withDirectives(sources ? createVNode("picture", {
          "class": "v-img__picture"
        }, [sources, img]) : img, [[vShow, state.value === "loaded"]])]
      });
    };
    const __preloadImage = () => createVNode(MaybeTransition, {
      "transition": props.transition
    }, {
      default: () => [normalisedSrc.value.lazySrc && state.value !== "loaded" && createVNode("img", {
        "class": ["v-img__img", "v-img__img--preload", containClasses.value],
        "src": normalisedSrc.value.lazySrc,
        "alt": ""
      }, null)]
    });
    const __placeholder = () => {
      if (!slots.placeholder)
        return null;
      return createVNode(MaybeTransition, {
        "transition": props.transition,
        "appear": true
      }, {
        default: () => [(state.value === "loading" || state.value === "error" && !slots.error) && createVNode("div", {
          "class": "v-img__placeholder"
        }, [slots.placeholder()])]
      });
    };
    const __error = () => {
      if (!slots.error)
        return null;
      return createVNode(MaybeTransition, {
        "transition": props.transition,
        "appear": true
      }, {
        default: () => [state.value === "error" && createVNode("div", {
          "class": "v-img__error"
        }, [slots.error()])]
      });
    };
    const __gradient = () => {
      if (!props.gradient)
        return null;
      return createVNode("div", {
        "class": "v-img__gradient",
        "style": {
          backgroundImage: `linear-gradient(${props.gradient})`
        }
      }, null);
    };
    const isBooted = ref(false);
    {
      const stop = watch(aspectRatio, (val) => {
        if (val) {
          requestAnimationFrame(() => {
            requestAnimationFrame(() => {
              isBooted.value = true;
            });
          });
          stop();
        }
      });
    }
    useRender(() => withDirectives(createVNode(VResponsive, {
      "class": ["v-img", {
        "v-img--booting": !isBooted.value
      }],
      "style": {
        width: convertToUnit(props.width === "auto" ? naturalWidth.value : props.width)
      },
      "aspectRatio": aspectRatio.value,
      "aria-label": props.alt,
      "role": props.alt ? "img" : void 0
    }, {
      additional: () => createVNode(Fragment, null, [createVNode(__image, null, null), createVNode(__preloadImage, null, null), createVNode(__gradient, null, null), createVNode(__placeholder, null, null), createVNode(__error, null, null)]),
      default: slots.default
    }), [[resolveDirective("intersect"), {
      handler: init,
      options: props.options
    }, null, {
      once: true
    }]]));
    return {
      currentSrc,
      image,
      state,
      naturalWidth,
      naturalHeight
    };
  }
});
const allowedVariants = ["elevated", "flat", "tonal", "outlined", "text", "plain"];
function genOverlays(isClickable, name2) {
  return createVNode(Fragment, null, [isClickable && createVNode("span", {
    "key": "overlay",
    "class": `${name2}__overlay`
  }, null), createVNode("span", {
    "key": "underlay",
    "class": `${name2}__underlay`
  }, null)]);
}
const makeVariantProps = propsFactory({
  color: String,
  variant: {
    type: String,
    default: "elevated",
    validator: (v) => allowedVariants.includes(v)
  }
}, "variant");
function useVariant(props) {
  let name2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
  const variantClasses = computed(() => {
    const {
      variant
    } = unref(props);
    return `${name2}--variant-${variant}`;
  });
  const {
    colorClasses,
    colorStyles
  } = useColor(computed(() => {
    const {
      variant,
      color
    } = unref(props);
    return {
      [["elevated", "flat"].includes(variant) ? "background" : "text"]: color
    };
  }));
  return {
    colorClasses,
    colorStyles,
    variantClasses
  };
}
const makeVAvatarProps = propsFactory({
  start: Boolean,
  end: Boolean,
  icon: IconValue,
  image: String,
  ...makeDensityProps(),
  ...makeRoundedProps(),
  ...makeSizeProps(),
  ...makeTagProps(),
  ...makeThemeProps(),
  ...makeVariantProps({
    variant: "flat"
  })
}, "v-avatar");
const VAvatar = defineComponent({
  name: "VAvatar",
  props: makeVAvatarProps(),
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const {
      themeClasses
    } = provideTheme(props);
    const {
      colorClasses,
      colorStyles,
      variantClasses
    } = useVariant(props);
    const {
      densityClasses
    } = useDensity(props);
    const {
      roundedClasses
    } = useRounded(props);
    const {
      sizeClasses,
      sizeStyles
    } = useSize(props);
    useRender(() => {
      var _slots$default;
      return createVNode(props.tag, {
        "class": ["v-avatar", {
          "v-avatar--start": props.start,
          "v-avatar--end": props.end
        }, themeClasses.value, colorClasses.value, densityClasses.value, roundedClasses.value, sizeClasses.value, variantClasses.value],
        "style": [colorStyles.value, sizeStyles.value]
      }, {
        default: () => [props.image ? createVNode(VImg, {
          "key": "image",
          "src": props.image,
          "alt": "",
          "cover": true
        }, null) : props.icon ? createVNode(VIcon, {
          "key": "icon",
          "icon": props.icon
        }, null) : (_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots), genOverlays(false, "v-avatar")]
      });
    });
    return {};
  }
});
const VChipGroup = "";
const makeGroupProps = propsFactory({
  modelValue: {
    type: null,
    default: void 0
  },
  multiple: Boolean,
  mandatory: [Boolean, String],
  max: Number,
  selectedClass: String,
  disabled: Boolean
}, "group");
const makeGroupItemProps = propsFactory({
  value: null,
  disabled: Boolean,
  selectedClass: String
}, "group-item");
function useGroupItem(props, injectKey) {
  let required = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
  const vm = getCurrentInstance("useGroupItem");
  if (!vm) {
    throw new Error("[Vuetify] useGroupItem composable must be used inside a component setup function");
  }
  const id = getUid();
  provide(Symbol.for(`${injectKey.description}:id`), id);
  const group = inject$1(injectKey, null);
  if (!group) {
    if (!required)
      return group;
    throw new Error(`[Vuetify] Could not find useGroup injection with symbol ${injectKey.description}`);
  }
  const value = toRef(props, "value");
  const disabled = computed(() => group.disabled.value || props.disabled);
  group.register({
    id,
    value,
    disabled
  }, vm);
  onBeforeUnmount(() => {
    group.unregister(id);
  });
  const isSelected = computed(() => {
    return group.isSelected(id);
  });
  const selectedClass = computed(() => isSelected.value && [group.selectedClass.value, props.selectedClass]);
  watch(isSelected, (value2) => {
    vm.emit("group:selected", {
      value: value2
    });
  });
  return {
    id,
    isSelected,
    toggle: () => group.select(id, !isSelected.value),
    select: (value2) => group.select(id, value2),
    selectedClass,
    value,
    disabled,
    group
  };
}
function useGroup(props, injectKey) {
  let isUnmounted = false;
  const items = reactive([]);
  const selected = useProxiedModel(props, "modelValue", [], (v) => {
    if (v == null)
      return [];
    return getIds(items, wrapInArray(v));
  }, (v) => {
    const arr = getValues(items, v);
    return props.multiple ? arr : arr[0];
  });
  const groupVm = getCurrentInstance("useGroup");
  function register(item, vm) {
    const unwrapped = item;
    const key = Symbol.for(`${injectKey.description}:id`);
    const children = findChildrenWithProvide(key, groupVm == null ? void 0 : groupVm.vnode);
    const index2 = children.indexOf(vm);
    if (index2 > -1) {
      items.splice(index2, 0, unwrapped);
    } else {
      items.push(unwrapped);
    }
  }
  function unregister(id) {
    if (isUnmounted)
      return;
    forceMandatoryValue();
    const index2 = items.findIndex((item) => item.id === id);
    items.splice(index2, 1);
  }
  function forceMandatoryValue() {
    const item = items.find((item2) => !item2.disabled);
    if (item && props.mandatory === "force" && !selected.value.length) {
      selected.value = [item.id];
    }
  }
  onMounted(() => {
    forceMandatoryValue();
  });
  onBeforeUnmount(() => {
    isUnmounted = true;
  });
  function select(id, value) {
    const item = items.find((item2) => item2.id === id);
    if (value && item != null && item.disabled)
      return;
    if (props.multiple) {
      const internalValue = selected.value.slice();
      const index2 = internalValue.findIndex((v) => v === id);
      const isSelected = ~index2;
      value = value != null ? value : !isSelected;
      if (isSelected && props.mandatory && internalValue.length <= 1)
        return;
      if (!isSelected && props.max != null && internalValue.length + 1 > props.max)
        return;
      if (index2 < 0 && value)
        internalValue.push(id);
      else if (index2 >= 0 && !value)
        internalValue.splice(index2, 1);
      selected.value = internalValue;
    } else {
      const isSelected = selected.value.includes(id);
      if (props.mandatory && isSelected)
        return;
      selected.value = (value != null ? value : !isSelected) ? [id] : [];
    }
  }
  function step(offset) {
    if (props.multiple)
      consoleWarn('This method is not supported when using "multiple" prop');
    if (!selected.value.length) {
      const item = items.find((item2) => !item2.disabled);
      item && (selected.value = [item.id]);
    } else {
      const currentId = selected.value[0];
      const currentIndex = items.findIndex((i2) => i2.id === currentId);
      let newIndex = (currentIndex + offset) % items.length;
      let newItem = items[newIndex];
      while (newItem.disabled && newIndex !== currentIndex) {
        newIndex = (newIndex + offset) % items.length;
        newItem = items[newIndex];
      }
      if (newItem.disabled)
        return;
      selected.value = [items[newIndex].id];
    }
  }
  const state = {
    register,
    unregister,
    selected,
    select,
    disabled: toRef(props, "disabled"),
    prev: () => step(items.length - 1),
    next: () => step(1),
    isSelected: (id) => selected.value.includes(id),
    selectedClass: computed(() => props.selectedClass),
    items: computed(() => items),
    getItemIndex: (value) => getItemIndex(items, value)
  };
  provide(injectKey, state);
  return state;
}
function getItemIndex(items, value) {
  const ids = getIds(items, [value]);
  if (!ids.length)
    return -1;
  return items.findIndex((item) => item.id === ids[0]);
}
function getIds(items, modelValue) {
  const ids = [];
  for (let i2 = 0; i2 < items.length; i2++) {
    const item = items[i2];
    if (item.value != null) {
      if (modelValue.find((value) => deepEqual(value, item.value)) != null) {
        ids.push(item.id);
      }
    } else if (modelValue.includes(i2)) {
      ids.push(item.id);
    }
  }
  return ids;
}
function getValues(items, ids) {
  const values = [];
  for (let i2 = 0; i2 < items.length; i2++) {
    const item = items[i2];
    if (ids.includes(item.id)) {
      values.push(item.value != null ? item.value : i2);
    }
  }
  return values;
}
const VChipGroupSymbol = Symbol.for("vuetify:v-chip-group");
defineComponent({
  name: "VChipGroup",
  props: {
    column: Boolean,
    filter: Boolean,
    valueComparator: {
      type: Function,
      default: deepEqual
    },
    ...makeGroupProps({
      selectedClass: "v-chip--selected"
    }),
    ...makeTagProps(),
    ...makeThemeProps(),
    ...makeVariantProps({
      variant: "tonal"
    })
  },
  emits: {
    "update:modelValue": (value) => true
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const {
      themeClasses
    } = provideTheme(props);
    const {
      isSelected,
      select,
      next,
      prev,
      selected
    } = useGroup(props, VChipGroupSymbol);
    provideDefaults({
      VChip: {
        color: toRef(props, "color"),
        disabled: toRef(props, "disabled"),
        filter: toRef(props, "filter"),
        variant: toRef(props, "variant")
      }
    });
    useRender(() => {
      var _slots$default;
      return createVNode(props.tag, {
        "class": ["v-chip-group", {
          "v-chip-group--column": props.column
        }, themeClasses.value]
      }, {
        default: () => [(_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots, {
          isSelected,
          select,
          next,
          prev,
          selected: selected.value
        })]
      });
    });
    return {};
  }
});
const VDefaultsProvider = defineComponent$1({
  name: "VDefaultsProvider",
  props: {
    defaults: Object,
    reset: [Number, String],
    root: Boolean,
    scoped: Boolean
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const {
      defaults: defaults2,
      reset,
      root,
      scoped
    } = toRefs(props);
    provideDefaults(defaults2, {
      reset,
      root,
      scoped
    });
    return () => {
      var _slots$default;
      return (_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots);
    };
  }
});
const makeBorderProps = propsFactory({
  border: [Boolean, Number, String]
}, "border");
function useBorder(props) {
  let name2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
  const borderClasses = computed(() => {
    const border = isRef(props) ? props.value : props.border;
    const classes = [];
    if (border === true || border === "") {
      classes.push(`${name2}--border`);
    } else if (typeof border === "string" || border === 0) {
      for (const value of String(border).split(" ")) {
        classes.push(`border-${value}`);
      }
    }
    return classes;
  });
  return {
    borderClasses
  };
}
const makeElevationProps = propsFactory({
  elevation: {
    type: [Number, String],
    validator(v) {
      const value = parseInt(v);
      return !isNaN(value) && value >= 0 && value <= 24;
    }
  }
}, "elevation");
function useElevation(props) {
  const elevationClasses = computed(() => {
    const elevation = isRef(props) ? props.value : props.elevation;
    const classes = [];
    if (elevation == null)
      return classes;
    classes.push(`elevation-${elevation}`);
    return classes;
  });
  return {
    elevationClasses
  };
}
function useRouter() {
  var _getCurrentInstance, _getCurrentInstance$p;
  return (_getCurrentInstance = getCurrentInstance("useRouter")) == null ? void 0 : (_getCurrentInstance$p = _getCurrentInstance.proxy) == null ? void 0 : _getCurrentInstance$p.$router;
}
function useLink(props, attrs) {
  const RouterLink = resolveDynamicComponent("RouterLink");
  const isLink = computed(() => !!(props.href || props.to));
  const isClickable = computed(() => {
    return (isLink == null ? void 0 : isLink.value) || hasEvent(attrs, "click") || hasEvent(props, "click");
  });
  if (typeof RouterLink === "string") {
    return {
      isLink,
      isClickable,
      href: toRef(props, "href")
    };
  }
  const link = props.to ? RouterLink.useLink(props) : void 0;
  return {
    isLink,
    isClickable,
    route: link == null ? void 0 : link.route,
    navigate: link == null ? void 0 : link.navigate,
    isActive: link && computed(() => {
      var _link$isExactActive, _link$isActive;
      return props.exact ? (_link$isExactActive = link.isExactActive) == null ? void 0 : _link$isExactActive.value : (_link$isActive = link.isActive) == null ? void 0 : _link$isActive.value;
    }),
    href: computed(() => props.to ? link == null ? void 0 : link.route.value.href : props.href)
  };
}
const makeRouterProps = propsFactory({
  href: String,
  replace: Boolean,
  to: [String, Object],
  exact: Boolean
}, "router");
let inTransition = false;
function useBackButton(router, cb) {
  let popped = false;
  let removeBefore;
  let removeAfter;
  if (IN_BROWSER) {
    nextTick(() => {
      window.addEventListener("popstate", onPopstate);
      removeBefore = router == null ? void 0 : router.beforeEach((to, from, next) => {
        if (!inTransition) {
          setTimeout(() => popped ? cb(next) : next());
        } else {
          popped ? cb(next) : next();
        }
        inTransition = true;
      });
      removeAfter = router == null ? void 0 : router.afterEach(() => {
        inTransition = false;
      });
    });
    onScopeDispose(() => {
      var _removeBefore, _removeAfter;
      window.removeEventListener("popstate", onPopstate);
      (_removeBefore = removeBefore) == null ? void 0 : _removeBefore();
      (_removeAfter = removeAfter) == null ? void 0 : _removeAfter();
    });
  }
  function onPopstate(e3) {
    var _e$state;
    if ((_e$state = e3.state) != null && _e$state.replaced)
      return;
    popped = true;
    setTimeout(() => popped = false);
  }
}
const VChip = defineComponent({
  name: "VChip",
  directives: {
    Ripple
  },
  props: {
    activeClass: String,
    appendAvatar: String,
    appendIcon: IconValue,
    closable: Boolean,
    closeIcon: {
      type: IconValue,
      default: "$delete"
    },
    closeLabel: {
      type: String,
      default: "$vuetify.close"
    },
    draggable: Boolean,
    filter: Boolean,
    filterIcon: {
      type: String,
      default: "$complete"
    },
    label: Boolean,
    link: {
      type: Boolean,
      default: void 0
    },
    pill: Boolean,
    prependAvatar: String,
    prependIcon: IconValue,
    ripple: {
      type: Boolean,
      default: true
    },
    text: String,
    modelValue: {
      type: Boolean,
      default: true
    },
    onClick: EventProp,
    onClickOnce: EventProp,
    ...makeBorderProps(),
    ...makeDensityProps(),
    ...makeElevationProps(),
    ...makeGroupItemProps(),
    ...makeRoundedProps(),
    ...makeRouterProps(),
    ...makeSizeProps(),
    ...makeTagProps({
      tag: "span"
    }),
    ...makeThemeProps(),
    ...makeVariantProps({
      variant: "tonal"
    })
  },
  emits: {
    "click:close": (e3) => true,
    "update:modelValue": (value) => true,
    "group:selected": (val) => true,
    click: (e3) => true
  },
  setup(props, _ref) {
    let {
      attrs,
      emit: emit2,
      slots
    } = _ref;
    const {
      t: t3
    } = useLocale();
    const {
      borderClasses
    } = useBorder(props);
    const {
      colorClasses,
      colorStyles,
      variantClasses
    } = useVariant(props);
    const {
      densityClasses
    } = useDensity(props);
    const {
      elevationClasses
    } = useElevation(props);
    const {
      roundedClasses
    } = useRounded(props);
    const {
      sizeClasses
    } = useSize(props);
    const {
      themeClasses
    } = provideTheme(props);
    const isActive = useProxiedModel(props, "modelValue");
    const group = useGroupItem(props, VChipGroupSymbol, false);
    const link = useLink(props, attrs);
    const isLink = computed(() => props.link !== false && link.isLink.value);
    const isClickable = computed(() => !props.disabled && props.link !== false && (!!group || props.link || link.isClickable.value));
    function onCloseClick(e3) {
      isActive.value = false;
      emit2("click:close", e3);
    }
    function onClick(e3) {
      var _link$navigate;
      emit2("click", e3);
      if (!isClickable.value)
        return;
      (_link$navigate = link.navigate) == null ? void 0 : _link$navigate.call(link, e3);
      group == null ? void 0 : group.toggle();
    }
    function onKeyDown(e3) {
      if (e3.key === "Enter" || e3.key === " ") {
        e3.preventDefault();
        onClick(e3);
      }
    }
    return () => {
      var _slots$default;
      const Tag = link.isLink.value ? "a" : props.tag;
      const hasAppend = !!(slots.append || props.appendIcon || props.appendAvatar);
      const hasClose = !!(slots.close || props.closable);
      const hasFilter = !!(slots.filter || props.filter) && group;
      const hasPrepend = !!(slots.prepend || props.prependIcon || props.prependAvatar);
      const hasColor = !group || group.isSelected.value;
      return isActive.value && withDirectives(createVNode(Tag, {
        "class": ["v-chip", {
          "v-chip--disabled": props.disabled,
          "v-chip--label": props.label,
          "v-chip--link": isClickable.value,
          "v-chip--filter": hasFilter,
          "v-chip--pill": props.pill
        }, themeClasses.value, borderClasses.value, hasColor ? colorClasses.value : void 0, densityClasses.value, elevationClasses.value, roundedClasses.value, sizeClasses.value, variantClasses.value, group == null ? void 0 : group.selectedClass.value],
        "style": [hasColor ? colorStyles.value : void 0],
        "disabled": props.disabled || void 0,
        "draggable": props.draggable,
        "href": link.href.value,
        "tabindex": isClickable.value ? 0 : void 0,
        "onClick": onClick,
        "onKeydown": isClickable.value && !isLink.value && onKeyDown
      }, {
        default: () => {
          var _a2;
          return [genOverlays(isClickable.value, "v-chip"), hasFilter && createVNode(VDefaultsProvider, {
            "key": "filter",
            "defaults": {
              VIcon: {
                icon: props.filterIcon
              }
            }
          }, {
            default: () => [createVNode(VExpandXTransition, null, {
              default: () => [withDirectives(createVNode("div", {
                "class": "v-chip__filter"
              }, [slots.filter ? slots.filter() : createVNode(VIcon, null, null)]), [[vShow, group.isSelected.value]])]
            })]
          }), hasPrepend && createVNode(VDefaultsProvider, {
            "key": "prepend",
            "defaults": {
              VAvatar: {
                image: props.prependAvatar
              },
              VIcon: {
                icon: props.prependIcon
              }
            }
          }, {
            default: () => [slots.prepend ? createVNode("div", {
              "class": "v-chip__prepend"
            }, [slots.prepend()]) : props.prependAvatar ? createVNode(VAvatar, {
              "start": true
            }, null) : props.prependIcon ? createVNode(VIcon, {
              "start": true
            }, null) : void 0]
          }), (_a2 = (_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots, {
            isSelected: group == null ? void 0 : group.isSelected.value,
            selectedClass: group == null ? void 0 : group.selectedClass.value,
            select: group == null ? void 0 : group.select,
            toggle: group == null ? void 0 : group.toggle,
            value: group == null ? void 0 : group.value.value,
            disabled: props.disabled
          })) != null ? _a2 : props.text, hasAppend && createVNode(VDefaultsProvider, {
            "key": "append",
            "defaults": {
              VAvatar: {
                image: props.appendAvatar
              },
              VIcon: {
                icon: props.appendIcon
              }
            }
          }, {
            default: () => [slots.append ? createVNode("div", {
              "class": "v-chip__append"
            }, [slots.append()]) : props.appendAvatar ? createVNode(VAvatar, {
              "end": true
            }, null) : props.appendIcon ? createVNode(VIcon, {
              "end": true
            }, null) : void 0]
          }), hasClose && createVNode(VDefaultsProvider, {
            "key": "close",
            "defaults": {
              VIcon: {
                icon: props.closeIcon,
                size: "x-small"
              }
            }
          }, {
            default: () => [createVNode("div", {
              "class": "v-chip__close",
              "aria-label": t3(props.closeLabel),
              "onClick": onCloseClick
            }, [slots.close ? slots.close() : createVNode(VIcon, null, null)])]
          })];
        }
      }), [[resolveDirective("ripple"), isClickable.value && props.ripple, null]]);
    };
  }
});
const VList$1 = "";
const VDivider$1 = "";
const VDivider = defineComponent({
  name: "VDivider",
  props: {
    color: String,
    inset: Boolean,
    length: [Number, String],
    thickness: [Number, String],
    vertical: Boolean,
    ...makeThemeProps()
  },
  setup(props, _ref) {
    let {
      attrs
    } = _ref;
    const {
      themeClasses
    } = provideTheme(props);
    const {
      textColorClasses,
      textColorStyles
    } = useTextColor(toRef(props, "color"));
    const dividerStyles = computed(() => {
      const styles = {};
      if (props.length) {
        styles[props.vertical ? "maxHeight" : "maxWidth"] = convertToUnit(props.length);
      }
      if (props.thickness) {
        styles[props.vertical ? "borderRightWidth" : "borderTopWidth"] = convertToUnit(props.thickness);
      }
      return styles;
    });
    useRender(() => createVNode("hr", {
      "class": [{
        "v-divider": true,
        "v-divider--inset": props.inset,
        "v-divider--vertical": props.vertical
      }, themeClasses.value, textColorClasses.value],
      "style": [dividerStyles.value, textColorStyles.value],
      "aria-orientation": !attrs.role || attrs.role === "separator" ? props.vertical ? "vertical" : "horizontal" : void 0,
      "role": `${attrs.role || "separator"}`
    }, null));
    return {};
  }
});
const ListKey = Symbol.for("vuetify:list");
function createList() {
  const parent = inject$1(ListKey, {
    hasPrepend: ref(false),
    updateHasPrepend: () => null
  });
  const data = {
    hasPrepend: ref(false),
    updateHasPrepend: (value) => {
      if (value)
        data.hasPrepend.value = value;
    }
  };
  provide(ListKey, data);
  return parent;
}
function useList() {
  return inject$1(ListKey, null);
}
const singleOpenStrategy = {
  open: (_ref) => {
    let {
      id,
      value,
      opened,
      parents
    } = _ref;
    if (value) {
      const newOpened = /* @__PURE__ */ new Set();
      newOpened.add(id);
      let parent = parents.get(id);
      while (parent != null) {
        newOpened.add(parent);
        parent = parents.get(parent);
      }
      return newOpened;
    } else {
      opened.delete(id);
      return opened;
    }
  },
  select: () => null
};
const multipleOpenStrategy = {
  open: (_ref2) => {
    let {
      id,
      value,
      opened,
      parents
    } = _ref2;
    if (value) {
      let parent = parents.get(id);
      opened.add(id);
      while (parent != null && parent !== id) {
        opened.add(parent);
        parent = parents.get(parent);
      }
      return opened;
    } else {
      opened.delete(id);
    }
    return opened;
  },
  select: () => null
};
const listOpenStrategy = {
  open: multipleOpenStrategy.open,
  select: (_ref3) => {
    let {
      id,
      value,
      opened,
      parents
    } = _ref3;
    if (!value)
      return opened;
    const path = [];
    let parent = parents.get(id);
    while (parent != null) {
      path.push(parent);
      parent = parents.get(parent);
    }
    return new Set(path);
  }
};
const independentSelectStrategy = (mandatory) => {
  const strategy = {
    select: (_ref) => {
      let {
        id,
        value,
        selected
      } = _ref;
      if (mandatory && !value) {
        const on = Array.from(selected.entries()).reduce((arr, _ref2) => {
          let [key, value2] = _ref2;
          return value2 === "on" ? [...arr, key] : arr;
        }, []);
        if (on.length === 1 && on[0] === id)
          return selected;
      }
      selected.set(id, value ? "on" : "off");
      return selected;
    },
    in: (v, children, parents) => {
      let map = /* @__PURE__ */ new Map();
      for (const id of v || []) {
        map = strategy.select({
          id,
          value: true,
          selected: new Map(map),
          children,
          parents
        });
      }
      return map;
    },
    out: (v) => {
      const arr = [];
      for (const [key, value] of v.entries()) {
        if (value === "on")
          arr.push(key);
      }
      return arr;
    }
  };
  return strategy;
};
const independentSingleSelectStrategy = (mandatory) => {
  const parentStrategy = independentSelectStrategy(mandatory);
  const strategy = {
    select: (_ref3) => {
      let {
        selected,
        id,
        ...rest
      } = _ref3;
      const singleSelected = selected.has(id) ? /* @__PURE__ */ new Map([[id, selected.get(id)]]) : /* @__PURE__ */ new Map();
      return parentStrategy.select({
        ...rest,
        id,
        selected: singleSelected
      });
    },
    in: (v, children, parents) => {
      let map = /* @__PURE__ */ new Map();
      if (v != null && v.length) {
        map = parentStrategy.in(v.slice(0, 1), children, parents);
      }
      return map;
    },
    out: (v, children, parents) => {
      return parentStrategy.out(v, children, parents);
    }
  };
  return strategy;
};
const leafSelectStrategy = (mandatory) => {
  const parentStrategy = independentSelectStrategy(mandatory);
  const strategy = {
    select: (_ref4) => {
      let {
        id,
        selected,
        children,
        ...rest
      } = _ref4;
      if (children.has(id))
        return selected;
      return parentStrategy.select({
        id,
        selected,
        children,
        ...rest
      });
    },
    in: parentStrategy.in,
    out: parentStrategy.out
  };
  return strategy;
};
const leafSingleSelectStrategy = (mandatory) => {
  const parentStrategy = independentSingleSelectStrategy(mandatory);
  const strategy = {
    select: (_ref5) => {
      let {
        id,
        selected,
        children,
        ...rest
      } = _ref5;
      if (children.has(id))
        return selected;
      return parentStrategy.select({
        id,
        selected,
        children,
        ...rest
      });
    },
    in: parentStrategy.in,
    out: parentStrategy.out
  };
  return strategy;
};
const classicSelectStrategy = (mandatory) => {
  const strategy = {
    select: (_ref6) => {
      let {
        id,
        value,
        selected,
        children,
        parents
      } = _ref6;
      const original = new Map(selected);
      const items = [id];
      while (items.length) {
        const item = items.shift();
        selected.set(item, value ? "on" : "off");
        if (children.has(item)) {
          items.push(...children.get(item));
        }
      }
      let parent = parents.get(id);
      while (parent) {
        const childrenIds = children.get(parent);
        const everySelected = childrenIds.every((cid) => selected.get(cid) === "on");
        const noneSelected = childrenIds.every((cid) => !selected.has(cid) || selected.get(cid) === "off");
        selected.set(parent, everySelected ? "on" : noneSelected ? "off" : "indeterminate");
        parent = parents.get(parent);
      }
      if (mandatory && !value) {
        const on = Array.from(selected.entries()).reduce((arr, _ref7) => {
          let [key, value2] = _ref7;
          return value2 === "on" ? [...arr, key] : arr;
        }, []);
        if (on.length === 0)
          return original;
      }
      return selected;
    },
    in: (v, children, parents) => {
      let map = /* @__PURE__ */ new Map();
      for (const id of v || []) {
        map = strategy.select({
          id,
          value: true,
          selected: new Map(map),
          children,
          parents
        });
      }
      return map;
    },
    out: (v, children) => {
      const arr = [];
      for (const [key, value] of v.entries()) {
        if (value === "on" && !children.has(key))
          arr.push(key);
      }
      return arr;
    }
  };
  return strategy;
};
const VNestedSymbol = Symbol.for("vuetify:nested");
const emptyNested = {
  id: ref(),
  root: {
    register: () => null,
    unregister: () => null,
    parents: ref(/* @__PURE__ */ new Map()),
    children: ref(/* @__PURE__ */ new Map()),
    open: () => null,
    openOnSelect: () => null,
    select: () => null,
    opened: ref(/* @__PURE__ */ new Set()),
    selected: ref(/* @__PURE__ */ new Map()),
    selectedValues: ref([])
  }
};
const makeNestedProps = propsFactory({
  selectStrategy: [String, Function],
  openStrategy: [String, Object],
  opened: Array,
  selected: Array,
  mandatory: Boolean
}, "nested");
const useNested = (props) => {
  let isUnmounted = false;
  const children = ref(/* @__PURE__ */ new Map());
  const parents = ref(/* @__PURE__ */ new Map());
  const opened = useProxiedModel(props, "opened", props.opened, (v) => new Set(v), (v) => [...v.values()]);
  const selectStrategy = computed(() => {
    if (typeof props.selectStrategy === "object")
      return props.selectStrategy;
    switch (props.selectStrategy) {
      case "single-leaf":
        return leafSingleSelectStrategy(props.mandatory);
      case "leaf":
        return leafSelectStrategy(props.mandatory);
      case "independent":
        return independentSelectStrategy(props.mandatory);
      case "single-independent":
        return independentSingleSelectStrategy(props.mandatory);
      case "classic":
      default:
        return classicSelectStrategy(props.mandatory);
    }
  });
  const openStrategy = computed(() => {
    if (typeof props.openStrategy === "object")
      return props.openStrategy;
    switch (props.openStrategy) {
      case "list":
        return listOpenStrategy;
      case "single":
        return singleOpenStrategy;
      case "multiple":
      default:
        return multipleOpenStrategy;
    }
  });
  const selected = useProxiedModel(props, "selected", props.selected, (v) => selectStrategy.value.in(v, children.value, parents.value), (v) => selectStrategy.value.out(v, children.value, parents.value));
  onBeforeUnmount(() => {
    isUnmounted = true;
  });
  function getPath(id) {
    const path = [];
    let parent = id;
    while (parent != null) {
      path.unshift(parent);
      parent = parents.value.get(parent);
    }
    return path;
  }
  const vm = getCurrentInstance("nested");
  const nested = {
    id: ref(),
    root: {
      opened,
      selected,
      selectedValues: computed(() => {
        const arr = [];
        for (const [key, value] of selected.value.entries()) {
          if (value === "on")
            arr.push(key);
        }
        return arr;
      }),
      register: (id, parentId, isGroup) => {
        parentId && id !== parentId && parents.value.set(id, parentId);
        isGroup && children.value.set(id, []);
        if (parentId != null) {
          children.value.set(parentId, [...children.value.get(parentId) || [], id]);
        }
      },
      unregister: (id) => {
        var _a2;
        if (isUnmounted)
          return;
        children.value.delete(id);
        const parent = parents.value.get(id);
        if (parent) {
          const list = (_a2 = children.value.get(parent)) != null ? _a2 : [];
          children.value.set(parent, list.filter((child) => child !== id));
        }
        parents.value.delete(id);
        opened.value.delete(id);
      },
      open: (id, value, event) => {
        vm.emit("click:open", {
          id,
          value,
          path: getPath(id),
          event
        });
        const newOpened = openStrategy.value.open({
          id,
          value,
          opened: new Set(opened.value),
          children: children.value,
          parents: parents.value,
          event
        });
        newOpened && (opened.value = newOpened);
      },
      openOnSelect: (id, value, event) => {
        const newOpened = openStrategy.value.select({
          id,
          value,
          selected: new Map(selected.value),
          opened: new Set(opened.value),
          children: children.value,
          parents: parents.value,
          event
        });
        newOpened && (opened.value = newOpened);
      },
      select: (id, value, event) => {
        vm.emit("click:select", {
          id,
          value,
          path: getPath(id),
          event
        });
        const newSelected = selectStrategy.value.select({
          id,
          value,
          selected: new Map(selected.value),
          children: children.value,
          parents: parents.value,
          event
        });
        newSelected && (selected.value = newSelected);
        nested.root.openOnSelect(id, value, event);
      },
      children,
      parents
    }
  };
  provide(VNestedSymbol, nested);
  return nested.root;
};
const useNestedItem = (id, isGroup) => {
  const parent = inject$1(VNestedSymbol, emptyNested);
  const uidSymbol = Symbol(getUid());
  const computedId = computed(() => {
    var _a2;
    return (_a2 = id.value) != null ? _a2 : uidSymbol;
  });
  const item = {
    ...parent,
    id: computedId,
    open: (open, e3) => parent.root.open(computedId.value, open, e3),
    openOnSelect: (open, e3) => parent.root.openOnSelect(computedId.value, open, e3),
    isOpen: computed(() => parent.root.opened.value.has(computedId.value)),
    parent: computed(() => parent.root.parents.value.get(computedId.value)),
    select: (selected, e3) => parent.root.select(computedId.value, selected, e3),
    isSelected: computed(() => parent.root.selected.value.get(computedId.value) === "on"),
    isIndeterminate: computed(() => parent.root.selected.value.get(computedId.value) === "indeterminate"),
    isLeaf: computed(() => !parent.root.children.value.get(computedId.value)),
    isGroupActivator: parent.isGroupActivator
  };
  !parent.isGroupActivator && parent.root.register(computedId.value, parent.id.value, isGroup);
  onBeforeUnmount(() => {
    !parent.isGroupActivator && parent.root.unregister(computedId.value);
  });
  isGroup && provide(VNestedSymbol, item);
  return item;
};
const useNestedGroupActivator = () => {
  const parent = inject$1(VNestedSymbol, emptyNested);
  provide(VNestedSymbol, {
    ...parent,
    isGroupActivator: true
  });
};
const VListGroupActivator = defineComponent({
  name: "VListGroupActivator",
  setup(_2, _ref) {
    let {
      slots
    } = _ref;
    useNestedGroupActivator();
    return () => {
      var _slots$default;
      return (_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots);
    };
  }
});
const makeVListGroupProps = propsFactory({
  activeColor: String,
  color: String,
  collapseIcon: {
    type: IconValue,
    default: "$collapse"
  },
  expandIcon: {
    type: IconValue,
    default: "$expand"
  },
  prependIcon: IconValue,
  appendIcon: IconValue,
  fluid: Boolean,
  subgroup: Boolean,
  value: null,
  ...makeTagProps()
}, "v-list-group");
const VListGroup = genericComponent()({
  name: "VListGroup",
  props: {
    title: String,
    ...makeVListGroupProps()
  },
  setup(props, _ref2) {
    let {
      slots
    } = _ref2;
    const {
      isOpen,
      open,
      id: _id
    } = useNestedItem(toRef(props, "value"), true);
    const id = computed(() => `v-list-group--id-${String(_id.value)}`);
    const list = useList();
    function onClick(e3) {
      open(!isOpen.value, e3);
    }
    const activatorProps = computed(() => ({
      onClick,
      class: "v-list-group__header",
      id: id.value
    }));
    const toggleIcon = computed(() => isOpen.value ? props.collapseIcon : props.expandIcon);
    useRender(() => {
      var _slots$default2;
      return createVNode(props.tag, {
        "class": ["v-list-group", {
          "v-list-group--prepend": list == null ? void 0 : list.hasPrepend.value,
          "v-list-group--fluid": props.fluid,
          "v-list-group--subgroup": props.subgroup,
          "v-list-group--open": isOpen.value
        }]
      }, {
        default: () => [slots.activator && createVNode(VDefaultsProvider, {
          "defaults": {
            VListItem: {
              active: isOpen.value,
              activeColor: props.activeColor,
              color: props.color,
              prependIcon: props.prependIcon || props.subgroup && toggleIcon.value,
              appendIcon: props.appendIcon || !props.subgroup && toggleIcon.value,
              title: props.title,
              value: props.value
            }
          }
        }, {
          default: () => [createVNode(VListGroupActivator, null, {
            default: () => [slots.activator({
              props: activatorProps.value,
              isOpen
            })]
          })]
        }), createVNode(VExpandTransition, null, {
          default: () => [withDirectives(createVNode("div", {
            "class": "v-list-group__items",
            "role": "group",
            "aria-labelledby": id.value
          }, [(_slots$default2 = slots.default) == null ? void 0 : _slots$default2.call(slots)]), [[vShow, isOpen.value]])]
        })]
      });
    });
    return {};
  }
});
function filterListGroupProps(props) {
  return pick(props, Object.keys(VListGroup.props));
}
const VListItem$1 = "";
const VListItemSubtitle = createSimpleFunctional("v-list-item-subtitle");
const VListItemTitle = createSimpleFunctional("v-list-item-title");
const VListItem = genericComponent()({
  name: "VListItem",
  directives: {
    Ripple
  },
  props: {
    active: {
      type: Boolean,
      default: void 0
    },
    activeClass: String,
    activeColor: String,
    appendAvatar: String,
    appendIcon: IconValue,
    disabled: Boolean,
    lines: String,
    link: {
      type: Boolean,
      default: void 0
    },
    nav: Boolean,
    prependAvatar: String,
    prependIcon: IconValue,
    ripple: {
      type: Boolean,
      default: true
    },
    subtitle: [String, Number, Boolean],
    title: [String, Number, Boolean],
    value: null,
    onClick: EventProp,
    onClickOnce: EventProp,
    ...makeBorderProps(),
    ...makeDensityProps(),
    ...makeDimensionProps(),
    ...makeElevationProps(),
    ...makeRoundedProps(),
    ...makeRouterProps(),
    ...makeTagProps(),
    ...makeThemeProps(),
    ...makeVariantProps({
      variant: "text"
    })
  },
  emits: {
    click: (e3) => true
  },
  setup(props, _ref) {
    let {
      attrs,
      slots,
      emit: emit2
    } = _ref;
    const link = useLink(props, attrs);
    const id = computed(() => {
      var _a2;
      return (_a2 = props.value) != null ? _a2 : link.href.value;
    });
    const {
      select,
      isSelected,
      isIndeterminate,
      isGroupActivator,
      root,
      parent,
      openOnSelect
    } = useNestedItem(id, false);
    const list = useList();
    const isActive = computed(() => {
      var _link$isActive;
      return props.active !== false && (props.active || ((_link$isActive = link.isActive) == null ? void 0 : _link$isActive.value) || isSelected.value);
    });
    const isLink = computed(() => props.link !== false && link.isLink.value);
    const isClickable = computed(() => !props.disabled && props.link !== false && (props.link || link.isClickable.value || props.value != null && !!list));
    const roundedProps = computed(() => props.rounded || props.nav);
    const variantProps = computed(() => {
      var _a2;
      return {
        color: isActive.value ? (_a2 = props.activeColor) != null ? _a2 : props.color : props.color,
        variant: props.variant
      };
    });
    watch(() => {
      var _link$isActive2;
      return (_link$isActive2 = link.isActive) == null ? void 0 : _link$isActive2.value;
    }, (val) => {
      if (val && parent.value != null) {
        root.open(parent.value, true);
      }
      if (val) {
        openOnSelect(val);
      }
    }, {
      immediate: true
    });
    const {
      themeClasses
    } = provideTheme(props);
    const {
      borderClasses
    } = useBorder(props);
    const {
      colorClasses,
      colorStyles,
      variantClasses
    } = useVariant(variantProps);
    const {
      densityClasses
    } = useDensity(props);
    const {
      dimensionStyles
    } = useDimension(props);
    const {
      elevationClasses
    } = useElevation(props);
    const {
      roundedClasses
    } = useRounded(roundedProps);
    const lineClasses = computed(() => props.lines ? `v-list-item--${props.lines}-line` : void 0);
    const slotProps = computed(() => ({
      isActive: isActive.value,
      select,
      isSelected: isSelected.value,
      isIndeterminate: isIndeterminate.value
    }));
    function onClick(e3) {
      var _link$navigate;
      emit2("click", e3);
      if (isGroupActivator || !isClickable.value)
        return;
      (_link$navigate = link.navigate) == null ? void 0 : _link$navigate.call(link, e3);
      props.value != null && select(!isSelected.value, e3);
    }
    function onKeyDown(e3) {
      if (e3.key === "Enter" || e3.key === " ") {
        e3.preventDefault();
        onClick(e3);
      }
    }
    useRender(() => {
      var _slots$title, _slots$subtitle, _slots$default;
      const Tag = isLink.value ? "a" : props.tag;
      const hasColor = !list || isSelected.value || isActive.value;
      const hasTitle = slots.title || props.title;
      const hasSubtitle = slots.subtitle || props.subtitle;
      const hasAppend = !!(slots.append || props.appendAvatar || props.appendIcon);
      const hasPrepend = !!(slots.prepend || props.prependAvatar || props.prependIcon);
      list == null ? void 0 : list.updateHasPrepend(hasPrepend);
      return withDirectives(createVNode(Tag, {
        "class": ["v-list-item", {
          "v-list-item--active": isActive.value,
          "v-list-item--disabled": props.disabled,
          "v-list-item--link": isClickable.value,
          "v-list-item--nav": props.nav,
          "v-list-item--prepend": !hasPrepend && (list == null ? void 0 : list.hasPrepend.value),
          [`${props.activeClass}`]: props.activeClass && isActive.value
        }, themeClasses.value, borderClasses.value, hasColor ? colorClasses.value : void 0, densityClasses.value, elevationClasses.value, lineClasses.value, roundedClasses.value, variantClasses.value],
        "style": [hasColor ? colorStyles.value : void 0, dimensionStyles.value],
        "href": link.href.value,
        "tabindex": isClickable.value ? 0 : void 0,
        "onClick": onClick,
        "onKeydown": isClickable.value && !isLink.value && onKeyDown
      }, {
        default: () => [genOverlays(isClickable.value || isActive.value, "v-list-item"), hasPrepend && createVNode("div", {
          "key": "prepend",
          "class": "v-list-item__prepend"
        }, [props.prependAvatar && createVNode(VAvatar, {
          "key": "prepend-avatar",
          "density": props.density,
          "image": props.prependAvatar
        }, null), props.prependIcon && createVNode(VIcon, {
          "key": "prepend-icon",
          "density": props.density,
          "icon": props.prependIcon
        }, null), slots.prepend && createVNode(VDefaultsProvider, {
          "key": "prepend",
          "defaults": {
            VAvatar: {
              density: props.density,
              image: props.prependAvatar
            },
            VIcon: {
              density: props.density,
              icon: props.prependIcon
            },
            VListItemAction: {
              start: true
            }
          }
        }, {
          default: () => [slots.prepend(slotProps.value)]
        })]), createVNode("div", {
          "class": "v-list-item__content",
          "data-no-activator": ""
        }, [hasTitle && createVNode(VListItemTitle, {
          "key": "title"
        }, {
          default: () => {
            var _a2;
            return [(_a2 = (_slots$title = slots.title) == null ? void 0 : _slots$title.call(slots, {
              title: props.title
            })) != null ? _a2 : props.title];
          }
        }), hasSubtitle && createVNode(VListItemSubtitle, {
          "key": "subtitle"
        }, {
          default: () => {
            var _a2;
            return [(_a2 = (_slots$subtitle = slots.subtitle) == null ? void 0 : _slots$subtitle.call(slots, {
              subtitle: props.subtitle
            })) != null ? _a2 : props.subtitle];
          }
        }), (_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots, slotProps.value)]), hasAppend && createVNode("div", {
          "key": "append",
          "class": "v-list-item__append"
        }, [slots.append && createVNode(VDefaultsProvider, {
          "key": "append",
          "defaults": {
            VAvatar: {
              density: props.density,
              image: props.appendAvatar
            },
            VIcon: {
              density: props.density,
              icon: props.appendIcon
            },
            VListItemAction: {
              end: true
            }
          }
        }, {
          default: () => [slots.append(slotProps.value)]
        }), props.appendIcon && createVNode(VIcon, {
          "key": "append-icon",
          "density": props.density,
          "icon": props.appendIcon
        }, null), props.appendAvatar && createVNode(VAvatar, {
          "key": "append-avatar",
          "density": props.density,
          "image": props.appendAvatar
        }, null)])]
      }), [[resolveDirective("ripple"), isClickable.value && props.ripple]]);
    });
    return {};
  }
});
const VListSubheader = defineComponent({
  name: "VListSubheader",
  props: {
    color: String,
    inset: Boolean,
    sticky: Boolean,
    title: String,
    ...makeTagProps()
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const {
      textColorClasses,
      textColorStyles
    } = useTextColor(toRef(props, "color"));
    useRender(() => {
      var _slots$default;
      const hasText = !!(slots.default || props.title);
      return createVNode(props.tag, {
        "class": ["v-list-subheader", {
          "v-list-subheader--inset": props.inset,
          "v-list-subheader--sticky": props.sticky
        }, textColorClasses.value],
        "style": {
          textColorStyles
        }
      }, {
        default: () => {
          var _a2;
          return [hasText && createVNode("div", {
            "class": "v-list-subheader__text"
          }, [(_a2 = (_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots)) != null ? _a2 : props.title])];
        }
      });
    });
    return {};
  }
});
const VListChildren = genericComponent()({
  name: "VListChildren",
  props: {
    items: Array
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    createList();
    return () => {
      var _a2;
      var _slots$default, _props$items;
      return (_a2 = (_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots)) != null ? _a2 : (_props$items = props.items) == null ? void 0 : _props$items.map((_ref2) => {
        var _a3, _b;
        let {
          children,
          props: itemProps,
          type,
          raw: item
        } = _ref2;
        if (type === "divider") {
          var _slots$divider;
          return (_a3 = (_slots$divider = slots.divider) == null ? void 0 : _slots$divider.call(slots, {
            props: itemProps
          })) != null ? _a3 : createVNode(VDivider, itemProps, null);
        }
        if (type === "subheader") {
          var _slots$subheader;
          return (_b = (_slots$subheader = slots.subheader) == null ? void 0 : _slots$subheader.call(slots, {
            props: itemProps
          })) != null ? _b : createVNode(VListSubheader, itemProps, {
            default: slots.subheader
          });
        }
        const slotsWithItem = {
          subtitle: slots.subtitle ? (slotProps) => {
            var _slots$subtitle;
            return (_slots$subtitle = slots.subtitle) == null ? void 0 : _slots$subtitle.call(slots, {
              ...slotProps,
              item
            });
          } : void 0,
          prepend: slots.prepend ? (slotProps) => {
            var _slots$prepend;
            return (_slots$prepend = slots.prepend) == null ? void 0 : _slots$prepend.call(slots, {
              ...slotProps,
              item
            });
          } : void 0,
          append: slots.append ? (slotProps) => {
            var _slots$append;
            return (_slots$append = slots.append) == null ? void 0 : _slots$append.call(slots, {
              ...slotProps,
              item
            });
          } : void 0,
          default: slots.default ? (slotProps) => {
            var _slots$default2;
            return (_slots$default2 = slots.default) == null ? void 0 : _slots$default2.call(slots, {
              ...slotProps,
              item
            });
          } : void 0,
          title: slots.title ? (slotProps) => {
            var _slots$title;
            return (_slots$title = slots.title) == null ? void 0 : _slots$title.call(slots, {
              ...slotProps,
              item
            });
          } : void 0
        };
        const [listGroupProps, _1] = filterListGroupProps(itemProps);
        return children ? createVNode(VListGroup, mergeProps({
          "value": itemProps == null ? void 0 : itemProps.value
        }, listGroupProps), {
          activator: (_ref3) => {
            let {
              props: activatorProps
            } = _ref3;
            return slots.header ? slots.header({
              ...itemProps,
              ...activatorProps
            }) : createVNode(VListItem, mergeProps(itemProps, activatorProps), slotsWithItem);
          },
          default: () => createVNode(VListChildren, {
            "items": children
          }, slots)
        }) : slots.item ? slots.item(itemProps) : createVNode(VListItem, itemProps, slotsWithItem);
      });
    };
  }
});
const makeItemsProps = propsFactory({
  items: {
    type: Array,
    default: () => []
  },
  itemTitle: {
    type: [String, Array, Function],
    default: "title"
  },
  itemValue: {
    type: [String, Array, Function],
    default: "value"
  },
  itemChildren: {
    type: [Boolean, String, Array, Function],
    default: "children"
  },
  itemProps: {
    type: [Boolean, String, Array, Function],
    default: "props"
  },
  returnObject: Boolean
}, "item");
function transformItem$1(props, item) {
  var _a2;
  const title = getPropertyFromItem(item, props.itemTitle, item);
  const value = props.returnObject ? item : getPropertyFromItem(item, props.itemValue, title);
  const children = getPropertyFromItem(item, props.itemChildren);
  const itemProps = props.itemProps === true ? typeof item === "object" && item != null && !Array.isArray(item) ? "children" in item ? pick(item, ["children"])[1] : item : void 0 : getPropertyFromItem(item, props.itemProps);
  const _props = {
    title,
    value,
    ...itemProps
  };
  return {
    title: String((_a2 = _props.title) != null ? _a2 : ""),
    value: _props.value,
    props: _props,
    children: Array.isArray(children) ? transformItems$1(props, children) : void 0,
    raw: item
  };
}
function transformItems$1(props, items) {
  const array = [];
  for (const item of items) {
    array.push(transformItem$1(props, item));
  }
  return array;
}
function useItems(props) {
  const items = computed(() => transformItems$1(props, props.items));
  function transformIn(value) {
    return value.map((item) => transformItem$1(props, item));
  }
  function transformOut(value) {
    return value.map((_ref) => {
      let {
        props: props2
      } = _ref;
      return props2.value;
    });
  }
  return {
    items,
    transformIn,
    transformOut
  };
}
function isPrimitive(value) {
  return typeof value === "string" || typeof value === "number" || typeof value === "boolean";
}
function transformItem(props, item) {
  const type = getPropertyFromItem(item, props.itemType, "item");
  const title = isPrimitive(item) ? item : getPropertyFromItem(item, props.itemTitle);
  const value = getPropertyFromItem(item, props.itemValue, void 0);
  const children = getPropertyFromItem(item, props.itemChildren);
  const itemProps = props.itemProps === true ? pick(item, ["children"])[1] : getPropertyFromItem(item, props.itemProps);
  const _props = {
    title,
    value,
    ...itemProps
  };
  return {
    type,
    title: _props.title,
    value: _props.value,
    props: _props,
    children: type === "item" && children ? transformItems(props, children) : void 0,
    raw: item
  };
}
function transformItems(props, items) {
  const array = [];
  for (const item of items) {
    array.push(transformItem(props, item));
  }
  return array;
}
function useListItems(props) {
  const items = computed(() => transformItems(props, props.items));
  return {
    items
  };
}
const VList = genericComponent()({
  name: "VList",
  props: {
    activeColor: String,
    activeClass: String,
    bgColor: String,
    disabled: Boolean,
    lines: {
      type: [Boolean, String],
      default: "one"
    },
    nav: Boolean,
    ...makeNestedProps({
      selectStrategy: "single-leaf",
      openStrategy: "list"
    }),
    ...makeBorderProps(),
    ...makeDensityProps(),
    ...makeDimensionProps(),
    ...makeElevationProps(),
    itemType: {
      type: String,
      default: "type"
    },
    ...makeItemsProps(),
    ...makeRoundedProps(),
    ...makeTagProps(),
    ...makeThemeProps(),
    ...makeVariantProps({
      variant: "text"
    })
  },
  emits: {
    "update:selected": (val) => true,
    "update:opened": (val) => true,
    "click:open": (value) => true,
    "click:select": (value) => true
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const {
      items
    } = useListItems(props);
    const {
      themeClasses
    } = provideTheme(props);
    const {
      backgroundColorClasses,
      backgroundColorStyles
    } = useBackgroundColor(toRef(props, "bgColor"));
    const {
      borderClasses
    } = useBorder(props);
    const {
      densityClasses
    } = useDensity(props);
    const {
      dimensionStyles
    } = useDimension(props);
    const {
      elevationClasses
    } = useElevation(props);
    const {
      roundedClasses
    } = useRounded(props);
    const {
      open,
      select
    } = useNested(props);
    const lineClasses = computed(() => props.lines ? `v-list--${props.lines}-line` : void 0);
    const activeColor = toRef(props, "activeColor");
    const color = toRef(props, "color");
    createList();
    provideDefaults({
      VListGroup: {
        activeColor,
        color
      },
      VListItem: {
        activeClass: toRef(props, "activeClass"),
        activeColor,
        color,
        density: toRef(props, "density"),
        disabled: toRef(props, "disabled"),
        lines: toRef(props, "lines"),
        nav: toRef(props, "nav"),
        variant: toRef(props, "variant")
      }
    });
    const isFocused = ref(false);
    const contentRef = ref();
    function onFocusin(e3) {
      isFocused.value = true;
    }
    function onFocusout(e3) {
      isFocused.value = false;
    }
    function onFocus(e3) {
      var _contentRef$value;
      if (!isFocused.value && !(e3.relatedTarget && (_contentRef$value = contentRef.value) != null && _contentRef$value.contains(e3.relatedTarget)))
        focus();
    }
    function onKeydown(e3) {
      if (!contentRef.value)
        return;
      if (e3.key === "ArrowDown") {
        focus("next");
      } else if (e3.key === "ArrowUp") {
        focus("prev");
      } else if (e3.key === "Home") {
        focus("first");
      } else if (e3.key === "End") {
        focus("last");
      } else {
        return;
      }
      e3.preventDefault();
    }
    function focus(location) {
      if (!contentRef.value)
        return;
      const focusable = [...contentRef.value.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])')].filter((el2) => !el2.hasAttribute("disabled"));
      const idx = focusable.indexOf(document.activeElement);
      if (!location) {
        if (!contentRef.value.contains(document.activeElement)) {
          var _focusable$;
          (_focusable$ = focusable[0]) == null ? void 0 : _focusable$.focus();
        }
      } else if (location === "first") {
        var _focusable$2;
        (_focusable$2 = focusable[0]) == null ? void 0 : _focusable$2.focus();
      } else if (location === "last") {
        var _focusable$at;
        (_focusable$at = focusable.at(-1)) == null ? void 0 : _focusable$at.focus();
      } else {
        let el2;
        let idxx = idx;
        const inc = location === "next" ? 1 : -1;
        do {
          idxx += inc;
          el2 = focusable[idxx];
        } while ((!el2 || el2.offsetParent == null) && idxx < focusable.length && idxx >= 0);
        if (el2)
          el2.focus();
        else
          focus(location === "next" ? "first" : "last");
      }
    }
    useRender(() => {
      return createVNode(props.tag, {
        "ref": contentRef,
        "class": ["v-list", {
          "v-list--disabled": props.disabled,
          "v-list--nav": props.nav
        }, themeClasses.value, backgroundColorClasses.value, borderClasses.value, densityClasses.value, elevationClasses.value, lineClasses.value, roundedClasses.value],
        "style": [backgroundColorStyles.value, dimensionStyles.value],
        "role": "listbox",
        "aria-activedescendant": void 0,
        "onFocusin": onFocusin,
        "onFocusout": onFocusout,
        "onFocus": onFocus,
        "onKeydown": onKeydown
      }, {
        default: () => [createVNode(VListChildren, {
          "items": items.value
        }, slots)]
      });
    });
    return {
      open,
      select,
      focus
    };
  }
});
const VMenu$1 = "";
const VOverlay$1 = "";
const makeDelayProps = propsFactory({
  closeDelay: [Number, String],
  openDelay: [Number, String]
}, "delay");
function useDelay(props, cb) {
  const delays = {};
  const runDelayFactory = (prop) => () => {
    if (!IN_BROWSER)
      return Promise.resolve(true);
    const active = prop === "openDelay";
    delays.closeDelay && window.clearTimeout(delays.closeDelay);
    delete delays.closeDelay;
    delays.openDelay && window.clearTimeout(delays.openDelay);
    delete delays.openDelay;
    return new Promise((resolve2) => {
      var _a2;
      const delay = parseInt((_a2 = props[prop]) != null ? _a2 : 0, 10);
      delays[prop] = window.setTimeout(() => {
        cb == null ? void 0 : cb(active);
        resolve2(active);
      }, delay);
    });
  };
  return {
    runCloseDelay: runDelayFactory("closeDelay"),
    runOpenDelay: runDelayFactory("openDelay")
  };
}
const VMenuSymbol = Symbol.for("vuetify:v-menu");
const makeActivatorProps = propsFactory({
  activator: [String, Object],
  activatorProps: {
    type: Object,
    default: () => ({})
  },
  openOnClick: {
    type: Boolean,
    default: void 0
  },
  openOnHover: Boolean,
  openOnFocus: {
    type: Boolean,
    default: void 0
  },
  closeOnContentClick: Boolean,
  ...makeDelayProps()
}, "v-overlay-activator");
function useActivator(props, _ref) {
  let {
    isActive,
    isTop
  } = _ref;
  const activatorEl = ref();
  let isHovered = false;
  let isFocused = false;
  let firstEnter = true;
  const openOnFocus = computed(() => props.openOnFocus || props.openOnFocus == null && props.openOnHover);
  const openOnClick = computed(() => props.openOnClick || props.openOnClick == null && !props.openOnHover && !openOnFocus.value);
  const {
    runOpenDelay,
    runCloseDelay
  } = useDelay(props, (value) => {
    if (value === (props.openOnHover && isHovered || openOnFocus.value && isFocused) && !(props.openOnHover && isActive.value && !isTop.value)) {
      if (isActive.value !== value) {
        firstEnter = true;
      }
      isActive.value = value;
    }
  });
  const availableEvents = {
    click: (e3) => {
      e3.stopPropagation();
      activatorEl.value = e3.currentTarget || e3.target;
      isActive.value = !isActive.value;
    },
    mouseenter: (e3) => {
      isHovered = true;
      activatorEl.value = e3.currentTarget || e3.target;
      runOpenDelay();
    },
    mouseleave: (e3) => {
      isHovered = false;
      runCloseDelay();
    },
    focus: (e3) => {
      if (SUPPORTS_FOCUS_VISIBLE && !e3.target.matches(":focus-visible"))
        return;
      isFocused = true;
      e3.stopPropagation();
      activatorEl.value = e3.currentTarget || e3.target;
      runOpenDelay();
    },
    blur: (e3) => {
      isFocused = false;
      e3.stopPropagation();
      runCloseDelay();
    }
  };
  const activatorEvents = computed(() => {
    const events = {};
    if (openOnClick.value) {
      events.click = availableEvents.click;
    }
    if (props.openOnHover) {
      events.mouseenter = availableEvents.mouseenter;
      events.mouseleave = availableEvents.mouseleave;
    }
    if (openOnFocus.value) {
      events.focus = availableEvents.focus;
      events.blur = availableEvents.blur;
    }
    return events;
  });
  const contentEvents = computed(() => {
    const events = {};
    if (props.openOnHover) {
      events.mouseenter = () => {
        isHovered = true;
        runOpenDelay();
      };
      events.mouseleave = () => {
        isHovered = false;
        runCloseDelay();
      };
    }
    if (props.closeOnContentClick) {
      const menu = inject$1(VMenuSymbol, null);
      events.click = () => {
        isActive.value = false;
        menu == null ? void 0 : menu.closeParents();
      };
    }
    return events;
  });
  const scrimEvents = computed(() => {
    const events = {};
    if (props.openOnHover) {
      events.mouseenter = () => {
        if (firstEnter) {
          isHovered = true;
          firstEnter = false;
          runOpenDelay();
        }
      };
      events.mouseleave = () => {
        isHovered = false;
        runCloseDelay();
      };
    }
    return events;
  });
  watch(isTop, (val) => {
    if (val && (props.openOnHover && !isHovered && (!openOnFocus.value || !isFocused) || openOnFocus.value && !isFocused && (!props.openOnHover || !isHovered))) {
      isActive.value = false;
    }
  });
  const activatorRef = ref();
  watchEffect(() => {
    if (!activatorRef.value)
      return;
    nextTick(() => {
      const activator = activatorRef.value;
      activatorEl.value = isComponentInstance(activator) ? activator.$el : activator;
    });
  });
  const vm = getCurrentInstance("useActivator");
  let scope;
  watch(() => !!props.activator, (val) => {
    if (val && IN_BROWSER) {
      scope = effectScope();
      scope.run(() => {
        _useActivator(props, vm, {
          activatorEl,
          activatorEvents
        });
      });
    } else if (scope) {
      scope.stop();
    }
  }, {
    flush: "post",
    immediate: true
  });
  onScopeDispose(() => {
    var _scope;
    (_scope = scope) == null ? void 0 : _scope.stop();
  });
  return {
    activatorEl,
    activatorRef,
    activatorEvents,
    contentEvents,
    scrimEvents
  };
}
function _useActivator(props, vm, _ref2) {
  let {
    activatorEl,
    activatorEvents
  } = _ref2;
  watch(() => props.activator, (val, oldVal) => {
    if (oldVal && val !== oldVal) {
      const activator = getActivator(oldVal);
      activator && unbindActivatorProps(activator);
    }
    if (val) {
      nextTick(() => bindActivatorProps());
    }
  }, {
    immediate: true
  });
  watch(() => props.activatorProps, () => {
    bindActivatorProps();
  });
  onScopeDispose(() => {
    unbindActivatorProps();
  });
  function bindActivatorProps() {
    let el2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : getActivator();
    let _props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : props.activatorProps;
    if (!el2)
      return;
    Object.entries(activatorEvents.value).forEach((_ref3) => {
      let [name2, cb] = _ref3;
      el2.addEventListener(name2, cb);
    });
    Object.keys(_props).forEach((k2) => {
      if (_props[k2] == null) {
        el2.removeAttribute(k2);
      } else {
        el2.setAttribute(k2, _props[k2]);
      }
    });
  }
  function unbindActivatorProps() {
    let el2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : getActivator();
    let _props = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : props.activatorProps;
    if (!el2)
      return;
    Object.entries(activatorEvents.value).forEach((_ref4) => {
      let [name2, cb] = _ref4;
      el2.removeEventListener(name2, cb);
    });
    Object.keys(_props).forEach((k2) => {
      el2.removeAttribute(k2);
    });
  }
  function getActivator() {
    var _activator;
    let selector = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : props.activator;
    let activator;
    if (selector) {
      if (selector === "parent") {
        var _vm$proxy, _vm$proxy$$el;
        let el2 = vm == null ? void 0 : (_vm$proxy = vm.proxy) == null ? void 0 : (_vm$proxy$$el = _vm$proxy.$el) == null ? void 0 : _vm$proxy$$el.parentNode;
        while (el2.hasAttribute("data-no-activator")) {
          el2 = el2.parentNode;
        }
        activator = el2;
      } else if (typeof selector === "string") {
        activator = document.querySelector(selector);
      } else if ("$el" in selector) {
        activator = selector.$el;
      } else {
        activator = selector;
      }
    }
    activatorEl.value = ((_activator = activator) == null ? void 0 : _activator.nodeType) === Node.ELEMENT_NODE ? activator : null;
    return activatorEl.value;
  }
}
const makeLazyProps = propsFactory({
  eager: Boolean
}, "lazy");
function useLazy(props, active) {
  const isBooted = ref(false);
  const hasContent = computed(() => isBooted.value || props.eager || active.value);
  watch(active, () => isBooted.value = true);
  function onAfterLeave() {
    if (!props.eager)
      isBooted.value = false;
  }
  return {
    isBooted,
    hasContent,
    onAfterLeave
  };
}
function elementToViewport(point, offset) {
  return {
    x: point.x + offset.x,
    y: point.y + offset.y
  };
}
function getOffset(a3, b3) {
  return {
    x: a3.x - b3.x,
    y: a3.y - b3.y
  };
}
function anchorToPoint(anchor, box) {
  if (anchor.side === "top" || anchor.side === "bottom") {
    const {
      side,
      align
    } = anchor;
    const x2 = align === "left" ? 0 : align === "center" ? box.width / 2 : align === "right" ? box.width : align;
    const y3 = side === "top" ? 0 : side === "bottom" ? box.height : side;
    return elementToViewport({
      x: x2,
      y: y3
    }, box);
  } else if (anchor.side === "left" || anchor.side === "right") {
    const {
      side,
      align
    } = anchor;
    const x2 = side === "left" ? 0 : side === "right" ? box.width : side;
    const y3 = align === "top" ? 0 : align === "center" ? box.height / 2 : align === "bottom" ? box.height : align;
    return elementToViewport({
      x: x2,
      y: y3
    }, box);
  }
  return elementToViewport({
    x: box.width / 2,
    y: box.height / 2
  }, box);
}
const locationStrategies = {
  static: staticLocationStrategy,
  connected: connectedLocationStrategy
};
const makeLocationStrategyProps = propsFactory({
  locationStrategy: {
    type: [String, Function],
    default: "static",
    validator: (val) => typeof val === "function" || val in locationStrategies
  },
  location: {
    type: String,
    default: "bottom"
  },
  origin: {
    type: String,
    default: "auto"
  },
  offset: [Number, String, Array]
}, "v-overlay-location-strategies");
function useLocationStrategies(props, data) {
  const contentStyles = ref({});
  const updateLocation = ref();
  if (IN_BROWSER) {
    useToggleScope(() => !!(data.isActive.value && props.locationStrategy), (reset) => {
      watch(() => props.locationStrategy, reset);
      onScopeDispose(() => {
        updateLocation.value = void 0;
      });
      if (typeof props.locationStrategy === "function") {
        var _props$locationStrate;
        updateLocation.value = (_props$locationStrate = props.locationStrategy(data, props, contentStyles)) == null ? void 0 : _props$locationStrate.updateLocation;
      } else {
        var _locationStrategies$p;
        updateLocation.value = (_locationStrategies$p = locationStrategies[props.locationStrategy](data, props, contentStyles)) == null ? void 0 : _locationStrategies$p.updateLocation;
      }
    });
    window.addEventListener("resize", onResize, {
      passive: true
    });
    onScopeDispose(() => {
      window.removeEventListener("resize", onResize);
      updateLocation.value = void 0;
    });
  }
  function onResize(e3) {
    var _updateLocation$value;
    (_updateLocation$value = updateLocation.value) == null ? void 0 : _updateLocation$value.call(updateLocation, e3);
  }
  return {
    contentStyles,
    updateLocation
  };
}
function staticLocationStrategy() {
}
function getIntrinsicSize(el2) {
  const contentBox = nullifyTransforms(el2);
  contentBox.x -= parseFloat(el2.style.left || 0);
  contentBox.y -= parseFloat(el2.style.top || 0);
  return contentBox;
}
function connectedLocationStrategy(data, props, contentStyles) {
  const activatorFixed = isFixedPosition(data.activatorEl.value);
  if (activatorFixed) {
    Object.assign(contentStyles.value, {
      position: "fixed"
    });
  }
  const {
    preferredAnchor,
    preferredOrigin
  } = destructComputed(() => {
    const parsedAnchor = parseAnchor(props.location, data.isRtl.value);
    const parsedOrigin = props.origin === "overlap" ? parsedAnchor : props.origin === "auto" ? flipSide(parsedAnchor) : parseAnchor(props.origin, data.isRtl.value);
    if (parsedAnchor.side === parsedOrigin.side && parsedAnchor.align === flipAlign(parsedOrigin).align) {
      return {
        preferredAnchor: flipCorner(parsedAnchor),
        preferredOrigin: flipCorner(parsedOrigin)
      };
    } else {
      return {
        preferredAnchor: parsedAnchor,
        preferredOrigin: parsedOrigin
      };
    }
  });
  const [minWidth, minHeight, maxWidth, maxHeight] = ["minWidth", "minHeight", "maxWidth", "maxHeight"].map((key) => {
    return computed(() => {
      const val = parseFloat(props[key]);
      return isNaN(val) ? Infinity : val;
    });
  });
  const offset = computed(() => {
    if (Array.isArray(props.offset)) {
      return props.offset;
    }
    if (typeof props.offset === "string") {
      const offset2 = props.offset.split(" ").map(parseFloat);
      if (offset2.length < 2)
        offset2.push(0);
      return offset2;
    }
    return typeof props.offset === "number" ? [props.offset, 0] : [0, 0];
  });
  let observe = false;
  const observer = new ResizeObserver(() => {
    if (observe)
      updateLocation();
  });
  watch([data.activatorEl, data.contentEl], (_ref, _ref2) => {
    let [newActivatorEl, newContentEl] = _ref;
    let [oldActivatorEl, oldContentEl] = _ref2;
    if (oldActivatorEl)
      observer.unobserve(oldActivatorEl);
    if (newActivatorEl)
      observer.observe(newActivatorEl);
    if (oldContentEl)
      observer.unobserve(oldContentEl);
    if (newContentEl)
      observer.observe(newContentEl);
  }, {
    immediate: true
  });
  onScopeDispose(() => {
    observer.disconnect();
  });
  function updateLocation() {
    observe = false;
    requestAnimationFrame(() => {
      requestAnimationFrame(() => observe = true);
    });
    if (!data.activatorEl.value || !data.contentEl.value)
      return;
    const targetBox = data.activatorEl.value.getBoundingClientRect();
    const contentBox = getIntrinsicSize(data.contentEl.value);
    const scrollParents = getScrollParents(data.contentEl.value);
    const viewportMargin = 12;
    if (!scrollParents.length) {
      scrollParents.push(document.documentElement);
      if (!(data.contentEl.value.style.top && data.contentEl.value.style.left)) {
        contentBox.x += parseFloat(document.documentElement.style.getPropertyValue("--v-body-scroll-x") || 0);
        contentBox.y += parseFloat(document.documentElement.style.getPropertyValue("--v-body-scroll-y") || 0);
      }
    }
    const viewport = scrollParents.reduce((box, el2) => {
      const rect = el2.getBoundingClientRect();
      const scrollBox = new Box({
        x: el2 === document.documentElement ? 0 : rect.x,
        y: el2 === document.documentElement ? 0 : rect.y,
        width: el2.clientWidth,
        height: el2.clientHeight
      });
      if (box) {
        return new Box({
          x: Math.max(box.left, scrollBox.left),
          y: Math.max(box.top, scrollBox.top),
          width: Math.min(box.right, scrollBox.right) - Math.max(box.left, scrollBox.left),
          height: Math.min(box.bottom, scrollBox.bottom) - Math.max(box.top, scrollBox.top)
        });
      }
      return scrollBox;
    }, void 0);
    viewport.x += viewportMargin;
    viewport.y += viewportMargin;
    viewport.width -= viewportMargin * 2;
    viewport.height -= viewportMargin * 2;
    let placement = {
      anchor: preferredAnchor.value,
      origin: preferredOrigin.value
    };
    function checkOverflow(_placement) {
      const box = new Box(contentBox);
      const targetPoint = anchorToPoint(_placement.anchor, targetBox);
      const contentPoint = anchorToPoint(_placement.origin, box);
      let {
        x: x3,
        y: y4
      } = getOffset(targetPoint, contentPoint);
      switch (_placement.anchor.side) {
        case "top":
          y4 -= offset.value[0];
          break;
        case "bottom":
          y4 += offset.value[0];
          break;
        case "left":
          x3 -= offset.value[0];
          break;
        case "right":
          x3 += offset.value[0];
          break;
      }
      switch (_placement.anchor.align) {
        case "top":
          y4 -= offset.value[1];
          break;
        case "bottom":
          y4 += offset.value[1];
          break;
        case "left":
          x3 -= offset.value[1];
          break;
        case "right":
          x3 += offset.value[1];
          break;
      }
      box.x += x3;
      box.y += y4;
      box.width = Math.min(box.width, maxWidth.value);
      box.height = Math.min(box.height, maxHeight.value);
      const overflows = getOverflow(box, viewport);
      return {
        overflows,
        x: x3,
        y: y4
      };
    }
    let x2 = 0;
    let y3 = 0;
    const available = {
      x: 0,
      y: 0
    };
    const flipped = {
      x: false,
      y: false
    };
    let resets = -1;
    while (true) {
      if (resets++ > 10) {
        consoleError("Infinite loop detected in connectedLocationStrategy");
        break;
      }
      const {
        x: _x,
        y: _y,
        overflows
      } = checkOverflow(placement);
      x2 += _x;
      y3 += _y;
      contentBox.x += _x;
      contentBox.y += _y;
      {
        const axis2 = getAxis(placement.anchor);
        const hasOverflowX = overflows.x.before || overflows.x.after;
        const hasOverflowY = overflows.y.before || overflows.y.after;
        let reset = false;
        ["x", "y"].forEach((key) => {
          if (key === "x" && hasOverflowX && !flipped.x || key === "y" && hasOverflowY && !flipped.y) {
            const newPlacement = {
              anchor: {
                ...placement.anchor
              },
              origin: {
                ...placement.origin
              }
            };
            const flip = key === "x" ? axis2 === "y" ? flipAlign : flipSide : axis2 === "y" ? flipSide : flipAlign;
            newPlacement.anchor = flip(newPlacement.anchor);
            newPlacement.origin = flip(newPlacement.origin);
            const {
              overflows: newOverflows
            } = checkOverflow(newPlacement);
            if (newOverflows[key].before <= overflows[key].before && newOverflows[key].after <= overflows[key].after || newOverflows[key].before + newOverflows[key].after < (overflows[key].before + overflows[key].after) / 2) {
              placement = newPlacement;
              reset = flipped[key] = true;
            }
          }
        });
        if (reset)
          continue;
      }
      if (overflows.x.before) {
        x2 += overflows.x.before;
        contentBox.x += overflows.x.before;
      }
      if (overflows.x.after) {
        x2 -= overflows.x.after;
        contentBox.x -= overflows.x.after;
      }
      if (overflows.y.before) {
        y3 += overflows.y.before;
        contentBox.y += overflows.y.before;
      }
      if (overflows.y.after) {
        y3 -= overflows.y.after;
        contentBox.y -= overflows.y.after;
      }
      {
        const overflows2 = getOverflow(contentBox, viewport);
        available.x = viewport.width - overflows2.x.before - overflows2.x.after;
        available.y = viewport.height - overflows2.y.before - overflows2.y.after;
        x2 += overflows2.x.before;
        contentBox.x += overflows2.x.before;
        y3 += overflows2.y.before;
        contentBox.y += overflows2.y.before;
      }
      break;
    }
    const axis = getAxis(placement.anchor);
    Object.assign(contentStyles.value, {
      "--v-overlay-anchor-origin": `${placement.anchor.side} ${placement.anchor.align}`,
      transformOrigin: `${placement.origin.side} ${placement.origin.align}`,
      top: convertToUnit(pixelRound(y3)),
      left: convertToUnit(pixelRound(x2)),
      minWidth: convertToUnit(axis === "y" ? Math.min(minWidth.value, targetBox.width) : minWidth.value),
      maxWidth: convertToUnit(pixelCeil(clamp(available.x, minWidth.value === Infinity ? 0 : minWidth.value, maxWidth.value))),
      maxHeight: convertToUnit(pixelCeil(clamp(available.y, minHeight.value === Infinity ? 0 : minHeight.value, maxHeight.value)))
    });
    return {
      available,
      contentBox
    };
  }
  watch(() => [preferredAnchor.value, preferredOrigin.value, props.offset, props.minWidth, props.minHeight, props.maxWidth, props.maxHeight], () => updateLocation());
  nextTick(() => {
    const result = updateLocation();
    if (!result)
      return;
    const {
      available,
      contentBox
    } = result;
    if (contentBox.height > available.y) {
      requestAnimationFrame(() => {
        updateLocation();
        requestAnimationFrame(() => {
          updateLocation();
        });
      });
    }
  });
  return {
    updateLocation
  };
}
function pixelRound(val) {
  return Math.round(val * devicePixelRatio) / devicePixelRatio;
}
function pixelCeil(val) {
  return Math.ceil(val * devicePixelRatio) / devicePixelRatio;
}
let clean = true;
const frames = [];
function requestNewFrame(cb) {
  if (!clean || frames.length) {
    frames.push(cb);
    run();
  } else {
    clean = false;
    cb();
    run();
  }
}
let raf = -1;
function run() {
  cancelAnimationFrame(raf);
  raf = requestAnimationFrame(() => {
    const frame = frames.shift();
    if (frame)
      frame();
    if (frames.length)
      run();
    else
      clean = true;
  });
}
const scrollStrategies = {
  none: null,
  close: closeScrollStrategy,
  block: blockScrollStrategy,
  reposition: repositionScrollStrategy
};
const makeScrollStrategyProps = propsFactory({
  scrollStrategy: {
    type: [String, Function],
    default: "block",
    validator: (val) => typeof val === "function" || val in scrollStrategies
  }
}, "v-overlay-scroll-strategies");
function useScrollStrategies(props, data) {
  if (!IN_BROWSER)
    return;
  let scope;
  watchEffect(async () => {
    var _scope;
    (_scope = scope) == null ? void 0 : _scope.stop();
    if (!(data.isActive.value && props.scrollStrategy))
      return;
    scope = effectScope();
    await nextTick();
    scope.run(() => {
      if (typeof props.scrollStrategy === "function") {
        props.scrollStrategy(data, props, scope);
      } else {
        var _scrollStrategies$pro;
        (_scrollStrategies$pro = scrollStrategies[props.scrollStrategy]) == null ? void 0 : _scrollStrategies$pro.call(scrollStrategies, data, props, scope);
      }
    });
  });
  onScopeDispose(() => {
    var _scope2;
    (_scope2 = scope) == null ? void 0 : _scope2.stop();
  });
}
function closeScrollStrategy(data) {
  var _a2;
  function onScroll(e3) {
    data.isActive.value = false;
  }
  bindScroll((_a2 = data.activatorEl.value) != null ? _a2 : data.contentEl.value, onScroll);
}
function blockScrollStrategy(data, props) {
  var _data$root$value;
  const offsetParent = (_data$root$value = data.root.value) == null ? void 0 : _data$root$value.offsetParent;
  const scrollElements = [.../* @__PURE__ */ new Set([...getScrollParents(data.activatorEl.value, props.contained ? offsetParent : void 0), ...getScrollParents(data.contentEl.value, props.contained ? offsetParent : void 0)])].filter((el2) => !el2.classList.contains("v-overlay-scroll-blocked"));
  const scrollbarWidth = window.innerWidth - document.documentElement.offsetWidth;
  const scrollableParent = ((el2) => hasScrollbar(el2) && el2)(offsetParent || document.documentElement);
  if (scrollableParent) {
    data.root.value.classList.add("v-overlay--scroll-blocked");
  }
  scrollElements.forEach((el2, i2) => {
    el2.style.setProperty("--v-body-scroll-x", convertToUnit(-el2.scrollLeft));
    el2.style.setProperty("--v-body-scroll-y", convertToUnit(-el2.scrollTop));
    el2.style.setProperty("--v-scrollbar-offset", convertToUnit(scrollbarWidth));
    el2.classList.add("v-overlay-scroll-blocked");
  });
  onScopeDispose(() => {
    scrollElements.forEach((el2, i2) => {
      const x2 = parseFloat(el2.style.getPropertyValue("--v-body-scroll-x"));
      const y3 = parseFloat(el2.style.getPropertyValue("--v-body-scroll-y"));
      el2.style.removeProperty("--v-body-scroll-x");
      el2.style.removeProperty("--v-body-scroll-y");
      el2.style.removeProperty("--v-scrollbar-offset");
      el2.classList.remove("v-overlay-scroll-blocked");
      el2.scrollLeft = -x2;
      el2.scrollTop = -y3;
    });
    if (scrollableParent) {
      data.root.value.classList.remove("v-overlay--scroll-blocked");
    }
  });
}
function repositionScrollStrategy(data, props, scope) {
  let slow = false;
  let raf2 = -1;
  let ric = -1;
  function update(e3) {
    requestNewFrame(() => {
      var _data$updateLocation$, _data$updateLocation;
      const start = performance.now();
      (_data$updateLocation$ = (_data$updateLocation = data.updateLocation).value) == null ? void 0 : _data$updateLocation$.call(_data$updateLocation, e3);
      const time = performance.now() - start;
      slow = time / (1e3 / 60) > 2;
    });
  }
  ric = requestIdleCallback(() => {
    scope.run(() => {
      var _a2;
      bindScroll((_a2 = data.activatorEl.value) != null ? _a2 : data.contentEl.value, (e3) => {
        if (slow) {
          cancelAnimationFrame(raf2);
          raf2 = requestAnimationFrame(() => {
            raf2 = requestAnimationFrame(() => {
              update(e3);
            });
          });
        } else {
          update(e3);
        }
      });
    });
  });
  onScopeDispose(() => {
    cancelIdleCallback(ric);
    cancelAnimationFrame(raf2);
  });
}
function bindScroll(el2, onScroll) {
  const scrollElements = [document, ...getScrollParents(el2)];
  scrollElements.forEach((el3) => {
    el3.addEventListener("scroll", onScroll, {
      passive: true
    });
  });
  onScopeDispose(() => {
    scrollElements.forEach((el3) => {
      el3.removeEventListener("scroll", onScroll);
    });
  });
}
function useHydration() {
  if (!IN_BROWSER)
    return ref(false);
  const {
    ssr
  } = useDisplay();
  if (ssr) {
    const isMounted = ref(false);
    onMounted(() => {
      isMounted.value = true;
    });
    return isMounted;
  } else {
    return ref(true);
  }
}
function useScopeId() {
  const vm = getCurrentInstance("useScopeId");
  const scopeId = vm.vnode.scopeId;
  return {
    scopeId: scopeId ? {
      [scopeId]: ""
    } : void 0
  };
}
const StackSymbol = Symbol.for("vuetify:stack");
const globalStack = reactive([]);
function useStack(isActive, zIndex, disableGlobalStack) {
  const vm = getCurrentInstance("useStack");
  const createStackEntry = !disableGlobalStack;
  const parent = inject$1(StackSymbol, void 0);
  const stack = reactive({
    activeChildren: /* @__PURE__ */ new Set()
  });
  provide(StackSymbol, stack);
  const _zIndex = ref(+zIndex.value);
  useToggleScope(isActive, () => {
    var _globalStack$at;
    const lastZIndex = (_globalStack$at = globalStack.at(-1)) == null ? void 0 : _globalStack$at[1];
    _zIndex.value = lastZIndex ? lastZIndex + 10 : +zIndex.value;
    if (createStackEntry) {
      globalStack.push([vm.uid, _zIndex.value]);
    }
    parent == null ? void 0 : parent.activeChildren.add(vm.uid);
    onScopeDispose(() => {
      if (createStackEntry) {
        const idx = globalStack.findIndex((v) => v[0] === vm.uid);
        globalStack.splice(idx, 1);
      }
      parent == null ? void 0 : parent.activeChildren.delete(vm.uid);
    });
  });
  const globalTop = ref(true);
  if (createStackEntry) {
    watchEffect(() => {
      var _globalStack$at2;
      const _isTop = ((_globalStack$at2 = globalStack.at(-1)) == null ? void 0 : _globalStack$at2[0]) === vm.uid;
      setTimeout(() => globalTop.value = _isTop);
    });
  }
  const localTop = computed(() => !stack.activeChildren.size);
  return {
    globalTop: readonly(globalTop),
    localTop,
    stackStyles: computed(() => ({
      zIndex: _zIndex.value
    }))
  };
}
function useTeleport(target) {
  const teleportTarget = computed(() => {
    const _target = target.value;
    if (_target === true || !IN_BROWSER)
      return void 0;
    const targetElement = _target === false ? document.body : typeof _target === "string" ? document.querySelector(_target) : _target;
    if (targetElement == null) {
      return void 0;
    }
    let container = targetElement.querySelector(".v-overlay-container");
    if (!container) {
      container = document.createElement("div");
      container.className = "v-overlay-container";
      targetElement.appendChild(container);
    }
    return container;
  });
  return {
    teleportTarget
  };
}
function defaultConditional() {
  return true;
}
function checkEvent(e3, el2, binding) {
  if (!e3 || checkIsActive(e3, binding) === false)
    return false;
  const root = attachedRoot(el2);
  if (typeof ShadowRoot !== "undefined" && root instanceof ShadowRoot && root.host === e3.target)
    return false;
  const elements = (typeof binding.value === "object" && binding.value.include || (() => []))();
  elements.push(el2);
  return !elements.some((el3) => el3 == null ? void 0 : el3.contains(e3.target));
}
function checkIsActive(e3, binding) {
  const isActive = typeof binding.value === "object" && binding.value.closeConditional || defaultConditional;
  return isActive(e3);
}
function directive(e3, el2, binding) {
  const handler = typeof binding.value === "function" ? binding.value : binding.value.handler;
  el2._clickOutside.lastMousedownWasOutside && checkEvent(e3, el2, binding) && setTimeout(() => {
    checkIsActive(e3, binding) && handler && handler(e3);
  }, 0);
}
function handleShadow(el2, callback) {
  const root = attachedRoot(el2);
  callback(document);
  if (typeof ShadowRoot !== "undefined" && root instanceof ShadowRoot) {
    callback(root);
  }
}
const ClickOutside = {
  mounted(el2, binding) {
    const onClick = (e3) => directive(e3, el2, binding);
    const onMousedown = (e3) => {
      el2._clickOutside.lastMousedownWasOutside = checkEvent(e3, el2, binding);
    };
    handleShadow(el2, (app2) => {
      app2.addEventListener("click", onClick, true);
      app2.addEventListener("mousedown", onMousedown, true);
    });
    if (!el2._clickOutside) {
      el2._clickOutside = {
        lastMousedownWasOutside: true
      };
    }
    el2._clickOutside[binding.instance.$.uid] = {
      onClick,
      onMousedown
    };
  },
  unmounted(el2, binding) {
    if (!el2._clickOutside)
      return;
    handleShadow(el2, (app2) => {
      var _el$_clickOutside;
      if (!app2 || !((_el$_clickOutside = el2._clickOutside) != null && _el$_clickOutside[binding.instance.$.uid]))
        return;
      const {
        onClick,
        onMousedown
      } = el2._clickOutside[binding.instance.$.uid];
      app2.removeEventListener("click", onClick, true);
      app2.removeEventListener("mousedown", onMousedown, true);
    });
    delete el2._clickOutside[binding.instance.$.uid];
  }
};
function Scrim(props) {
  const {
    modelValue,
    color,
    ...rest
  } = props;
  return createVNode(Transition, {
    "name": "fade-transition",
    "appear": true
  }, {
    default: () => [props.modelValue && createVNode("div", mergeProps({
      "class": ["v-overlay__scrim", props.color.backgroundColorClasses.value],
      "style": props.color.backgroundColorStyles.value
    }, rest), null)]
  });
}
const makeVOverlayProps = propsFactory({
  absolute: Boolean,
  attach: [Boolean, String, Object],
  closeOnBack: {
    type: Boolean,
    default: true
  },
  contained: Boolean,
  contentClass: null,
  contentProps: null,
  disabled: Boolean,
  noClickAnimation: Boolean,
  modelValue: Boolean,
  persistent: Boolean,
  scrim: {
    type: [String, Boolean],
    default: true
  },
  zIndex: {
    type: [Number, String],
    default: 2e3
  },
  ...makeActivatorProps(),
  ...makeDimensionProps(),
  ...makeLazyProps(),
  ...makeLocationStrategyProps(),
  ...makeScrollStrategyProps(),
  ...makeThemeProps(),
  ...makeTransitionProps()
}, "v-overlay");
const VOverlay = genericComponent()({
  name: "VOverlay",
  directives: {
    ClickOutside
  },
  inheritAttrs: false,
  props: {
    _disableGlobalStack: Boolean,
    ...makeVOverlayProps()
  },
  emits: {
    "click:outside": (e3) => true,
    "update:modelValue": (value) => true,
    afterLeave: () => true
  },
  setup(props, _ref) {
    let {
      slots,
      attrs,
      emit: emit2
    } = _ref;
    const model = useProxiedModel(props, "modelValue");
    const isActive = computed({
      get: () => model.value,
      set: (v) => {
        if (!(v && props.disabled))
          model.value = v;
      }
    });
    const {
      teleportTarget
    } = useTeleport(computed(() => props.attach || props.contained));
    const {
      themeClasses
    } = provideTheme(props);
    const {
      rtlClasses,
      isRtl
    } = useRtl();
    const {
      hasContent,
      onAfterLeave
    } = useLazy(props, isActive);
    const scrimColor = useBackgroundColor(computed(() => {
      return typeof props.scrim === "string" ? props.scrim : null;
    }));
    const {
      globalTop,
      localTop,
      stackStyles
    } = useStack(isActive, toRef(props, "zIndex"), props._disableGlobalStack);
    const {
      activatorEl,
      activatorRef,
      activatorEvents,
      contentEvents,
      scrimEvents
    } = useActivator(props, {
      isActive,
      isTop: localTop
    });
    const {
      dimensionStyles
    } = useDimension(props);
    const isMounted = useHydration();
    const {
      scopeId
    } = useScopeId();
    watch(() => props.disabled, (v) => {
      if (v)
        isActive.value = false;
    });
    const root = ref();
    const contentEl = ref();
    const {
      contentStyles,
      updateLocation
    } = useLocationStrategies(props, {
      isRtl,
      contentEl,
      activatorEl,
      isActive
    });
    useScrollStrategies(props, {
      root,
      contentEl,
      activatorEl,
      isActive,
      updateLocation
    });
    function onClickOutside(e3) {
      emit2("click:outside", e3);
      if (!props.persistent)
        isActive.value = false;
      else
        animateClick();
    }
    function closeConditional() {
      return isActive.value && globalTop.value;
    }
    IN_BROWSER && watch(isActive, (val) => {
      if (val) {
        window.addEventListener("keydown", onKeydown);
      } else {
        window.removeEventListener("keydown", onKeydown);
      }
    }, {
      immediate: true
    });
    function onKeydown(e3) {
      if (e3.key === "Escape" && globalTop.value) {
        if (!props.persistent) {
          isActive.value = false;
        } else
          animateClick();
      }
    }
    const router = useRouter();
    useToggleScope(() => props.closeOnBack, () => {
      useBackButton(router, (next) => {
        if (globalTop.value && isActive.value) {
          next(false);
          if (!props.persistent)
            isActive.value = false;
          else
            animateClick();
        } else {
          next();
        }
      });
    });
    const top = ref();
    watch(() => isActive.value && (props.absolute || props.contained) && teleportTarget.value == null, (val) => {
      if (val) {
        const scrollParent = getScrollParent(root.value);
        if (scrollParent && scrollParent !== document.scrollingElement) {
          top.value = scrollParent.scrollTop;
        }
      }
    });
    function animateClick() {
      if (props.noClickAnimation)
        return;
      contentEl.value && animate(contentEl.value, [{
        transformOrigin: "center"
      }, {
        transform: "scale(1.03)"
      }, {
        transformOrigin: "center"
      }], {
        duration: 150,
        easing: standardEasing
      });
    }
    useRender(() => {
      var _slots$activator, _slots$default;
      return createVNode(Fragment, null, [(_slots$activator = slots.activator) == null ? void 0 : _slots$activator.call(slots, {
        isActive: isActive.value,
        props: mergeProps({
          ref: activatorRef
        }, toHandlers(activatorEvents.value), props.activatorProps)
      }), isMounted.value && createVNode(Teleport, {
        "disabled": !teleportTarget.value,
        "to": teleportTarget.value
      }, {
        default: () => [hasContent.value && createVNode("div", mergeProps({
          "class": ["v-overlay", {
            "v-overlay--absolute": props.absolute || props.contained,
            "v-overlay--active": isActive.value,
            "v-overlay--contained": props.contained
          }, themeClasses.value, rtlClasses.value],
          "style": [stackStyles.value, {
            top: convertToUnit(top.value)
          }],
          "ref": root
        }, scopeId, attrs), [createVNode(Scrim, mergeProps({
          "color": scrimColor,
          "modelValue": isActive.value && !!props.scrim
        }, toHandlers(scrimEvents.value)), null), createVNode(MaybeTransition, {
          "appear": true,
          "persisted": true,
          "transition": props.transition,
          "target": activatorEl.value,
          "onAfterLeave": () => {
            onAfterLeave();
            emit2("afterLeave");
          }
        }, {
          default: () => [withDirectives(createVNode("div", mergeProps({
            "ref": contentEl,
            "class": ["v-overlay__content", props.contentClass],
            "style": [dimensionStyles.value, contentStyles.value]
          }, toHandlers(contentEvents.value), props.contentProps), [(_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots, {
            isActive
          })]), [[vShow, isActive.value], [resolveDirective("click-outside"), {
            handler: onClickOutside,
            closeConditional,
            include: () => [activatorEl.value]
          }]])]
        })])]
      })]);
    });
    return {
      activatorEl,
      animateClick,
      contentEl,
      globalTop,
      localTop,
      updateLocation
    };
  }
});
function filterVOverlayProps(props) {
  return pick(props, Object.keys(VOverlay.props));
}
const VMenu = genericComponent()({
  name: "VMenu",
  props: {
    id: String,
    ...omit(makeVOverlayProps({
      closeDelay: 250,
      closeOnContentClick: true,
      locationStrategy: "connected",
      openDelay: 300,
      scrim: false,
      scrollStrategy: "reposition",
      transition: {
        component: VDialogTransition
      }
    }), ["absolute"])
  },
  emits: {
    "update:modelValue": (value) => true
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const isActive = useProxiedModel(props, "modelValue");
    const {
      scopeId
    } = useScopeId();
    const uid2 = getUid();
    const id = computed(() => props.id || `v-menu-${uid2}`);
    const overlay = ref();
    const parent = inject$1(VMenuSymbol, null);
    let openChildren = 0;
    provide(VMenuSymbol, {
      register() {
        ++openChildren;
      },
      unregister() {
        --openChildren;
      },
      closeParents() {
        setTimeout(() => {
          if (!openChildren) {
            isActive.value = false;
            parent == null ? void 0 : parent.closeParents();
          }
        }, 40);
      }
    });
    watch(isActive, (val) => {
      val ? parent == null ? void 0 : parent.register() : parent == null ? void 0 : parent.unregister();
    });
    function onClickOutside() {
      parent == null ? void 0 : parent.closeParents();
    }
    const activatorProps = computed(() => mergeProps({
      "aria-haspopup": "menu",
      "aria-expanded": String(isActive.value),
      "aria-owns": id.value
    }, props.activatorProps));
    useRender(() => {
      const [overlayProps] = filterVOverlayProps(props);
      return createVNode(VOverlay, mergeProps({
        "ref": overlay,
        "class": ["v-menu"]
      }, overlayProps, {
        "modelValue": isActive.value,
        "onUpdate:modelValue": ($event) => isActive.value = $event,
        "absolute": true,
        "activatorProps": activatorProps.value,
        "onClick:outside": onClickOutside
      }, scopeId), {
        activator: slots.activator,
        default: function() {
          var _slots$default;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          return createVNode(VDefaultsProvider, {
            "root": true
          }, {
            default: () => [(_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots, ...args)]
          });
        }
      });
    });
    return forwardRefs({
      id
    }, overlay);
  }
});
const makeSelectProps = propsFactory({
  chips: Boolean,
  closableChips: Boolean,
  eager: Boolean,
  hideNoData: Boolean,
  hideSelected: Boolean,
  menu: Boolean,
  menuIcon: {
    type: IconValue,
    default: "$dropdown"
  },
  menuProps: {
    type: Object
  },
  multiple: Boolean,
  noDataText: {
    type: String,
    default: "$vuetify.noDataText"
  },
  openOnClear: Boolean,
  valueComparator: {
    type: Function,
    default: deepEqual
  },
  ...makeItemsProps({
    itemChildren: false
  })
}, "v-select");
const VSelect = genericComponent()({
  name: "VSelect",
  props: {
    ...makeSelectProps(),
    ...omit(makeVTextFieldProps({
      modelValue: null
    }), ["validationValue", "dirty", "appendInnerIcon"]),
    ...makeTransitionProps({
      transition: {
        component: VDialogTransition
      }
    })
  },
  emits: {
    "update:modelValue": (val) => true,
    "update:menu": (val) => true
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const {
      t: t3
    } = useLocale();
    const vTextFieldRef = ref();
    const menu = useProxiedModel(props, "menu");
    const {
      items,
      transformIn,
      transformOut
    } = useItems(props);
    const model = useProxiedModel(props, "modelValue", [], (v) => transformIn(wrapInArray(v)), (v) => {
      var _a2;
      const transformed = transformOut(v);
      return props.multiple ? transformed : (_a2 = transformed[0]) != null ? _a2 : null;
    });
    const form = useForm();
    const selections = computed(() => {
      return model.value.map((v) => {
        return items.value.find((item) => props.valueComparator(item.value, v.value)) || v;
      });
    });
    const selected = computed(() => selections.value.map((selection) => selection.props.value));
    const displayItems = computed(() => {
      if (props.hideSelected) {
        return items.value.filter((item) => !selections.value.some((s3) => s3 === item));
      }
      return items.value;
    });
    const listRef = ref();
    function onClear(e3) {
      model.value = [];
      if (props.openOnClear) {
        menu.value = true;
      }
    }
    function onClickControl() {
      if (props.hideNoData && !items.value.length || props.readonly || form != null && form.isReadonly.value)
        return;
      menu.value = !menu.value;
    }
    function onKeydown(e3) {
      if (props.readonly || form != null && form.isReadonly.value)
        return;
      if (["Enter", " ", "ArrowDown", "ArrowUp", "Home", "End"].includes(e3.key)) {
        e3.preventDefault();
      }
      if (["Enter", "ArrowDown", " "].includes(e3.key)) {
        menu.value = true;
      }
      if (["Escape", "Tab"].includes(e3.key)) {
        menu.value = false;
      }
      if (e3.key === "ArrowDown") {
        var _listRef$value;
        (_listRef$value = listRef.value) == null ? void 0 : _listRef$value.focus("next");
      } else if (e3.key === "ArrowUp") {
        var _listRef$value2;
        (_listRef$value2 = listRef.value) == null ? void 0 : _listRef$value2.focus("prev");
      } else if (e3.key === "Home") {
        var _listRef$value3;
        (_listRef$value3 = listRef.value) == null ? void 0 : _listRef$value3.focus("first");
      } else if (e3.key === "End") {
        var _listRef$value4;
        (_listRef$value4 = listRef.value) == null ? void 0 : _listRef$value4.focus("last");
      }
    }
    function select(item) {
      if (props.multiple) {
        const index2 = selected.value.findIndex((selection) => props.valueComparator(selection, item.value));
        if (index2 === -1) {
          model.value = [...model.value, item];
        } else {
          const value = [...model.value];
          value.splice(index2, 1);
          model.value = value;
        }
      } else {
        model.value = [item];
        menu.value = false;
      }
    }
    function onBlur(e3) {
      var _listRef$value5;
      if (!((_listRef$value5 = listRef.value) != null && _listRef$value5.$el.contains(e3.relatedTarget))) {
        menu.value = false;
      }
    }
    function onFocusout(e3) {
      if (e3.relatedTarget == null) {
        var _vTextFieldRef$value;
        (_vTextFieldRef$value = vTextFieldRef.value) == null ? void 0 : _vTextFieldRef$value.focus();
      }
    }
    useRender(() => {
      const hasChips = !!(props.chips || slots.chip);
      const hasList = !!(!props.hideNoData || displayItems.value.length || slots.prepend || slots.append || slots["no-data"]);
      const [textFieldProps] = filterVTextFieldProps(props);
      return createVNode(VTextField, mergeProps({
        "ref": vTextFieldRef
      }, textFieldProps, {
        "modelValue": model.value.map((v) => v.props.value).join(", "),
        "onUpdate:modelValue": (v) => {
          if (v == null)
            model.value = [];
        },
        "validationValue": model.externalValue,
        "dirty": model.value.length > 0,
        "class": ["v-select", {
          "v-select--active-menu": menu.value,
          "v-select--chips": !!props.chips,
          [`v-select--${props.multiple ? "multiple" : "single"}`]: true,
          "v-select--selected": model.value.length
        }],
        "appendInnerIcon": props.menuIcon,
        "readonly": true,
        "onClick:clear": onClear,
        "onClick:control": onClickControl,
        "onBlur": onBlur,
        "onKeydown": onKeydown
      }), {
        ...slots,
        default: () => {
          var _slots$noData, _slots$prependItem, _slots$appendItem;
          return createVNode(Fragment, null, [createVNode(VMenu, mergeProps({
            "modelValue": menu.value,
            "onUpdate:modelValue": ($event) => menu.value = $event,
            "activator": "parent",
            "contentClass": "v-select__content",
            "eager": props.eager,
            "maxHeight": 310,
            "openOnClick": false,
            "closeOnContentClick": false,
            "transition": props.transition
          }, props.menuProps), {
            default: () => [hasList && createVNode(VList, {
              "ref": listRef,
              "selected": selected.value,
              "selectStrategy": props.multiple ? "independent" : "single-independent",
              "onMousedown": (e3) => e3.preventDefault(),
              "onFocusout": onFocusout
            }, {
              default: () => {
                var _a2;
                return [!displayItems.value.length && !props.hideNoData && ((_a2 = (_slots$noData = slots["no-data"]) == null ? void 0 : _slots$noData.call(slots)) != null ? _a2 : createVNode(VListItem, {
                  "title": t3(props.noDataText)
                }, null)), (_slots$prependItem = slots["prepend-item"]) == null ? void 0 : _slots$prependItem.call(slots), displayItems.value.map((item, index2) => {
                  if (slots.item) {
                    var _slots$item;
                    return (_slots$item = slots.item) == null ? void 0 : _slots$item.call(slots, {
                      item,
                      index: index2,
                      props: mergeProps(item.props, {
                        onClick: () => select(item)
                      })
                    });
                  }
                  return createVNode(VListItem, mergeProps({
                    "key": index2
                  }, item.props, {
                    "onClick": () => select(item)
                  }), {
                    prepend: (_ref2) => {
                      let {
                        isSelected
                      } = _ref2;
                      return props.multiple && !props.hideSelected ? createVNode(VCheckboxBtn, {
                        "modelValue": isSelected,
                        "ripple": false
                      }, null) : void 0;
                    }
                  });
                }), (_slots$appendItem = slots["append-item"]) == null ? void 0 : _slots$appendItem.call(slots)];
              }
            })]
          }), selections.value.map((item, index2) => {
            function onChipClose(e3) {
              e3.stopPropagation();
              e3.preventDefault();
              select(item);
            }
            const slotProps = {
              "onClick:close": onChipClose,
              modelValue: true,
              "onUpdate:modelValue": void 0
            };
            return createVNode("div", {
              "key": item.value,
              "class": "v-select__selection"
            }, [hasChips ? createVNode(VDefaultsProvider, {
              "defaults": {
                VChip: {
                  closable: props.closableChips,
                  size: "small",
                  text: item.title
                }
              }
            }, {
              default: () => [slots.chip ? slots.chip({
                item,
                index: index2,
                props: slotProps
              }) : createVNode(VChip, slotProps, null)]
            }) : slots.selection ? slots.selection({
              item,
              index: index2
            }) : createVNode("span", {
              "class": "v-select__selection-text"
            }, [item.title, props.multiple && index2 < selections.value.length - 1 && createVNode("span", {
              "class": "v-select__selection-comma"
            }, [createTextVNode(",")])])]);
          })]);
        }
      });
    });
    return forwardRefs({
      menu,
      select
    }, vTextFieldRef);
  }
});
const VSwitch$1 = "";
const VProgressCircular$1 = "";
const VProgressCircular = defineComponent({
  name: "VProgressCircular",
  props: {
    bgColor: String,
    color: String,
    indeterminate: [Boolean, String],
    modelValue: {
      type: [Number, String],
      default: 0
    },
    rotate: {
      type: [Number, String],
      default: 0
    },
    width: {
      type: [Number, String],
      default: 4
    },
    ...makeSizeProps(),
    ...makeTagProps({
      tag: "div"
    }),
    ...makeThemeProps()
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const MAGIC_RADIUS_CONSTANT = 20;
    const CIRCUMFERENCE = 2 * Math.PI * MAGIC_RADIUS_CONSTANT;
    const root = ref();
    const {
      themeClasses
    } = provideTheme(props);
    const {
      sizeClasses,
      sizeStyles
    } = useSize(props);
    const {
      textColorClasses,
      textColorStyles
    } = useTextColor(toRef(props, "color"));
    const {
      textColorClasses: underlayColorClasses,
      textColorStyles: underlayColorStyles
    } = useTextColor(toRef(props, "bgColor"));
    const {
      intersectionRef,
      isIntersecting
    } = useIntersectionObserver();
    const {
      resizeRef,
      contentRect
    } = useResizeObserver();
    const normalizedValue = computed(() => Math.max(0, Math.min(100, parseFloat(props.modelValue))));
    const width = computed(() => Number(props.width));
    const size2 = computed(() => {
      return sizeStyles.value ? Number(props.size) : contentRect.value ? contentRect.value.width : Math.max(width.value, 32);
    });
    const diameter = computed(() => MAGIC_RADIUS_CONSTANT / (1 - width.value / size2.value) * 2);
    const strokeWidth = computed(() => width.value / size2.value * diameter.value);
    const strokeDashOffset = computed(() => convertToUnit((100 - normalizedValue.value) / 100 * CIRCUMFERENCE));
    watchEffect(() => {
      intersectionRef.value = root.value;
      resizeRef.value = root.value;
    });
    useRender(() => createVNode(props.tag, {
      "ref": root,
      "class": ["v-progress-circular", {
        "v-progress-circular--indeterminate": !!props.indeterminate,
        "v-progress-circular--visible": isIntersecting.value,
        "v-progress-circular--disable-shrink": props.indeterminate === "disable-shrink"
      }, themeClasses.value, sizeClasses.value, textColorClasses.value],
      "style": [sizeStyles.value, textColorStyles.value],
      "role": "progressbar",
      "aria-valuemin": "0",
      "aria-valuemax": "100",
      "aria-valuenow": props.indeterminate ? void 0 : normalizedValue.value
    }, {
      default: () => [createVNode("svg", {
        "style": {
          transform: `rotate(calc(-90deg + ${Number(props.rotate)}deg))`
        },
        "xmlns": "http://www.w3.org/2000/svg",
        "viewBox": `0 0 ${diameter.value} ${diameter.value}`
      }, [createVNode("circle", {
        "class": ["v-progress-circular__underlay", underlayColorClasses.value],
        "style": underlayColorStyles.value,
        "fill": "transparent",
        "cx": "50%",
        "cy": "50%",
        "r": MAGIC_RADIUS_CONSTANT,
        "stroke-width": strokeWidth.value,
        "stroke-dasharray": CIRCUMFERENCE,
        "stroke-dashoffset": 0
      }, null), createVNode("circle", {
        "class": "v-progress-circular__overlay",
        "fill": "transparent",
        "cx": "50%",
        "cy": "50%",
        "r": MAGIC_RADIUS_CONSTANT,
        "stroke-width": strokeWidth.value,
        "stroke-dasharray": CIRCUMFERENCE,
        "stroke-dashoffset": strokeDashOffset.value
      }, null)]), slots.default && createVNode("div", {
        "class": "v-progress-circular__content"
      }, [slots.default({
        value: normalizedValue.value
      })])]
    }));
    return {};
  }
});
const VSwitch = defineComponent({
  name: "VSwitch",
  inheritAttrs: false,
  props: {
    indeterminate: Boolean,
    inset: Boolean,
    flat: Boolean,
    loading: {
      type: [Boolean, String],
      default: false
    },
    ...makeVInputProps(),
    ...makeSelectionControlProps()
  },
  emits: {
    "update:focused": (focused) => true,
    "update:modelValue": () => true,
    "update:indeterminate": (val) => true
  },
  setup(props, _ref) {
    let {
      attrs,
      slots
    } = _ref;
    const indeterminate = useProxiedModel(props, "indeterminate");
    const model = useProxiedModel(props, "modelValue");
    const {
      loaderClasses
    } = useLoader(props);
    const {
      isFocused,
      focus,
      blur
    } = useFocus(props);
    const loaderColor = computed(() => {
      return typeof props.loading === "string" && props.loading !== "" ? props.loading : props.color;
    });
    const uid2 = getUid();
    const id = computed(() => props.id || `switch-${uid2}`);
    function onChange() {
      if (indeterminate.value) {
        indeterminate.value = false;
      }
    }
    useRender(() => {
      const [inputAttrs, controlAttrs] = filterInputAttrs(attrs);
      const [inputProps, _1] = filterInputProps(props);
      const [controlProps, _2] = filterControlProps(props);
      const control = ref();
      function onClick() {
        var _control$value, _control$value$input;
        (_control$value = control.value) == null ? void 0 : (_control$value$input = _control$value.input) == null ? void 0 : _control$value$input.click();
      }
      return createVNode(VInput, mergeProps({
        "class": ["v-switch", {
          "v-switch--inset": props.inset
        }, {
          "v-switch--indeterminate": indeterminate.value
        }, loaderClasses.value]
      }, inputAttrs, inputProps, {
        "id": id.value,
        "focused": isFocused.value
      }), {
        ...slots,
        default: (_ref2) => {
          let {
            id: id2,
            messagesId,
            isDisabled,
            isReadonly: isReadonly2,
            isValid: isValid2
          } = _ref2;
          return createVNode(VSelectionControl, mergeProps({
            "ref": control
          }, controlProps, {
            "modelValue": model.value,
            "onUpdate:modelValue": [($event) => model.value = $event, onChange],
            "id": id2.value,
            "aria-describedby": messagesId.value,
            "type": "checkbox",
            "aria-checked": indeterminate.value ? "mixed" : void 0,
            "disabled": isDisabled.value,
            "readonly": isReadonly2.value,
            "onFocus": focus,
            "onBlur": blur
          }, controlAttrs), {
            ...slots,
            default: () => createVNode("div", {
              "class": "v-switch__track",
              "onClick": onClick
            }, null),
            input: (_ref3) => {
              let {
                textColorClasses,
                textColorStyles
              } = _ref3;
              return createVNode("div", {
                "class": ["v-switch__thumb", textColorClasses.value],
                "style": textColorStyles.value
              }, [props.loading && createVNode(LoaderSlot, {
                "name": "v-switch",
                "active": true,
                "color": isValid2.value === false ? void 0 : loaderColor.value
              }, {
                default: (slotProps) => slots.loader ? slots.loader(slotProps) : createVNode(VProgressCircular, {
                  "active": slotProps.isActive,
                  "color": slotProps.color,
                  "indeterminate": true,
                  "size": "16",
                  "width": "2"
                }, null)
              })]);
            }
          });
        }
      });
    });
    return {};
  }
});
const BY_VALUE$2 = "BY_VALUE";
const BY_QUANTITY$2 = "BY_QUANTITY";
const ALL_OPTION$2 = "All";
const _sfc_main$l = {
  name: "FilterSelection",
  props: {
    isDataLoading: { type: Boolean, default: false }
  },
  data() {
    return {
      filters: {
        refreshDates: {
          items: [],
          selected: null
        },
        categories: {
          items: [],
          selected: null,
          filterlabel: "Categories"
        },
        customers: {
          items: [],
          selected: null,
          filterlabel: "Customers"
        },
        valueOrQuantity: BY_QUANTITY$2
      },
      currency: "USD",
      dataLoaded: false,
      BY_VALUE: BY_VALUE$2,
      BY_QUANTITY: BY_QUANTITY$2,
      ALL_OPTION: ALL_OPTION$2,
      includes: _.includes
    };
  },
  async created() {
    const options = await fetchDashboardOptions().catch(() => null);
    if (options) {
      this.filters.categories.items = _.get(options, "ms.categories");
      this.filters.customers.items = _.get(options, "ms.customers");
      this.filters.refreshDates.items = _.get(options, "updateDates");
    }
    this.filters.customers.items = _.concat(
      ALL_OPTION$2,
      this.filters.customers.items
    );
    let earliestRefreshDate = null;
    if (_.first(this.filters.refreshDates.items)) {
      earliestRefreshDate = parse(
        _.first(this.filters.refreshDates.items),
        "yyyy-MM-dd",
        new Date()
      );
    }
    if (earliestRefreshDate !== null) {
      this.updateLatestRefreshDate(earliestRefreshDate);
      this.refreshDateUpdated(
        {
          month: earliestRefreshDate.getMonth(),
          year: earliestRefreshDate.getFullYear()
        },
        true
      );
    }
    this.selectFilterUpdated(
      "categories",
      this.filters.categories.items[0],
      true
    );
    this.selectFilterUpdated(
      "customers",
      this.filters.customers.items[0],
      true
    );
    this.dataLoaded = true;
  },
  emits: ["updateFilters", "updateFiltersInstant", "latestRefreshDateUpdate"],
  methods: {
    formatDatePickerValue(date) {
      return format(date, "MMM yyyy");
    },
    getMinDate() {
      return parse(
        _.last(this.filters.refreshDates.items),
        "yyyy-MM-dd",
        new Date()
      );
    },
    getMaxDate() {
      return endOfMonth(
        parse(
          _.first(this.filters.refreshDates.items),
          "yyyy-MM-dd",
          new Date()
        )
      );
    },
    updateLatestRefreshDate(dateObj) {
      this.$emit("latestRefreshDateUpdate", dateObj);
    },
    selectFilterUpdated(filterName, currentSelection, isInstant = false) {
      this.filters[filterName].selected = currentSelection;
      isInstant ? this.filterUpdatedInstant() : this.filtersUpdated();
    },
    refreshDateUpdated({ month, year }, isInstant = false) {
      this.filters.refreshDates.selected = { month, year };
      isInstant ? this.filterUpdatedInstant() : this.filtersUpdated();
    },
    valueOrQuantityUpdate(event, isInstant = false) {
      this.filters.valueOrQuantity = this.filters.valueOrQuantity === BY_VALUE$2 ? BY_QUANTITY$2 : BY_VALUE$2;
      isInstant ? this.filterUpdatedInstant() : this.filtersUpdated();
    },
    filtersUpdated() {
      this.$emit("updateFilters", this.filters);
    },
    filterUpdatedInstant() {
      this.$emit("updateFiltersInstant", this.filters);
    }
  }
};
const _hoisted_1$k = { class: "tw-flex tw-gap-x-3 tw-w-full tw-bg-white tw-px-3" };
const _hoisted_2$i = { class: "tw-pt-3 tw-min-w-[14%] tw--mb-3" };
const _hoisted_3$i = /* @__PURE__ */ createBaseVNode("label", {
  for: "date-picker",
  class: "tw-text-sm"
}, "Month & Year", -1);
const _hoisted_4$i = { class: "tw-text-base" };
const _hoisted_5$f = { class: "tw-pt-3 tw-min-w-[14%] tw--mb-3" };
const _hoisted_6$e = /* @__PURE__ */ createBaseVNode("label", {
  for: "category",
  class: "tw-text-sm"
}, "Category", -1);
const _hoisted_7$d = { class: "tw-pt-3 tw-min-w-[14%] tw--mb-3" };
const _hoisted_8$d = /* @__PURE__ */ createBaseVNode("label", {
  for: "customers",
  class: "tw-text-sm"
}, "Customer(s)", -1);
const _hoisted_9$d = { class: "tw-flex tw-gap-1.5 tw-pt-3 tw-pl-3 tw--mb-3" };
const _hoisted_10$b = { class: "tw-flex tw-pt-8 tw-text-brand-primary" };
function _sfc_render$l(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_VueDatePicker = resolveComponent("VueDatePicker");
  return openBlock(), createElementBlock("div", _hoisted_1$k, [
    createBaseVNode("div", _hoisted_2$i, [
      _hoisted_3$i,
      createVNode(_component_VueDatePicker, {
        id: "date-picker",
        modelValue: $data.filters.refreshDates.selected,
        "onUpdate:modelValue": [
          _cache[0] || (_cache[0] = ($event) => $data.filters.refreshDates.selected = $event),
          $options.refreshDateUpdated
        ],
        "month-picker": "",
        format: $options.formatDatePickerValue,
        "min-date": $options.getMinDate(),
        "max-date": $options.getMaxDate(),
        clearable: false,
        disabled: $props.isDataLoading || $data.filters.refreshDates.selected === null,
        "auto-apply": "",
        "menu-class-name": "dp-custom-menu"
      }, {
        "dp-input": withCtx(({ value }) => [
          createBaseVNode("div", {
            class: normalizeClass(`tw-flex tw-items-center tw-justify-between tw-py-2 tw-px-3 tw-bg-brand-gray-1
            ${$props.isDataLoading ? "tw-opacity-40" : "tw-cursor-pointer"}`)
          }, [
            createBaseVNode("span", _hoisted_4$i, toDisplayString(value), 1),
            createVNode(VIcon, {
              icon: "mdi-calendar-month",
              class: "tw-text-brand-primary",
              size: 32
            })
          ], 2)
        ]),
        _: 1
      }, 8, ["modelValue", "onUpdate:modelValue", "format", "min-date", "max-date", "disabled"])
    ]),
    createBaseVNode("div", _hoisted_5$f, [
      _hoisted_6$e,
      createVNode(VSelect, {
        id: "category",
        items: $data.filters.categories.items,
        "model-value": $data.filters.categories.selected,
        "onUpdate:modelValue": _cache[1] || (_cache[1] = (value) => $options.selectFilterUpdated("categories", value)),
        density: "comfortable",
        disabled: $props.isDataLoading
      }, null, 8, ["items", "model-value", "disabled"])
    ]),
    createBaseVNode("div", _hoisted_7$d, [
      _hoisted_8$d,
      createVNode(VSelect, {
        id: "customers",
        items: $data.filters.customers.items,
        "model-value": $data.filters.customers.selected,
        "onUpdate:modelValue": _cache[2] || (_cache[2] = (value) => $options.selectFilterUpdated("customers", value)),
        density: "comfortable",
        disabled: $props.isDataLoading
      }, null, 8, ["items", "model-value", "disabled"])
    ]),
    createBaseVNode("div", _hoisted_9$d, [
      createBaseVNode("span", {
        class: normalizeClass(`tw-pt-10 ${$data.filters.valueOrQuantity === $data.BY_VALUE ? "tw-font-medium" : ""}`)
      }, " Value (" + toDisplayString($data.currency) + ") ", 3),
      createBaseVNode("div", _hoisted_10$b, [
        createVNode(VSwitch, {
          "model-value": $data.filters.valueOrQuantity === $data.BY_QUANTITY,
          inset: "",
          density: "compact",
          onClick: $options.valueOrQuantityUpdate,
          disabled: $props.isDataLoading
        }, null, 8, ["model-value", "onClick", "disabled"])
      ]),
      createBaseVNode("span", {
        class: normalizeClass(`tw-pt-10 ${$data.filters.valueOrQuantity === $data.BY_QUANTITY ? "tw-font-medium" : ""}`)
      }, " Volume ", 2)
    ])
  ]);
}
const FiltersSection$2 = /* @__PURE__ */ _export_sfc(_sfc_main$l, [["render", _sfc_render$l]]);
async function getReviews({
  refreshDate,
  customer,
  category,
  valueOrQuantity,
  periodStart,
  periodEnd,
  forecastPeriodType
}) {
  const data = await apiBase("reviews", {
    refreshDate,
    customer,
    category,
    valueOrQuantity,
    periodStart,
    periodEnd,
    forecastPeriodType,
    invalidate: `${Date.now()}`
  });
  const headers = _.get(data, "result.headers");
  const reviews = _.get(data, "result.data");
  const dataForUi = _.map(reviews, (item) => {
    const reviewObj = {};
    _.forEach(headers, (header, index2) => {
      reviewObj[header] = item[index2];
    });
    return reviewObj;
  });
  return dataForUi;
}
async function postApiBase(enpoint, payload) {
  const data = await invokePostApi(enpoint, payload);
  return data;
}
async function addReview({
  userId,
  userDisplayName,
  action,
  asOn,
  comment,
  periodStartDate,
  periodEndDate,
  customer,
  category,
  byValueOrByVolume,
  forecastPeriodType
}) {
  const data = await postApiBase("reviews", {
    userId,
    userDisplayName,
    action,
    asOn,
    comment,
    periodStartDate,
    periodEndDate,
    customer,
    category,
    byValueOrByVolume,
    forecastPeriodType,
    invalidate: `${Date.now()}`
  });
  return data;
}
const chartsScriptUrl = "https://www.gstatic.com/charts/loader.js";
let chartsLoaderPromise = null;
const loadedPackages = /* @__PURE__ */ new Map();
function getChartsLoader() {
  if (window.google !== void 0) {
    return Promise.resolve(window.google.charts);
  }
  if (chartsLoaderPromise === null) {
    chartsLoaderPromise = new Promise((resolve2) => {
      const foundScript = document.querySelector('script[src="'.concat(chartsScriptUrl, '"]'));
      const script = foundScript || document.createElement("script");
      if (!foundScript) {
        script.src = chartsScriptUrl;
        script.type = "text/javascript";
        document.head.append(script);
      }
      script.onload = () => {
        if (window.google !== void 0) {
          resolve2(window.google.charts);
        }
      };
    });
  }
  return chartsLoaderPromise;
}
async function loadGoogleCharts() {
  let version2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "current", { packages = [
    "corechart",
    "controls"
  ], language = "en", mapsApiKey } = arguments.length > 1 ? arguments[1] : void 0;
  const loader = await getChartsLoader();
  const settingsKey = "".concat(version2, "_").concat(packages.join("_"), "_").concat(language);
  if (loadedPackages.has(settingsKey))
    return loadedPackages.get(settingsKey);
  const loaderPromise = new Promise((resolve2) => {
    loader.load(version2, {
      packages,
      language,
      mapsApiKey
    });
    loader.setOnLoadCallback(
      () => resolve2(window.google)
    );
  });
  loadedPackages.set(settingsKey, loaderPromise);
  return loaderPromise;
}
function getValidChartData(chartsLib2, data, isFirstRowLabels) {
  if (chartsLib2 !== null && data instanceof chartsLib2.visualization.DataTable) {
    return data;
  }
  if (chartsLib2 !== null && data instanceof chartsLib2.visualization.DataView) {
    return data;
  }
  if (chartsLib2 !== null && Array.isArray(data)) {
    return chartsLib2.visualization.arrayToDataTable(data, isFirstRowLabels);
  }
  if (chartsLib2 !== null && data !== null && typeof data === "object") {
    return new chartsLib2.visualization.DataTable(data);
  }
  return null;
}
function createChartObject(chartsLib2, chartObject, chartEl, chartType, chartEvents, createChartFunction) {
  const createChart = (el2, google, type) => {
    if (type === void 0) {
      throw new Error("please, provide chart type property");
    }
    return new google.visualization[type](el2);
  };
  if (chartsLib2 === null) {
    throw new Error("please, provide charts lib property");
  }
  if (chartEl === null) {
    throw new Error("please, provide chart element property");
  }
  const fn2 = createChartFunction || createChart;
  chartObject = fn2(chartEl, chartsLib2, chartType);
  attachListeners(chartsLib2, chartObject, chartEvents);
  return chartObject;
}
function attachListeners(chartsLib2, chartObject, chartEvents) {
  if (chartEvents === null) {
    return;
  }
  for (const [event, listener] of Object.entries(chartEvents)) {
    if (chartsLib2 !== null && chartObject !== null) {
      chartsLib2.visualization.events.addListener(chartObject, event, listener);
    }
  }
}
function debounce(func) {
  let waitMilliseconds = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 50;
  let timeoutId;
  function nextInvokeTimeout() {
    return waitMilliseconds;
  }
  const debouncedFunction = function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    const context = this;
    const invokeFunction = function() {
      timeoutId = void 0;
      func.apply(context, args);
    };
    if (timeoutId !== void 0) {
      clearTimeout(timeoutId);
    }
    timeoutId = setTimeout(invokeFunction, nextInvokeTimeout());
  };
  return debouncedFunction;
}
let chartsLib = null;
const GChart = defineComponent$1({
  name: "GChart",
  props: {
    type: {
      type: String,
      required: true
    },
    data: {
      type: [
        Array,
        Object,
        null
      ],
      default: () => []
    },
    isFirstRowLabels: {
      type: Boolean,
      default: false
    },
    options: {
      type: Object,
      default: () => ({})
    },
    version: {
      type: String,
      default: "current"
    },
    settings: {
      type: Object,
      default: () => ({
        packages: [
          "corechart",
          "table"
        ]
      })
    },
    events: {
      type: Object,
      default: null
    },
    createChart: {
      type: Function,
      default: void 0
    },
    resizeDebounce: {
      type: Number,
      default: 200
    }
  },
  setup(props, param) {
    let { emit: emit2 } = param;
    const chartObject = ref(null);
    const chartEl = ref(null);
    function drawChart() {
      if (chartsLib === null || chartObject.value === null) {
        return;
      }
      const data = getValidChartData(chartsLib, props.data, props.isFirstRowLabels);
      if (data !== null) {
        var ref1;
        (ref1 = chartObject.value) === null || ref1 === void 0 ? void 0 : ref1.draw(data, props.options);
      }
    }
    watch(
      () => props.data,
      () => drawChart(),
      {
        deep: true
      }
    );
    watch(
      () => props.options,
      () => drawChart(),
      {
        deep: true
      }
    );
    watch(
      () => props.type,
      () => {
        chartObject.value = createChartObject(chartsLib, chartObject.value, chartEl.value, props.type, props.events, props.createChart);
        drawChart();
      }
    );
    onMounted(() => {
      loadGoogleCharts(props.version, props.settings).then((api) => {
        if (api !== void 0) {
          chartsLib = api;
          chartObject.value = createChartObject(chartsLib, chartObject.value, chartEl.value, props.type, props.events, props.createChart);
          emit2("ready", chartObject.value, api);
          drawChart();
        }
      });
      if (props.resizeDebounce > 0) {
        window.addEventListener("resize", debounce(drawChart, props.resizeDebounce));
      }
    });
    onBeforeUnmount(() => {
      if (chartObject.value !== null && typeof chartObject.value.clearChart === "function") {
        chartObject.value.clearChart();
      }
      if (props.resizeDebounce > 0) {
        window.removeEventListener("resize", debounce(drawChart, props.resizeDebounce));
      }
    });
    return () => h("div", {
      ref: chartEl
    }, []);
  }
});
const app$1 = createApp({});
function install() {
  app$1.component("GChart", GChart);
}
const plugin = {
  version: "1.1.0",
  install
};
let GlobalVue = null;
if (typeof window !== "undefined") {
  GlobalVue = window.Vue;
}
if (GlobalVue !== null && GlobalVue !== void 0) {
  app$1.use(plugin);
}
async function fetchHistoricalModelAccuracyData({
  marketSensingRefreshDate,
  category,
  horizon,
  forecastPeriodType
}) {
  const data = await apiBase("historical_model_accuracy", {
    marketSensingRefreshDate,
    category,
    horizon,
    forecastPeriodType
  });
  return data;
}
const _imports_0 = "/assets/model-accuracy-scale.9965a99a.svg";
const _sfc_main$k = {
  name: "ModelAccuracyChart",
  components: {
    GChart
  },
  props: {
    data: {
      type: Object,
      required: true
    },
    getColorCode: {
      type: Function,
      required: true
    }
  },
  data() {
    return {
      ModelAccuracyScaleIcon: _imports_0
    };
  },
  computed: {
    chartData() {
      return [
        ["period", "modelAccuracy", { role: "style" }, { role: "annotation" }],
        ..._.map(this.data, (el2) => {
          const modelAccuracy = _.toNumber(_.last(el2));
          return [
            ...el2,
            `color: ${this.getColorCode(modelAccuracy)}`,
            `${modelAccuracy}%`
          ];
        })
      ];
    }
  }
};
const _hoisted_1$j = { class: "tw-w-full tw-h-full tw-p-3 tw-bg-white tw-border tw-rounded tw-border-[#D9D9D9] tw-shadow-2xl" };
const _hoisted_2$h = /* @__PURE__ */ createBaseVNode("h1", { class: "tw-text-xl tw-font-medium" }, " Model Accuracy (Rolling Test) for past 6 months ", -1);
const _hoisted_3$h = /* @__PURE__ */ createBaseVNode("div", { class: "tw-w-full tw-border tw-border-solid tw-border-brand-gray-2" }, null, -1);
const _hoisted_4$h = { class: "tw-w-full tw-py-3 tw-px-5 tw-flex tw-justify-center" };
const _hoisted_5$e = ["src"];
function _sfc_render$k(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_GChart = resolveComponent("GChart");
  return openBlock(), createElementBlock("div", _hoisted_1$j, [
    _hoisted_2$h,
    _hoisted_3$h,
    createBaseVNode("div", _hoisted_4$h, [
      createBaseVNode("img", { src: $data.ModelAccuracyScaleIcon }, null, 8, _hoisted_5$e)
    ]),
    createVNode(_component_GChart, {
      type: "ColumnChart",
      data: $options.chartData,
      options: {
        legend: { position: "none" },
        tooltip: { trigger: "none" },
        height: 240,
        width: 560,
        annotations: {
          textStyle: {
            color: "#000000",
            fontSize: 16
          }
        },
        vAxis: {
          gridlines: {
            count: 0
          },
          textPosition: "none",
          viewWindow: {
            max: 100,
            min: 0
          }
        },
        hAxis: {
          textStyle: {
            color: "#1E1E1E",
            fontName: "Graphik",
            fontSize: 11
          }
        },
        chartArea: {
          left: "6%",
          bottom: "12%",
          width: "100%",
          height: "84%"
        }
      }
    }, null, 8, ["data"])
  ]);
}
const ModelAccuracyChart = /* @__PURE__ */ _export_sfc(_sfc_main$k, [["render", _sfc_render$k]]);
const _sfc_main$j = {
  name: "ModelAccuracySection",
  components: {
    GChart,
    ModelAccuracyChart
  },
  props: {
    marketSensingRefreshDate: { type: String, required: true },
    category: { type: String, required: true },
    horizon: { type: String, required: true },
    forecastPeriodType: {
      type: String,
      required: true
    }
  },
  data() {
    return {
      chartData: [],
      modelAccuracy: null,
      isLoading: true,
      error: null
    };
  },
  methods: {
    getColorCode(n2) {
      switch (true) {
        case n2 >= 90:
          return "#8737E1";
        case n2 >= 80:
          return "#BF9CEC";
        case n2 >= 60:
          return "#C6C6C9";
        default:
          return "#A7A7AA";
      }
    },
    async fetchData() {
      this.isLoading = true;
      this.error = null;
      try {
        const response = await fetchHistoricalModelAccuracyData({
          marketSensingRefreshDate: this.marketSensingRefreshDate,
          category: this.category,
          horizon: this.horizon,
          forecastPeriodType: this.forecastPeriodType
        });
        const performance2 = _.get(response, "performance");
        this.chartData = _.take(performance2, _.size(performance2) - 1);
        this.modelAccuracy = _.toNumber(_.last(_.last(performance2)));
      } catch (e3) {
        this.error = e3;
      }
      this.isLoading = false;
    }
  },
  created() {
    this.fetchData();
  }
};
const _hoisted_1$i = /* @__PURE__ */ createBaseVNode("div", { class: "tw-w-96 tw-h-14 tw-p-2 tw-bg-white tw-border tw-rounded tw-border-[#D9D9D9] tw-shadow-2xl" }, [
  /* @__PURE__ */ createBaseVNode("p", { class: "tw-text-sm tw-text-center" }, " ML Model accuracy is the percentage of correctness of prediction by ML Model for the given dataset. ")
], -1);
const _hoisted_2$g = { id: "modelAccuracyPieChart" };
const _hoisted_3$g = {
  key: 0,
  class: "tw-w-full tw-flex tw-justify-center tw-items-center"
};
const _hoisted_4$g = { class: "tw-absolute tw-z-10 tw-h-full tw-w-full tw-flex tw-items-center tw-justify-center tw-text-xl tw-font-semibold" };
function _sfc_render$j(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_GChart = resolveComponent("GChart");
  const _component_ModelAccuracyChart = resolveComponent("ModelAccuracyChart");
  return openBlock(), createElementBlock(Fragment, null, [
    createVNode(VMenu, {
      "open-on-hover": "",
      location: "top"
    }, {
      activator: withCtx(({ props }) => [
        createBaseVNode("p", mergeProps(props, { class: "tw-text-sm desktop:tw-text-xs small-laptop:tw-text-xs tw-font-medium tw-text-center tw-pb-2" }), " ML Model Accuracy ", 16)
      ]),
      default: withCtx(() => [
        _hoisted_1$i
      ]),
      _: 1
    }),
    createBaseVNode("div", _hoisted_2$g, [
      $data.isLoading ? (openBlock(), createElementBlock("div", _hoisted_3$g, [
        createVNode(VProgressCircular, {
          indeterminate: "",
          color: "#7823DC",
          size: 60,
          width: 8
        })
      ])) : createCommentVNode("", true),
      !$data.isLoading && !$data.error ? (openBlock(), createBlock(VMenu, {
        key: 1,
        "open-on-hover": "",
        location: "right"
      }, {
        activator: withCtx(({ props }) => [
          $data.modelAccuracy ? (openBlock(), createElementBlock("div", mergeProps({
            key: 0,
            class: "tw-relative tw-flex tw-items-center"
          }, props), [
            createBaseVNode("div", _hoisted_4$g, toDisplayString(Math.round($data.modelAccuracy, 0)) + "% ", 1),
            createVNode(_component_GChart, {
              type: "PieChart",
              data: [
                ["Effort", "Percentage"],
                ["single", $data.modelAccuracy],
                ["", 100 - $data.modelAccuracy]
              ],
              options: {
                pieHole: 0.7,
                pieSliceTextStyle: {
                  color: "black",
                  fontSize: "20px"
                },
                theme: "maximized",
                legend: "none",
                tooltip: { trigger: "none" },
                slices: {
                  0: {
                    color: $options.getColorCode($data.modelAccuracy),
                    textStyle: { color: "transparent" }
                  },
                  1: {
                    color: "#E6E6E6",
                    textStyle: { color: "transparent" }
                  }
                },
                height: 72,
                width: 72
              }
            }, null, 8, ["data", "options"])
          ], 16)) : createCommentVNode("", true)
        ]),
        default: withCtx(() => [
          $data.chartData ? (openBlock(), createBlock(_component_ModelAccuracyChart, {
            key: 0,
            data: $data.chartData,
            getColorCode: $options.getColorCode
          }, null, 8, ["data", "getColorCode"])) : createCommentVNode("", true)
        ]),
        _: 1
      })) : createCommentVNode("", true)
    ])
  ], 64);
}
const ModelAccuracySection = /* @__PURE__ */ _export_sfc(_sfc_main$j, [["render", _sfc_render$j]]);
const VBtn$1 = "";
const VBtnToggle = "";
const VBtnGroup$1 = "";
const makeVBtnGroupProps = propsFactory({
  divided: Boolean,
  ...makeBorderProps(),
  ...makeDensityProps(),
  ...makeElevationProps(),
  ...makeRoundedProps(),
  ...makeTagProps(),
  ...makeThemeProps(),
  ...makeVariantProps()
}, "v-btn-group");
const VBtnGroup = defineComponent({
  name: "VBtnGroup",
  props: makeVBtnGroupProps(),
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const {
      themeClasses
    } = provideTheme(props);
    const {
      densityClasses
    } = useDensity(props);
    const {
      borderClasses
    } = useBorder(props);
    const {
      elevationClasses
    } = useElevation(props);
    const {
      roundedClasses
    } = useRounded(props);
    provideDefaults({
      VBtn: {
        height: "auto",
        color: toRef(props, "color"),
        density: toRef(props, "density"),
        flat: true,
        variant: toRef(props, "variant")
      }
    });
    useRender(() => {
      return createVNode(props.tag, {
        "class": ["v-btn-group", {
          "v-btn-group--divided": props.divided
        }, themeClasses.value, borderClasses.value, densityClasses.value, elevationClasses.value, roundedClasses.value]
      }, slots);
    });
  }
});
function filterVBtnGroupProps(props) {
  return pick(props, Object.keys(VBtnGroup.props));
}
const VBtnToggleSymbol = Symbol.for("vuetify:v-btn-toggle");
genericComponent()({
  name: "VBtnToggle",
  props: {
    ...makeVBtnGroupProps(),
    ...makeGroupProps()
  },
  emits: {
    "update:modelValue": (value) => true
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const {
      isSelected,
      next,
      prev,
      select,
      selected
    } = useGroup(props, VBtnToggleSymbol);
    useRender(() => {
      var _slots$default;
      const [btnGroupProps] = filterVBtnGroupProps(props);
      return createVNode(VBtnGroup, mergeProps({
        "class": "v-btn-toggle"
      }, btnGroupProps), {
        default: () => [(_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots, {
          isSelected,
          next,
          prev,
          select,
          selected
        })]
      });
    });
    return {
      next,
      prev,
      select
    };
  }
});
const positionValues = ["static", "relative", "fixed", "absolute", "sticky"];
const makePositionProps = propsFactory({
  position: {
    type: String,
    validator: (v) => positionValues.includes(v)
  }
}, "position");
function usePosition(props) {
  let name2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getCurrentInstanceName();
  const positionClasses = computed(() => {
    return props.position ? `${name2}--${props.position}` : void 0;
  });
  return {
    positionClasses
  };
}
function useSelectLink(link, select) {
  watch(() => {
    var _link$isActive;
    return (_link$isActive = link.isActive) == null ? void 0 : _link$isActive.value;
  }, (isActive) => {
    if (link.isLink.value && isActive && select) {
      nextTick(() => {
        select(true);
      });
    }
  }, {
    immediate: true
  });
}
const VBtn = defineComponent({
  name: "VBtn",
  directives: {
    Ripple
  },
  props: {
    active: {
      type: Boolean,
      default: void 0
    },
    symbol: {
      type: null,
      default: VBtnToggleSymbol
    },
    flat: Boolean,
    icon: [Boolean, String, Function, Object],
    prependIcon: IconValue,
    appendIcon: IconValue,
    block: Boolean,
    stacked: Boolean,
    ripple: {
      type: Boolean,
      default: true
    },
    ...makeBorderProps(),
    ...makeRoundedProps(),
    ...makeDensityProps(),
    ...makeDimensionProps(),
    ...makeElevationProps(),
    ...makeGroupItemProps(),
    ...makeLoaderProps(),
    ...makeLocationProps(),
    ...makePositionProps(),
    ...makeRouterProps(),
    ...makeSizeProps(),
    ...makeTagProps({
      tag: "button"
    }),
    ...makeThemeProps(),
    ...makeVariantProps({
      variant: "elevated"
    })
  },
  emits: {
    "group:selected": (val) => true
  },
  setup(props, _ref) {
    let {
      attrs,
      slots
    } = _ref;
    const {
      themeClasses
    } = provideTheme(props);
    const {
      borderClasses
    } = useBorder(props);
    const {
      colorClasses,
      colorStyles,
      variantClasses
    } = useVariant(props);
    const {
      densityClasses
    } = useDensity(props);
    const {
      dimensionStyles
    } = useDimension(props);
    const {
      elevationClasses
    } = useElevation(props);
    const {
      loaderClasses
    } = useLoader(props);
    const {
      locationStyles
    } = useLocation(props);
    const {
      positionClasses
    } = usePosition(props);
    const {
      roundedClasses
    } = useRounded(props);
    const {
      sizeClasses,
      sizeStyles
    } = useSize(props);
    const group = useGroupItem(props, props.symbol, false);
    const link = useLink(props, attrs);
    const isActive = computed(() => {
      if (props.active !== void 0) {
        return props.active;
      }
      if (link.isLink.value) {
        var _link$isActive;
        return (_link$isActive = link.isActive) == null ? void 0 : _link$isActive.value;
      }
      return group == null ? void 0 : group.isSelected.value;
    });
    const isDisabled = computed(() => (group == null ? void 0 : group.disabled.value) || props.disabled);
    const isElevated = computed(() => {
      return props.variant === "elevated" && !(props.disabled || props.flat || props.border);
    });
    const valueAttr = computed(() => {
      if (props.value === void 0)
        return void 0;
      return Object(props.value) === props.value ? JSON.stringify(props.value, null, 0) : props.value;
    });
    useSelectLink(link, group == null ? void 0 : group.select);
    useRender(() => {
      var _link$isActive2, _link$isActive3, _slots$prepend, _slots$default, _slots$append, _slots$loader;
      const Tag = link.isLink.value ? "a" : props.tag;
      const hasPrepend = !!(props.prependIcon || slots.prepend);
      const hasAppend = !!(props.appendIcon || slots.append);
      const hasIcon = !!(props.icon && props.icon !== true);
      const hasColor = (group == null ? void 0 : group.isSelected.value) && (!link.isLink.value || ((_link$isActive2 = link.isActive) == null ? void 0 : _link$isActive2.value)) || !group || ((_link$isActive3 = link.isActive) == null ? void 0 : _link$isActive3.value);
      return withDirectives(createVNode(Tag, {
        "type": Tag === "a" ? void 0 : "button",
        "class": ["v-btn", group == null ? void 0 : group.selectedClass.value, {
          "v-btn--active": isActive.value,
          "v-btn--block": props.block,
          "v-btn--disabled": isDisabled.value,
          "v-btn--elevated": isElevated.value,
          "v-btn--flat": props.flat,
          "v-btn--icon": !!props.icon,
          "v-btn--loading": props.loading,
          "v-btn--stacked": props.stacked
        }, themeClasses.value, borderClasses.value, hasColor ? colorClasses.value : void 0, densityClasses.value, elevationClasses.value, loaderClasses.value, positionClasses.value, roundedClasses.value, sizeClasses.value, variantClasses.value],
        "style": [hasColor ? colorStyles.value : void 0, dimensionStyles.value, locationStyles.value, sizeStyles.value],
        "disabled": isDisabled.value || void 0,
        "href": link.href.value,
        "onClick": (e3) => {
          var _link$navigate;
          if (isDisabled.value)
            return;
          (_link$navigate = link.navigate) == null ? void 0 : _link$navigate.call(link, e3);
          group == null ? void 0 : group.toggle();
        },
        "value": valueAttr.value
      }, {
        default: () => {
          var _a2;
          return [genOverlays(true, "v-btn"), !props.icon && hasPrepend && createVNode(VDefaultsProvider, {
            "key": "prepend",
            "defaults": {
              VIcon: {
                icon: props.prependIcon
              }
            }
          }, {
            default: () => {
              var _a3;
              return [createVNode("span", {
                "class": "v-btn__prepend"
              }, [(_a3 = (_slots$prepend = slots.prepend) == null ? void 0 : _slots$prepend.call(slots)) != null ? _a3 : createVNode(VIcon, null, null)])];
            }
          }), createVNode("span", {
            "class": "v-btn__content",
            "data-no-activator": ""
          }, [createVNode(VDefaultsProvider, {
            "key": "content",
            "defaults": {
              VIcon: {
                icon: hasIcon ? props.icon : void 0
              }
            }
          }, {
            default: () => {
              var _a3;
              return [(_a3 = (_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots)) != null ? _a3 : hasIcon && createVNode(VIcon, {
                "key": "icon"
              }, null)];
            }
          })]), !props.icon && hasAppend && createVNode(VDefaultsProvider, {
            "key": "append",
            "defaults": {
              VIcon: {
                icon: props.appendIcon
              }
            }
          }, {
            default: () => {
              var _a3;
              return [createVNode("span", {
                "class": "v-btn__append"
              }, [(_a3 = (_slots$append = slots.append) == null ? void 0 : _slots$append.call(slots)) != null ? _a3 : createVNode(VIcon, null, null)])];
            }
          }), !!props.loading && createVNode("span", {
            "key": "loader",
            "class": "v-btn__loader"
          }, [(_a2 = (_slots$loader = slots.loader) == null ? void 0 : _slots$loader.call(slots)) != null ? _a2 : createVNode(VProgressCircular, {
            "color": typeof props.loading === "boolean" ? void 0 : props.loading,
            "indeterminate": true,
            "size": "23",
            "width": "2"
          }, null)])];
        }
      }), [[resolveDirective("ripple"), !isDisabled.value && props.ripple, null]]);
    });
    return {};
  }
});
const _sfc_main$i = {
  name: "ActionButton",
  props: {
    variance: {
      type: Number,
      required: true
    },
    isFetchingReviews: {
      type: Boolean,
      default: false
    },
    isReviewed: {
      type: Boolean,
      required: true
    }
  },
  methods: {
    getIcon(n2) {
      if (this.isFetchingReviews)
        return "mdi-circle";
      if (this.isReviewed)
        return "mdi-circle-outline";
      return Math.abs(n2) >= 20 ? "mdi-alert-circle" : "mdi-circle";
    },
    getColorCode(n2) {
      if (Math.abs(n2) >= 20) {
        return "#DC3545";
      }
      if (Math.abs(n2) >= 6) {
        return "#FF9900";
      }
      return "#04BB46";
    },
    getActionButtonLabel(n2) {
      if (this.isFetchingReviews)
        return "Loading...";
      if (this.isReviewed)
        return "Reviewed";
      if (Math.abs(n2) >= 20) {
        return "Review";
      }
      if (Math.abs(n2) >= 6) {
        return "Watch List";
      }
      return "No Action";
    }
  }
};
const _hoisted_1$h = { class: "tw-text-black tw-normal-case tw-font-medium desktop:tw-text-xs small-laptop:xs tw-text-base" };
function _sfc_render$i(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(VBtn, {
    variant: "outlined",
    rounded: "pill",
    size: "large",
    color: $options.getColorCode($props.variance),
    ripple: false,
    disabled: $props.isFetchingReviews
  }, {
    default: withCtx(() => [
      createVNode(VIcon, {
        icon: $options.getIcon($props.variance),
        start: "",
        color: $options.getColorCode($props.variance),
        size: 24
      }, null, 8, ["icon", "color"]),
      createBaseVNode("span", _hoisted_1$h, toDisplayString($options.getActionButtonLabel($props.variance)), 1),
      createVNode(VIcon, {
        icon: "mdi-chevron-right",
        end: "",
        color: "black",
        size: 24
      })
    ]),
    _: 1
  }, 8, ["color", "disabled"]);
}
const ActionButton = /* @__PURE__ */ _export_sfc(_sfc_main$i, [["render", _sfc_render$i]]);
const VDialog$1 = "";
const VDialog = genericComponent()({
  name: "VDialog",
  props: {
    fullscreen: Boolean,
    retainFocus: {
      type: Boolean,
      default: true
    },
    scrollable: Boolean,
    ...makeVOverlayProps({
      origin: "center center",
      scrollStrategy: "block",
      transition: {
        component: VDialogTransition
      },
      zIndex: 2400
    })
  },
  emits: {
    "update:modelValue": (value) => true
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const isActive = useProxiedModel(props, "modelValue");
    const {
      scopeId
    } = useScopeId();
    const overlay = ref();
    function onFocusin(e3) {
      var _overlay$value, _overlay$value2;
      const before = e3.relatedTarget;
      const after = e3.target;
      if (before !== after && (_overlay$value = overlay.value) != null && _overlay$value.contentEl && (_overlay$value2 = overlay.value) != null && _overlay$value2.globalTop && ![document, overlay.value.contentEl].includes(after) && !overlay.value.contentEl.contains(after)) {
        const focusable = [...overlay.value.contentEl.querySelectorAll('button, [href], input:not([type="hidden"]), select, textarea, [tabindex]:not([tabindex="-1"])')].filter((el2) => !el2.hasAttribute("disabled") && !el2.matches('[tabindex="-1"]'));
        if (!focusable.length)
          return;
        const firstElement = focusable[0];
        const lastElement = focusable[focusable.length - 1];
        if (before === firstElement) {
          lastElement.focus();
        } else {
          firstElement.focus();
        }
      }
    }
    if (IN_BROWSER) {
      watch(() => isActive.value && props.retainFocus, (val) => {
        val ? document.addEventListener("focusin", onFocusin) : document.removeEventListener("focusin", onFocusin);
      }, {
        immediate: true
      });
    }
    watch(isActive, async (val) => {
      await nextTick();
      if (val) {
        var _contentEl;
        (_contentEl = overlay.value.contentEl) == null ? void 0 : _contentEl.focus({
          preventScroll: true
        });
      } else {
        var _activatorEl;
        (_activatorEl = overlay.value.activatorEl) == null ? void 0 : _activatorEl.focus({
          preventScroll: true
        });
      }
    });
    const activatorProps = computed(() => mergeProps({
      "aria-haspopup": "dialog",
      "aria-expanded": String(isActive.value)
    }, props.activatorProps));
    useRender(() => {
      const [overlayProps] = filterVOverlayProps(props);
      return createVNode(VOverlay, mergeProps({
        "ref": overlay,
        "class": ["v-dialog", {
          "v-dialog--fullscreen": props.fullscreen,
          "v-dialog--scrollable": props.scrollable
        }]
      }, overlayProps, {
        "modelValue": isActive.value,
        "onUpdate:modelValue": ($event) => isActive.value = $event,
        "aria-role": "dialog",
        "aria-modal": "true",
        "activatorProps": activatorProps.value
      }, scopeId), {
        activator: slots.activator,
        default: function() {
          var _slots$default;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          return createVNode(VDefaultsProvider, {
            "root": true
          }, {
            default: () => [(_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots, ...args)]
          });
        }
      });
    });
    return forwardRefs({}, overlay);
  }
});
const {
  PENDING_ACTION: PENDING_ACTION$1,
  REVIEWED_AND_ACTION_TAKEN: REVIEWED_AND_ACTION_TAKEN$1,
  REVIEWED_AND_ACTION_NOT_TAKEN: REVIEWED_AND_ACTION_NOT_TAKEN$1
} = ACTION_STATUS_LABELS;
const ACTION_STATUS_LIST = [
  PENDING_ACTION$1,
  REVIEWED_AND_ACTION_TAKEN$1,
  REVIEWED_AND_ACTION_NOT_TAKEN$1
];
const _sfc_main$h = {
  name: "ActionForm",
  props: {
    actionFormIsShown: {
      type: Boolean,
      required: true
    },
    variance: {
      type: Number,
      required: true
    },
    reviews: {
      type: Array,
      required: true
    },
    actionStatus: {
      type: String,
      default: PENDING_ACTION$1
    },
    isFetching: {
      type: Boolean,
      required: true
    },
    isSubmitting: {
      type: Boolean,
      required: true
    },
    responseSubmitted: {
      type: Boolean,
      default: false
    }
  },
  emits: ["closeForm", "fetchReviews", "submitReview"],
  data() {
    return {
      selectedAction: this.actionStatus,
      userResponse: null,
      ACTION_STATUS_LIST,
      lodGet: _.get
    };
  },
  methods: {
    formatDate(dateString, format$1 = "yyyy-MM-dd") {
      return format(new Date(dateString), format$1);
    },
    getStatus(n2) {
      if (Math.abs(n2) >= 20) {
        return "Review";
      }
      if (Math.abs(n2) >= 6) {
        return "Watch List";
      }
      return "No Action";
    },
    updateActionStatus(action) {
      this.selectedAction = action;
    },
    isSubmitButtonDisabled() {
      return !(this.userResponse && this.selectedAction) || this.isSubmitting || this.isFetching;
    },
    async submitHandler() {
      this.$emit("submitReview", {
        selectedAction: this.selectedAction,
        userResponse: this.userResponse
      });
      this.userResponse = null;
    }
  }
};
const _hoisted_1$g = { class: "tw-w-[80vw] tw-h-[80vh] tw-overflow-auto tw-bg-white tw-p-3" };
const _hoisted_2$f = { class: "tw-w-full tw-h-full tw-min-w-[800px] tw-min-h-[450px] tw-flex tw-flex-col" };
const _hoisted_3$f = { class: "tw-text-lg tw-font-bold tw-pb-3" };
const _hoisted_4$f = { class: "tw-grid tw-grid-cols-2 tw-grow" };
const _hoisted_5$d = { class: "tw-col-span-1 tw-py-3 tw-px-4 tw-border-2 tw-border-solid tw-border-brand-secondary-10 tw-overflow-auto" };
const _hoisted_6$d = {
  key: 0,
  class: "tw-w-full tw-h-3/4 tw-flex tw-justify-center tw-items-center"
};
const _hoisted_7$c = {
  key: 1,
  class: "tw-flex tw-flex-col tw-gap-y-7"
};
const _hoisted_8$c = { class: "tw-flex tw-justify-between" };
const _hoisted_9$c = { class: "tw-text-base tw-font-medium tw-text-black" };
const _hoisted_10$a = { class: "tw-text-base tw-text-brand-gray-3" };
const _hoisted_11$a = { class: "tw-col-span-1 tw-p-4 tw-border-2 tw-border-solid tw-border-brand-secondary-10" };
const _hoisted_12$8 = { class: "tw-w-full tw-h-3/5 small-laptop:tw-h-2/4 tw-overflow-auto tw-mb-4" };
const _hoisted_13$7 = /* @__PURE__ */ createBaseVNode("label", { for: "review" }, "Add Your Response", -1);
const _hoisted_14$6 = /* @__PURE__ */ createBaseVNode("label", { for: "status" }, "Recommended Action Status", -1);
const _hoisted_15$6 = { class: "tw-flex tw-items-center tw-gap-x-4 tw-pt-4" };
const _hoisted_16$5 = ["disabled"];
const _hoisted_17$4 = /* @__PURE__ */ createBaseVNode("span", { class: "tw-text-white tw-text-base" }, "Save Updates", -1);
const _hoisted_18$4 = [
  _hoisted_17$4
];
const _hoisted_19$3 = {
  key: 0,
  class: "tw-px-4 tw-py-1 tw-flex tw-items-center tw-gap-x-2 tw-border-2 tw-border-solid tw-border-brand-green-1 tw-rounded-sm tw-bg-brand-green-3"
};
const _hoisted_20$3 = /* @__PURE__ */ createBaseVNode("span", { class: "tw-text-brand-green-1 tw-text-base" }, "Updated Successfully", -1);
const _hoisted_21$3 = /* @__PURE__ */ createBaseVNode("span", { class: "tw-text-white tw-text-base" }, "Close", -1);
const _hoisted_22$3 = [
  _hoisted_21$3
];
function _sfc_render$h(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(VDialog, {
    "model-value": $props.actionFormIsShown,
    width: "auto",
    persistent: ""
  }, {
    default: withCtx(() => [
      createBaseVNode("div", _hoisted_1$g, [
        createBaseVNode("div", _hoisted_2$f, [
          createBaseVNode("h1", _hoisted_3$f, " Recommended Action - " + toDisplayString($options.getStatus($props.variance)) + " Status ", 1),
          createBaseVNode("div", _hoisted_4$f, [
            createBaseVNode("div", _hoisted_5$d, [
              $props.isFetching ? (openBlock(), createElementBlock("div", _hoisted_6$d, [
                createVNode(VProgressCircular, {
                  indeterminate: "",
                  color: "#7823DC",
                  size: 60,
                  width: 10
                })
              ])) : (openBlock(), createElementBlock("div", _hoisted_7$c, [
                (openBlock(true), createElementBlock(Fragment, null, renderList($props.reviews, (review) => {
                  return openBlock(), createElementBlock("div", {
                    key: $data.lodGet(review, "id"),
                    class: "tw-flex tw-flex-col tw-gap-y-2"
                  }, [
                    createBaseVNode("div", _hoisted_8$c, [
                      createBaseVNode("span", _hoisted_9$c, toDisplayString($data.lodGet(review, "user_display_name")), 1),
                      createBaseVNode("span", _hoisted_10$a, toDisplayString($options.formatDate($data.lodGet(review, "date"), "MMM dd, yyyy")), 1)
                    ]),
                    createBaseVNode("p", null, toDisplayString($data.lodGet(review, "comment")), 1)
                  ]);
                }), 128))
              ]))
            ]),
            createBaseVNode("div", _hoisted_11$a, [
              createBaseVNode("div", _hoisted_12$8, [
                _hoisted_13$7,
                withDirectives(createBaseVNode("textarea", {
                  id: "review",
                  "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $data.userResponse = $event),
                  placeholder: "Mention about action items",
                  class: "tw-w-full tw-h-3/4 tw-max-h-72 small-laptop:tw-max-h-40 tw-text-base tw-py-2 tw-px-4 tw-border-2 tw-border-solid tw-border-brand-secondary-20"
                }, null, 512), [
                  [vModelText, $data.userResponse]
                ])
              ]),
              createBaseVNode("div", null, [
                _hoisted_14$6,
                createVNode(VSelect, {
                  id: "status",
                  "model-value": $data.selectedAction,
                  items: $data.ACTION_STATUS_LIST,
                  "onUpdate:modelValue": _cache[1] || (_cache[1] = (value) => $options.updateActionStatus(value)),
                  density: "comfortable"
                }, null, 8, ["model-value", "items"])
              ])
            ])
          ]),
          createBaseVNode("div", _hoisted_15$6, [
            createBaseVNode("button", {
              class: normalizeClass(`tw-px-6 tw-py-2 ${$options.isSubmitButtonDisabled() ? "tw-bg-brand-primary-disabled" : "tw-bg-brand-primary"}`),
              disabled: $options.isSubmitButtonDisabled(),
              onClick: _cache[2] || (_cache[2] = (...args) => $options.submitHandler && $options.submitHandler(...args))
            }, _hoisted_18$4, 10, _hoisted_16$5),
            $props.responseSubmitted ? (openBlock(), createElementBlock("div", _hoisted_19$3, [
              createVNode(VIcon, {
                icon: "mdi-check-circle",
                color: "#04BB46"
              }),
              _hoisted_20$3
            ])) : createCommentVNode("", true),
            createBaseVNode("button", {
              class: "tw-px-4 tw-py-2 tw-bg-brand-gray-3 tw-ml-auto",
              onClick: _cache[3] || (_cache[3] = ($event) => _ctx.$emit("closeForm"))
            }, _hoisted_22$3)
          ])
        ])
      ])
    ]),
    _: 1
  }, 8, ["model-value"]);
}
const ActionForm = /* @__PURE__ */ _export_sfc(_sfc_main$h, [["render", _sfc_render$h]]);
const {
  PENDING_ACTION,
  REVIEWED_AND_ACTION_TAKEN,
  REVIEWED_AND_ACTION_NOT_TAKEN
} = ACTION_STATUS_LABELS;
const _sfc_main$g = {
  name: "CardsListItem",
  components: {
    ModelAccuracySection,
    ActionButton,
    ActionForm
  },
  props: {
    data: {
      type: Object,
      required: true
    },
    options: Object
  },
  data() {
    return {
      reviews: [],
      actionFormIsShown: false,
      actionStatus: PENDING_ACTION,
      isReviewed: false,
      isFetchingReviews: true,
      getReviewsError: null,
      isSubmittingReview: false,
      submitReviewError: null,
      responseSubmitted: false
    };
  },
  computed: {
    isModelAccuracyHidden() {
      return this.options.isModelAccuracyHidden || false;
    },
    selectedFilters() {
      return _.get(this.options, "selectedFilters");
    },
    userData() {
      return _.get(this.options, "userData");
    },
    period() {
      return _.get(this.data, "period");
    },
    periodStartDate() {
      return getPeriodStartDate(this.period);
    },
    periodEndDate() {
      return getPeriodEndDate(this.period);
    },
    variance() {
      return _.toNumber(
        this.lodGetNumeric(this.data, "metrics.variance", false)
      );
    },
    horizon() {
      return _.get(this.data, "horizon");
    },
    forecastPeriodType() {
      return _.get(this.options, "forecastPeriodType");
    },
    periodLabel() {
      return _.get(this.data, "label");
    },
    formattedHorizon() {
      if (this.forecastPeriodType === FORECAST_PERIOD_TYPES.R3M_VIEW) {
        return _.get(this.data, "formattedHorizon");
      }
      return "";
    }
  },
  methods: {
    showFormHandler() {
      this.actionFormIsShown = true;
    },
    hideFormHandler() {
      this.actionFormIsShown = false;
    },
    lodGetNumeric(obj, path, isPercentValue = true) {
      const val = _.get(obj, path, null);
      if (val === null || _.isNaN(val) || !_.isNumber(val)) {
        return "NA";
      }
      return `${val}${isPercentValue ? "%" : ""}`;
    },
    getColorCode(num) {
      const n2 = _.toNumber(num);
      if (Math.abs(n2) >= 20) {
        return "#DC3545";
      }
      if (Math.abs(n2) >= 6) {
        return "#FF9900";
      }
      return "#04BB46";
    },
    handleSuccessfulSubmission() {
      this.responseSubmitted = true;
      setTimeout(() => {
        this.responseSubmitted = false;
      }, 5e3);
      this.fetchReviews();
    },
    async submitHandler({ selectedAction, userResponse }) {
      this.isSubmittingReview = true;
      try {
        await addReview({
          userId: _.get(this.userData, "userId"),
          userDisplayName: _.get(this.userData, "userDisplayName"),
          action: selectedAction,
          asOn: this.selectedFilters.marketSensingRefreshDate,
          comment: userResponse,
          periodStartDate: this.periodStartDate,
          periodEndDate: this.periodEndDate,
          customer: this.selectedFilters.customer,
          category: this.selectedFilters.category,
          byValueOrByVolume: this.selectedFilters.valueOrQuantity,
          forecastPeriodType: this.forecastPeriodType
        });
        this.handleSuccessfulSubmission();
      } catch (error) {
        this.submitReviewError = error;
      }
      this.isSubmittingReview = false;
    },
    async fetchReviews() {
      this.isFetchingReviews = true;
      try {
        this.reviews = await getReviews({
          refreshDate: this.selectedFilters.marketSensingRefreshDate,
          customer: this.selectedFilters.customer,
          category: this.selectedFilters.category,
          valueOrQuantity: this.selectedFilters.valueOrQuantity,
          periodStart: this.periodStartDate,
          periodEnd: this.periodEndDate,
          forecastPeriodType: this.forecastPeriodType
        });
        this.actionStatus = _.get(this.reviews, "[0].action");
        if (this.actionStatus === REVIEWED_AND_ACTION_TAKEN || this.actionStatus === REVIEWED_AND_ACTION_NOT_TAKEN) {
          this.isReviewed = true;
        } else {
          this.isReviewed = false;
        }
      } catch (e3) {
        this.getReviewsError = e3;
      }
      this.isFetchingReviews = false;
    }
  },
  created() {
    this.fetchReviews();
  }
};
const _hoisted_1$f = { class: "tw-w-full tw-h-full tw-px-3 tw-py-4" };
const _hoisted_2$e = { class: "tw-flex tw-flex-col tw-py-2" };
const _hoisted_3$e = /* @__PURE__ */ createBaseVNode("p", {
  style: { "color": "#9291a5" },
  class: "desktop:tw-text-sm small-laptop:tw-text-xs"
}, "Projected Period", -1);
const _hoisted_4$e = { class: "tw-flex tw-gap-x-4 desktop:tw-gap-x-3 tw-items-center tw-w-full" };
const _hoisted_5$c = { class: "tw-text-lg desktop:tw-text-sm small-laptop:tw-text-sm tw-font-medium" };
const _hoisted_6$c = {
  key: 0,
  class: "tw-bg-brand-gray-4 tw-rounded tw-text-center"
};
const _hoisted_7$b = { class: "tw-p-1 tw-text-sm desktop:tw-text-xs small-laptop:tw-text-xs" };
const _hoisted_8$b = /* @__PURE__ */ createBaseVNode("div", { class: "tw-w-full tw-border-t tw-border-solid tw-border-brand-gray-2" }, null, -1);
const _hoisted_9$b = { class: "tw-col-span-3" };
const _hoisted_10$9 = /* @__PURE__ */ createBaseVNode("div", { class: "tw-w-52 tw-h-14 tw-p-2 tw-bg-white tw-border tw-rounded tw-border-[#D9D9D9] tw-shadow-2xl" }, [
  /* @__PURE__ */ createBaseVNode("p", { class: "tw-text-sm tw-text-center" }, " The % increase in demand the company expects. ")
], -1);
const _hoisted_11$9 = { class: "tw-grid tw-grid-cols-2 tw-pt-4" };
const _hoisted_12$7 = { class: "tw-text-2xl desktop:tw-text-xl small-laptop:tw-text-lg tw-font-semibold" };
const _hoisted_13$6 = /* @__PURE__ */ createBaseVNode("p", { class: "tw-text-xs desktop:tw-text-xxs small-laptop:tw-text-xxs" }, "Planned Internal Forecast", -1);
const _hoisted_14$5 = /* @__PURE__ */ createBaseVNode("div", { class: "tw-w-80 tw-h-14 tw-p-2 tw-bg-white tw-border tw-rounded tw-border-[#D9D9D9] tw-shadow-2xl" }, [
  /* @__PURE__ */ createBaseVNode("p", { class: "tw-text-sm tw-text-center" }, " Internal market demands at a category level determined by internal historical data. ")
], -1);
const _hoisted_15$5 = { class: "tw-text-2xl desktop:tw-text-xl small-laptop:tw-text-lg tw-font-semibold" };
const _hoisted_16$4 = /* @__PURE__ */ createBaseVNode("p", { class: "tw-text-xs desktop:tw-text-xxs small-laptop:tw-text-xxs" }, "Market Sensing Model Forecast", -1);
const _hoisted_17$3 = /* @__PURE__ */ createBaseVNode("div", { class: "tw-w-96 tw-h-20 tw-p-2 tw-bg-white tw-border tw-rounded tw-border-[#D9D9D9] tw-shadow-2xl" }, [
  /* @__PURE__ */ createBaseVNode("p", { class: "tw-text-sm tw-text-center" }, " Highly accurate market demand projections at a category level based on ML models that analyze and learn from internal and external data feeds ")
], -1);
const _hoisted_18$3 = {
  key: 0,
  class: "tw-flex tw-flex-col tw-items-center tw-col-span-2"
};
const _hoisted_19$2 = { class: "tw-w-full tw-flex tw-justify-center tw-items-center tw-gap-3 tw-pt-2" };
const _hoisted_20$2 = /* @__PURE__ */ createBaseVNode("span", { class: "tw-text-xs desktop:tw-text-xxs small-laptop:tw-text-xxs" }, "Variance", -1);
const _hoisted_21$2 = { class: "tw-w-80 tw-h-20 tw-p-2 tw-bg-white tw-border tw-rounded tw-border-[#D9D9D9] tw-shadow-2xl" };
const _hoisted_22$2 = { class: "tw-text-sm tw-text-center" };
function _sfc_render$g(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_ModelAccuracySection = resolveComponent("ModelAccuracySection");
  const _component_ActionButton = resolveComponent("ActionButton");
  const _component_ActionForm = resolveComponent("ActionForm");
  return openBlock(), createElementBlock("div", _hoisted_1$f, [
    createBaseVNode("div", _hoisted_2$e, [
      _hoisted_3$e,
      createBaseVNode("div", _hoisted_4$e, [
        createBaseVNode("p", _hoisted_5$c, toDisplayString($options.periodLabel), 1),
        $options.formattedHorizon ? (openBlock(), createElementBlock("div", _hoisted_6$c, [
          createBaseVNode("p", _hoisted_7$b, "Future " + toDisplayString($options.formattedHorizon) + " months", 1)
        ])) : createCommentVNode("", true)
      ])
    ]),
    _hoisted_8$b,
    createBaseVNode("div", {
      class: normalizeClass(`tw-grid tw-py-2 small-laptop:tw-py-1 ${$options.isModelAccuracyHidden ? "tw-grid-cols-3" : "tw-grid-cols-5"}`)
    }, [
      createBaseVNode("div", _hoisted_9$b, [
        createVNode(VMenu, {
          "open-on-hover": "",
          location: "top"
        }, {
          activator: withCtx(({ props }) => [
            createBaseVNode("p", mergeProps(props, { class: "tw-text-sm desktop:tw-text-xs small-laptop:tw-text-xs tw-font-medium" }), " Projected Growth (%YoY) ", 16)
          ]),
          default: withCtx(() => [
            _hoisted_10$9
          ]),
          _: 1
        }),
        createBaseVNode("div", _hoisted_11$9, [
          createVNode(VMenu, {
            "open-on-hover": "",
            location: "top"
          }, {
            activator: withCtx(({ props }) => [
              createBaseVNode("div", mergeProps(props, { class: "tw-text-center" }), [
                createBaseVNode("p", _hoisted_12$7, toDisplayString(`${$options.lodGetNumeric($props.data, "metrics.jdaGrowth")}`), 1),
                _hoisted_13$6
              ], 16)
            ]),
            default: withCtx(() => [
              _hoisted_14$5
            ]),
            _: 1
          }),
          createVNode(VMenu, {
            "open-on-hover": "",
            location: "top"
          }, {
            activator: withCtx(({ props }) => [
              createBaseVNode("div", mergeProps(props, { class: "tw-text-center" }), [
                createBaseVNode("p", _hoisted_15$5, toDisplayString(`${$options.lodGetNumeric($props.data, "metrics.marketSensingGrowth")}`), 1),
                _hoisted_16$4
              ], 16)
            ]),
            default: withCtx(() => [
              _hoisted_17$3
            ]),
            _: 1
          })
        ])
      ]),
      !$options.isModelAccuracyHidden ? (openBlock(), createElementBlock("div", _hoisted_18$3, [
        createVNode(_component_ModelAccuracySection, {
          marketSensingRefreshDate: this.selectedFilters.marketSensingRefreshDate,
          category: this.selectedFilters.category,
          horizon: $options.horizon,
          forecastPeriodType: $options.forecastPeriodType
        }, null, 8, ["marketSensingRefreshDate", "category", "horizon", "forecastPeriodType"])
      ])) : createCommentVNode("", true)
    ], 2),
    createBaseVNode("div", _hoisted_19$2, [
      createVNode(VMenu, {
        "open-on-hover": "",
        location: "top"
      }, {
        activator: withCtx(({ props }) => [
          createBaseVNode("div", mergeProps(props, { class: "tw-flex tw-flex-col tw-items-center" }), [
            createBaseVNode("span", {
              class: "tw-text-4xl desktop:tw-text-2xl small-laptop:tw-text-lg tw-font-semibold",
              style: normalizeStyle({ color: $options.getColorCode($options.variance) })
            }, toDisplayString(`${$options.lodGetNumeric($props.data, "metrics.variance")}`), 5),
            _hoisted_20$2
          ], 16)
        ]),
        default: withCtx(() => [
          createBaseVNode("div", _hoisted_21$2, [
            createBaseVNode("p", _hoisted_22$2, toDisplayString(`The difference between market sensing and the internal forecast results in a 
              ${$options.lodGetNumeric($props.data, "metrics.variance")} variance.`), 1)
          ])
        ]),
        _: 1
      }),
      createBaseVNode("div", null, [
        createVNode(_component_ActionButton, {
          variance: $options.variance,
          isReviewed: $data.isReviewed,
          isFetchingReviews: $data.isFetchingReviews,
          onClick: $options.showFormHandler
        }, null, 8, ["variance", "isReviewed", "isFetchingReviews", "onClick"])
      ])
    ]),
    $data.actionFormIsShown ? (openBlock(), createBlock(_component_ActionForm, {
      key: 0,
      actionFormIsShown: $data.actionFormIsShown,
      variance: $options.variance,
      reviews: $data.reviews,
      actionStatus: $data.actionStatus,
      isFetching: $data.isFetchingReviews,
      isSubmitting: $data.isSubmittingReview,
      responseSubmitted: $data.responseSubmitted,
      onCloseForm: $options.hideFormHandler,
      onFetchReviews: $options.fetchReviews,
      onSubmitReview: $options.submitHandler
    }, null, 8, ["actionFormIsShown", "variance", "reviews", "actionStatus", "isFetching", "isSubmitting", "responseSubmitted", "onCloseForm", "onFetchReviews", "onSubmitReview"])) : createCommentVNode("", true)
  ]);
}
const CardsListItem$1 = /* @__PURE__ */ _export_sfc(_sfc_main$g, [["render", _sfc_render$g]]);
const _sfc_main$f = {
  name: "CardsList",
  components: {
    CardsListItem: CardsListItem$1
  },
  props: {
    data: {
      type: Array,
      required: true
    },
    options: Object
  },
  emits: ["setActiveCard"]
};
const _hoisted_1$e = ["onClick"];
const _hoisted_2$d = {
  key: 0,
  class: "tw-flex tw-w-full tw-justify-center"
};
const _hoisted_3$d = /* @__PURE__ */ createBaseVNode("div", {
  class: "tw-w-0 tw-h-0 tw-border-solid tw-border-t-brand-primary",
  style: { "border-left-width": "16px", "border-left-color": "transparent", "border-right-width": "16px", "border-right-color": "transparent", "border-top-width": "16px" }
}, null, -1);
const _hoisted_4$d = [
  _hoisted_3$d
];
function _sfc_render$f(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_CardsListItem = resolveComponent("CardsListItem");
  return openBlock(true), createElementBlock(Fragment, null, renderList($props.data, (cardData, index2) => {
    return openBlock(), createElementBlock("div", {
      key: cardData.label,
      onClick: ($event) => _ctx.$emit("setActiveCard", index2),
      class: normalizeClass(`tw-w-1/4 tw-cursor-pointer ${cardData.isActive ? "tw-border-x tw-border-t tw-border-b-4 tw-border-solid tw-border-brand-primary tw--mb-5" : "tw-border tw-border-solid tw-border-brand-secondary-10 tw-opacity-60"}`)
    }, [
      createVNode(_component_CardsListItem, {
        data: cardData,
        options: $props.options
      }, null, 8, ["data", "options"]),
      cardData.isActive ? (openBlock(), createElementBlock("div", _hoisted_2$d, _hoisted_4$d)) : createCommentVNode("", true)
    ], 10, _hoisted_1$e);
  }), 128);
}
const CardsList$1 = /* @__PURE__ */ _export_sfc(_sfc_main$f, [["render", _sfc_render$f]]);
const dataKeys$3 = ["dataPoint", "source", "value"];
async function fetchKeyDemandDriverDetails({
  marketSensingRefreshDate,
  category,
  horizon,
  driver
}) {
  const response = await apiBase("key_demand_driver_drill_down", {
    marketSensingRefreshDate,
    category,
    horizon,
    driver
  });
  const data = _.get(response, "data");
  let dataForUi = _.map(data, (el2) => {
    const transformedElement = {};
    _.forEach(dataKeys$3, (key, index2) => {
      transformedElement[key] = el2[index2];
    });
    return transformedElement;
  });
  return dataForUi;
}
const OTHERS_START_INDEX = 5;
const OTHER_DRIVERS = "Others";
const _sfc_main$e = {
  name: "ChartKeyDemandDrivers",
  components: {
    GChart
  },
  props: {
    data: { type: Array, required: true },
    selectedFilters: { type: Object, required: true },
    horizon: { type: String, required: true }
  },
  data() {
    return {
      dialogIsShown: false,
      isFetchingDriverDetails: false,
      selectedDriver: null,
      selectedDriverDetails: null,
      chartEvents: {
        click: (e3) => {
          const { targetID } = e3;
          const [el2, , index2] = _.split(targetID, "#");
          if (el2 === "bar" || el2 === "annotationtext") {
            this.selectedDriver = _.head(this.chartData[_.toNumber(index2) + 1]);
            this.fetchDriverDetails(this.selectedDriver);
            this.dialogIsShown = true;
          } else {
            this.dialogIsShown = false;
          }
        }
      },
      lodSize: _.size
    };
  },
  methods: {
    closeDialog() {
      this.dialogIsShown = false;
    },
    async fetchDriverDetails(driver) {
      this.isFetchingDriverDetails = true;
      try {
        if (driver === OTHER_DRIVERS) {
          this.selectedDriverDetails = _.flatten(
            _.concat(
              await Promise.all(
                _.map(this.otherDrivers, (el2) => {
                  const driver2 = _.keys(el2)[0];
                  return fetchKeyDemandDriverDetails({
                    ...this.apiParams,
                    driver: driver2
                  });
                })
              )
            )
          );
        } else {
          this.selectedDriverDetails = await fetchKeyDemandDriverDetails({
            ...this.apiParams,
            driver
          });
        }
      } catch (e3) {
        console.log(e3);
      }
      this.isFetchingDriverDetails = false;
    },
    getPercentValue(value) {
      if (value === null || value === void 0 || _.isNaN(_.toNumber(value)))
        return "NA";
      return `${value}%`;
    },
    getSelectedDriverLabel() {
      if (this.selectedDriver === OTHER_DRIVERS) {
        const otherDriverNames = _.map(
          this.otherDrivers,
          (el2) => _.keys(el2)[0]
        );
        return _.join(otherDriverNames, ", ");
      }
      return this.selectedDriver;
    }
  },
  computed: {
    otherDrivers() {
      return _.slice(this.data, OTHERS_START_INDEX);
    },
    chartData() {
      const otherDriversValue = this.otherDrivers.reduce(
        (accumulator, currentEl) => accumulator + _.toNumber(_.values(currentEl)[0]),
        0
      );
      const result = [
        ["X", "Y", { role: "annotation" }],
        ..._.map(_.slice(this.data, 0, OTHERS_START_INDEX), (v) => {
          return [
            _.keys(v)[0],
            _.values(v)[0],
            `${_.round(_.values(v)[0], 1)}%`
          ];
        })
      ];
      if (otherDriversValue > 0) {
        result.push([
          OTHER_DRIVERS,
          otherDriversValue,
          `${_.round(otherDriversValue, 1)}%`
        ]);
      }
      return result;
    },
    dataValues() {
      return _.map(this.data, (v) => {
        return _.values(v)[0];
      });
    },
    chartOptions() {
      return {
        legend: "none",
        tooltip: { trigger: "none" },
        colors: ["#646F79"],
        annotations: {
          textStyle: {
            color: "#000000",
            fontSize: 12
          },
          datum: { stem: { length: 2 } },
          alwaysOutside: true
        },
        vAxis: {
          textStyle: {
            color: "#1E1E1E",
            fontName: "Graphik",
            fontSize: 12
          }
        },
        hAxis: {
          gridlines: {
            count: 0
          },
          textPosition: "none",
          viewWindow: {
            max: _.add(_.max(this.dataValues), 5),
            min: _.subtract(_.min(this.dataValues), 5)
          }
        },
        chartArea: {
          right: "8%",
          width: "50%",
          height: "90%"
        }
      };
    },
    apiParams() {
      const marketSensingRefreshDate = _.get(
        this.selectedFilters,
        "marketSensingRefreshDate"
      );
      const category = _.get(this.selectedFilters, "category");
      return {
        marketSensingRefreshDate,
        category,
        horizon: this.horizon
      };
    }
  }
};
const _hoisted_1$d = { class: "tw-flex tw-flex-col tw-justify-between tw-h-full" };
const _hoisted_2$c = /* @__PURE__ */ createBaseVNode("div", { class: "tw-w-96 tw-h-20 tw-p-2 tw-bg-white tw-border tw-rounded tw-border-[#D9D9D9] tw-shadow-2xl" }, [
  /* @__PURE__ */ createBaseVNode("p", { class: "tw-text-sm tw-text-center" }, " Most impactful types of data for the select projected period of demand predictions. These factors are accounting the most for the demand forecast. ")
], -1);
const _hoisted_3$c = { class: "tw-w-full tw-max-h-[80vh] tw-min-h-[590px] tw-bg-white tw-px-5 tw-py-4 tw-overflow-auto" };
const _hoisted_4$c = { class: "tw-flex tw-justify-between tw-gap-x-2" };
const _hoisted_5$b = { class: "tw-flex tw-flex-col tw-items-start" };
const _hoisted_6$b = /* @__PURE__ */ createBaseVNode("span", { class: "tw-text-lg tw-text-brand-gray-3" }, " Key Demand Driver(s) ", -1);
const _hoisted_7$a = { class: "tw-text-2xl tw-font-medium tw-text-black" };
const _hoisted_8$a = {
  key: 0,
  class: "tw-w-full tw-mt-32 tw-flex tw-justify-center tw-items-center"
};
const _hoisted_9$a = {
  key: 1,
  class: "tw-py-4"
};
const _hoisted_10$8 = /* @__PURE__ */ createBaseVNode("div", { class: "tw-flex tw-justify-between tw-gap-x-3 tw-items-center tw-p-3 tw-bg-brand-gray-1" }, [
  /* @__PURE__ */ createBaseVNode("span", { class: "tw-text-lg tw-font-medium tw-text-black" }, " Data point(s) "),
  /* @__PURE__ */ createBaseVNode("div", { class: "tw-flex tw-gap-x-1" }, [
    /* @__PURE__ */ createBaseVNode("span", { class: "tw-text-lg tw-font-medium tw-text-black tw-text-left tw-w-44" }, " Source(s) "),
    /* @__PURE__ */ createBaseVNode("span", { class: "tw-text-lg tw-font-medium tw-text-black tw-text-right tw-w-24 tw-pr-1" }, " Value ")
  ])
], -1);
const _hoisted_11$8 = { class: "tw-max-h-[420px] tw-overflow-scroll" };
const _hoisted_12$6 = { class: "tw-text-base tw-text-black" };
const _hoisted_13$5 = { class: "tw-flex tw-gap-x-1" };
const _hoisted_14$4 = { class: "tw-text-base tw-text-black tw-text-left tw-w-44" };
const _hoisted_15$4 = { class: "tw-text-base tw-text-black tw-text-right tw-w-24 tw-pr-1" };
function _sfc_render$e(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_GChart = resolveComponent("GChart");
  return openBlock(), createElementBlock("div", _hoisted_1$d, [
    createVNode(VMenu, {
      "open-on-hover": "",
      location: "top"
    }, {
      activator: withCtx(({ props }) => [
        createBaseVNode("span", mergeProps(props, { class: "tw-font-medium tw-text-lg small-laptop:tw-text-base desktop:tw-text-base tw-cursor-default" }), " Key Demand Drivers ", 16)
      ]),
      default: withCtx(() => [
        _hoisted_2$c
      ]),
      _: 1
    }),
    createVNode(_component_GChart, {
      type: "BarChart",
      data: $options.chartData,
      options: $options.chartOptions,
      events: $data.chartEvents,
      ref: "chartKeyDemandDrivers"
    }, null, 8, ["data", "options", "events"]),
    createVNode(VDialog, {
      width: 1040,
      "close-on-content-click": false,
      modelValue: $data.dialogIsShown,
      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $data.dialogIsShown = $event)
    }, {
      default: withCtx(() => [
        createBaseVNode("div", _hoisted_3$c, [
          createBaseVNode("div", _hoisted_4$c, [
            createBaseVNode("div", _hoisted_5$b, [
              _hoisted_6$b,
              createBaseVNode("span", _hoisted_7$a, toDisplayString($options.getSelectedDriverLabel()), 1)
            ]),
            createVNode(VBtn, {
              variant: "plain",
              icon: "mdi-close",
              onClick: $options.closeDialog
            }, null, 8, ["onClick"])
          ]),
          $data.isFetchingDriverDetails ? (openBlock(), createElementBlock("div", _hoisted_8$a, [
            createVNode(VProgressCircular, {
              indeterminate: "",
              color: "#7823DC",
              size: 80,
              width: 10
            })
          ])) : createCommentVNode("", true),
          !$data.isFetchingDriverDetails && $data.lodSize($data.selectedDriverDetails) > 0 ? (openBlock(), createElementBlock("div", _hoisted_9$a, [
            _hoisted_10$8,
            createBaseVNode("ul", _hoisted_11$8, [
              (openBlock(true), createElementBlock(Fragment, null, renderList($data.selectedDriverDetails, (item, index2) => {
                return openBlock(), createElementBlock("li", {
                  key: item.dataPoint,
                  class: normalizeClass(`tw-flex tw-justify-between tw-gap-x-3 tw-items-center tw-p-3 ${index2 % 2 === 0 ? "tw-bg-white" : "tw-bg-brand-gray-1"}`)
                }, [
                  createBaseVNode("span", _hoisted_12$6, toDisplayString(item.dataPoint), 1),
                  createBaseVNode("div", _hoisted_13$5, [
                    createBaseVNode("span", _hoisted_14$4, toDisplayString(item.source), 1),
                    createBaseVNode("span", _hoisted_15$4, toDisplayString($options.getPercentValue(item.value)), 1)
                  ])
                ], 2);
              }), 128))
            ])
          ])) : createCommentVNode("", true)
        ])
      ]),
      _: 1
    }, 8, ["modelValue"])
  ]);
}
const ChartKeyDemandDrivers = /* @__PURE__ */ _export_sfc(_sfc_main$e, [["render", _sfc_render$e]]);
const DATA_CONFIG$2 = [
  {
    key: "pyVal",
    label: "PY Actual",
    color: "#A5A5A5"
  },
  {
    key: "impliedVal",
    label: "Implied",
    color: "#F8D887"
  }
];
const dataKeys$2 = _.map(DATA_CONFIG$2, (el2) => el2.key);
const _sfc_main$d = {
  name: "ChartPYandImpliedGrowth",
  components: {
    GChart
  },
  props: {
    projectedPeriod: {
      type: String,
      required: true
    },
    pyVal: {
      type: [Number, String],
      required: true
    },
    impliedVal: {
      type: [Number, String],
      required: true
    },
    chartsScale: { type: Object, required: true }
  },
  data() {
    return {
      legendData: DATA_CONFIG$2
    };
  },
  computed: {
    pyValNumeric() {
      return _.isNaN(_.toNumber(this.pyVal)) ? 0 : _.toNumber(this.pyVal);
    },
    impliedValNumeric() {
      return _.isNaN(_.toNumber(this.impliedVal)) ? 0 : _.toNumber(this.impliedVal);
    },
    chartData() {
      return [
        [
          "",
          dataKeys$2[0],
          { role: "annotation" },
          dataKeys$2[1],
          { role: "annotation" }
        ],
        [
          this.projectedPeriod,
          this.pyValNumeric,
          `${this.pyValNumeric}%`,
          this.impliedValNumeric,
          `${this.impliedValNumeric}%`
        ]
      ];
    },
    chartOptions() {
      return {
        legend: { position: "none" },
        tooltip: { trigger: "none" },
        annotations: {
          textStyle: {
            color: "#000000",
            fontSize: 12
          },
          datum: { stem: { length: 0 } },
          alwaysOutside: true
        },
        bar: { groupWidth: "44%" },
        vAxis: {
          gridlines: {
            count: 0
          },
          textPosition: "none",
          viewWindow: {
            max: _.get(this.chartsScale, "max"),
            min: _.get(this.chartsScale, "min")
          }
        },
        hAxis: {
          textStyle: {
            color: "#323232",
            fontName: "Graphik",
            fontSize: 13
          }
        },
        chartArea: {
          top: "10%",
          width: "70%",
          height: "80%"
        },
        colors: _.map(DATA_CONFIG$2, (el2) => el2.color)
      };
    }
  }
};
const _hoisted_1$c = { class: "tw-flex tw-flex-col tw-gap-y-2 desktop:tw-items-center small-laptop:tw-items-center" };
const _hoisted_2$b = { class: "tw-flex tw-items-center tw-gap-x-3" };
const _hoisted_3$b = { class: "tw-text-xs" };
const _hoisted_4$b = /* @__PURE__ */ createBaseVNode("div", { class: "tw-w-96 tw-h-14 tw-p-2 tw-bg-white tw-border tw-rounded tw-border-[#D9D9D9] tw-shadow-2xl" }, [
  /* @__PURE__ */ createBaseVNode("p", { class: "tw-text-sm tw-text-center" }, " Size of the company in relation to its market and its competitors based on demand projections ")
], -1);
function _sfc_render$d(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_GChart = resolveComponent("GChart");
  return openBlock(), createElementBlock(Fragment, null, [
    createVNode(VMenu, {
      "open-on-hover": "",
      location: "top"
    }, {
      activator: withCtx(({ props }) => [
        createBaseVNode("div", _hoisted_1$c, [
          createBaseVNode("span", mergeProps(props, { class: "tw-font-medium tw-text-lg desktop:tw-text-base small-laptop:tw-text-base tw-cursor-default" }), " Implied Market Share ", 16),
          createBaseVNode("div", _hoisted_2$b, [
            (openBlock(true), createElementBlock(Fragment, null, renderList($data.legendData, (item) => {
              return openBlock(), createElementBlock("div", {
                key: item.key,
                class: "tw-flex tw-items-center tw-gap-x-1"
              }, [
                createBaseVNode("span", {
                  style: normalizeStyle(`height: 12px; width: 12px; background: ${item.color}`)
                }, null, 4),
                createBaseVNode("span", _hoisted_3$b, toDisplayString(item.label), 1)
              ]);
            }), 128))
          ])
        ])
      ]),
      default: withCtx(() => [
        _hoisted_4$b
      ]),
      _: 1
    }),
    createVNode(_component_GChart, {
      type: "ColumnChart",
      data: $options.chartData,
      options: $options.chartOptions
    }, null, 8, ["data", "options"])
  ], 64);
}
const ChartPYandImpliedGrowth = /* @__PURE__ */ _export_sfc(_sfc_main$d, [["render", _sfc_render$d]]);
const DATA_CONFIG$1 = [
  {
    key: "period",
    label: "Period",
    color: ""
  },
  {
    key: "Internal",
    label: "Internal Forecast",
    color: "#787878"
  },
  {
    key: "Market Sensing",
    label: "Market Sensing Forecast",
    color: "#570EAA"
  },
  {
    key: "Adjusted",
    label: "Adjusted Internal",
    color: "#FFC107"
  },
  {
    key: "Actual",
    label: "Sales",
    color: "#C8A5F0"
  }
];
const dataKeys$1 = _.map(DATA_CONFIG$1, (el2) => el2.key);
const _sfc_main$c = {
  name: "ChartHistoricalAndActual",
  components: {
    GChart
  },
  props: {
    data: {
      type: Object,
      required: true
    },
    chartsScale: { type: Object, required: true }
  },
  computed: {
    chartColumns() {
      const columns = [];
      _.forEach(dataKeys$1, (key, i2) => {
        columns.push(key);
        if (i2 > 0)
          columns.push({ role: "annotation" });
      });
      return columns;
    },
    chartData() {
      return [
        [...this.chartColumns],
        ..._.map(this.data, (v) => {
          return _.map(this.chartColumns, (column, i2) => {
            let key = column;
            if (_.get(key, "role") === "annotation") {
              key = this.chartColumns[i2 - 1];
              return v[key] === null || v[key] === void 0 ? "NA" : `${_.round(_.toNumber(v[key]), 0)}%`;
            }
            return v[key] === null || v[key] === void 0 ? 0 : v[key];
          });
        })
      ];
    }
  },
  data() {
    return {
      legendData: DATA_CONFIG$1.slice(1),
      chartOptions: {
        legend: { position: "none" },
        tooltip: { trigger: "none" },
        series: {
          0: { color: DATA_CONFIG$1[1].color },
          1: { color: DATA_CONFIG$1[2].color },
          2: { color: DATA_CONFIG$1[3].color },
          3: { color: DATA_CONFIG$1[4].color }
        },
        annotations: {
          textStyle: {
            color: "#000000",
            fontSize: 12
          },
          datum: { stem: { length: 0 } },
          alwaysOutside: true
        },
        bar: { groupWidth: "76%" },
        hAxis: {
          textStyle: {
            color: "#323232",
            fontName: "Graphik",
            fontSize: 13
          }
        },
        vAxis: {
          gridlines: {
            count: 0
          },
          textPosition: "none",
          viewWindow: {
            max: _.get(this.chartsScale, "max"),
            min: _.get(this.chartsScale, "min")
          }
        },
        chartArea: {
          top: "6%",
          width: "100%",
          height: "84%"
        }
      }
    };
  }
};
const _hoisted_1$b = { class: "tw-flex tw-flex-col tw-gap-y-2 small-laptop:tw-overflow-auto" };
const _hoisted_2$a = /* @__PURE__ */ createBaseVNode("span", { class: "tw-font-medium tw-text-lg desktop:tw-text-base small-laptop:tw-text-base tw-cursor-default" }, " Market Sensing Forecast vs Sales (%, YoY) \u2013 Historical Period ", -1);
const _hoisted_3$a = { class: "tw-flex tw-items-center tw-gap-x-3" };
const _hoisted_4$a = { class: "tw-text-xs" };
const _hoisted_5$a = { class: "tw-overflow-x-auto tw-overflow-y-hidden" };
const _hoisted_6$a = { class: "tw-min-w-[800px]" };
function _sfc_render$c(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_GChart = resolveComponent("GChart");
  return openBlock(), createElementBlock(Fragment, null, [
    createBaseVNode("div", _hoisted_1$b, [
      _hoisted_2$a,
      createBaseVNode("div", _hoisted_3$a, [
        (openBlock(true), createElementBlock(Fragment, null, renderList($data.legendData, (item) => {
          return openBlock(), createElementBlock("div", {
            key: item.key,
            class: "tw-flex tw-items-center tw-gap-x-1"
          }, [
            createBaseVNode("span", {
              style: normalizeStyle(`height: 12px; width: 12px; background: ${item.color}`)
            }, null, 4),
            createBaseVNode("span", _hoisted_4$a, toDisplayString(item.label), 1)
          ]);
        }), 128))
      ])
    ]),
    createBaseVNode("div", _hoisted_5$a, [
      createBaseVNode("div", _hoisted_6$a, [
        createVNode(_component_GChart, {
          type: "ColumnChart",
          data: $options.chartData,
          options: $data.chartOptions
        }, null, 8, ["data", "options"])
      ])
    ])
  ], 64);
}
const ChartHistoricalAndActual = /* @__PURE__ */ _export_sfc(_sfc_main$c, [["render", _sfc_render$c]]);
const _sfc_main$b = {
  name: "ChartsSection",
  components: {
    ChartKeyDemandDrivers,
    ChartPYandImpliedGrowth,
    ChartHistoricalAndActual
  },
  props: {
    activePeriodData: {
      type: Object,
      required: true
    },
    options: Object
  },
  computed: {
    metrics() {
      return this.activePeriodData.metrics;
    },
    periodLabel() {
      return _.get(this.activePeriodData, "label");
    },
    horizon() {
      return _.get(this.activePeriodData, "horizon");
    },
    selectedFilters() {
      return _.get(this.options, "selectedFilters");
    },
    forecastPeriodType() {
      return _.get(this.options, "forecastPeriodType");
    },
    formattedHorizon() {
      if (this.forecastPeriodType === FORECAST_PERIOD_TYPES.R3M_VIEW) {
        return _.get(this.activePeriodData, "formattedHorizon");
      }
      return "";
    },
    chartsScale() {
      const pyValNumeric = this.getNumericValue(
        _.get(this.metrics, "pyGrowth")
      );
      const impliedValNumeric = this.getNumericValue(
        _.get(this.metrics, "impliedGrowth")
      );
      const numericValuesOfHistoricalChart = _.flatMap(
        _.get(this.metrics, "historical"),
        (el2) => {
          const values = _.values(el2);
          return _.map(values, (v) => this.getNumericValue(v));
        }
      );
      const numericValuesOfAllCharts = [
        pyValNumeric,
        impliedValNumeric,
        ...numericValuesOfHistoricalChart
      ];
      return {
        max: _.add(_.max(numericValuesOfAllCharts), 5),
        min: _.subtract(_.min(numericValuesOfAllCharts), 5)
      };
    }
  },
  methods: {
    getNumericValue(value) {
      if (value === null || _.isNaN(_.toNumber(value))) {
        return 0;
      }
      return _.toNumber(value);
    }
  }
};
const _hoisted_1$a = { class: "tw-flex tw-gap-x-4 tw-items-center tw-w-full tw-py-2" };
const _hoisted_2$9 = { class: "tw-font-medium tw-text-2xl desktop:tw-text-xl small-laptop:tw-text-lg" };
const _hoisted_3$9 = {
  key: 0,
  class: "tw-bg-brand-gray-4 tw-rounded"
};
const _hoisted_4$9 = { class: "tw-p-1 tw-text-sm desktop:tw-text-xs small-laptop:tw-text-xs" };
const _hoisted_5$9 = { class: "tw-py-3 tw-w-full" };
const _hoisted_6$9 = {
  key: 0,
  class: "tw-grid tw-grid-cols-7 desktop:tw-grid-cols-12 small-laptop:tw-grid-cols-12 tw-gap-4"
};
const _hoisted_7$9 = { class: "tw-col-span-2 desktop:tw-col-span-4 small-laptop:tw-col-span-4" };
const _hoisted_8$9 = { class: "tw-col-span-1 desktop:tw-col-span-2 small-laptop:tw-col-span-2" };
const _hoisted_9$9 = { class: "tw-col-span-4 desktop:tw-col-span-6 small-laptop:tw-col-span-6" };
function _sfc_render$b(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_ChartKeyDemandDrivers = resolveComponent("ChartKeyDemandDrivers");
  const _component_ChartPYandImpliedGrowth = resolveComponent("ChartPYandImpliedGrowth");
  const _component_ChartHistoricalAndActual = resolveComponent("ChartHistoricalAndActual");
  return openBlock(), createElementBlock(Fragment, null, [
    createBaseVNode("div", _hoisted_1$a, [
      createBaseVNode("p", _hoisted_2$9, " More details for " + toDisplayString($options.periodLabel), 1),
      $options.formattedHorizon ? (openBlock(), createElementBlock("div", _hoisted_3$9, [
        createBaseVNode("p", _hoisted_4$9, " Future " + toDisplayString($options.formattedHorizon) + " months ", 1)
      ])) : createCommentVNode("", true)
    ]),
    createBaseVNode("div", _hoisted_5$9, [
      $options.metrics ? (openBlock(), createElementBlock("div", _hoisted_6$9, [
        createBaseVNode("div", _hoisted_7$9, [
          createVNode(_component_ChartKeyDemandDrivers, {
            data: $options.metrics.keyDemandDrivers,
            horizon: $options.horizon,
            selectedFilters: $options.selectedFilters
          }, null, 8, ["data", "horizon", "selectedFilters"])
        ]),
        createBaseVNode("div", _hoisted_8$9, [
          createVNode(_component_ChartPYandImpliedGrowth, {
            projectedPeriod: $options.periodLabel,
            pyVal: $options.metrics.pyGrowth,
            impliedVal: $options.metrics.impliedGrowth,
            chartsScale: $options.chartsScale
          }, null, 8, ["projectedPeriod", "pyVal", "impliedVal", "chartsScale"])
        ]),
        createBaseVNode("div", _hoisted_9$9, [
          createVNode(_component_ChartHistoricalAndActual, {
            data: $options.metrics.historical,
            chartsScale: $options.chartsScale
          }, null, 8, ["data", "chartsScale"])
        ])
      ])) : createCommentVNode("", true)
    ])
  ], 64);
}
const ChartsSection = /* @__PURE__ */ _export_sfc(_sfc_main$b, [["render", _sfc_render$b]]);
const VAlert$1 = "";
const VAlertTitle = createSimpleFunctional("v-alert-title");
const allowedTypes = ["success", "info", "warning", "error"];
const VAlert = defineComponent({
  name: "VAlert",
  props: {
    border: {
      type: [Boolean, String],
      validator: (val) => {
        return typeof val === "boolean" || ["top", "end", "bottom", "start"].includes(val);
      }
    },
    borderColor: String,
    closable: Boolean,
    closeIcon: {
      type: IconValue,
      default: "$close"
    },
    closeLabel: {
      type: String,
      default: "$vuetify.close"
    },
    icon: {
      type: [Boolean, String, Function, Object],
      default: null
    },
    modelValue: {
      type: Boolean,
      default: true
    },
    prominent: Boolean,
    title: String,
    text: String,
    type: {
      type: String,
      validator: (val) => allowedTypes.includes(val)
    },
    ...makeDensityProps(),
    ...makeDimensionProps(),
    ...makeElevationProps(),
    ...makeLocationProps(),
    ...makePositionProps(),
    ...makeRoundedProps(),
    ...makeTagProps(),
    ...makeThemeProps(),
    ...makeVariantProps({
      variant: "flat"
    })
  },
  emits: {
    "update:modelValue": (value) => true
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    const isActive = useProxiedModel(props, "modelValue");
    const icon = computed(() => {
      var _a2;
      if (props.icon === false)
        return void 0;
      if (!props.type)
        return props.icon;
      return (_a2 = props.icon) != null ? _a2 : `$${props.type}`;
    });
    const variantProps = computed(() => {
      var _a2;
      return {
        color: (_a2 = props.color) != null ? _a2 : props.type,
        variant: props.variant
      };
    });
    const {
      themeClasses
    } = provideTheme(props);
    const {
      colorClasses,
      colorStyles,
      variantClasses
    } = useVariant(variantProps);
    const {
      densityClasses
    } = useDensity(props);
    const {
      dimensionStyles
    } = useDimension(props);
    const {
      elevationClasses
    } = useElevation(props);
    const {
      locationStyles
    } = useLocation(props);
    const {
      positionClasses
    } = usePosition(props);
    const {
      roundedClasses
    } = useRounded(props);
    const {
      textColorClasses,
      textColorStyles
    } = useTextColor(toRef(props, "borderColor"));
    const {
      t: t3
    } = useLocale();
    const closeProps = computed(() => ({
      "aria-label": t3(props.closeLabel),
      onClick(e3) {
        isActive.value = false;
      }
    }));
    return () => {
      var _slots$default, _slots$close;
      const hasPrepend = !!(slots.prepend || icon.value);
      const hasTitle = !!(slots.title || props.title);
      const hasText = !!(props.text || slots.text);
      const hasClose = !!(slots.close || props.closable);
      return isActive.value && createVNode(props.tag, {
        "class": ["v-alert", props.border && {
          "v-alert--border": !!props.border,
          [`v-alert--border-${props.border === true ? "start" : props.border}`]: true
        }, {
          "v-alert--prominent": props.prominent
        }, themeClasses.value, colorClasses.value, densityClasses.value, elevationClasses.value, positionClasses.value, roundedClasses.value, variantClasses.value],
        "style": [colorStyles.value, dimensionStyles.value, locationStyles.value],
        "role": "alert"
      }, {
        default: () => [genOverlays(false, "v-alert"), props.border && createVNode("div", {
          "key": "border",
          "class": ["v-alert__border", textColorClasses.value],
          "style": textColorStyles.value
        }, null), hasPrepend && createVNode(VDefaultsProvider, {
          "key": "prepend",
          "defaults": {
            VIcon: {
              density: props.density,
              icon: icon.value,
              size: props.prominent ? 44 : 28
            }
          }
        }, {
          default: () => [createVNode("div", {
            "class": "v-alert__prepend"
          }, [slots.prepend ? slots.prepend() : icon.value && createVNode(VIcon, null, null)])]
        }), createVNode("div", {
          "class": "v-alert__content"
        }, [hasTitle && createVNode(VAlertTitle, {
          "key": "title"
        }, {
          default: () => [slots.title ? slots.title() : props.title]
        }), hasText && (slots.text ? slots.text() : props.text), (_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots)]), slots.append && createVNode("div", {
          "key": "append",
          "class": "v-alert__append"
        }, [slots.append()]), hasClose && createVNode(VDefaultsProvider, {
          "key": "close",
          "defaults": {
            VBtn: {
              icon: props.closeIcon,
              size: "x-small",
              variant: "text"
            }
          }
        }, {
          default: () => {
            var _a2;
            return [createVNode("div", {
              "class": "v-alert__close"
            }, [(_a2 = (_slots$close = slots.close) == null ? void 0 : _slots$close.call(slots, {
              props: closeProps.value
            })) != null ? _a2 : createVNode(VBtn, closeProps.value, null)])];
          }
        })]
      });
    };
  }
});
const { R3M_VIEW, QUARTERLY_VIEW } = FORECAST_PERIOD_TYPES;
const FILTER_UPDATE_GAP_MS$2 = 3e3;
const FILTER_INSTANT_UPDATE_GAP_MS$1 = 500;
const _sfc_main$a = {
  name: "DemandPlanner",
  components: {
    FiltersSection: FiltersSection$2,
    CardsList: CardsList$1,
    ChartsSection
  },
  props: {
    userdata: {
      type: Object,
      required: true
    }
  },
  data() {
    return {
      dataLoading: true,
      error: null,
      debounceUpdateFilters: _.debounce(
        this.updateFilters,
        FILTER_UPDATE_GAP_MS$2
      ),
      debounceUpdateFiltersInstant: _.debounce(
        this.updateFilters,
        FILTER_INSTANT_UPDATE_GAP_MS$1
      ),
      dashboardData: {},
      selectedFilters: {
        marketSensingRefreshDate: null,
        category: "",
        customer: "",
        valueORvolume: null
      },
      latestRefreshDate: null,
      selectedRefreshDate: null,
      isModelAccuracyHidden: false,
      forecastPeriodType: R3M_VIEW,
      getPeriodDataLabel,
      getConcisePeriodLabel,
      R3M_VIEW,
      EyeIcon,
      EyeOffIcon,
      lodGet: _.get
    };
  },
  computed: {
    selectedCards() {
      return _.filter(
        _.get(this.dashboardData, "periodsData"),
        (v) => v.isChecked
      );
    },
    activePeriodData() {
      return _.find(
        _.get(this.dashboardData, "periodsData"),
        (v) => v.isActive
      );
    },
    userId() {
      return _.get(this.userdata, "deocdedJWT.email");
    },
    userDisplayName() {
      let userDisplayName = _.get(this.userdata, "deocdedJWT.name");
      if (!userDisplayName) {
        const { isAdmin } = this.userdata;
        const userEmail = _.get(this.userdata, "deocdedJWT.email");
        userDisplayName = isAdmin ? `${userEmail}[admin]` : userEmail;
      }
      return userDisplayName;
    },
    fetchApi() {
      if (this.forecastPeriodType === QUARTERLY_VIEW) {
        return fetchQuarterlyData;
      }
      return fetchR3MData;
    },
    isApiDataAvailable() {
      return _.size(_.get(this.dashboardData, "periodsData")) > 0;
    }
  },
  methods: {
    formatHorizon(value) {
      if (!value)
        return "";
      const formattedValue = value.replaceAll("_", "-").replaceAll("m", "");
      return formattedValue;
    },
    toggleForecastPeriodType() {
      this.forecastPeriodType = this.forecastPeriodType === R3M_VIEW ? QUARTERLY_VIEW : R3M_VIEW;
      this.fetchDashboardData();
    },
    latestRefreshDateUpdateHandler(dateObj) {
      this.latestRefreshDate = format(dateObj, "MMM dd, yyyy");
    },
    isCheckDisabled(isChecked) {
      return isChecked && _.size(
        _.filter(
          _.map(this.dashboardData.periodsData, (v) => v.isChecked),
          (v) => v === true
        )
      ) === 1;
    },
    setActiveCard(activeCardIndex) {
      _.forEach(_.get(this.dashboardData, "periodsData"), (v, i2) => {
        _.set(
          this.dashboardData,
          `periodsData[${i2}].isActive`,
          i2 === activeCardIndex
        );
      });
    },
    async fetchDashboardData() {
      this.dataLoading = true;
      this.error = null;
      try {
        const response = await this.fetchApi({
          marketSensingRefreshDate: this.selectedFilters.marketSensingRefreshDate,
          categories: this.selectedFilters.category,
          customers: this.selectedFilters.customer,
          valueORvolume: this.selectedFilters.valueOrQuantity
        });
        if (!_.isEmpty(response)) {
          this.dashboardData.periodsData = response;
          _.forEach(this.dashboardData.periodsData, (v, i2) => {
            v.period = _.get(_.keys(v), "[0]");
            v.label = this.getPeriodDataLabel(
              v.period,
              this.forecastPeriodType
            );
            v.metrics = _.get(v, `${v.period}.metrics`, {});
            v.horizon = _.get(v, `${v.period}.horizon`, "");
            v.formattedHorizon = this.formatHorizon(v.horizon);
            delete v[v.period];
            v.metrics.historical = _.map(
              _.get(v.metrics, "historical"),
              (el2) => {
                const historicalPeriod = _.get(el2, "period");
                const periodLabel = this.getConcisePeriodLabel(
                  historicalPeriod,
                  this.forecastPeriodType
                );
                return { ...el2, period: periodLabel };
              }
            );
            v.metrics.variance = _.round(
              _.subtract(v.metrics.marketSensingGrowth, v.metrics.jdaGrowth),
              0
            );
            v.checkboxLabel = this.getConcisePeriodLabel(
              v.period,
              this.forecastPeriodType
            );
            v.isChecked = true;
            v.isActive = i2 === 0;
          });
        } else {
          throw new Error("Unable to fetch data");
        }
      } catch (e3) {
        this.error = e3;
      }
      this.dataLoading = false;
    },
    async updateFilters(filtersData) {
      const selectedMarketSensingRefreshDate = _.get(
        filtersData,
        "refreshDates.selected"
      );
      const selectedCategories = _.get(filtersData, "categories.selected");
      const selectedCustomers = _.get(filtersData, "customers.selected");
      const selectedValueORvolume = _.get(filtersData, "valueOrQuantity");
      try {
        if (selectedMarketSensingRefreshDate === null) {
          throw new Error("Market Sensing Refresh Date is not available.");
        }
        const marketSensingRefreshDateP = parse(
          `${selectedMarketSensingRefreshDate.year}-${selectedMarketSensingRefreshDate.month + 1}`,
          "yyyy-M",
          new Date()
        );
        const marketSensingRefreshDate = format(
          marketSensingRefreshDateP,
          "yyyy-MM-dd"
        );
        this.selectedRefreshDate = format(
          marketSensingRefreshDateP,
          "MMM yyyy"
        );
        this.selectedFilters = {
          marketSensingRefreshDate,
          category: selectedCategories,
          customer: selectedCustomers === ALL_OPTION$2 ? "*" : selectedCustomers,
          valueOrQuantity: selectedValueORvolume
        };
        this.fetchDashboardData();
      } catch (e3) {
        this.error = e3;
        this.dataLoading = false;
      }
    }
  }
};
const _hoisted_1$9 = { class: "tw-h-full tw-w-full tw-bg-brand-gray-1" };
const _hoisted_2$8 = { class: "tw-flex tw-w-full tw-h-8 tw-bg-brand-gray-1" };
const _hoisted_3$8 = { class: "tw-flex tw-h-full tw-items-center tw-font-bold tw-text-lg" };
const _hoisted_4$8 = {
  key: 0,
  class: "tw-ml-auto tw-h-full tw-flex tw-items-center"
};
const _hoisted_5$8 = /* @__PURE__ */ createBaseVNode("div", { class: "tw-flex tw-w-full tw-flex-auto tw-border-t tw-border-solid tw-border-brand-gray-2" }, null, -1);
const _hoisted_6$8 = { class: "tw-py-5" };
const _hoisted_7$8 = {
  key: 0,
  class: "tw-w-full tw-h-3/4 tw-flex tw-justify-center tw-items-center"
};
const _hoisted_8$8 = {
  key: 1,
  class: "tw-w-full tw-p-4 tw-bg-white"
};
const _hoisted_9$8 = { class: "tw-flex tw-flex-col tw-w-full tw-border-b tw-border-solid tw-border-brand-gray-2" };
const _hoisted_10$7 = /* @__PURE__ */ createBaseVNode("h1", { class: "desktop:tw-text-2xl small-laptop:tw-text-2xl tw-text-3xl tw-font-bold" }, " Future Demand Forecasting ", -1);
const _hoisted_11$7 = { class: "tw-flex tw-items-center tw-w-full" };
const _hoisted_12$5 = /* @__PURE__ */ createBaseVNode("p", { class: "desktop:tw-text-sm small-laptop:tw-text-sm" }, " Show demand projections for: ", -1);
const _hoisted_13$4 = ["for"];
const _hoisted_14$3 = { class: "tw-flex tw-gap-x-3 tw-ml-auto small-laptop:tw-ml-3" };
const _hoisted_15$3 = { class: "tw-flex tw-gap-x-2 desktop:tw-gap-x-1 small-laptop:tw-gap-x-0" };
const _hoisted_16$3 = ["src"];
const _hoisted_17$2 = { class: "tw-text-sm desktop:tw-text-xs" };
const _hoisted_18$2 = ["disabled"];
const _hoisted_19$1 = { class: "tw-text-white tw-text-sm desktop:tw-text-xs small-laptop:tw-text-xs" };
const _hoisted_20$1 = {
  key: 0,
  class: "tw-flex tw-justify-center tw-gap-2.5 tw-w-full tw-py-5"
};
const _hoisted_21$1 = { class: "tw-p-4 desktop:tw-p-1 tw-border tw-border-solid tw-border-brand-primary" };
const _hoisted_22$1 = { key: 2 };
function _sfc_render$a(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_FiltersSection = resolveComponent("FiltersSection");
  const _component_CardsList = resolveComponent("CardsList");
  const _component_ChartsSection = resolveComponent("ChartsSection");
  return openBlock(), createElementBlock("div", _hoisted_1$9, [
    createBaseVNode("div", _hoisted_2$8, [
      createBaseVNode("h1", _hoisted_3$8, " Demand Planner Dashboard " + toDisplayString($data.selectedRefreshDate ? `as of ${$data.selectedRefreshDate}` : ""), 1),
      $data.latestRefreshDate ? (openBlock(), createElementBlock("div", _hoisted_4$8, " Last refreshed on " + toDisplayString($data.latestRefreshDate), 1)) : createCommentVNode("", true)
    ]),
    _hoisted_5$8,
    createBaseVNode("div", _hoisted_6$8, [
      createVNode(_component_FiltersSection, {
        onUpdateFilters: $data.debounceUpdateFilters,
        onUpdateFiltersInstant: $data.debounceUpdateFiltersInstant,
        onLatestRefreshDateUpdate: $options.latestRefreshDateUpdateHandler,
        isDataLoading: $data.dataLoading
      }, null, 8, ["onUpdateFilters", "onUpdateFiltersInstant", "onLatestRefreshDateUpdate", "isDataLoading"])
    ]),
    $data.dataLoading ? (openBlock(), createElementBlock("div", _hoisted_7$8, [
      createVNode(VProgressCircular, {
        indeterminate: "",
        color: "#7823DC",
        size: 80,
        width: 10
      })
    ])) : createCommentVNode("", true),
    !$data.dataLoading && !$data.error && $options.isApiDataAvailable ? (openBlock(), createElementBlock("div", _hoisted_8$8, [
      createBaseVNode("div", _hoisted_9$8, [
        _hoisted_10$7,
        createBaseVNode("div", _hoisted_11$7, [
          _hoisted_12$5,
          (openBlock(true), createElementBlock(Fragment, null, renderList($data.dashboardData.periodsData, (periodData) => {
            return openBlock(), createElementBlock("div", {
              key: periodData.label,
              class: "tw-flex tw-items-center tw-text-brand-primary"
            }, [
              createVNode(VCheckbox, {
                id: `period${periodData.checkboxLabel}`,
                "hide-details": "",
                disabled: $options.isCheckDisabled(periodData.isChecked),
                modelValue: periodData.isChecked,
                "onUpdate:modelValue": ($event) => periodData.isChecked = $event
              }, null, 8, ["id", "disabled", "modelValue", "onUpdate:modelValue"]),
              createBaseVNode("label", {
                for: `period${periodData.checkboxLabel}`,
                class: "tw-text-black desktop:tw-text-sm small-laptop:tw-text-sm"
              }, toDisplayString(periodData.checkboxLabel), 9, _hoisted_13$4)
            ]);
          }), 128)),
          createBaseVNode("div", _hoisted_14$3, [
            createBaseVNode("button", {
              class: "small-laptop:tw-hidden tw-px-2 tw-py-1.5 tw-border tw-border-solid tw-border-brand-primary",
              onClick: _cache[0] || (_cache[0] = ($event) => $data.isModelAccuracyHidden = !$data.isModelAccuracyHidden)
            }, [
              createBaseVNode("div", _hoisted_15$3, [
                createBaseVNode("img", {
                  src: $data.isModelAccuracyHidden ? $data.EyeIcon : $data.EyeOffIcon
                }, null, 8, _hoisted_16$3),
                createBaseVNode("span", _hoisted_17$2, toDisplayString($data.isModelAccuracyHidden ? "Show" : "Hide") + " Model Accuracy ", 1)
              ])
            ]),
            createBaseVNode("button", {
              class: "tw-px-3 tw-py-1.5 small-laptop:tw-px-1 small-laptop:tw-py-1 tw-bg-brand-primary",
              onClick: _cache[1] || (_cache[1] = (...args) => $options.toggleForecastPeriodType && $options.toggleForecastPeriodType(...args)),
              disabled: $data.dataLoading
            }, [
              createBaseVNode("span", _hoisted_19$1, " Switch to " + toDisplayString($data.forecastPeriodType === $data.R3M_VIEW ? "Fixed/Quarterly" : "Rolling 3 Months") + " View ", 1)
            ], 8, _hoisted_18$2)
          ])
        ])
      ]),
      $data.lodGet($data.dashboardData, "periodsData.length") ? (openBlock(), createElementBlock("div", _hoisted_20$1, [
        createVNode(_component_CardsList, {
          data: $options.selectedCards,
          onSetActiveCard: $options.setActiveCard,
          options: {
            isModelAccuracyHidden: $data.isModelAccuracyHidden,
            selectedFilters: $data.selectedFilters,
            userData: { userId: $options.userId, userDisplayName: $options.userDisplayName },
            forecastPeriodType: $data.forecastPeriodType
          }
        }, null, 8, ["data", "onSetActiveCard", "options"])
      ])) : createCommentVNode("", true),
      createBaseVNode("div", _hoisted_21$1, [
        $options.activePeriodData ? (openBlock(), createBlock(_component_ChartsSection, {
          key: 0,
          activePeriodData: $options.activePeriodData,
          options: {
            selectedFilters: $data.selectedFilters,
            forecastPeriodType: $data.forecastPeriodType
          }
        }, null, 8, ["activePeriodData", "options"])) : createCommentVNode("", true)
      ])
    ])) : createCommentVNode("", true),
    !$data.dataLoading && $data.error ? (openBlock(), createElementBlock("div", _hoisted_22$1, [
      createVNode(VAlert, {
        type: "error",
        text: $data.error.toString()
      }, null, 8, ["text"])
    ])) : createCommentVNode("", true)
  ]);
}
const DemandPlanner = /* @__PURE__ */ _export_sfc(_sfc_main$a, [["render", _sfc_render$a]]);
const InfoIcon = "/assets/info-icon.ae33a7d8.svg";
const HeatMapScaleIcon = "/assets/heatmap-scale.cf4e8548.svg";
const FiltersSection_vue_vue_type_style_index_0_lang = "";
const BY_VALUE$1 = "BY_VALUE";
const BY_QUANTITY$1 = "BY_QUANTITY";
const _sfc_main$9 = {
  name: "FiltersSection",
  props: {
    isDataLoading: { type: Boolean, default: false }
  },
  data() {
    return {
      filters: {
        refreshDates: {
          items: [],
          selected: null
        },
        valueOrQuantity: BY_QUANTITY$1
      },
      customers: [],
      categories: [],
      dataLoaded: false,
      currency: "USD",
      BY_VALUE: BY_VALUE$1,
      BY_QUANTITY: BY_QUANTITY$1,
      InfoIcon,
      HeatMapScaleIcon
    };
  },
  async created() {
    const options = await fetchDashboardOptions().catch(() => null);
    if (options) {
      this.filters.refreshDates.items = _.get(options, "updateDates");
      this.customers = _.get(options, "ms.customers", []);
      this.categories = _.get(options, "ms.categories", []);
    }
    let earliestRefreshDate = null;
    if (_.first(this.filters.refreshDates.items)) {
      earliestRefreshDate = parse(
        _.first(this.filters.refreshDates.items),
        "yyyy-MM-dd",
        new Date()
      );
    }
    if (earliestRefreshDate !== null) {
      this.updateLatestRefreshDate(earliestRefreshDate);
      this.refreshDateUpdated(
        {
          month: earliestRefreshDate.getMonth(),
          year: earliestRefreshDate.getFullYear()
        },
        true
      );
    } else {
      this.filterUpdatedInstant();
    }
    this.dataLoaded = true;
  },
  emits: ["updateFilters", "updateFiltersInstant", "latestRefreshDateUpdate"],
  methods: {
    formatDatePickerValue(date) {
      return format(date, "MMM yyyy");
    },
    getMinDate() {
      return parse(
        _.last(this.filters.refreshDates.items),
        "yyyy-MM-dd",
        new Date()
      );
    },
    getMaxDate() {
      return endOfMonth(
        parse(
          _.first(this.filters.refreshDates.items),
          "yyyy-MM-dd",
          new Date()
        )
      );
    },
    updateLatestRefreshDate(dateObj) {
      this.$emit("latestRefreshDateUpdate", dateObj);
    },
    refreshDateUpdated({ month, year }, isInstant = false) {
      this.filters.refreshDates.selected = { month, year };
      isInstant ? this.filterUpdatedInstant() : this.filtersUpdated();
    },
    valueOrQuantityUpdate(event, isInstant = false) {
      this.filters.valueOrQuantity = this.filters.valueOrQuantity === BY_VALUE$1 ? BY_QUANTITY$1 : BY_VALUE$1;
      isInstant ? this.filterUpdatedInstant() : this.filtersUpdated();
    },
    filtersUpdated() {
      this.$emit("updateFilters", this.filters, {
        customers: this.customers,
        categories: this.categories
      });
    },
    filterUpdatedInstant() {
      this.$emit("updateFiltersInstant", this.filters, {
        customers: this.customers,
        categories: this.categories
      });
    }
  }
};
const _hoisted_1$8 = { class: "tw-flex tw-gap-x-3 tw-w-full tw-bg-white tw-px-3" };
const _hoisted_2$7 = { class: "tw-pt-3 tw-min-w-[14%] tw--mb-3" };
const _hoisted_3$7 = /* @__PURE__ */ createBaseVNode("label", {
  for: "date-picker",
  class: "tw-text-sm"
}, "Month & Year", -1);
const _hoisted_4$7 = { class: "tw-text-base" };
const _hoisted_5$7 = { class: "tw-flex tw-gap-1.5 tw-pt-3 tw-pl-3 tw--mb-3" };
const _hoisted_6$7 = { class: "tw-flex tw-pt-8 tw-text-brand-primary" };
const _hoisted_7$7 = { class: "tw-flex tw-justify-end tw-items-end tw-ml-auto tw-py-2" };
const _hoisted_8$7 = { class: "tw-flex tw-gap-1" };
const _hoisted_9$7 = ["src"];
const _hoisted_10$6 = /* @__PURE__ */ createBaseVNode("div", { class: "tw-w-80 tw-h-20 tw-p-2 tw-bg-white tw-border tw-rounded tw-border-[#D9D9D9] tw-shadow-2xl" }, [
  /* @__PURE__ */ createBaseVNode("p", { class: "tw-text-sm tw-text-center" }, [
    /* @__PURE__ */ createTextVNode(" Value = Market Sensing - Internal Prediction"),
    /* @__PURE__ */ createBaseVNode("br"),
    /* @__PURE__ */ createTextVNode("- = Internal higher than Market"),
    /* @__PURE__ */ createBaseVNode("br"),
    /* @__PURE__ */ createTextVNode("+ = Market Higher than Internal ")
  ])
], -1);
const _hoisted_11$6 = /* @__PURE__ */ createBaseVNode("span", { class: "tw-flex tw-items-center" }, "Abs value scale:", -1);
const _hoisted_12$4 = { class: "tw-w-8/12 tw-pb-2 tw-pl-3" };
const _hoisted_13$3 = ["src"];
function _sfc_render$9(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_VueDatePicker = resolveComponent("VueDatePicker");
  return openBlock(), createElementBlock("div", _hoisted_1$8, [
    createBaseVNode("div", _hoisted_2$7, [
      _hoisted_3$7,
      createVNode(_component_VueDatePicker, {
        id: "date-picker",
        modelValue: $data.filters.refreshDates.selected,
        "onUpdate:modelValue": [
          _cache[0] || (_cache[0] = ($event) => $data.filters.refreshDates.selected = $event),
          $options.refreshDateUpdated
        ],
        "month-picker": "",
        format: $options.formatDatePickerValue,
        "min-date": $options.getMinDate(),
        "max-date": $options.getMaxDate(),
        clearable: false,
        disabled: $props.isDataLoading || $data.filters.refreshDates.selected === null,
        "auto-apply": "",
        "menu-class-name": "dp-custom-menu"
      }, {
        "dp-input": withCtx(({ value }) => [
          createBaseVNode("div", {
            class: normalizeClass(`tw-flex tw-items-center tw-justify-between tw-py-2 tw-px-3 tw-bg-brand-gray-1
            ${$props.isDataLoading ? "tw-opacity-40" : "tw-cursor-pointer"}`)
          }, [
            createBaseVNode("span", _hoisted_4$7, toDisplayString(value), 1),
            createVNode(VIcon, {
              icon: "mdi-calendar-month",
              class: "tw-text-brand-primary",
              size: 32
            })
          ], 2)
        ]),
        _: 1
      }, 8, ["modelValue", "onUpdate:modelValue", "format", "min-date", "max-date", "disabled"])
    ]),
    createBaseVNode("div", _hoisted_5$7, [
      createBaseVNode("span", {
        class: normalizeClass(`tw-pt-10 desktop:tw-text-sm ${$data.filters.valueOrQuantity === $data.BY_VALUE ? "tw-font-medium" : ""}`)
      }, " Value (" + toDisplayString($data.currency) + ") ", 3),
      createBaseVNode("div", _hoisted_6$7, [
        createVNode(VSwitch, {
          "model-value": $data.filters.valueOrQuantity === $data.BY_QUANTITY,
          inset: "",
          density: "compact",
          onClick: $options.valueOrQuantityUpdate,
          disabled: $props.isDataLoading
        }, null, 8, ["model-value", "onClick", "disabled"])
      ]),
      createBaseVNode("span", {
        class: normalizeClass(`tw-pt-10 desktop:tw-text-sm ${$data.filters.valueOrQuantity === $data.BY_QUANTITY ? "tw-font-medium" : ""}`)
      }, " Volume ", 2)
    ]),
    createBaseVNode("div", _hoisted_7$7, [
      createBaseVNode("div", _hoisted_8$7, [
        createVNode(VMenu, {
          "open-on-hover": "",
          location: "top"
        }, {
          activator: withCtx(({ props }) => [
            createBaseVNode("img", mergeProps(props, {
              src: $data.InfoIcon,
              class: "tw-h-6 tw-m-2"
            }), null, 16, _hoisted_9$7)
          ]),
          default: withCtx(() => [
            _hoisted_10$6
          ]),
          _: 1
        }),
        _hoisted_11$6
      ]),
      createBaseVNode("div", _hoisted_12$4, [
        createBaseVNode("img", {
          src: $data.HeatMapScaleIcon,
          class: "tw-h-full"
        }, null, 8, _hoisted_13$3)
      ])
    ])
  ]);
}
const FiltersSection$1 = /* @__PURE__ */ _export_sfc(_sfc_main$9, [["render", _sfc_render$9]]);
const VALUE = "Value (USD)";
const VOLUME = "Volume";
const NAME = "Name";
function getPeriodLabel(dateString, lag) {
  const parsedDateObj = new Date(parse(dateString, "yyyy-MM-dd", new Date()));
  const monthIndex = getMonth(parsedDateObj);
  const year = getYear(parsedDateObj);
  const periodStartDate = format(
    add(new Date(year, monthIndex), { months: lag }),
    "MMM \u2018yy"
  );
  const periodEndDate = format(
    add(new Date(year, monthIndex), { months: lag + 2 }),
    "MMM \u2018yy"
  );
  return `${periodStartDate} - ${periodEndDate}`;
}
function getCustomerName(customer, valueORvolume) {
  if (customer === "*") {
    if (valueORvolume === BY_VALUE$1)
      return VALUE;
    if (valueORvolume === BY_QUANTITY$1)
      return VOLUME;
  }
  return customer;
}
async function fetchHeatMapData({
  marketSensingRefreshDate,
  valueORvolume,
  customers,
  categories,
  lag
}) {
  const data = await apiBase("heatmapdashboard", {
    marketSensingRefreshDate,
    valueORvolume,
    customers: _.join(customers, ","),
    categories: _.join(categories, ","),
    lag
  });
  const varianceArr = _.get(data, "variance");
  const columnHeaders = _.concat(NAME, _.get(data, "categories"));
  const records = _.map(_.get(data, "customers"), (customer, index2) => {
    const customerName = getCustomerName(customer, valueORvolume);
    const rowData = _.map(varianceArr, (el2) => {
      return el2[index2];
    });
    return _.concat(customerName, rowData);
  });
  const dataForUi = {
    period: getPeriodLabel(marketSensingRefreshDate, lag),
    columnHeaders,
    records
  };
  return dataForUi;
}
const GoogleChart = defineComponent$1({
  name: "GoogleChart",
  props: {
    data: {
      type: Array,
      required: true
    },
    options: Object,
    type: String
  },
  components: {
    GChart
  },
  setup(props) {
    return () => h(GChart, {
      data: props.data,
      options: props.options,
      type: props.type
    });
  }
});
const getNumericValue = (value) => {
  if (value === null || _.isNaN(_.toNumber(value))) {
    return 0;
  }
  return _.toNumber(value);
};
const getCustomerValueForApi = (customer) => {
  if (customer === VALUE || customer === VOLUME) {
    return "*";
  }
  return customer;
};
async function fetchDemandForecastData({
  marketSensingRefreshDate,
  valueORvolume,
  category,
  customer,
  lag
}) {
  const data = await apiBase("heat_map_historical", {
    marketSensingRefreshDate,
    valueORvolume,
    category,
    customer: getCustomerValueForApi(customer),
    lag
  });
  const dataKeys2 = _.keys(data);
  let dataForUi = _.map(dataKeys2, (key) => {
    const values = _.get(data, `${key}`);
    const marketSensingForecast = getNumericValue(
      _.get(values, "msForecastGrwoth")
    );
    const internalForecast = getNumericValue(
      _.get(values, "internalForecastGrowth")
    );
    const sales = getNumericValue(_.get(values, "actualGrowth"));
    return {
      period: key,
      marketSensingForecast,
      internalForecast,
      sales
    };
  });
  return dataForUi;
}
const DATA_CONFIG = [
  {
    key: "period",
    label: "Time Period",
    color: ""
  },
  {
    key: "marketSensingForecast",
    label: "Market Sensing Forecast",
    color: "#570EAA",
    legendStyle: "solid"
  },
  {
    key: "internalForecast",
    label: "Internal Forecast",
    color: "#8C8C8C",
    legendStyle: "dashed"
  },
  {
    key: "sales",
    label: "Sales",
    color: "#B991EB",
    legendStyle: "solid"
  }
];
const dataKeys = _.map(DATA_CONFIG, (el2) => el2.key);
const _sfc_main$8 = {
  name: "TooltipChart",
  props: {
    marketSensingRefreshDate: { type: String, required: true },
    valueORvolume: { type: String, required: true },
    category: { type: String, required: true },
    customer: { type: String, required: true },
    lag: { type: Number, required: true }
  },
  components: {
    GoogleChart
  },
  data() {
    return {
      apiData: [],
      isLoading: true,
      error: null,
      legendData: DATA_CONFIG.slice(1)
    };
  },
  async created() {
    this.isLoading = true;
    try {
      this.apiData = await fetchDemandForecastData({
        marketSensingRefreshDate: this.marketSensingRefreshDate,
        valueORvolume: this.valueORvolume,
        category: this.category,
        customer: this.customer,
        lag: this.lag
      });
    } catch (e3) {
      this.error = e3;
      this.closeMenu();
    }
    this.isLoading = false;
  },
  emits: ["closeEvent"],
  methods: {
    closeMenu() {
      this.$emit("closeEvent");
    }
  },
  computed: {
    chartColumns() {
      const columns = [];
      _.forEach(dataKeys, (key, i2) => {
        columns.push(key);
        if (i2 > 0)
          columns.push({ role: "annotation" });
      });
      return columns;
    },
    chartData() {
      return [
        [...this.chartColumns],
        ..._.map(this.apiData, (v) => {
          return _.map(this.chartColumns, (column, i2) => {
            let key = column;
            if (_.get(key, "role") === "annotation") {
              key = this.chartColumns[i2 - 1];
              return v[key] === null || v[key] === void 0 ? "NA" : `${_.round(_.toNumber(v[key]), 0)}%`;
            }
            return v[key] === null || v[key] === void 0 ? 0 : v[key];
          });
        })
      ];
    },
    chartOptions() {
      return {
        title: "",
        curveType: "none",
        legend: { position: "none" },
        width: 850,
        height: 350,
        annotations: {
          textStyle: {
            color: "#000000",
            fontSize: 12
          },
          datum: { stem: { length: 4 } }
        },
        hAxis: {
          textStyle: {
            color: "#323232",
            fontName: "Graphik",
            fontSize: 12
          }
        },
        vAxis: {
          gridlines: {
            count: 0
          },
          textPosition: "none"
        },
        chartArea: {
          top: "4%",
          width: "90%",
          height: "84%"
        },
        series: {
          0: {
            color: DATA_CONFIG[1].color,
            annotations: {
              stem: {
                color: DATA_CONFIG[1].color
              }
            }
          },
          1: {
            color: DATA_CONFIG[2].color,
            lineDashStyle: [6, 6],
            annotations: {
              stem: {
                color: DATA_CONFIG[2].color
              }
            }
          },
          2: {
            color: DATA_CONFIG[3].color,
            annotations: {
              stem: {
                color: DATA_CONFIG[3].color
              }
            }
          }
        }
      };
    }
  }
};
const _hoisted_1$7 = { class: "tw-w-full tw-h-full tw-p-3 tw-bg-white tw-border-2 tw-rounded tw-border-[#D9D9D9] tw-shadow-2xl tw-z-10" };
const _hoisted_2$6 = {
  key: 0,
  class: "tw-w-60 tw-h-60 tw-flex tw-justify-center tw-items-center"
};
const _hoisted_3$6 = { key: 1 };
const _hoisted_4$6 = { class: "tw-flex tw-items-center tw-w-full" };
const _hoisted_5$6 = { class: "tw-text-xl tw-font-medium" };
const _hoisted_6$6 = { class: "tw-flex tw-items-center tw-ml-auto" };
const _hoisted_7$6 = /* @__PURE__ */ createBaseVNode("div", { class: "tw-w-full tw-border tw-border-solid tw-border-brand-gray-2" }, null, -1);
const _hoisted_8$6 = { class: "tw-flex tw-items-center tw-pt-3 tw-px-4" };
const _hoisted_9$6 = { class: "tw-text-xs tw-text-black" };
const _hoisted_10$5 = { class: "tw-w-full tw-flex tw-justify-center tw-pt-4" };
const _hoisted_11$5 = { key: 2 };
function _sfc_render$8(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_GoogleChart = resolveComponent("GoogleChart");
  return openBlock(), createElementBlock("div", _hoisted_1$7, [
    $data.isLoading ? (openBlock(), createElementBlock("div", _hoisted_2$6, [
      createVNode(VProgressCircular, {
        indeterminate: "",
        color: "#7823DC",
        size: 60,
        width: 10
      })
    ])) : createCommentVNode("", true),
    !$data.isLoading && $data.apiData.length > 0 ? (openBlock(), createElementBlock("div", _hoisted_3$6, [
      createBaseVNode("div", _hoisted_4$6, [
        createBaseVNode("h1", _hoisted_5$6, " Demand Forecast : " + toDisplayString($props.category) + " / " + toDisplayString($props.customer), 1),
        createBaseVNode("div", _hoisted_6$6, [
          createVNode(VBtn, {
            variant: "plain",
            icon: "mdi-close",
            onClick: $options.closeMenu
          }, null, 8, ["onClick"])
        ])
      ]),
      _hoisted_7$6,
      createBaseVNode("div", _hoisted_8$6, [
        (openBlock(true), createElementBlock(Fragment, null, renderList($data.legendData, (item) => {
          return openBlock(), createElementBlock("div", {
            key: item.key,
            class: "tw-flex tw-items-center tw-gap-x-1 tw-pl-3"
          }, [
            createBaseVNode("span", {
              style: normalizeStyle(`width: 24px; border: 2px ${item.legendStyle} ${item.color}`)
            }, null, 4),
            createBaseVNode("span", _hoisted_9$6, toDisplayString(item.label), 1)
          ]);
        }), 128))
      ]),
      createBaseVNode("div", _hoisted_10$5, [
        createVNode(_component_GoogleChart, {
          type: "LineChart",
          options: $options.chartOptions,
          data: $options.chartData
        }, null, 8, ["options", "data"])
      ])
    ])) : createCommentVNode("", true),
    !$data.isLoading && $data.error ? (openBlock(), createElementBlock("div", _hoisted_11$5, [
      createVNode(VAlert, {
        type: "error",
        text: $data.error.toString()
      }, null, 8, ["text"])
    ])) : createCommentVNode("", true)
  ]);
}
const TooltipChart = /* @__PURE__ */ _export_sfc(_sfc_main$8, [["render", _sfc_render$8]]);
const _sfc_main$7 = {
  name: "CardsListItem",
  props: {
    data: {
      type: Object,
      required: true
    },
    selectedFilters: {
      type: Object,
      required: true
    },
    lag: {
      type: Number,
      required: true
    }
  },
  components: {
    TooltipChart
  },
  data() {
    return {
      lodGet: _.get,
      lodSize: _.size,
      menu: {}
    };
  },
  computed: {
    marketSensingRefreshDate() {
      return _.get(this.selectedFilters, "marketSensingRefreshDate");
    },
    valueORvolume() {
      return _.get(this.selectedFilters, "valueORvolume");
    },
    formattedHorizon() {
      return `${this.lag}-${this.lag + 2}`;
    }
  },
  methods: {
    getCellStyling(cellValue, isRowLabel = false) {
      let styles = "tw-py-3 desktop:tw-py-2 small-laptop:tw-py-2 tw-font-medium";
      if (isRowLabel) {
        styles += " tw-text-sm desktop:tw-text-xxs small-laptop:tw-text-xxs tw-text-left tw-whitespace-nowrap tw-text-ellipsis tw-overflow-hidden tw-cursor-default";
        return styles;
      } else {
        styles += " tw-text-center tw-rounded tw-shadow tw-cursor-pointer";
      }
      if (cellValue === null || _.isNaN(_.toNumber(cellValue))) {
        styles += " tw-bg-brand-gray-2";
        return styles;
      }
      const val = _.round(_.toNumber(cellValue), 0);
      if (Math.abs(val) >= 20)
        styles += " tw-bg-brand-red-2";
      else if (Math.abs(val) >= 6)
        styles += " tw-bg-brand-yellow-2";
      else
        styles += " tw-bg-brand-green-2";
      return styles;
    },
    getCellLabel(cellValue, isPercentValue = true) {
      if (cellValue === null || _.isNaN(_.toNumber(cellValue)))
        return "NA";
      const val = _.round(_.toNumber(cellValue), 0);
      return `${val}${isPercentValue ? "%" : ""}`;
    },
    closeMenu(key) {
      this.menu[key] = false;
    },
    handleCellClick(key, isClickDisabled = false) {
      if (isClickDisabled)
        return;
      this.menu[key] = true;
    }
  }
};
const _hoisted_1$6 = { class: "tw-flex tw-flex-col tw-gap-3 tw-w-full tw-h-full tw-bg-white tw-p-4 desktop:tw-p-2 small-laptop:tw-p-2" };
const _hoisted_2$5 = { class: "tw-flex tw-gap-x-4 tw-items-center tw-w-full" };
const _hoisted_3$5 = { class: "tw-text-xl desktop:tw-text-base small-laptop:tw-text-base tw-font-medium" };
const _hoisted_4$5 = { class: "tw-bg-brand-gray-4 tw-rounded tw-text-center" };
const _hoisted_5$5 = { class: "tw-p-1 tw-text-sm desktop:tw-text-xs small-laptop:tw-text-xs" };
const _hoisted_6$5 = /* @__PURE__ */ createBaseVNode("div", { class: "tw-w-full tw-border tw-border-solid tw-border-brand-gray-2" }, null, -1);
const _hoisted_7$5 = { class: "tw-w-full tw-h-full tw-overflow-auto" };
const _hoisted_8$5 = { key: 0 };
const _hoisted_9$5 = { class: "tw-w-auto tw-h-auto tw-flex tw-items-center tw-p-1 tw-text-sm desktop:tw-text-xs small-laptop:tw-text-xs tw-bg-white tw-border tw-rounded tw-border-[#D9D9D9] tw-shadow-xl" };
const _hoisted_10$4 = ["onClick"];
const _hoisted_11$4 = {
  key: 0,
  class: "desktop:tw-text-xs small-laptop:tw-text-xs"
};
const _hoisted_12$3 = { class: "tw-w-auto tw-h-auto tw-flex tw-items-center tw-p-1 tw-text-sm desktop:tw-text-xs small-laptop:tw-text-xs tw-bg-white tw-border tw-rounded tw-border-[#D9D9D9] tw-shadow-xl" };
function _sfc_render$7(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_TooltipChart = resolveComponent("TooltipChart");
  return openBlock(), createElementBlock("div", _hoisted_1$6, [
    createBaseVNode("div", _hoisted_2$5, [
      createBaseVNode("p", _hoisted_3$5, toDisplayString($props.data.period), 1),
      createBaseVNode("div", _hoisted_4$5, [
        createBaseVNode("p", _hoisted_5$5, "Future " + toDisplayString($options.formattedHorizon) + " months", 1)
      ])
    ]),
    _hoisted_6$5,
    createBaseVNode("div", _hoisted_7$5, [
      createBaseVNode("div", {
        class: normalizeClass(`tw-grid tw-grid-cols-${$data.lodSize(
          $data.lodGet($props.data, "columnHeaders", [])
        )} tw-grid-flow-col tw-gap-x-3 tw-pb-4`)
      }, [
        (openBlock(true), createElementBlock(Fragment, null, renderList($props.data.columnHeaders, (columnHeader, index2) => {
          return openBlock(), createElementBlock("span", {
            key: columnHeader,
            class: normalizeClass(`tw-font-medium tw-text-sm desktop:tw-text-xs small-laptop:tw-text-xs tw-cursor-default ${index2 > 0 ? "tw-text-center" : "tw-text-left"}`)
          }, [
            index2 === 0 ? (openBlock(), createElementBlock("span", _hoisted_8$5, toDisplayString(columnHeader), 1)) : createCommentVNode("", true),
            index2 > 0 ? (openBlock(), createBlock(VMenu, {
              key: 1,
              "open-on-hover": "",
              location: "top"
            }, {
              activator: withCtx(({ props }) => [
                createBaseVNode("span", normalizeProps(guardReactiveProps(props)), toDisplayString(columnHeader), 17)
              ]),
              default: withCtx(() => [
                createBaseVNode("div", _hoisted_9$5, toDisplayString(columnHeader), 1)
              ]),
              _: 2
            }, 1024)) : createCommentVNode("", true)
          ], 2);
        }), 128))
      ], 2),
      createBaseVNode("div", {
        class: normalizeClass(`tw-grid tw-grid-rows-${$data.lodSize(
          $data.lodGet($props.data, "records", [])
        )} tw-grid-flow-row tw-gap-y-3`)
      }, [
        (openBlock(true), createElementBlock(Fragment, null, renderList($props.data.records, (rowData) => {
          return openBlock(), createElementBlock("div", {
            key: rowData[0],
            class: normalizeClass(`tw-grid tw-grid-cols-${$data.lodSize(
              rowData != null ? rowData : []
            )} tw-grid-flow-col tw-gap-x-3 tw-items-center`)
          }, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(rowData, (cellValue, index2) => {
              return openBlock(), createElementBlock("div", {
                key: `${rowData[0]}-${cellValue}`
              }, [
                createVNode(VMenu, {
                  location: "right",
                  "close-on-content-click": false,
                  modelValue: $data.menu[`${rowData[0]}${index2}`],
                  "onUpdate:modelValue": ($event) => $data.menu[`${rowData[0]}${index2}`] = $event
                }, {
                  activator: withCtx(({ props }) => [
                    createBaseVNode("div", mergeProps(index2 > 0 && props, {
                      onClick: ($event) => $options.handleCellClick(`${rowData[0]}${index2}`, index2 === 0),
                      class: $options.getCellStyling(cellValue, index2 === 0)
                    }), [
                      index2 > 0 ? (openBlock(), createElementBlock("span", _hoisted_11$4, toDisplayString($options.getCellLabel(cellValue)), 1)) : createCommentVNode("", true),
                      index2 === 0 ? (openBlock(), createBlock(VMenu, {
                        key: 1,
                        "open-on-hover": "",
                        location: "top"
                      }, {
                        activator: withCtx(({ props: props2 }) => [
                          createBaseVNode("span", mergeProps(props2, { class: "desktop:tw-text-xs small-laptop:tw-text-xs" }), toDisplayString(cellValue), 17)
                        ]),
                        default: withCtx(() => [
                          createBaseVNode("div", _hoisted_12$3, toDisplayString(cellValue), 1)
                        ]),
                        _: 2
                      }, 1024)) : createCommentVNode("", true)
                    ], 16, _hoisted_10$4)
                  ]),
                  default: withCtx(() => [
                    createVNode(_component_TooltipChart, {
                      marketSensingRefreshDate: $options.marketSensingRefreshDate,
                      valueORvolume: $options.valueORvolume,
                      category: $props.data.columnHeaders[index2],
                      customer: rowData[0],
                      lag: $props.lag,
                      onCloseEvent: ($event) => $options.closeMenu(`${rowData[0]}${index2}`)
                    }, null, 8, ["marketSensingRefreshDate", "valueORvolume", "category", "customer", "lag", "onCloseEvent"])
                  ]),
                  _: 2
                }, 1032, ["modelValue", "onUpdate:modelValue"])
              ]);
            }), 128))
          ], 2);
        }), 128))
      ], 2)
    ])
  ]);
}
const CardsListItem = /* @__PURE__ */ _export_sfc(_sfc_main$7, [["render", _sfc_render$7]]);
const _sfc_main$6 = {
  name: "CardsList",
  components: {
    CardsListItem
  },
  props: {
    data: {
      type: Array,
      required: true
    },
    selectedFilters: {
      type: Object,
      required: true
    }
  },
  data() {
    return {
      LAG_VALUES
    };
  }
};
const _hoisted_1$5 = { class: "tw-grid tw-grid-cols-2 tw-gap-5 tw-w-full tw-h-full" };
function _sfc_render$6(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_CardsListItem = resolveComponent("CardsListItem");
  return openBlock(), createElementBlock("div", _hoisted_1$5, [
    (openBlock(true), createElementBlock(Fragment, null, renderList($props.data, (cardData, index2) => {
      return openBlock(), createElementBlock("div", {
        key: cardData.period
      }, [
        createVNode(_component_CardsListItem, {
          data: cardData,
          selectedFilters: $props.selectedFilters,
          lag: $data.LAG_VALUES[index2]
        }, null, 8, ["data", "selectedFilters", "lag"])
      ]);
    }), 128))
  ]);
}
const CardsList = /* @__PURE__ */ _export_sfc(_sfc_main$6, [["render", _sfc_render$6]]);
const LAG_VALUES = [1, 4, 7, 10];
const FILTER_UPDATE_GAP_MS$1 = 3e3;
const FILTER_INSTANT_UPDATE_GAP_MS = 500;
const _sfc_main$5 = {
  name: "HeatMap",
  components: {
    FiltersSection: FiltersSection$1,
    CardsList
  },
  data() {
    return {
      apiData: [],
      isFetchingData: true,
      error: null,
      selectedFilters: {
        marketSensingRefreshDate: null,
        valueORvolume: null
      },
      debounceUpdateFilters: _.debounce(
        this.updateFilters,
        FILTER_UPDATE_GAP_MS$1
      ),
      debounceUpdateFiltersInstant: _.debounce(
        this.updateFilters,
        FILTER_INSTANT_UPDATE_GAP_MS
      ),
      latestRefreshDate: null
    };
  },
  methods: {
    latestRefreshDateUpdateHandler(dateObj) {
      this.latestRefreshDate = format(dateObj, "MMM dd, yyyy");
    },
    async fetchDashboardData(metaData) {
      this.isFetchingData = true;
      this.error = null;
      try {
        this.apiData = await Promise.all(
          _.map(LAG_VALUES, (lag) => {
            return fetchHeatMapData({
              ...metaData,
              marketSensingRefreshDate: this.selectedFilters.marketSensingRefreshDate,
              valueORvolume: this.selectedFilters.valueORvolume,
              lag
            });
          })
        );
        if (_.isEmpty(this.apiData)) {
          this.error = "Error: Unable to fetch data";
        }
      } catch (e3) {
        this.error = e3;
      }
      this.isFetchingData = false;
    },
    async updateFilters(filtersData, metaData) {
      const selectedMarketSensingRefreshDate = _.get(
        filtersData,
        "refreshDates.selected"
      );
      const selectedValueORvolume = _.get(filtersData, "valueOrQuantity");
      try {
        if (selectedMarketSensingRefreshDate === null) {
          throw new Error("Market Sensing Refresh Date is not available.");
        }
        const marketSensingRefreshDateP = parse(
          `${selectedMarketSensingRefreshDate.year}-${selectedMarketSensingRefreshDate.month + 1}`,
          "yyyy-M",
          new Date()
        );
        const marketSensingRefreshDate = format(
          marketSensingRefreshDateP,
          "yyyy-MM-dd"
        );
        this.selectedFilters = {
          marketSensingRefreshDate,
          valueORvolume: selectedValueORvolume
        };
        this.fetchDashboardData(metaData);
      } catch (e3) {
        this.error = e3;
        this.isFetchingData = false;
      }
    }
  }
};
const _hoisted_1$4 = { class: "tw-h-full tw-w-full tw-pb-10 tw-bg-brand-gray-1" };
const _hoisted_2$4 = { class: "tw-flex tw-w-full tw-h-8 tw-bg-brand-gray-1" };
const _hoisted_3$4 = /* @__PURE__ */ createBaseVNode("div", { class: "tw-flex tw-h-full tw-items-center" }, [
  /* @__PURE__ */ createBaseVNode("h1", { class: "tw-text-lg" }, [
    /* @__PURE__ */ createBaseVNode("span", { class: "tw-font-bold" }, "Heat-map View -"),
    /* @__PURE__ */ createTextVNode(" Representation of variance across categories and stores ")
  ])
], -1);
const _hoisted_4$4 = {
  key: 0,
  class: "tw-ml-auto tw-h-full tw-flex tw-items-center"
};
const _hoisted_5$4 = /* @__PURE__ */ createBaseVNode("div", { class: "tw-flex tw-w-full tw-flex-auto tw-border-t tw-border-solid tw-border-brand-gray-2" }, null, -1);
const _hoisted_6$4 = { class: "tw-py-5" };
const _hoisted_7$4 = {
  key: 0,
  class: "tw-w-full tw-h-3/4 tw-flex tw-justify-center tw-items-center"
};
const _hoisted_8$4 = { key: 1 };
const _hoisted_9$4 = { key: 2 };
function _sfc_render$5(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_FiltersSection = resolveComponent("FiltersSection");
  const _component_CardsList = resolveComponent("CardsList");
  return openBlock(), createElementBlock("div", _hoisted_1$4, [
    createBaseVNode("div", _hoisted_2$4, [
      _hoisted_3$4,
      $data.latestRefreshDate ? (openBlock(), createElementBlock("div", _hoisted_4$4, " Last refreshed on " + toDisplayString($data.latestRefreshDate), 1)) : createCommentVNode("", true)
    ]),
    _hoisted_5$4,
    createBaseVNode("div", _hoisted_6$4, [
      createVNode(_component_FiltersSection, {
        onUpdateFilters: $data.debounceUpdateFilters,
        onUpdateFiltersInstant: $data.debounceUpdateFiltersInstant,
        onLatestRefreshDateUpdate: $options.latestRefreshDateUpdateHandler,
        isDataLoading: $data.isFetchingData
      }, null, 8, ["onUpdateFilters", "onUpdateFiltersInstant", "onLatestRefreshDateUpdate", "isDataLoading"])
    ]),
    $data.isFetchingData ? (openBlock(), createElementBlock("div", _hoisted_7$4, [
      createVNode(VProgressCircular, {
        indeterminate: "",
        color: "#7823DC",
        size: 80,
        width: 10
      })
    ])) : createCommentVNode("", true),
    !$data.isFetchingData && !$data.error ? (openBlock(), createElementBlock("div", _hoisted_8$4, [
      createVNode(_component_CardsList, {
        data: $data.apiData,
        selectedFilters: $data.selectedFilters
      }, null, 8, ["data", "selectedFilters"])
    ])) : createCommentVNode("", true),
    !$data.isFetchingData && $data.error ? (openBlock(), createElementBlock("div", _hoisted_9$4, [
      createVNode(VAlert, {
        type: "error",
        text: $data.error.toString()
      }, null, 8, ["text"])
    ])) : createCommentVNode("", true)
  ]);
}
const HeatMap = /* @__PURE__ */ _export_sfc(_sfc_main$5, [["render", _sfc_render$5]]);
const BY_VALUE = "BY_VALUE";
const BY_QUANTITY = "BY_QUANTITY";
const ALL_OPTION$1 = "All";
const _sfc_main$4 = {
  name: "FiltersSection",
  props: {
    filtersDisabled: { type: Boolean, default: false }
  },
  data() {
    return {
      filters: {
        categories: {
          items: [],
          selected: null,
          filterlabel: "Categories"
        },
        customers: {
          items: [],
          selected: null,
          filterlabel: "Customers"
        },
        time_horizon: {
          items: [],
          selected: null,
          filterlabel: "Time Horizon"
        },
        internal_model: {
          items: [],
          selected: null,
          filterlabel: "Internal Model"
        },
        refreshDate: null,
        valueOrQuantity: BY_QUANTITY
      },
      currency: "USD",
      BY_VALUE,
      BY_QUANTITY,
      ALL_OPTION: ALL_OPTION$1
    };
  },
  async created() {
    const options = await fetchDashboardOptions().catch(() => null);
    if (options) {
      this.filters.categories.items = options.ms.categories;
      this.filters.customers.items = options.ms.customers;
      this.filters.customers.items = _.concat(
        ALL_OPTION$1,
        this.filters.customers.items
      );
      this.filters.time_horizon.items = options.ms.msTimeHorizon;
      this.filters.internal_model.items = options.clientData.models;
    }
    this.filters.refreshDate = options.updateDates[0];
    this.selectFilterUpdated("categories", this.filters.categories.items[0]);
    this.selectFilterUpdated(
      "time_horizon",
      this.filters.time_horizon.items[0]
    );
    this.selectFilterUpdated(
      "internal_model",
      this.filters.internal_model.items[0]
    );
    this.selectFilterUpdated("customers", this.filters.customers.items[0]);
  },
  emits: ["updateFilters"],
  methods: {
    selectFilterUpdated(filterName, currentSelection) {
      this.filters[filterName].selected = currentSelection;
      this.filtersUpdated();
    },
    valueOrQuantityUpdate() {
      this.filters.valueOrQuantity = this.filters.valueOrQuantity === BY_VALUE ? BY_QUANTITY : BY_VALUE;
      this.filtersUpdated();
    },
    filtersUpdated() {
      this.$emit("updateFilters", this.filters);
    }
  }
};
const _hoisted_1$3 = { class: "tw-flex tw-gap-x-3 tw-w-full tw-bg-white tw-px-3" };
const _hoisted_2$3 = { class: "tw-pt-3 tw-min-w-[14%] tw--mb-3" };
const _hoisted_3$3 = /* @__PURE__ */ createBaseVNode("label", {
  for: "category",
  class: "tw-text-sm"
}, "Category", -1);
const _hoisted_4$3 = { class: "tw-pt-3 tw-min-w-[14%] tw--mb-3" };
const _hoisted_5$3 = /* @__PURE__ */ createBaseVNode("label", {
  for: "customer",
  class: "tw-text-sm"
}, "Customer(s)", -1);
const _hoisted_6$3 = { class: "tw-pt-3 tw-min-w-[14%] tw--mb-3" };
const _hoisted_7$3 = /* @__PURE__ */ createBaseVNode("label", {
  for: "mstimehorizon",
  class: "tw-text-sm"
}, "MS Time Horizon", -1);
const _hoisted_8$3 = { class: "tw-pt-3 tw-min-w-[14%] tw--mb-3" };
const _hoisted_9$3 = /* @__PURE__ */ createBaseVNode("label", {
  for: "model",
  class: "tw-text-sm"
}, "Model", -1);
const _hoisted_10$3 = { class: "tw-flex tw-gap-1.5 tw-pt-3 tw-pl-3 tw--mb-3" };
const _hoisted_11$3 = { class: "tw-flex tw-pt-8 tw-text-brand-primary" };
function _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$3, [
    createBaseVNode("div", _hoisted_2$3, [
      _hoisted_3$3,
      createVNode(VSelect, {
        disabled: $props.filtersDisabled,
        items: $data.filters.categories.items,
        "model-value": $data.filters.categories.selected,
        "onUpdate:modelValue": _cache[0] || (_cache[0] = (value) => $options.selectFilterUpdated("categories", value)),
        density: "comfortable"
      }, null, 8, ["disabled", "items", "model-value"])
    ]),
    createBaseVNode("div", _hoisted_4$3, [
      _hoisted_5$3,
      createVNode(VSelect, {
        disabled: $props.filtersDisabled,
        items: $data.filters.customers.items,
        "model-value": $data.filters.customers.selected,
        "onUpdate:modelValue": _cache[1] || (_cache[1] = (value) => $options.selectFilterUpdated("customers", value)),
        density: "comfortable"
      }, null, 8, ["disabled", "items", "model-value"])
    ]),
    createBaseVNode("div", _hoisted_6$3, [
      _hoisted_7$3,
      createVNode(VSelect, {
        disabled: $props.filtersDisabled,
        items: $data.filters.time_horizon.items,
        "model-value": $data.filters.time_horizon.selected,
        "onUpdate:modelValue": _cache[2] || (_cache[2] = (value) => $options.selectFilterUpdated("time_horizon", value)),
        density: "comfortable"
      }, null, 8, ["disabled", "items", "model-value"])
    ]),
    createBaseVNode("div", _hoisted_8$3, [
      _hoisted_9$3,
      createVNode(VSelect, {
        disabled: $props.filtersDisabled,
        items: $data.filters.internal_model.items,
        "model-value": $data.filters.internal_model.selected,
        "onUpdate:modelValue": _cache[3] || (_cache[3] = (value) => $options.selectFilterUpdated("internal_model", value)),
        density: "comfortable"
      }, null, 8, ["disabled", "items", "model-value"])
    ]),
    createBaseVNode("div", _hoisted_10$3, [
      createBaseVNode("span", {
        class: normalizeClass(`tw-pt-10 ${$data.filters.valueOrQuantity === $data.BY_VALUE ? "tw-font-medium" : ""}`)
      }, " Value (" + toDisplayString($data.currency) + ") ", 3),
      createBaseVNode("div", _hoisted_11$3, [
        createVNode(VSwitch, {
          "model-value": $data.filters.valueOrQuantity === $data.BY_QUANTITY,
          inset: "",
          density: "compact",
          onClick: $options.valueOrQuantityUpdate,
          disabled: $props.filtersDisabled
        }, null, 8, ["model-value", "onClick", "disabled"])
      ]),
      createBaseVNode("span", {
        class: normalizeClass(`tw-pt-10 ${$data.filters.valueOrQuantity === $data.BY_QUANTITY ? "tw-font-medium" : ""}`)
      }, " Volume ", 2)
    ])
  ]);
}
const FiltersSection = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["render", _sfc_render$4]]);
async function fetchInternalChartsData({ categories, customers, valueORvolume, msTimeHorizon, internalModel, refreshDate }) {
  const data = await apiBase("internalcharts", {
    marketSensingRefreshDate: refreshDate,
    categories,
    customers,
    valueORvolume,
    msTimeHorizon,
    internalModel
  });
  let dataForUi = _.get(data, "result.data", {});
  let unit = _.get(data, "result.unit", {});
  dataForUi = _.map(dataForUi, (v, k2) => ({
    ...v,
    timeline: k2,
    actualGrowth: v.actualGrowth == null || v.actualGrowth == "" ? 0 : v.actualGrowth,
    forecastSales: v.forecastSales == null || v.forecastSales == "" ? 0 : v.forecastSales,
    forecastGrowth: v.forecastGrowth == null || v.forecastGrowth == "" ? 0 : v.forecastGrowth,
    msProjectedGrowth: v.msProjectedGrowth == null || v.msProjectedGrowth == "" ? 0 : v.msProjectedGrowth,
    actualSales: v.actualSales == null || v.actualSales == "" ? 0 : v.actualSales,
    unit
  }));
  console.log(dataForUi);
  return dataForUi;
}
const VCard$1 = "";
const VCardActions = defineComponent({
  name: "VCardActions",
  setup(_2, _ref) {
    let {
      slots
    } = _ref;
    provideDefaults({
      VBtn: {
        variant: "text"
      }
    });
    useRender(() => {
      var _slots$default;
      return createVNode("div", {
        "class": "v-card-actions"
      }, [(_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots)]);
    });
    return {};
  }
});
const VCardSubtitle = createSimpleFunctional("v-card-subtitle");
const VCardTitle = createSimpleFunctional("v-card-title");
const VCardItem = defineComponent({
  name: "VCardItem",
  props: {
    appendAvatar: String,
    appendIcon: IconValue,
    prependAvatar: String,
    prependIcon: IconValue,
    subtitle: String,
    title: String,
    ...makeDensityProps()
  },
  setup(props, _ref) {
    let {
      slots
    } = _ref;
    useRender(() => {
      var _slots$prepend, _slots$title, _slots$subtitle, _slots$default, _slots$append;
      const hasPrepend = !!(props.prependAvatar || props.prependIcon || slots.prepend);
      const hasAppend = !!(props.appendAvatar || props.appendIcon || slots.append);
      const hasTitle = !!(props.title || slots.title);
      const hasSubtitle = !!(props.subtitle || slots.subtitle);
      return createVNode("div", {
        "class": "v-card-item"
      }, [hasPrepend && createVNode(VDefaultsProvider, {
        "key": "prepend",
        "defaults": {
          VAvatar: {
            density: props.density,
            icon: props.prependIcon,
            image: props.prependAvatar
          },
          VIcon: {
            density: props.density,
            icon: props.prependIcon
          }
        }
      }, {
        default: () => {
          var _a2;
          return [createVNode("div", {
            "class": "v-card-item__prepend"
          }, [(_a2 = (_slots$prepend = slots.prepend) == null ? void 0 : _slots$prepend.call(slots)) != null ? _a2 : createVNode(VAvatar, null, null)])];
        }
      }), createVNode("div", {
        "class": "v-card-item__content"
      }, [hasTitle && createVNode(VCardTitle, {
        "key": "title"
      }, {
        default: () => {
          var _a2;
          return [(_a2 = (_slots$title = slots.title) == null ? void 0 : _slots$title.call(slots)) != null ? _a2 : props.title];
        }
      }), hasSubtitle && createVNode(VCardSubtitle, {
        "key": "subtitle"
      }, {
        default: () => {
          var _a2;
          return [(_a2 = (_slots$subtitle = slots.subtitle) == null ? void 0 : _slots$subtitle.call(slots)) != null ? _a2 : props.subtitle];
        }
      }), (_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots)]), hasAppend && createVNode(VDefaultsProvider, {
        "key": "append",
        "defaults": {
          VAvatar: {
            density: props.density,
            icon: props.appendIcon,
            image: props.appendAvatar
          },
          VIcon: {
            density: props.density,
            icon: props.appendIcon
          }
        }
      }, {
        default: () => {
          var _a2;
          return [createVNode("div", {
            "class": "v-card-item__append"
          }, [(_a2 = (_slots$append = slots.append) == null ? void 0 : _slots$append.call(slots)) != null ? _a2 : createVNode(VAvatar, null, null)])];
        }
      })]);
    });
    return {};
  }
});
const VCardText = createSimpleFunctional("v-card-text");
const VCard = defineComponent({
  name: "VCard",
  directives: {
    Ripple
  },
  props: {
    appendAvatar: String,
    appendIcon: IconValue,
    disabled: Boolean,
    flat: Boolean,
    hover: Boolean,
    image: String,
    link: {
      type: Boolean,
      default: void 0
    },
    prependAvatar: String,
    prependIcon: IconValue,
    ripple: {
      type: Boolean,
      default: true
    },
    subtitle: String,
    text: String,
    title: String,
    ...makeThemeProps(),
    ...makeBorderProps(),
    ...makeDensityProps(),
    ...makeDimensionProps(),
    ...makeElevationProps(),
    ...makeLoaderProps(),
    ...makeLocationProps(),
    ...makePositionProps(),
    ...makeRoundedProps(),
    ...makeRouterProps(),
    ...makeTagProps(),
    ...makeVariantProps({
      variant: "elevated"
    })
  },
  setup(props, _ref) {
    let {
      attrs,
      slots
    } = _ref;
    const {
      themeClasses
    } = provideTheme(props);
    const {
      borderClasses
    } = useBorder(props);
    const {
      colorClasses,
      colorStyles,
      variantClasses
    } = useVariant(props);
    const {
      densityClasses
    } = useDensity(props);
    const {
      dimensionStyles
    } = useDimension(props);
    const {
      elevationClasses
    } = useElevation(props);
    const {
      loaderClasses
    } = useLoader(props);
    const {
      locationStyles
    } = useLocation(props);
    const {
      positionClasses
    } = usePosition(props);
    const {
      roundedClasses
    } = useRounded(props);
    const link = useLink(props, attrs);
    const isLink = computed(() => props.link !== false && link.isLink.value);
    const isClickable = computed(() => !props.disabled && props.link !== false && (props.link || link.isClickable.value));
    useRender(() => {
      var _slots$image, _slots$text, _slots$default;
      const Tag = isLink.value ? "a" : props.tag;
      const hasTitle = !!(slots.title || props.title);
      const hasSubtitle = !!(slots.subtitle || props.subtitle);
      const hasHeader2 = hasTitle || hasSubtitle;
      const hasAppend = !!(slots.append || props.appendAvatar || props.appendIcon);
      const hasPrepend = !!(slots.prepend || props.prependAvatar || props.prependIcon);
      const hasImage = !!(slots.image || props.image);
      const hasCardItem = hasHeader2 || hasPrepend || hasAppend;
      const hasText = !!(slots.text || props.text);
      return withDirectives(createVNode(Tag, {
        "class": ["v-card", {
          "v-card--disabled": props.disabled,
          "v-card--flat": props.flat,
          "v-card--hover": props.hover && !(props.disabled || props.flat),
          "v-card--link": isClickable.value
        }, themeClasses.value, borderClasses.value, colorClasses.value, densityClasses.value, elevationClasses.value, loaderClasses.value, positionClasses.value, roundedClasses.value, variantClasses.value],
        "style": [colorStyles.value, dimensionStyles.value, locationStyles.value],
        "href": link.href.value,
        "onClick": isClickable.value && link.navigate,
        "tabindex": props.disabled ? -1 : void 0
      }, {
        default: () => [hasImage && createVNode(VDefaultsProvider, {
          "key": "image",
          "defaults": {
            VImg: {
              cover: true,
              src: props.image
            }
          }
        }, {
          default: () => {
            var _a2;
            return [createVNode("div", {
              "class": "v-card__image"
            }, [(_a2 = (_slots$image = slots.image) == null ? void 0 : _slots$image.call(slots)) != null ? _a2 : createVNode(VImg, null, null)])];
          }
        }), createVNode(LoaderSlot, {
          "name": "v-card",
          "active": !!props.loading,
          "color": typeof props.loading === "boolean" ? void 0 : props.loading
        }, {
          default: slots.loader
        }), hasCardItem && createVNode(VCardItem, {
          "key": "item",
          "prependAvatar": props.prependAvatar,
          "prependIcon": props.prependIcon,
          "title": props.title,
          "subtitle": props.subtitle,
          "appendAvatar": props.appendAvatar,
          "appendIcon": props.appendIcon
        }, {
          default: slots.item,
          prepend: slots.prepend,
          title: slots.title,
          subtitle: slots.subtitle,
          append: slots.append
        }), hasText && createVNode(VCardText, {
          "key": "text"
        }, {
          default: () => {
            var _a2;
            return [(_a2 = (_slots$text = slots.text) == null ? void 0 : _slots$text.call(slots)) != null ? _a2 : props.text];
          }
        }), (_slots$default = slots.default) == null ? void 0 : _slots$default.call(slots), slots.actions && createVNode(VCardActions, null, {
          default: slots.actions
        }), genOverlays(isClickable.value, "v-card")]
      }), [[resolveDirective("ripple"), isClickable.value && props.ripple]]);
    });
    return {};
  }
});
const FILTER_UPDATE_GAP_MS = 3500;
const _sfc_main$3 = {
  name: "InternalCharts",
  components: {
    GChart,
    FiltersSection
  },
  data() {
    return {
      isLoading: true,
      refreshDate: null,
      apiData: [],
      columnChartData: [],
      debounceUpdateFilters: _.debounce(
        this.updateFilters,
        FILTER_UPDATE_GAP_MS
      ),
      filtersDisabled: false,
      columnChartOptions: {
        height: 320,
        explorer: {
          axis: "horizontal"
        },
        legend: { position: "none" },
        tooltip: { trigger: "none" },
        colors: ["#787878", "#B991EB"],
        hAxis: {
          textStyle: {
            fontSize: 12
          }
        },
        vAxis: {
          minorGridlines: { color: "none" },
          gridlines: {
            count: 0
          },
          textPosition: "none"
        },
        chartArea: {
          left: "1%",
          width: "100%"
        },
        annotations: {
          textStyle: {
            color: "#000000",
            fontSize: 12
          },
          datum: { stem: { length: 0 } },
          alwaysOutside: true
        }
      },
      lineChartData: [],
      lineChartOptions: {
        curveType: "none",
        explorer: {
          axis: "horizontal"
        },
        tooltip: { trigger: "none" },
        vAxis: {
          minorGridlines: { color: "none" },
          gridlines: {
            count: 0
          },
          textPosition: "none"
        },
        annotations: {
          textStyle: {
            color: "#000000",
            fontSize: 12
          },
          datum: { stem: { length: 0 } },
          alwaysOutside: true
        },
        legend: { position: "top", textStyle: { fontSize: 12 } },
        colors: ["#570EAA", "#787878", "#C8A5F0"],
        height: 370,
        series: {
          1: { lineDashStyle: [4, 4] }
        },
        hAxis: {
          textStyle: {
            fontSize: 12
          }
        },
        chartArea: {
          left: "1%",
          width: "100%"
        }
      }
    };
  },
  methods: {
    async updateFilters(filtersData) {
      try {
        this.columnChartData = [];
        this.lineChartData = [];
        this.isLoading = true;
        this.filtersDisabled = true;
        const selectedCategories = _.get(filtersData, "categories.selected");
        const selectedCustomers = _.get(filtersData, "customers.selected");
        const selectedValueORvolume = _.get(filtersData, "valueOrQuantity");
        const selectedTimeHorizon = _.get(filtersData, "time_horizon.selected");
        const selectedInternalModel = _.get(
          filtersData,
          "internal_model.selected"
        );
        const refreshDate = _.get(filtersData, "refreshDate");
        this.refreshDate = format(
          new Date(_.get(filtersData, "refreshDate")),
          "MMM dd,yyyy"
        );
        const response = await fetchInternalChartsData({
          categories: selectedCategories === ALL_OPTION$1 ? "*" : selectedCategories,
          customers: selectedCustomers === ALL_OPTION$1 ? "*" : selectedCustomers,
          valueORvolume: selectedValueORvolume,
          msTimeHorizon: selectedTimeHorizon,
          internalModel: selectedInternalModel,
          refreshDate
        });
        if (!_.isEmpty(response)) {
          this.apiData = response;
          this.isLoading = false;
          this.filtersDisabled = false;
          let v = this;
          if (!this.columnChartData.length) {
            this.columnChartData.push([
              "period",
              "Internal",
              { role: "annotation" },
              "Actual",
              { role: "annotation" }
            ]);
            _.forEach(this.apiData, function(data) {
              v.columnChartData.push([
                data.timeline,
                data.forecastSales,
                data.forecastSales + data.unit,
                data.actualSales,
                data.actualSales + data.unit
              ]);
            });
          }
          if (!this.lineChartData.length) {
            this.lineChartData.push([
              "period",
              "Market Sensing Forecast",
              { role: "annotation" },
              "Internal Forecast",
              { role: "annotation" },
              "Sales",
              { role: "annotation" }
            ]);
            _.forEach(this.apiData, function(data) {
              v.lineChartData.push([
                data.timeline,
                data.msProjectedGrowth,
                data.msProjectedGrowth + "%",
                data.forecastGrowth,
                data.forecastGrowth + "%",
                data.actualGrowth,
                data.actualGrowth + "%"
              ]);
            });
          }
        }
      } catch (e3) {
        console.log(e3);
        this.isLoading = false;
        alert("There was an error while fetching data");
      }
      this.isLoading = false;
    }
  }
};
const _hoisted_1$2 = { class: "tw-w-full tw-h-full tw-bg-brand-gray-1" };
const _hoisted_2$2 = { class: "tw-flex tw-w-full tw-h-8 tw-bg-brand-gray-1" };
const _hoisted_3$2 = /* @__PURE__ */ createBaseVNode("div", { class: "tw-flex tw-h-full tw-items-center tw-font-bold tw-text-lg" }, " Internal Charts ", -1);
const _hoisted_4$2 = { class: "tw-ml-auto tw-h-full tw-flex tw-items-center" };
const _hoisted_5$2 = /* @__PURE__ */ createBaseVNode("div", { class: "tw-flex tw-w-full tw-flex-auto tw-border-t tw-border-solid tw-border-brand-gray-2" }, null, -1);
const _hoisted_6$2 = { class: "tw-py-5 tw-bg-brand-gray-1" };
const _hoisted_7$2 = {
  key: 0,
  class: "tw-w-full tw-h-3/4 tw-flex tw-justify-center tw-items-center"
};
const _hoisted_8$2 = {
  key: 1,
  class: "tw-w-full tw-border-t tw-border-solid tw-border-brand-gray-2"
};
const _hoisted_9$2 = { class: "tw-grid tw-grid-rows-2 tw-gap-6" };
const _hoisted_10$2 = { style: { "overflow-x": "auto !important" } };
const _hoisted_11$2 = /* @__PURE__ */ createBaseVNode("p", { class: "tw-font-medium tw-text-xl tw-pl-2 tw-pt-2 tw-mb-2" }, " Internal Forecast vs Sales ", -1);
const _hoisted_12$2 = /* @__PURE__ */ createBaseVNode("div", { class: "overflow-x-auto tw-w-full tw-items-left tw-border-t tw-border-solid tw-border-brand-gray-2" }, null, -1);
const _hoisted_13$2 = /* @__PURE__ */ createBaseVNode("div", { class: "tw-flex tw-mt-3" }, [
  /* @__PURE__ */ createBaseVNode("div", {
    style: { "width": "12px", "height": "12px", "background": "#787878" },
    class: "tw-ml-3 tw-mt-px"
  }),
  /* @__PURE__ */ createBaseVNode("div", {
    style: { "height": "12px" },
    class: "tw-text-xs tw-ml-1"
  }, " Internal Forecast "),
  /* @__PURE__ */ createBaseVNode("div", { class: "tw-flex" }, [
    /* @__PURE__ */ createBaseVNode("div", {
      style: { "width": "12px", "height": "12px", "background": "#b991eb" },
      class: "tw-ml-3 tw-mt-px"
    }),
    /* @__PURE__ */ createBaseVNode("div", {
      style: { "height": "12px" },
      class: "tw-text-xs tw-ml-1"
    }, "Sales")
  ])
], -1);
const _hoisted_14$2 = { style: { "overflow-x": "auto !important" } };
const _hoisted_15$2 = /* @__PURE__ */ createBaseVNode("p", { class: "tw-font-medium tw-text-xl tw-pl-2 tw-pt-2 tw-mb-2" }, " Projections of Market Sensing Forecast vs Internal Forecast vs Sales ", -1);
const _hoisted_16$2 = /* @__PURE__ */ createBaseVNode("div", { class: "tw-flex tw-w-full tw-flex-auto tw-border-t tw-border-solid tw-border-brand-gray-2" }, null, -1);
function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_FiltersSection = resolveComponent("FiltersSection");
  const _component_GChart = resolveComponent("GChart");
  return openBlock(), createElementBlock("div", _hoisted_1$2, [
    createBaseVNode("div", _hoisted_2$2, [
      _hoisted_3$2,
      createBaseVNode("div", _hoisted_4$2, " Last refreshed on " + toDisplayString($data.refreshDate), 1)
    ]),
    _hoisted_5$2,
    createBaseVNode("div", _hoisted_6$2, [
      createVNode(_component_FiltersSection, {
        onUpdateFilters: $data.debounceUpdateFilters,
        filtersDisabled: $data.filtersDisabled
      }, null, 8, ["onUpdateFilters", "filtersDisabled"])
    ]),
    $data.isLoading ? (openBlock(), createElementBlock("div", _hoisted_7$2, [
      createVNode(VProgressCircular, {
        indeterminate: "",
        color: "#7823DC",
        size: 80,
        width: 10
      })
    ])) : createCommentVNode("", true),
    !$data.isLoading ? (openBlock(), createElementBlock("div", _hoisted_8$2, [
      createBaseVNode("div", _hoisted_9$2, [
        createBaseVNode("div", _hoisted_10$2, [
          createVNode(VCard, { style: { "width": "3500px", "height": "370px" } }, {
            default: withCtx(() => [
              _hoisted_11$2,
              _hoisted_12$2,
              _hoisted_13$2,
              createVNode(_component_GChart, {
                type: "ColumnChart",
                data: $data.columnChartData,
                options: $data.columnChartOptions,
                height: "370"
              }, null, 8, ["data", "options"])
            ]),
            _: 1
          })
        ]),
        createBaseVNode("div", _hoisted_14$2, [
          createVNode(VCard, { style: { "width": "3500px", "height": "370px" } }, {
            default: withCtx(() => [
              _hoisted_15$2,
              _hoisted_16$2,
              createVNode(_component_GChart, {
                type: "LineChart",
                options: $data.lineChartOptions,
                data: $data.lineChartData
              }, null, 8, ["options", "data"])
            ]),
            _: 1
          })
        ])
      ])
    ])) : createCommentVNode("", true)
  ]);
}
const InternalCharts = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["render", _sfc_render$3]]);
async function fetchModelAccuracyData({ categoriesAccuracy, categoriesHistoric, projected_period }) {
  const data = await apiBase("modelaccuracy", {
    category: categoriesHistoric,
    horizon: projected_period
  });
  let dataForUi = data;
  let cvAccuracyDataObject = _.get(data, "performance.current", []);
  let unit = _.get(data, "unit", []);
  let forecastDataObject = _.get(data, "forecast", []);
  let actualDataObject = _.get(data, "actual", []);
  let accuracy = _.get(data, "performance.past", []);
  let cvAccuracyData = _.map(cvAccuracyDataObject, (v, k2) => ({
    period: v[0],
    value: v[1]
  }));
  let rollingAccuracyData = _.map(cvAccuracyDataObject, (v, k2) => ({
    period: v[0],
    value: v[2]
  }));
  let historicData = _.map(forecastDataObject, (v, k2) => ({
    period: k2,
    value1: v
  }));
  let historicActualData = _.map(actualDataObject, (v, k2) => ({
    period: k2,
    value2: v
  }));
  let historicPredicted = [];
  _.forEach(historicActualData, function(v, k2) {
    historicPredicted.push([v.period, historicData[k2].value1, historicData[k2].value1 + unit, v.value2, v.value2 + unit]);
  });
  let accuracyData = [];
  _.forEach(accuracy, function(v, k2) {
    accuracyData.push([k2, v]);
  });
  dataForUi["cvAccuracyData"] = cvAccuracyData;
  dataForUi["rollingAccuracyData"] = rollingAccuracyData;
  dataForUi["historicPredicted"] = historicPredicted;
  dataForUi["accuracyData"] = accuracyData;
  return dataForUi;
}
async function fetchCVRollingAccuracyData({ categoriesAccuracy }) {
  const data = await apiBase("modelaccuracy", {
    category: categoriesAccuracy,
    horizon: ""
  });
  let dataForUi = data;
  let cvAccuracyDataObject = _.get(data, "performance.current", []);
  let unit = _.get(data, "unit", []);
  let forecastDataObject = _.get(data, "forecast", []);
  let actualDataObject = _.get(data, "actual", []);
  let accuracy = _.get(data, "performance.past", []);
  let cvAccuracyData = _.map(cvAccuracyDataObject, (v, k2) => ({
    period: v[0],
    value: v[1]
  }));
  let rollingAccuracyData = _.map(cvAccuracyDataObject, (v, k2) => ({
    period: v[0],
    value: v[2]
  }));
  let historicData = _.map(forecastDataObject, (v, k2) => ({
    period: k2,
    value1: v
  }));
  let historicActualData = _.map(actualDataObject, (v, k2) => ({
    period: k2,
    value2: v
  }));
  let historicPredicted = [];
  _.forEach(historicActualData, function(v, k2) {
    historicPredicted.push([v.period, historicData[k2].value1, historicData[k2].value1 + unit, v.value2, v.value2 + unit]);
  });
  let accuracyData = [];
  _.forEach(accuracy, function(v, k2) {
    accuracyData.push([k2, v]);
  });
  dataForUi["cvAccuracyData"] = cvAccuracyData;
  dataForUi["rollingAccuracyData"] = rollingAccuracyData;
  dataForUi["historicPredicted"] = historicPredicted;
  dataForUi["accuracyData"] = accuracyData;
  return dataForUi;
}
async function fetchModelAccuracyOptions() {
  const dataForUi = await apiBase("dashboard_filters");
  console.log(dataForUi);
  return dataForUi.ms;
}
const ALL_OPTION = "All";
const _sfc_main$2 = {
  name: "InternalCharts",
  components: {
    GChart
  },
  data() {
    return {
      isLoading: true,
      firstTimeLoad: true,
      isCVAccuracyLoading: false,
      isHistoricPerformanceLoading: false,
      cvAccuracy: false,
      accuracy_disabled: false,
      historic_disabled: false,
      apiData: [],
      filtersTestAccuracy: {
        categories: {
          items: [],
          selected: null,
          filterlabel: "Categories"
        }
      },
      filtersCharts: {
        categories: {
          items: [],
          selected: null,
          filterlabel: "Categories"
        },
        projected_period: {
          items: [],
          selected: null,
          filterlabel: "Projected Period"
        }
      },
      columnChartData: [],
      columnChartOptions: {
        bar: { groupWidth: "50%" },
        height: 400,
        tooltip: { trigger: "none" },
        legend: { position: "none" },
        colors: ["#A5A5A5", "#5F5F5F"],
        hAxis: {
          textStyle: {
            fontSize: 10
          }
        },
        vAxis: {
          gridlines: {
            count: 0
          },
          textPosition: "none"
        },
        chartArea: {
          left: "3%",
          width: "90%"
        },
        annotations: {
          textStyle: {
            color: "#000000",
            fontSize: 12
          },
          datum: { stem: { length: 0 } },
          alwaysOutside: true
        }
      },
      lineChartData: [],
      lineChartOptions: {
        curveType: "none",
        tooltip: { trigger: "none" },
        legend: { position: "none" },
        colors: ["#8737E1"],
        height: 100,
        series: {
          1: { lineDashStyle: [4, 4] }
        },
        annotations: {
          textStyle: {
            color: "#000000",
            fontSize: 12
          },
          datum: { stem: { length: 0 } },
          alwaysOutside: true
        },
        hAxis: {
          baselineColor: "none",
          textPosition: "none",
          textStyle: {
            fontSize: 10
          },
          gridlines: {
            color: "transparent"
          }
        },
        vAxis: {
          baselineColor: "none",
          textPosition: "none",
          gridlines: {
            color: "transparent"
          }
        },
        chartArea: {
          left: "3%",
          width: "90%",
          height: "90%"
        }
      },
      cvAccuracyData: [],
      cvAccuracyOptions: {
        height: 410,
        width: 650,
        bar: { groupWidth: "50%" },
        colors: ["#570EAA"],
        legend: {
          position: "none"
        },
        annotations: {
          textStyle: {
            color: "#000000",
            fontSize: 12
          },
          datum: { stem: { length: 2, color: "none" } }
        },
        tooltip: { trigger: "none" },
        chartArea: {
          left: "3%",
          width: "100%"
        },
        vAxis: {
          gridlines: {
            count: 0
          },
          minValue: 0,
          textPosition: "none"
        }
      },
      rollingTestAccuracyData: [],
      rollingTestAccuracyOptions: {
        height: 380,
        width: 650,
        bar: { groupWidth: "50%" },
        legend: {
          position: "none"
        },
        annotations: {
          textStyle: {
            color: "black",
            fontSize: 13
          },
          datum: { stem: { length: 2, color: "none" } }
        },
        vAxis: {
          gridlines: {
            count: 0
          },
          textPosition: "none",
          minValue: 0
        },
        tooltip: { trigger: "none" },
        chartArea: {
          left: "3%",
          width: "100%"
        }
      },
      ALL_OPTION,
      includes: _.includes
    };
  },
  methods: {
    getColorCode(n2) {
      switch (true) {
        case n2 >= 90:
          return "#8737E1";
        case n2 >= 80:
          return "#BF9CEC";
        case n2 >= 60:
          return "#C6C6C9";
        default:
          return "#A7A7AA";
      }
    },
    selectFilterUpdated: function(filterName, currentSelection) {
      this.filtersCharts[filterName].selected = currentSelection;
      this.filtersUpdated();
    },
    selectAccuracyFilterUpdated(filterName, currentSelection) {
      this.filtersTestAccuracy[filterName].selected = currentSelection;
      this.filtersAccuracyUpdated();
    },
    filtersUpdated: _.debounce(async function() {
      let v = this;
      this.lineChartData = [];
      this.columnChartData = [];
      if (this.firstTimeLoad) {
        this.isLoading = true;
        this.isHistoricPerformanceLoading = false;
      } else {
        this.isLoading = false;
        this.isHistoricPerformanceLoading = true;
        this.historic_disabled = true;
      }
      const selectedHistoricCategories = _.get(this.filtersCharts, "categories.selected");
      const selectedprojectedPeriod = _.get(this.filtersCharts, "projected_period.selected");
      const response = await fetchModelAccuracyData({ categoriesHistoric: selectedHistoricCategories === ALL_OPTION ? "*" : selectedHistoricCategories, projected_period: selectedprojectedPeriod });
      if (!_.isEmpty(response)) {
        this.apiData = response;
        if (!this.columnChartData.length) {
          this.columnChartData.push(["Period", "Predicted Values", { "role": "annotation" }, "Actual Values", { "role": "annotation" }]);
          _.forEach(this.apiData.historicPredicted, function(data) {
            v.columnChartData.push(data);
          });
        }
        if (!this.lineChartData.length) {
          this.lineChartData.push(["Time Period", "Prediction Accuracy", { role: "annotation", type: "string" }]);
          _.forEach(this.apiData.accuracyData, function(data) {
            v.lineChartData.push([data[0], data[1], data[1] + "%"]);
          });
        }
      }
      if (this.firstTimeLoad) {
        this.isLoading = false;
        this.isHistoricPerformanceLoading = false;
      } else {
        this.isLoading = false;
        this.isHistoricPerformanceLoading = false;
        this.historic_disabled = false;
      }
      this.firstTimeLoad = false;
    }, 2e3),
    async filtersAccuracyUpdated() {
      let v = this;
      this.cvAccuracyData = [];
      this.rollingTestAccuracyData = [];
      if (this.firstTimeLoad) {
        this.isLoading = true;
        this.isCVAccuracyLoading = false;
      } else {
        this.isLoading = false;
        this.isCVAccuracyLoading = true;
        this.accuracy_disabled = true;
      }
      const selectedAccuracyCategories = _.get(this.filtersTestAccuracy, "categories.selected");
      const response = await fetchCVRollingAccuracyData({ categoriesAccuracy: selectedAccuracyCategories === ALL_OPTION ? "*" : selectedAccuracyCategories });
      if (!_.isEmpty(response)) {
        this.apiData = response;
        if (!this.cvAccuracyData.length) {
          this.cvAccuracyData.push(["Period", "Predicted Values", { role: "annotation" }, { role: "style" }]);
          _.forEach(this.apiData.cvAccuracyData, function(data) {
            v.cvAccuracyData.push([data["period"], data["value"], data["value"] + "%", `color: ${v.getColorCode(data["value"])}`]);
          });
        }
        if (!this.rollingTestAccuracyData.length) {
          this.rollingTestAccuracyData.push(["Period", "Predicted Values", { role: "annotation" }, { role: "style" }]);
          _.forEach(this.apiData.rollingAccuracyData, function(data) {
            v.rollingTestAccuracyData.push([data["period"], data["value"], data["value"] + "%", `color: ${v.getColorCode(data["value"])}`]);
          });
        }
      }
      if (this.firstTimeLoad) {
        this.isLoading = false;
        this.isCVAccuracyLoading = false;
      } else {
        this.isLoading = false;
        this.isCVAccuracyLoading = false;
        this.accuracy_disabled = false;
      }
      this.firstTimeLoad = false;
    }
  },
  emits: ["updateFilters"],
  async created() {
    this.isLoading = true;
    this.isCVAccuracyLoading = false;
    this.isHistoricPerformanceLoading = false;
    const options = await fetchModelAccuracyOptions().catch(() => null);
    if (options) {
      this.filtersCharts.categories.items = options.categories;
      this.filtersCharts.projected_period.items = options.msTimeHorizon;
      this.filtersTestAccuracy.categories.items = options.categories;
    }
    this.selectFilterUpdated("categories", this.filtersCharts.categories.items[0]);
    this.selectAccuracyFilterUpdated("categories", this.filtersTestAccuracy.categories.items[0]);
    this.selectFilterUpdated("projected_period", this.filtersCharts.projected_period.items[0]);
  }
};
const _hoisted_1$1 = { class: "tw-w-full tw-h-full tw-bg-brand-gray-1" };
const _hoisted_2$1 = /* @__PURE__ */ createBaseVNode("div", { class: "tw-flex tw-h-8 tw-items-center tw-font-bold" }, " Accuracy ", -1);
const _hoisted_3$1 = /* @__PURE__ */ createBaseVNode("div", { class: "tw-flex tw-w-full tw-flex-auto tw-border-t tw-border-solid tw-border-brand-gray-2" }, null, -1);
const _hoisted_4$1 = { class: "tw-w-full tw-border-t tw-border-solid tw-border-brand-gray-2" };
const _hoisted_5$1 = { class: "tw-grid tw-grid-rows-2" };
const _hoisted_6$1 = /* @__PURE__ */ createBaseVNode("div", { class: "tw-font-bold tw-py-2 tw-pl-2 tw-text-lg" }, " Model Accuracy Forecast Performance ", -1);
const _hoisted_7$1 = /* @__PURE__ */ createBaseVNode("div", { class: "tw-flex tw-w-full tw-flex-auto tw-border-t tw-border-solid tw-border-brand-gray-2" }, null, -1);
const _hoisted_8$1 = { class: "tw-flex tw-gap-x-4 tw-w-full tw-bg-white tw-px-3" };
const _hoisted_9$1 = { class: "tw-pt-3 tw-min-w-[14%] tw--mb-3" };
const _hoisted_10$1 = /* @__PURE__ */ createBaseVNode("label", {
  for: "category",
  class: "tw-text-sm"
}, "Category", -1);
const _hoisted_11$1 = { class: "tw-flex tw-items-center tw-gap-1.5 tw-mt-3" };
const _hoisted_12$1 = {
  class: "tw-flex tw-pt-5",
  style: { "color": "#7823DC" }
};
const _hoisted_13$1 = /* @__PURE__ */ createBaseVNode("div", {
  class: "tw-flex tw-justify-end tw-items-center tw-w-7/12 tw-mt-9",
  style: { "height": "72px" }
}, [
  /* @__PURE__ */ createBaseVNode("img", {
    src: _imports_0,
    class: "tw-h-full"
  })
], -1);
const _hoisted_14$1 = {
  key: 0,
  class: "tw-block tw-m-auto"
};
const _hoisted_15$1 = /* @__PURE__ */ createBaseVNode("div", { class: "tw-flex tw-justify-center" }, [
  /* @__PURE__ */ createBaseVNode("h3", { class: "tw-pl-2 tw-flex tw-h-8 tw-justify-center tw-font-bold tw-text-lg tw-pt-3" }, "CV Accuracy")
], -1);
const _hoisted_16$1 = {
  key: 0,
  class: "tw-flex tw-justify-center tw-p-6 tw-pt-5"
};
const _hoisted_17$1 = { key: 1 };
const _hoisted_18$1 = /* @__PURE__ */ createBaseVNode("div", { class: "tw-flex tw-justify-center" }, [
  /* @__PURE__ */ createBaseVNode("h3", { class: "tw-pl-2 tw-pt-3 tw-flex tw-h-8 tw-items-center tw-text-lg tw-font-bold" }, "Rolling Test Accuracy")
], -1);
const _hoisted_19 = {
  key: 0,
  class: "tw-flex tw-justify-center tw-p-6 tw-pt-5"
};
const _hoisted_20 = /* @__PURE__ */ createBaseVNode("h3", { class: "tw-font-bold tw-py-2 tw-pl-2 tw-text-lg" }, "Historic Actual vs Predicted Market Volume", -1);
const _hoisted_21 = /* @__PURE__ */ createBaseVNode("div", { class: "tw-flex tw-w-full tw-flex-auto tw-border-t tw-border-solid tw-border-brand-gray-2" }, null, -1);
const _hoisted_22 = { class: "tw-flex tw-gap-x-4 tw-w-full tw-bg-white tw-px-3" };
const _hoisted_23 = { class: "tw-pt-3 tw-min-w-[14%] tw--mb-3" };
const _hoisted_24 = /* @__PURE__ */ createBaseVNode("label", {
  for: "category",
  class: "tw-text-sm"
}, "Category", -1);
const _hoisted_25 = { class: "tw-pt-3 tw-min-w-[14%] tw--mb-3" };
const _hoisted_26 = /* @__PURE__ */ createBaseVNode("label", {
  for: "projection_period",
  class: "tw-text-sm"
}, "Projection Period", -1);
const _hoisted_27 = {
  key: 0,
  class: "tw-w-full tw-grid-rows-2"
};
const _hoisted_28 = /* @__PURE__ */ createBaseVNode("div", { class: "tw-h-1/6 tw-mt-4" }, [
  /* @__PURE__ */ createBaseVNode("div", { class: "tw-flex tw-ml-5" }, [
    /* @__PURE__ */ createBaseVNode("div", {
      style: { "width": "12px", "height": "12px", "background": "#A5A5A5" },
      class: "tw-ml-3"
    }),
    /* @__PURE__ */ createBaseVNode("div", {
      style: { "height": "14px" },
      class: "tw-text-xs tw-ml-1"
    }, "Predicted Values"),
    /* @__PURE__ */ createBaseVNode("div", { class: "tw-flex" }, [
      /* @__PURE__ */ createBaseVNode("div", {
        style: { "width": "12px", "height": "12px", "background": "#5F5F5F" },
        class: "tw-ml-3"
      }),
      /* @__PURE__ */ createBaseVNode("div", {
        style: { "height": "14px" },
        class: "tw-text-xs tw-ml-1"
      }, "Actual Values"),
      /* @__PURE__ */ createBaseVNode("div", {
        style: { "width": "24px", "height": "3px", "background": "#7823DC" },
        class: "tw-ml-3 tw-mt-1.5"
      }),
      /* @__PURE__ */ createBaseVNode("div", {
        style: { "height": "14px" },
        class: "tw-text-xs tw-ml-1"
      }, "Prediction Accuracy")
    ])
  ])
], -1);
function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_GChart = resolveComponent("GChart");
  return openBlock(), createElementBlock(Fragment, null, [
    $data.isLoading ? (openBlock(), createBlock(VProgressCircular, {
      key: 0,
      indeterminate: "",
      color: "#7823DC",
      size: 70,
      width: 7,
      style: { "position": "fixed", "left": "50%", "top": "35%", "z-index": "1000" }
    })) : createCommentVNode("", true),
    $data.isCVAccuracyLoading ? (openBlock(), createBlock(VProgressCircular, {
      key: 1,
      indeterminate: "",
      color: "#7823DC",
      size: 70,
      width: 7,
      style: { "position": "fixed", "left": "50%", "top": "35%", "z-index": "1000" }
    })) : createCommentVNode("", true),
    $data.isHistoricPerformanceLoading ? (openBlock(), createBlock(VProgressCircular, {
      key: 2,
      indeterminate: "",
      color: "#7823DC",
      size: 70,
      width: 7,
      style: { "position": "fixed", "left": "50%", "top": "70%", "z-index": "1000" }
    })) : createCommentVNode("", true),
    createBaseVNode("div", _hoisted_1$1, [
      _hoisted_2$1,
      _hoisted_3$1,
      createBaseVNode("div", _hoisted_4$1, [
        createBaseVNode("div", _hoisted_5$1, [
          createBaseVNode("div", null, [
            createVNode(VCard, null, {
              default: withCtx(() => [
                _hoisted_6$1,
                _hoisted_7$1,
                createBaseVNode("div", _hoisted_8$1, [
                  createBaseVNode("div", _hoisted_9$1, [
                    _hoisted_10$1,
                    createVNode(VSelect, {
                      disabled: $data.accuracy_disabled,
                      items: $data.filtersTestAccuracy.categories.items,
                      "model-value": $data.filtersTestAccuracy.categories.selected,
                      "onUpdate:modelValue": _cache[0] || (_cache[0] = (value) => $options.selectAccuracyFilterUpdated("categories", value)),
                      density: "comfortable"
                    }, null, 8, ["disabled", "items", "model-value"])
                  ]),
                  createBaseVNode("div", _hoisted_11$1, [
                    createBaseVNode("p", {
                      class: normalizeClass(`${!$data.cvAccuracy ? "tw-font-medium desktop:tw-leading-tight small-laptop:tw-leading-tight desktop:tw-text-end small-laptop:tw-text-end" : "desktop:tw-leading-tight small-laptop:tw-leading-tight desktop:tw-text-end small-laptop:tw-text-end"}`)
                    }, "Rolling Test Accuracy", 2),
                    createBaseVNode("div", _hoisted_12$1, [
                      createVNode(VSwitch, {
                        inset: "",
                        onClick: _cache[1] || (_cache[1] = ($event) => $data.cvAccuracy = !$data.cvAccuracy)
                      })
                    ]),
                    createBaseVNode("p", {
                      class: normalizeClass(`${$data.cvAccuracy ? "tw-font-medium desktop:tw-leading-tight small-laptop:tw-leading-tight" : "desktop:tw-leading-tight small-laptop:tw-leading-tight"}`)
                    }, "CV Accuracy", 2)
                  ]),
                  _hoisted_13$1
                ]),
                $data.cvAccuracy ? (openBlock(), createElementBlock("div", _hoisted_14$1, [
                  _hoisted_15$1,
                  !$data.isLoading && !$data.isCVAccuracyLoading ? (openBlock(), createElementBlock("div", _hoisted_16$1, [
                    createVNode(_component_GChart, {
                      type: "ColumnChart",
                      data: $data.cvAccuracyData,
                      options: $data.cvAccuracyOptions
                    }, null, 8, ["data", "options"])
                  ])) : createCommentVNode("", true)
                ])) : (openBlock(), createElementBlock("div", _hoisted_17$1, [
                  _hoisted_18$1,
                  !$data.isLoading && !$data.isCVAccuracyLoading ? (openBlock(), createElementBlock("div", _hoisted_19, [
                    createVNode(_component_GChart, {
                      type: "ColumnChart",
                      data: $data.rollingTestAccuracyData,
                      options: $data.rollingTestAccuracyOptions
                    }, null, 8, ["data", "options"])
                  ])) : createCommentVNode("", true)
                ]))
              ]),
              _: 1
            })
          ]),
          createBaseVNode("div", null, [
            createVNode(VCard, null, {
              default: withCtx(() => [
                _hoisted_20,
                _hoisted_21,
                createBaseVNode("div", _hoisted_22, [
                  createBaseVNode("div", _hoisted_23, [
                    _hoisted_24,
                    createVNode(VSelect, {
                      disabled: $data.historic_disabled,
                      items: $data.filtersCharts.categories.items,
                      "model-value": $data.filtersCharts.categories.selected,
                      "onUpdate:modelValue": _cache[2] || (_cache[2] = (value) => $options.selectFilterUpdated("categories", value)),
                      density: "comfortable"
                    }, null, 8, ["disabled", "items", "model-value"])
                  ]),
                  createBaseVNode("div", _hoisted_25, [
                    _hoisted_26,
                    createVNode(VSelect, {
                      disabled: $data.historic_disabled,
                      items: $data.filtersCharts.projected_period.items,
                      "model-value": $data.filtersCharts.projected_period.selected,
                      "onUpdate:modelValue": _cache[3] || (_cache[3] = (value) => $options.selectFilterUpdated("projected_period", value)),
                      density: "comfortable"
                    }, null, 8, ["disabled", "items", "model-value"])
                  ])
                ]),
                !$data.isLoading && !$data.isHistoricPerformanceLoading ? (openBlock(), createElementBlock("div", _hoisted_27, [
                  _hoisted_28,
                  createVNode(_component_GChart, {
                    type: "LineChart",
                    options: $data.lineChartOptions,
                    data: $data.lineChartData
                  }, null, 8, ["options", "data"]),
                  createBaseVNode("div", null, [
                    createVNode(_component_GChart, {
                      type: "ColumnChart",
                      data: $data.columnChartData,
                      options: $data.columnChartOptions,
                      height: "370"
                    }, null, 8, ["data", "options"])
                  ])
                ])) : createCommentVNode("", true)
              ]),
              _: 1
            })
          ])
        ])
      ])
    ]),
    createVNode(VDivider)
  ], 64);
}
const ModelAccuracy = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["render", _sfc_render$2]]);
const _sfc_main$1 = {
  name: "TheFAQ"
};
function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
  return " TheFAQ ";
}
const TheFaq = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["render", _sfc_render$1]]);
const HelpAndSupportImage = "/assets/HelpAndSupport.f6e330be.svg";
const _sfc_main = {
  name: "TheSupport",
  data() {
    return {
      HelpAndSupportImage,
      supportEmail: "arjun.shyamsundar@kearney.com",
      userGuideURL: "https://xebiagroup.sharepoint.com/sites/ProjectKearney/Gedeelde%20documenten/Forms/AllItems.aspx?ct=1685352691531&or=OWA%2DNT&cid=53032b96%2D2504%2D1874%2D133d%2D64ef240b56d6&ga=1&WSL=1&id=%2Fsites%2FProjectKearney%2FGedeelde%20documenten%2FGeneral%2FUserGuide%5FKSS%28MVP1%29%2FKSS%5FUser%20Guide%5FV4%2E0%2Epdf&viewid=6270bc2d%2De035%2D4015%2D86c1%2Dedb8f9493642&parent=%2Fsites%2FProjectKearney%2FGedeelde%20documenten%2FGeneral%2FUserGuide%5FKSS%28MVP1%29"
    };
  },
  methods: {
    downloadHandler() {
      window.open(this.userGuideURL, "_blank");
    }
  }
};
const _hoisted_1 = { class: "tw-h-full tw-w-full tw-bg-brand-gray-1" };
const _hoisted_2 = /* @__PURE__ */ createBaseVNode("div", { class: "tw-flex tw-w-full tw-bg-brand-gray-1 tw-border-b tw-border-solid tw-border-brand-gray-2" }, [
  /* @__PURE__ */ createBaseVNode("div", { class: "tw-flex tw-items-center" }, [
    /* @__PURE__ */ createBaseVNode("h1", { class: "tw-text-lg tw-font-bold" }, "Help & Support")
  ])
], -1);
const _hoisted_3 = { class: "tw-w-full tw-p-5 tw-my-5 tw-bg-white" };
const _hoisted_4 = /* @__PURE__ */ createBaseVNode("div", { class: "tw-w-full tw-border-b tw-border-solid tw-border-brand-gray-2" }, [
  /* @__PURE__ */ createBaseVNode("h2", { class: "tw-text-xl" }, " Get help getting started, with features and settings, and technical support. ")
], -1);
const _hoisted_5 = { class: "tw-grid tw-grid-cols-2 tw-w-full tw-py-5" };
const _hoisted_6 = { class: "tw-col-span-1" };
const _hoisted_7 = { class: "tw-flex tw-flex-col tw-gap-y-6 tw-py-5" };
const _hoisted_8 = { class: "tw-flex tw-flex-col tw-gap-3" };
const _hoisted_9 = /* @__PURE__ */ createBaseVNode("span", { class: "tw-text-base tw-text-black tw-font-medium" }, "For any queries, email at:", -1);
const _hoisted_10 = { class: "tw-flex tw-gap-x-4 tw-items-center" };
const _hoisted_11 = ["href"];
const _hoisted_12 = { class: "tw-flex tw-flex-col tw-gap-3" };
const _hoisted_13 = /* @__PURE__ */ createBaseVNode("span", { class: "tw-text-base tw-text-black tw-font-medium" }, "Read through the User Guide to know more:", -1);
const _hoisted_14 = { class: "tw-flex tw-gap-x-2 tw-items-center" };
const _hoisted_15 = /* @__PURE__ */ createBaseVNode("span", { class: "tw-text-base tw-text-black" }, " Download User Guide ", -1);
const _hoisted_16 = { class: "tw-col-span-1" };
const _hoisted_17 = { class: "tw-h-full tw-w-full tw-px-4" };
const _hoisted_18 = ["src"];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1, [
    _hoisted_2,
    createBaseVNode("div", _hoisted_3, [
      _hoisted_4,
      createBaseVNode("div", _hoisted_5, [
        createBaseVNode("div", _hoisted_6, [
          createBaseVNode("div", _hoisted_7, [
            createBaseVNode("div", _hoisted_8, [
              _hoisted_9,
              createBaseVNode("div", _hoisted_10, [
                createVNode(VIcon, {
                  icon: "mdi-email-outline",
                  class: "tw-text-brand-primary",
                  size: 32
                }),
                createBaseVNode("a", {
                  href: `mailto:${$data.supportEmail}`,
                  class: "tw-text-xl tw-text-black tw-underline"
                }, toDisplayString($data.supportEmail), 9, _hoisted_11)
              ])
            ]),
            createBaseVNode("div", _hoisted_12, [
              _hoisted_13,
              createBaseVNode("div", null, [
                createBaseVNode("button", {
                  class: "tw-px-2 tw-py-1.5 tw-border-2 tw-border-solid tw-border-brand-primary",
                  onClick: _cache[0] || (_cache[0] = (...args) => $options.downloadHandler && $options.downloadHandler(...args))
                }, [
                  createBaseVNode("div", _hoisted_14, [
                    createVNode(VIcon, {
                      icon: "mdi-tray-arrow-down",
                      class: "tw-text-brand-primary",
                      size: 24
                    }),
                    _hoisted_15
                  ])
                ])
              ])
            ])
          ])
        ]),
        createBaseVNode("div", _hoisted_16, [
          createBaseVNode("div", _hoisted_17, [
            createBaseVNode("img", {
              src: $data.HelpAndSupportImage,
              class: "tw-h-full tw-w-full tw-object-contain"
            }, null, 8, _hoisted_18)
          ])
        ])
      ])
    ])
  ]);
}
const TheSupport = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
const DemandPlannerIcon = "/assets/demand-planner-icon.baaa7b65.svg";
const DemandPlannerIconActive = "/assets/demand-planner-icon-active.d3fc6985.svg";
const HeatMapIcon = "/assets/heat-map-icon.1d0fe80a.svg";
const HeatMapIconActive = "/assets/heat-map-icon-active.7e0ef2a8.svg";
const InternalChartsIcon = "/assets/internal-charts-icon.ed193c46.svg";
const InternalChartsIconActive = "/assets/internal-charts-icon-active.cecfcdc9.svg";
const ModelAccuracyIcon = "/assets/model-accuracy-icon.4a109f25.svg";
const ModelAccuracyIconActive = "/assets/model-accuracy-icon-active.25192545.svg";
const FaqIcon = "/assets/faq-icon.b9cecf90.svg";
const FaqIconActive = "/assets/faq-icon-active.66296de8.svg";
const HelpSupportIcon = "/assets/help-support-icon.b008338f.svg";
const HelpSupportIconActive = "/assets/help-support-icon-active.dd73ac77.svg";
const PAGE_KEYS = {
  DEMAND_PLANNER: "demandPlanner",
  HEAT_MAP: "heatMap",
  INTERNAL_CHARTS: "internalCharts",
  MODEL_ACCURACY: "modelAccuracy",
  FAQS: "faqs",
  HELP: "help"
};
const PAGES_CONFIG = {
  demandPlanner: {
    label: "Demand Planner",
    icon: DemandPlannerIcon,
    icon_active: DemandPlannerIconActive,
    component: DemandPlanner
  },
  heatMap: {
    label: "Heat-map View",
    icon: HeatMapIcon,
    icon_active: HeatMapIconActive,
    component: HeatMap
  },
  internalCharts: {
    label: "Internal Charts",
    icon: InternalChartsIcon,
    icon_active: InternalChartsIconActive,
    component: InternalCharts
  },
  modelAccuracy: {
    label: "Accuracy",
    icon: ModelAccuracyIcon,
    icon_active: ModelAccuracyIconActive,
    component: ModelAccuracy
  },
  faqs: {
    label: "FAQs",
    icon: FaqIcon,
    icon_active: FaqIconActive,
    component: TheFaq
  },
  help: {
    label: "Help & Support",
    icon: HelpSupportIcon,
    icon_active: HelpSupportIconActive,
    component: TheSupport
  }
};
const OrgLogo = "/assets/orgLogo.d7e6b17b.svg";
const OrgLogoSmall = "/assets/orgLogoSmall.85b588fd.svg";
const index = "";
const app = createApp(App, { idpConfig: idpData$1, OrgLogo, OrgLogoSmall, PAGES_CONFIG, PAGE_KEYS });
app.component("VueDatePicker", Gn);
registerPlugins(app);
app.mount("#app");
